/*!
Copyright (C) 2014-2015 by WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function(window, document, Object, REGISTER_ELEMENT){'use strict';

// in case it's there or already patched
if (REGISTER_ELEMENT in document) return;

// DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK
// THIS IS A PROJECT BASED ON A BUILD SYSTEM
// THIS FILE IS JUST WRAPPED UP RESULTING IN
// build/document-register-element.js
// and its .max.js counter part

var
  // IE < 11 only + old WebKit for attributes + feature detection
  EXPANDO_UID = '__' + REGISTER_ELEMENT + (Math.random() * 10e4 >> 0),

  // shortcuts and costants
  ATTACHED = 'attached',
  DETACHED = 'detached',
  EXTENDS = 'extends',
  ADDITION = 'ADDITION',
  MODIFICATION = 'MODIFICATION',
  REMOVAL = 'REMOVAL',
  DOM_ATTR_MODIFIED = 'DOMAttrModified',
  DOM_CONTENT_LOADED = 'DOMContentLoaded',
  DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',
  PREFIX_TAG = '<',
  PREFIX_IS = '=',

  // valid and invalid node names
  validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,
  invalidNames = [
    'ANNOTATION-XML',
    'COLOR-PROFILE',
    'FONT-FACE',
    'FONT-FACE-SRC',
    'FONT-FACE-URI',
    'FONT-FACE-FORMAT',
    'FONT-FACE-NAME',
    'MISSING-GLYPH'
  ],

  // registered types and their prototypes
  types = [],
  protos = [],

  // to query subnodes
  query = '',

  // html shortcut used to feature detect
  documentElement = document.documentElement,

  // ES5 inline helpers || basic patches
  indexOf = types.indexOf || function (v) {
    for(var i = this.length; i-- && this[i] !== v;){}
    return i;
  },

  // other helpers / shortcuts
  OP = Object.prototype,
  hOP = OP.hasOwnProperty,
  iPO = OP.isPrototypeOf,

  defineProperty = Object.defineProperty,
  gOPD = Object.getOwnPropertyDescriptor,
  gOPN = Object.getOwnPropertyNames,
  gPO = Object.getPrototypeOf,
  sPO = Object.setPrototypeOf,

  // jshint proto: true
  hasProto = !!Object.__proto__,

  // used to create unique instances
  create = Object.create || function Bridge(proto) {
    // silly broken polyfill probably ever used but short enough to work
    return proto ? ((Bridge.prototype = proto), new Bridge()) : this;
  },

  // will set the prototype if possible
  // or copy over all properties
  setPrototype = sPO || (
    hasProto ?
      function (o, p) {
        o.__proto__ = p;
        return o;
      } : (
    (gOPN && gOPD) ?
      (function(){
        function setProperties(o, p) {
          for (var
            key,
            names = gOPN(p),
            i = 0, length = names.length;
            i < length; i++
          ) {
            key = names[i];
            if (!hOP.call(o, key)) {
              defineProperty(o, key, gOPD(p, key));
            }
          }
        }
        return function (o, p) {
          do {
            setProperties(o, p);
          } while ((p = gPO(p)) && !iPO.call(p, o));
          return o;
        };
      }()) :
      function (o, p) {
        for (var key in p) {
          o[key] = p[key];
        }
        return o;
      }
  )),

  // DOM shortcuts and helpers, if any

  MutationObserver = window.MutationObserver ||
                     window.WebKitMutationObserver,

  HTMLElementPrototype = (
    window.HTMLElement ||
    window.Element ||
    window.Node
  ).prototype,

  IE8 = !iPO.call(HTMLElementPrototype, documentElement),

  isValidNode = IE8 ?
    function (node) {
      return node.nodeType === 1;
    } :
    function (node) {
      return iPO.call(HTMLElementPrototype, node);
    },

  targets = IE8 && [],

  cloneNode = HTMLElementPrototype.cloneNode,
  setAttribute = HTMLElementPrototype.setAttribute,
  removeAttribute = HTMLElementPrototype.removeAttribute,

  // replaced later on
  createElement = document.createElement,

  // shared observer for all attributes
  attributesObserver = MutationObserver && {
    attributes: true,
    characterData: true,
    attributeOldValue: true
  },

  // useful to detect only if there's no MutationObserver
  DOMAttrModified = MutationObserver || function(e) {
    doesNotSupportDOMAttrModified = false;
    documentElement.removeEventListener(
      DOM_ATTR_MODIFIED,
      DOMAttrModified
    );
  },

  // will both be used to make DOMNodeInserted asynchronous
  asapQueue,
  rAF = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (fn) { setTimeout(fn, 10); },

  // internal flags
  setListener = false,
  doesNotSupportDOMAttrModified = true,
  dropDomContentLoaded = true,

  // needed for the innerHTML helper
  notFromInnerHTMLHelper = true,

  // optionally defined later on
  onSubtreeModified,
  callDOMAttrModified,
  getAttributesMirror,
  observer,

  // based on setting prototype capability
  // will check proto or the expando attribute
  // in order to setup the node once
  patchIfNotAlready,
  patch
;

if (sPO || hasProto) {
    patchIfNotAlready = function (node, proto) {
      if (!iPO.call(proto, node)) {
        setupNode(node, proto);
      }
    };
    patch = setupNode;
} else {
    patchIfNotAlready = function (node, proto) {
      if (!node[EXPANDO_UID]) {
        node[EXPANDO_UID] = Object(true);
        setupNode(node, proto);
      }
    };
    patch = patchIfNotAlready;
}
if (IE8) {
  doesNotSupportDOMAttrModified = false;
  (function (){
    var
      descriptor = gOPD(HTMLElementPrototype, 'addEventListener'),
      addEventListener = descriptor.value,
      patchedRemoveAttribute = function (name) {
        var e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
        e.attrName = name;
        e.prevValue = this.getAttribute(name);
        e.newValue = null;
        e[REMOVAL] = e.attrChange = 2;
        removeAttribute.call(this, name);
        this.dispatchEvent(e);
      },
      patchedSetAttribute = function (name, value) {
        var
          had = this.hasAttribute(name),
          old = had && this.getAttribute(name),
          e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true})
        ;
        setAttribute.call(this, name, value);
        e.attrName = name;
        e.prevValue = had ? old : null;
        e.newValue = value;
        if (had) {
          e[MODIFICATION] = e.attrChange = 1;
        } else {
          e[ADDITION] = e.attrChange = 0;
        }
        this.dispatchEvent(e);
      },
      onPropertyChange = function (e) {
        // jshint eqnull:true
        var
          node = e.currentTarget,
          superSecret = node[EXPANDO_UID],
          propertyName = e.propertyName,
          event
        ;
        if (superSecret.hasOwnProperty(propertyName)) {
          superSecret = superSecret[propertyName];
          event = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
          event.attrName = superSecret.name;
          event.prevValue = superSecret.value || null;
          event.newValue = (superSecret.value = node[propertyName] || null);
          if (event.prevValue == null) {
            event[ADDITION] = event.attrChange = 0;
          } else {
            event[MODIFICATION] = event.attrChange = 1;
          }
          node.dispatchEvent(event);
        }
      }
    ;
    descriptor.value = function (type, handler, capture) {
      if (
        type === DOM_ATTR_MODIFIED &&
        this.attributeChangedCallback &&
        this.setAttribute !== patchedSetAttribute
      ) {
        this[EXPANDO_UID] = {
          className: {
            name: 'class',
            value: this.className
          }
        };
        this.setAttribute = patchedSetAttribute;
        this.removeAttribute = patchedRemoveAttribute;
        addEventListener.call(this, 'propertychange', onPropertyChange);
      }
      addEventListener.call(this, type, handler, capture);
    };
    defineProperty(HTMLElementPrototype, 'addEventListener', descriptor);
  }());
} else if (!MutationObserver) {
  documentElement.addEventListener(DOM_ATTR_MODIFIED, DOMAttrModified);
  documentElement.setAttribute(EXPANDO_UID, 1);
  documentElement.removeAttribute(EXPANDO_UID);
  if (doesNotSupportDOMAttrModified) {
    onSubtreeModified = function (e) {
      var
        node = this,
        oldAttributes,
        newAttributes,
        key
      ;
      if (node === e.target) {
        oldAttributes = node[EXPANDO_UID];
        node[EXPANDO_UID] = (newAttributes = getAttributesMirror(node));
        for (key in newAttributes) {
          if (!(key in oldAttributes)) {
            // attribute was added
            return callDOMAttrModified(
              0,
              node,
              key,
              oldAttributes[key],
              newAttributes[key],
              ADDITION
            );
          } else if (newAttributes[key] !== oldAttributes[key]) {
            // attribute was changed
            return callDOMAttrModified(
              1,
              node,
              key,
              oldAttributes[key],
              newAttributes[key],
              MODIFICATION
            );
          }
        }
        // checking if it has been removed
        for (key in oldAttributes) {
          if (!(key in newAttributes)) {
            // attribute removed
            return callDOMAttrModified(
              2,
              node,
              key,
              oldAttributes[key],
              newAttributes[key],
              REMOVAL
            );
          }
        }
      }
    };
    callDOMAttrModified = function (
      attrChange,
      currentTarget,
      attrName,
      prevValue,
      newValue,
      action
    ) {
      var e = {
        attrChange: attrChange,
        currentTarget: currentTarget,
        attrName: attrName,
        prevValue: prevValue,
        newValue: newValue
      };
      e[action] = attrChange;
      onDOMAttrModified(e);
    };
    getAttributesMirror = function (node) {
      for (var
        attr, name,
        result = {},
        attributes = node.attributes,
        i = 0, length = attributes.length;
        i < length; i++
      ) {
        attr = attributes[i];
        name = attr.name;
        if (name !== 'setAttribute') {
          result[name] = attr.value;
        }
      }
      return result;
    };
  }
}

function loopAndVerify(list, action) {
  for (var i = 0, length = list.length; i < length; i++) {
    verifyAndSetupAndAction(list[i], action);
  }
}

function loopAndSetup(list) {
  for (var i = 0, length = list.length, node; i < length; i++) {
    node = list[i];
    patch(node, protos[getTypeIndex(node)]);
  }
}

function executeAction(action) {
  return function (node) {
    if (isValidNode(node)) {
      verifyAndSetupAndAction(node, action);
      loopAndVerify(
        node.querySelectorAll(query),
        action
      );
    }
  };
}

function getTypeIndex(target) {
  var
    is = target.getAttribute('is'),
    nodeName = target.nodeName.toUpperCase(),
    i = indexOf.call(
      types,
      is ?
          PREFIX_IS + is.toUpperCase() :
          PREFIX_TAG + nodeName
    )
  ;
  return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;
}

function isInQSA(name, type) {
  return -1 < query.indexOf(name + '[is="' + type + '"]');
}

function onDOMAttrModified(e) {
  var
    node = e.currentTarget,
    attrChange = e.attrChange,
    prevValue = e.prevValue,
    newValue = e.newValue
  ;
  if (notFromInnerHTMLHelper &&
      node.attributeChangedCallback &&
      e.attrName !== 'style') {
    node.attributeChangedCallback(
      e.attrName,
      attrChange === e[ADDITION] ? null : prevValue,
      attrChange === e[REMOVAL] ? null : newValue
    );
  }
}

function onDOMNode(action) {
  var executor = executeAction(action);
  return function (e) {
    asapQueue.push(executor, e.target);
  };
}

function onReadyStateChange(e) {
  if (dropDomContentLoaded) {
    dropDomContentLoaded = false;
    e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);
  }
  loopAndVerify(
    (e.target || document).querySelectorAll(query),
    e.detail === DETACHED ? DETACHED : ATTACHED
  );
  if (IE8) purge();
}

function patchedSetAttribute(name, value) {
  // jshint validthis:true
  var self = this;
  setAttribute.call(self, name, value);
  onSubtreeModified.call(self, {target: self});
}

function setupNode(node, proto) {
  setPrototype(node, proto);
  if (observer) {
    observer.observe(node, attributesObserver);
  } else {
    if (doesNotSupportDOMAttrModified) {
      node.setAttribute = patchedSetAttribute;
      node[EXPANDO_UID] = getAttributesMirror(node);
      node.addEventListener(DOM_SUBTREE_MODIFIED, onSubtreeModified);
    }
    node.addEventListener(DOM_ATTR_MODIFIED, onDOMAttrModified);
  }
  if (node.createdCallback && notFromInnerHTMLHelper) {
    node.created = true;
    node.createdCallback();
    node.created = false;
  }
}

function purge() {
  for (var
    node,
    i = 0,
    length = targets.length;
    i < length; i++
  ) {
    node = targets[i];
    if (!documentElement.contains(node)) {
      targets.splice(i, 1);
      verifyAndSetupAndAction(node, DETACHED);
    }
  }
}

function verifyAndSetupAndAction(node, action) {
  var
    fn,
    i = getTypeIndex(node)
  ;
  if (-1 < i) {
    patchIfNotAlready(node, protos[i]);
    i = 0;
    if (action === ATTACHED && !node[ATTACHED]) {
      node[DETACHED] = false;
      node[ATTACHED] = true;
      i = 1;
      if (IE8 && indexOf.call(targets, node) < 0) {
        targets.push(node);
      }
    } else if (action === DETACHED && !node[DETACHED]) {
      node[ATTACHED] = false;
      node[DETACHED] = true;
      i = 1;
    }
    if (i && (fn = node[action + 'Callback'])) fn.call(node);
  }
}

// set as enumerable, writable and configurable
document[REGISTER_ELEMENT] = function registerElement(type, options) {
  upperType = type.toUpperCase();
  if (!setListener) {
    // only first time document.registerElement is used
    // we need to set this listener
    // setting it by default might slow down for no reason
    setListener = true;
    if (MutationObserver) {
      observer = (function(attached, detached){
        function checkEmAll(list, callback) {
          for (var i = 0, length = list.length; i < length; callback(list[i++])){}
        }
        return new MutationObserver(function (records) {
          for (var
            current, node,
            i = 0, length = records.length; i < length; i++
          ) {
            current = records[i];
            if (current.type === 'childList') {
              checkEmAll(current.addedNodes, attached);
              checkEmAll(current.removedNodes, detached);
            } else {
              node = current.target;
              if (notFromInnerHTMLHelper &&
                  node.attributeChangedCallback &&
                  current.attributeName !== 'style') {
                node.attributeChangedCallback(
                  current.attributeName,
                  current.oldValue,
                  node.getAttribute(current.attributeName)
                );
              }
            }
          }
        });
      }(executeAction(ATTACHED), executeAction(DETACHED)));
      observer.observe(
        document,
        {
          childList: true,
          subtree: true
        }
      );
    } else {
      asapQueue = [];
      rAF(function ASAP() {
        while (asapQueue.length) {
          asapQueue.shift().call(
            null, asapQueue.shift()
          );
        }
        rAF(ASAP);
      });
      document.addEventListener('DOMNodeInserted', onDOMNode(ATTACHED));
      document.addEventListener('DOMNodeRemoved', onDOMNode(DETACHED));
    }

    document.addEventListener(DOM_CONTENT_LOADED, onReadyStateChange);
    document.addEventListener('readystatechange', onReadyStateChange);

    document.createElement = function (localName, typeExtension) {
      var
        node = createElement.apply(document, arguments),
        name = '' + localName,
        i = indexOf.call(
          types,
          (typeExtension ? PREFIX_IS : PREFIX_TAG) +
          (typeExtension || name).toUpperCase()
        ),
        setup = -1 < i
      ;
      if (typeExtension) {
        node.setAttribute('is', typeExtension = typeExtension.toLowerCase());
        if (setup) {
          setup = isInQSA(name.toUpperCase(), typeExtension);
        }
      }
      notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;
      if (setup) patch(node, protos[i]);
      return node;
    };

    HTMLElementPrototype.cloneNode = function (deep) {
      var
        node = cloneNode.call(this, !!deep),
        i = getTypeIndex(node)
      ;
      if (-1 < i) patch(node, protos[i]);
      if (deep) loopAndSetup(node.querySelectorAll(query));
      return node;
    };
  }

  if (-2 < (
    indexOf.call(types, PREFIX_IS + upperType) +
    indexOf.call(types, PREFIX_TAG + upperType)
  )) {
    throw new Error('A ' + type + ' type is already registered');
  }

  if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {
    throw new Error('The type ' + type + ' is invalid');
  }

  var
    constructor = function () {
      return extending ?
        document.createElement(nodeName, upperType) :
        document.createElement(nodeName);
    },
    opt = options || OP,
    extending = hOP.call(opt, EXTENDS),
    nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,
    i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1,
    upperType
  ;

  query = query.concat(
    query.length ? ',' : '',
    extending ? nodeName + '[is="' + type.toLowerCase() + '"]' : nodeName
  );

  constructor.prototype = (
    protos[i] = hOP.call(opt, 'prototype') ?
      opt.prototype :
      create(HTMLElementPrototype)
  );

  loopAndVerify(
    document.querySelectorAll(query),
    ATTACHED
  );

  return constructor;
};

}(window, document, Object, 'registerElement'));
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '72dev' };

// browserify support

if ( typeof module === 'object' ) {

  module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  Math.sign = function ( x ) {

    return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;

  };

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// DEPRECATED

THREE.Projector = function () {

  console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

  this.projectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    vector.project( camera );

  };

  this.unprojectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    vector.unproject( camera );

  };

  this.pickingRay = function ( vector, camera ) {

    console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

  };

};

THREE.CanvasRenderer = function () {

  console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

  this.domElement = document.createElement( 'canvas' );
  this.clear = function () {};
  this.render = function () {};
  this.setClearColor = function () {};
  this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

  if ( arguments.length === 3 ) {

    return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

  }

  return this.set( color )

};

THREE.Color.prototype = {

  constructor: THREE.Color,

  r: 1, g: 1, b: 1,

  set: function ( value ) {

    if ( value instanceof THREE.Color ) {

      this.copy( value );

    } else if ( typeof value === 'number' ) {

      this.setHex( value );

    } else if ( typeof value === 'string' ) {

      this.setStyle( value );

    }

    return this;

  },

  setHex: function ( hex ) {

    hex = Math.floor( hex );

    this.r = ( hex >> 16 & 255 ) / 255;
    this.g = ( hex >> 8 & 255 ) / 255;
    this.b = ( hex & 255 ) / 255;

    return this;

  },

  setRGB: function ( r, g, b ) {

    this.r = r;
    this.g = g;
    this.b = b;

    return this;

  },

  setHSL: function ( h, s, l ) {

    // h,s,l ranges are in 0.0 - 1.0

    if ( s === 0 ) {

      this.r = this.g = this.b = l;

    } else {

      var hue2rgb = function ( p, q, t ) {

        if ( t < 0 ) t += 1;
        if ( t > 1 ) t -= 1;
        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
        if ( t < 1 / 2 ) return q;
        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
        return p;

      };

      var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
      var q = ( 2 * l ) - p;

      this.r = hue2rgb( q, p, h + 1 / 3 );
      this.g = hue2rgb( q, p, h );
      this.b = hue2rgb( q, p, h - 1 / 3 );

    }

    return this;

  },

  setStyle: function ( style ) {

    // rgb(255,0,0)

    if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

      var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

      this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
      this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
      this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

      return this;

    }

    // rgb(100%,0%,0%)

    if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

      var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

      this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
      this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
      this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

      return this;

    }

    // #ff0000

    if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

      var color = /^\#([0-9a-f]{6})$/i.exec( style );

      this.setHex( parseInt( color[ 1 ], 16 ) );

      return this;

    }

    // #f00

    if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

      var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

      this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

      return this;

    }

    // red

    if ( /^(\w+)$/i.test( style ) ) {

      this.setHex( THREE.ColorKeywords[ style ] );

      return this;

    }


  },

  copy: function ( color ) {

    this.r = color.r;
    this.g = color.g;
    this.b = color.b;

    return this;

  },

  copyGammaToLinear: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    this.r = Math.pow( color.r, gammaFactor );
    this.g = Math.pow( color.g, gammaFactor );
    this.b = Math.pow( color.b, gammaFactor );

    return this;

  },

  copyLinearToGamma: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    this.r = Math.pow( color.r, safeInverse );
    this.g = Math.pow( color.g, safeInverse );
    this.b = Math.pow( color.b, safeInverse );

    return this;

  },

  convertGammaToLinear: function () {

    var r = this.r, g = this.g, b = this.b;

    this.r = r * r;
    this.g = g * g;
    this.b = b * b;

    return this;

  },

  convertLinearToGamma: function () {

    this.r = Math.sqrt( this.r );
    this.g = Math.sqrt( this.g );
    this.b = Math.sqrt( this.b );

    return this;

  },

  getHex: function () {

    return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  },

  getHexString: function () {

    return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  },

  getHSL: function ( optionalTarget ) {

    // h,s,l ranges are in 0.0 - 1.0

    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    var r = this.r, g = this.g, b = this.b;

    var max = Math.max( r, g, b );
    var min = Math.min( r, g, b );

    var hue, saturation;
    var lightness = ( min + max ) / 2.0;

    if ( min === max ) {

      hue = 0;
      saturation = 0;

    } else {

      var delta = max - min;

      saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

      switch ( max ) {

        case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
        case g: hue = ( b - r ) / delta + 2; break;
        case b: hue = ( r - g ) / delta + 4; break;

      }

      hue /= 6;

    }

    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;

    return hsl;

  },

  getStyle: function () {

    return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  },

  offsetHSL: function ( h, s, l ) {

    var hsl = this.getHSL();

    hsl.h += h; hsl.s += s; hsl.l += l;

    this.setHSL( hsl.h, hsl.s, hsl.l );

    return this;

  },

  add: function ( color ) {

    this.r += color.r;
    this.g += color.g;
    this.b += color.b;

    return this;

  },

  addColors: function ( color1, color2 ) {

    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;

    return this;

  },

  addScalar: function ( s ) {

    this.r += s;
    this.g += s;
    this.b += s;

    return this;

  },

  multiply: function ( color ) {

    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.r *= s;
    this.g *= s;
    this.b *= s;

    return this;

  },

  lerp: function ( color, alpha ) {

    this.r += ( color.r - this.r ) * alpha;
    this.g += ( color.g - this.g ) * alpha;
    this.b += ( color.b - this.b ) * alpha;

    return this;

  },

  equals: function ( c ) {

    return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  },

  fromArray: function ( array ) {

    this.r = array[ 0 ];
    this.g = array[ 1 ];
    this.b = array[ 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.r;
    array[ offset + 1 ] = this.g;
    array[ offset + 2 ] = this.b;

    return array;
  },

  clone: function () {

    return new THREE.Color().setRGB( this.r, this.g, this.b );

  }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

  constructor: THREE.Quaternion,

  _x: 0,_y: 0, _z: 0, _w: 0,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get w () {

    return this._w;

  },

  set w ( value ) {

    this._w = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, w ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;

  },

  copy: function ( quaternion ) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;

  },

  setFromEuler: function ( euler, update ) {

    if ( euler instanceof THREE.Euler === false ) {

      throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //  content/SpinCalc.m

    var c1 = Math.cos( euler._x / 2 );
    var c2 = Math.cos( euler._y / 2 );
    var c3 = Math.cos( euler._z / 2 );
    var s1 = Math.sin( euler._x / 2 );
    var s2 = Math.sin( euler._y / 2 );
    var s3 = Math.sin( euler._z / 2 );

    if ( euler.order === 'XYZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'YXZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'ZXY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'ZYX' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'YZX' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'XZY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromAxisAngle: function ( axis, angle ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos( halfAngle );

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

      trace = m11 + m22 + m33,
      s;

    if ( trace > 0 ) {

      s = 0.5 / Math.sqrt( trace + 1.0 );

      this._w = 0.25 / s;
      this._x = ( m32 - m23 ) * s;
      this._y = ( m13 - m31 ) * s;
      this._z = ( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

      this._w = ( m32 - m23 ) / s;
      this._x = 0.25 * s;
      this._y = ( m12 + m21 ) / s;
      this._z = ( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

      this._w = ( m13 - m31 ) / s;
      this._x = ( m12 + m21 ) / s;
      this._y = 0.25 * s;
      this._z = ( m23 + m32 ) / s;

    } else {

      s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

      this._w = ( m21 - m12 ) / s;
      this._x = ( m13 + m31 ) / s;
      this._y = ( m23 + m32 ) / s;
      this._z = 0.25 * s;

    }

    this.onChangeCallback();

    return this;

  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function ( vFrom, vTo ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {

        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

          v1.set( - vFrom.y, vFrom.x, 0 );

        } else {

          v1.set( 0, - vFrom.z, vFrom.y );

        }

      } else {

        v1.crossVectors( vFrom, vTo );

      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      this.normalize();

      return this;

    }

  }(),

  inverse: function () {

    this.conjugate().normalize();

    return this;

  },

  conjugate: function () {

    this._x *= - 1;
    this._y *= - 1;
    this._z *= - 1;

    this.onChangeCallback();

    return this;

  },

  dot: function ( v ) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  },

  lengthSq: function () {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  },

  length: function () {

    return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  },

  normalize: function () {

    var l = this.length();

    if ( l === 0 ) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;

    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;

    }

    this.onChangeCallback();

    return this;

  },

  multiply: function ( q, p ) {

    if ( p !== undefined ) {

      console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
      return this.multiplyQuaternions( q, p );

    }

    return this.multiplyQuaternions( this, q );

  },

  multiplyQuaternions: function ( a, b ) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    return vector.applyQuaternion( this );

  },

  slerp: function ( qb, t ) {

    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this._x, y = this._y, z = this._z, w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if ( cosHalfTheta < 0 ) {

      this._w = - qb._w;
      this._x = - qb._x;
      this._y = - qb._y;
      this._z = - qb._z;

      cosHalfTheta = - cosHalfTheta;

    } else {

      this.copy( qb );

    }

    if ( cosHalfTheta >= 1.0 ) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;

    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {

      this._w = 0.5 * ( w + this._w );
      this._x = 0.5 * ( x + this._x );
      this._y = 0.5 * ( y + this._y );
      this._z = 0.5 * ( z + this._z );

      return this;

    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this._w = ( w * ratioA + this._w * ratioB );
    this._x = ( x * ratioA + this._x * ratioB );
    this._y = ( y * ratioA + this._y * ratioB );
    this._z = ( z * ratioA + this._z * ratioB );

    this.onChangeCallback();

    return this;

  },

  equals: function ( quaternion ) {

    return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this._x = array[ offset ];
    this._y = array[ offset + 1 ];
    this._z = array[ offset + 2 ];
    this._w = array[ offset + 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._w;

    return array;

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Quaternion( this._x, this._y, this._z, this._w );

  }

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

  return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

  this.x = x || 0;
  this.y = y || 0;

};

THREE.Vector2.prototype = {

  constructor: THREE.Vector2,

  set: function ( x, y ) {

    this.x = x;
    this.y = y;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;

  },

  multiply: function ( v ) {

    this.x *= v.x;
    this.y *= v.y;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.x *= s;
    this.y *= s;

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    return this;
  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector2();
        max = new THREE.Vector2();

      }

      min.set( minVal, minVal );
      max.set( maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];

    return this;

  },

  clone: function () {

    return new THREE.Vector2( this.x, this.y );

  }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

THREE.Vector3.prototype = {

  constructor: THREE.Vector3,

  set: function ( x, y, z ) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
      return this.multiplyVectors( v, w );

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;

    return this;

  },

  multiplyVectors: function ( a, b ) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyEuler: function () {

    var quaternion;

    return function ( euler ) {

      if ( euler instanceof THREE.Euler === false ) {

        console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

      }

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromEuler( euler ) );

      return this;

    };

  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function ( axis, angle ) {

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      return this;

    };

  }(),

  applyMatrix3: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    return this;

  },

  applyMatrix4: function ( m ) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    return this;

  },

  applyProjection: function ( m ) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;
    var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    return this;

  },

  applyQuaternion: function ( q ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;

  },

  project: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
      return this.applyProjection( matrix );

    };

  }(),

  unproject: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
      return this.applyProjection( matrix );

    };

  }(),

  transformDirection: function ( m ) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    this.normalize();

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector3();
        max = new THREE.Vector3();

      }

      min.set( minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength  ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  cross: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
      return this.crossVectors( v, w );

    }

    var x = this.x, y = this.y, z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function ( a, b ) {

    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function ( vector ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( vector ).normalize();

      dot = this.dot( v1 );

      return this.copy( v1 ).multiplyScalar( dot );

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function ( planeNormal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( this ).projectOnVector( planeNormal );

      return this.sub( v1 );

    }

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function ( normal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    }

  }(),

  angleTo: function ( v ) {

    var theta = this.dot( v ) / ( this.length() * v.length() );

    // clamp, to handle numerical problems

    return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setEulerFromRotationMatrix: function ( m, order ) {

    console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  },

  setEulerFromQuaternion: function ( q, order ) {

    console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  },

  getPositionFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

    return this.setFromMatrixPosition( m );

  },

  getScaleFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

    return this.setFromMatrixScale( m );
  },

  getColumnFromMatrix: function ( index, matrix ) {

    console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

    return this.setFromMatrixColumn( index, matrix );

  },

  setFromMatrixPosition: function ( m ) {

    this.x = m.elements[ 12 ];
    this.y = m.elements[ 13 ];
    this.z = m.elements[ 14 ];

    return this;

  },

  setFromMatrixScale: function ( m ) {

    var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
    var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
    var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;
  },

  setFromMatrixColumn: function ( index, matrix ) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[ offset ];
    this.y = me[ offset + 1 ];
    this.z = me[ offset + 2 ];

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];

    return this;

  },

  clone: function () {

    return new THREE.Vector3( this.x, this.y, this.z );

  }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

  constructor: THREE.Vector4,

  set: function ( x, y, z, w ) {

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setW: function ( w ) {

    this.w = w;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      case 3: this.w = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      case 3: return this.w;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = ( v.w !== undefined ) ? v.w : 1;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;

    return this;

  },

  applyMatrix4: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
      this.w *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;

    }

    return this;

  },

  setAxisAngleFromQuaternion: function ( q ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos( q.w );

    var s = Math.sqrt( 1 - q.w * q.w );

    if ( s < 0.0001 ) {

       this.x = 1;
       this.y = 0;
       this.z = 0;

    } else {

       this.x = q.x / s;
       this.y = q.y / s;
       this.z = q.z / s;

    }

    return this;

  },

  setAxisAngleFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var angle, x, y, z,   // variables for result
      epsilon = 0.01,   // margin to allow for rounding errors
      epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees

      te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    if ( ( Math.abs( m12 - m21 ) < epsilon )
       && ( Math.abs( m13 - m31 ) < epsilon )
       && ( Math.abs( m23 - m32 ) < epsilon ) ) {

      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if ( ( Math.abs( m12 + m21 ) < epsilon2 )
         && ( Math.abs( m13 + m31 ) < epsilon2 )
         && ( Math.abs( m23 + m32 ) < epsilon2 )
         && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

        // this singularity is identity matrix so angle = 0

        this.set( 1, 0, 0, 0 );

        return this; // zero angle, arbitrary axis

      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;

      var xx = ( m11 + 1 ) / 2;
      var yy = ( m22 + 1 ) / 2;
      var zz = ( m33 + 1 ) / 2;
      var xy = ( m12 + m21 ) / 4;
      var xz = ( m13 + m31 ) / 4;
      var yz = ( m23 + m32 ) / 4;

      if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

        if ( xx < epsilon ) {

          x = 0;
          y = 0.707106781;
          z = 0.707106781;

        } else {

          x = Math.sqrt( xx );
          y = xy / x;
          z = xz / x;

        }

      } else if ( yy > zz ) { // m22 is the largest diagonal term

        if ( yy < epsilon ) {

          x = 0.707106781;
          y = 0;
          z = 0.707106781;

        } else {

          y = Math.sqrt( yy );
          x = xy / y;
          z = yz / y;

        }

      } else { // m33 is the largest diagonal term so base result on this

        if ( zz < epsilon ) {

          x = 0.707106781;
          y = 0.707106781;
          z = 0;

        } else {

          z = Math.sqrt( zz );
          x = xz / z;
          y = yz / z;

        }

      }

      this.set( x, y, z, angle );

      return this; // return 180 deg rotation

    }

    // as we have reached here there are no singularities so we can handle normally

    var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
              + ( m13 - m31 ) * ( m13 - m31 )
              + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    if ( Math.abs( s ) < 0.001 ) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = ( m32 - m23 ) / s;
    this.y = ( m13 - m31 ) / s;
    this.z = ( m21 - m12 ) / s;
    this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    if ( this.w > v.w ) {

      this.w = v.w;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    if ( this.w < v.w ) {

      this.w = v.w;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    if ( this.w < min.w ) {

      this.w = min.w;

    } else if ( this.w > max.w ) {

      this.w = max.w;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector4();
        max = new THREE.Vector4();

      }

      min.set( minVal, minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );
    this.w = Math.floor( this.w );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );
    this.w = Math.ceil( this.w );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );
    this.w = Math.round( this.w );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;
    this.w = - this.w;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );

    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;
    this.w += ( v.w - this.w ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];
    this.w = array[ offset + 3 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;
    array[ offset + 3 ] = this.w;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];
    this.w = attribute.array[ index + 3 ];

    return this;

  },

  clone: function () {

    return new THREE.Vector4( this.x, this.y, this.z, this.w );

  }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

  constructor: THREE.Euler,

  _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get order () {

    return this._order;

  },

  set order ( value ) {

    this._order = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, order ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;

  },

  copy: function ( euler ) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m, order, update ) {

    var clamp = THREE.Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._y = Math.asin( clamp( m13, - 1, 1 ) );

      if ( Math.abs( m13 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m33 );
        this._z = Math.atan2( - m12, m11 );

      } else {

        this._x = Math.atan2( m32, m22 );
        this._z = 0;

      }

    } else if ( order === 'YXZ' ) {

      this._x = Math.asin( - clamp( m23, - 1, 1 ) );

      if ( Math.abs( m23 ) < 0.99999 ) {

        this._y = Math.atan2( m13, m33 );
        this._z = Math.atan2( m21, m22 );

      } else {

        this._y = Math.atan2( - m31, m11 );
        this._z = 0;

      }

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin( clamp( m32, - 1, 1 ) );

      if ( Math.abs( m32 ) < 0.99999 ) {

        this._y = Math.atan2( - m31, m33 );
        this._z = Math.atan2( - m12, m22 );

      } else {

        this._y = 0;
        this._z = Math.atan2( m21, m11 );

      }

    } else if ( order === 'ZYX' ) {

      this._y = Math.asin( - clamp( m31, - 1, 1 ) );

      if ( Math.abs( m31 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m33 );
        this._z = Math.atan2( m21, m11 );

      } else {

        this._x = 0;
        this._z = Math.atan2( - m12, m22 );

      }

    } else if ( order === 'YZX' ) {

      this._z = Math.asin( clamp( m21, - 1, 1 ) );

      if ( Math.abs( m21 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m22 );
        this._y = Math.atan2( - m31, m11 );

      } else {

        this._x = 0;
        this._y = Math.atan2( m13, m33 );

      }

    } else if ( order === 'XZY' ) {

      this._z = Math.asin( - clamp( m12, - 1, 1 ) );

      if ( Math.abs( m12 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m22 );
        this._y = Math.atan2( m13, m11 );

      } else {

        this._x = Math.atan2( - m23, m33 );
        this._y = 0;

      }

    } else {

      console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

    }

    this._order = order;

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromQuaternion: function () {

    var matrix;

    return function ( q, order, update ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();
      matrix.makeRotationFromQuaternion( q );
      this.setFromRotationMatrix( matrix, order, update );

      return this;

    };

  }(),

  setFromVector3: function ( v, order ) {

    return this.set( v.x, v.y, v.z, order || this._order );

  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new THREE.Quaternion();

    return function ( newOrder ) {

      q.setFromEuler( this );
      this.setFromQuaternion( q, newOrder );

    };

  }(),

  equals: function ( euler ) {

    return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  },

  fromArray: function ( array ) {

    this._x = array[ 0 ];
    this._y = array[ 1 ];
    this._z = array[ 2 ];
    if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._order;

    return array;
  },

  toVector3: function ( optionalResult ) {

    if ( optionalResult ) {

      return optionalResult.set( this._x, this._y, this._z );

    } else {

      return new THREE.Vector3( this._x, this._y, this._z );

    }

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Euler( this._x, this._y, this._z, this._order );

  }

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

  this.start = ( start !== undefined ) ? start : new THREE.Vector3();
  this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

  constructor: THREE.Line3,

  set: function ( start, end ) {

    this.start.copy( start );
    this.end.copy( end );

    return this;

  },

  copy: function ( line ) {

    this.start.copy( line.start );
    this.end.copy( line.end );

    return this;

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  },

  delta: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.end, this.start );

  },

  distanceSq: function () {

    return this.start.distanceToSquared( this.end );

  },

  distance: function () {

    return this.start.distanceTo( this.end );

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  closestPointToPointParameter: function () {

    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();

    return function ( point, clampToLine ) {

      startP.subVectors( point, this.start );
      startEnd.subVectors( this.end, this.start );

      var startEnd2 = startEnd.dot( startEnd );
      var startEnd_startP = startEnd.dot( startP );

      var t = startEnd_startP / startEnd2;

      if ( clampToLine ) {

        t = THREE.Math.clamp( t, 0, 1 );

      }

      return t;

    };

  }(),

  closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    var t = this.closestPointToPointParameter( point, clampToLine );

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  applyMatrix4: function ( matrix ) {

    this.start.applyMatrix4( matrix );
    this.end.applyMatrix4( matrix );

    return this;

  },

  equals: function ( line ) {

    return line.start.equals( this.start ) && line.end.equals( this.end );

  },

  clone: function () {

    return new THREE.Line3().copy( this );

  }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

  constructor: THREE.Box2,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] )

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector2();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;
  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;
  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;
  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
         ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector2();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector2();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  },

  clone: function () {

    return new THREE.Box2().copy( this );

  }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

  constructor: THREE.Box3,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] );

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector3();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  setFromObject: function () {

    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and childrens', world transforms

    var v1 = new THREE.Vector3();

    return function ( object ) {

      var scope = this;

      object.updateMatrixWorld( true );

      this.makeEmpty();

      object.traverse( function ( node ) {

        var geometry = node.geometry;

        if ( geometry !== undefined ) {

          if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;

            for ( var i = 0, il = vertices.length; i < il; i ++ ) {

              v1.copy( vertices[ i ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          } else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

            var positions = geometry.attributes[ 'position' ].array;

            for ( var i = 0, il = positions.length; i < il; i += 3 ) {

              v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          }

        }

      } );

      return this;

    };

  }(),

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ||
         point.z < this.min.z || point.z > this.max.z ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
       ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
       ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector3();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
      ( point.z - this.min.z ) / ( this.max.z - this.min.z )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ||
         box.max.z < this.min.z || box.min.z > this.max.z ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  getBoundingSphere: function () {

    var v1 = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Sphere();

      result.center = this.center();
      result.radius = this.size( v1 ).length() * 0.5;

      return result;

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  applyMatrix4: function () {

    var points = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];

    return function ( matrix ) {

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
      points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
      points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
      points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
      points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
      points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
      points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
      points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

      this.makeEmpty();
      this.setFromPoints( points );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  },

  clone: function () {

    return new THREE.Box3().copy( this );

  }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

  this.elements = new Float32Array( [

    1, 0, 0,
    0, 1, 0,
    0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix3.prototype = {

  constructor: THREE.Matrix3,

  set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
    te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
    te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0,
      0, 1, 0,
      0, 0, 1

    );

    return this;

  },

  copy: function ( m ) {

    var me = m.elements;

    this.set(

      me[ 0 ], me[ 3 ], me[ 6 ],
      me[ 1 ], me[ 4 ], me[ 7 ],
      me[ 2 ], me[ 5 ], me[ 8 ]

    );

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    return vector.applyMatrix3( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix3( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix3( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    return this;

  },

  determinant: function () {

    var te = this.elements;

    var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
      d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
      g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  },

  getInverse: function ( matrix, throwOnInvertible ) {

    // input: THREE.Matrix4
    // ( based on http://code.google.com/p/webgl-mjs/ )

    var me = matrix.elements;
    var te = this.elements;

    te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
    te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
    te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
    te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
    te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
    te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
    te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
    te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
    te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

    var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

    // no inverse

    if ( det === 0 ) {

      var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1.0 / det );

    return this;

  },

  transpose: function () {

    var tmp, m = this.elements;

    tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset     ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];

    array[ offset + 3 ] = te[ 3 ];
    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];

    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];
    array[ offset + 8 ]  = te[ 8 ];

    return array;

  },

  getNormalMatrix: function ( m ) {

    // input: THREE.Matrix4

    this.getInverse( m ).transpose();

    return this;

  },

  transposeIntoArray: function ( r ) {

    var m = this.elements;

    r[ 0 ] = m[ 0 ];
    r[ 1 ] = m[ 3 ];
    r[ 2 ] = m[ 6 ];
    r[ 3 ] = m[ 1 ];
    r[ 4 ] = m[ 4 ];
    r[ 5 ] = m[ 7 ];
    r[ 6 ] = m[ 2 ];
    r[ 7 ] = m[ 5 ];
    r[ 8 ] = m[ 8 ];

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ],
      te[ 3 ], te[ 4 ], te[ 5 ],
      te[ 6 ], te[ 7 ], te[ 8 ]
    ];

  },

  clone: function () {

    return new THREE.Matrix3().fromArray( this.elements );

  }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

  this.elements = new Float32Array( [

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix4.prototype = {

  constructor: THREE.Matrix4,

  set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  copy: function ( m ) {

    this.elements.set( m.elements );

    return this;

  },

  extractPosition: function ( m ) {

    console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    return this.copyPosition( m );

  },

  copyPosition: function ( m ) {

    var te = this.elements;
    var me = m.elements;

    te[ 12 ] = me[ 12 ];
    te[ 13 ] = me[ 13 ];
    te[ 14 ] = me[ 14 ];

    return this;

  },

  extractBasis: function ( xAxis, yAxis, zAxis ) {

    var te = this.elements;

    xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
    yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
    zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

    return this;

  },

  makeBasis: function ( xAxis, yAxis, zAxis ) {

    this.set(
      xAxis.x, yAxis.x, zAxis.x, 0,
      xAxis.y, yAxis.y, zAxis.y, 0,
      xAxis.z, yAxis.z, zAxis.z, 0,
      0,       0,       0,       1
    );

    return this;

  },

  extractRotation: function () {

    var v1;

    return function ( m ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
      var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
      var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

      te[ 0 ] = me[ 0 ] * scaleX;
      te[ 1 ] = me[ 1 ] * scaleX;
      te[ 2 ] = me[ 2 ] * scaleX;

      te[ 4 ] = me[ 4 ] * scaleY;
      te[ 5 ] = me[ 5 ] * scaleY;
      te[ 6 ] = me[ 6 ] * scaleY;

      te[ 8 ] = me[ 8 ] * scaleZ;
      te[ 9 ] = me[ 9 ] * scaleZ;
      te[ 10 ] = me[ 10 ] * scaleZ;

      return this;

    };

  }(),

  makeRotationFromEuler: function ( euler ) {

    if ( euler instanceof THREE.Euler === false ) {

      console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    var te = this.elements;

    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos( x ), b = Math.sin( x );
    var c = Math.cos( y ), d = Math.sin( y );
    var e = Math.cos( z ), f = Math.sin( z );

    if ( euler.order === 'XYZ' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = - c * f;
      te[ 8 ] = d;

      te[ 1 ] = af + be * d;
      te[ 5 ] = ae - bf * d;
      te[ 9 ] = - b * c;

      te[ 2 ] = bf - ae * d;
      te[ 6 ] = be + af * d;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YXZ' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce + df * b;
      te[ 4 ] = de * b - cf;
      te[ 8 ] = a * d;

      te[ 1 ] = a * f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b;

      te[ 2 ] = cf * b - de;
      te[ 6 ] = df + ce * b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZXY' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce - df * b;
      te[ 4 ] = - a * f;
      te[ 8 ] = de + cf * b;

      te[ 1 ] = cf + de * b;
      te[ 5 ] = a * e;
      te[ 9 ] = df - ce * b;

      te[ 2 ] = - a * d;
      te[ 6 ] = b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZYX' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = be * d - af;
      te[ 8 ] = ae * d + bf;

      te[ 1 ] = c * f;
      te[ 5 ] = bf * d + ae;
      te[ 9 ] = af * d - be;

      te[ 2 ] = - d;
      te[ 6 ] = b * c;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YZX' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = bd - ac * f;
      te[ 8 ] = bc * f + ad;

      te[ 1 ] = f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b * e;

      te[ 2 ] = - d * e;
      te[ 6 ] = ad * f + bc;
      te[ 10 ] = ac - bd * f;

    } else if ( euler.order === 'XZY' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = - f;
      te[ 8 ] = d * e;

      te[ 1 ] = ac * f + bd;
      te[ 5 ] = a * e;
      te[ 9 ] = ad * f - bc;

      te[ 2 ] = bc * f - ad;
      te[ 6 ] = b * e;
      te[ 10 ] = bd * f + ac;

    }

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  setRotationFromQuaternion: function ( q ) {

    console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

    return this.makeRotationFromQuaternion( q );

  },

  makeRotationFromQuaternion: function ( q ) {

    var te = this.elements;

    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;

    te[ 0 ] = 1 - ( yy + zz );
    te[ 4 ] = xy - wz;
    te[ 8 ] = xz + wy;

    te[ 1 ] = xy + wz;
    te[ 5 ] = 1 - ( xx + zz );
    te[ 9 ] = yz - wx;

    te[ 2 ] = xz - wy;
    te[ 6 ] = yz + wx;
    te[ 10 ] = 1 - ( xx + yy );

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  lookAt: function () {

    var x, y, z;

    return function ( eye, target, up ) {

      if ( x === undefined ) x = new THREE.Vector3();
      if ( y === undefined ) y = new THREE.Vector3();
      if ( z === undefined ) z = new THREE.Vector3();

      var te = this.elements;

      z.subVectors( eye, target ).normalize();

      if ( z.length() === 0 ) {

        z.z = 1;

      }

      x.crossVectors( up, z ).normalize();

      if ( x.length() === 0 ) {

        z.x += 0.0001;
        x.crossVectors( up, z ).normalize();

      }

      y.crossVectors( z, x );


      te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
      te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
      te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

      return this;

    };

  }(),

  multiply: function ( m, n ) {

    if ( n !== undefined ) {

      console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
      return this.multiplyMatrices( m, n );

    }

    return this.multiplyMatrices( this, m );

  },

  multiplyMatrices: function ( a, b ) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;

  },

  multiplyToArray: function ( a, b, r ) {

    var te = this.elements;

    this.multiplyMatrices( a, b );

    r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    return this;

  },

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    return vector.applyProjection( this );

  },

  multiplyVector4: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix4( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix4( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  rotateAxis: function ( v ) {

    console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

    v.transformDirection( this );

  },

  crossVector: function ( vector ) {

    console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  determinant: function () {

    var te = this.elements;

    var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return (
      n41 * (
        + n14 * n23 * n32
         - n13 * n24 * n32
         - n14 * n22 * n33
         + n12 * n24 * n33
         + n13 * n22 * n34
         - n12 * n23 * n34
      ) +
      n42 * (
        + n11 * n23 * n34
         - n11 * n24 * n33
         + n14 * n21 * n33
         - n13 * n21 * n34
         + n13 * n24 * n31
         - n14 * n23 * n31
      ) +
      n43 * (
        + n11 * n24 * n32
         - n11 * n22 * n34
         - n14 * n21 * n32
         + n12 * n21 * n34
         + n14 * n22 * n31
         - n12 * n24 * n31
      ) +
      n44 * (
        - n13 * n22 * n31
         - n11 * n23 * n32
         + n11 * n22 * n33
         + n13 * n21 * n32
         - n12 * n21 * n33
         + n12 * n23 * n31
      )

    );

  },

  transpose: function () {

    var te = this.elements;
    var tmp;

    tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset     ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];
    array[ offset + 3 ] = te[ 3 ];

    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];
    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];

    array[ offset + 8 ]  = te[ 8 ];
    array[ offset + 9 ]  = te[ 9 ];
    array[ offset + 10 ] = te[ 10 ];
    array[ offset + 11 ] = te[ 11 ];

    array[ offset + 12 ] = te[ 12 ];
    array[ offset + 13 ] = te[ 13 ];
    array[ offset + 14 ] = te[ 14 ];
    array[ offset + 15 ] = te[ 15 ];

    return array;

  },

  getPosition: function () {

    var v1;

    return function () {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

      var te = this.elements;
      return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

    };

  }(),

  setPosition: function ( v ) {

    var te = this.elements;

    te[ 12 ] = v.x;
    te[ 13 ] = v.y;
    te[ 14 ] = v.z;

    return this;

  },

  getInverse: function ( m, throwOnInvertible ) {

    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements;
    var me = m.elements;

    var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
    var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
    var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
    var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

    te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

    var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

    if ( det === 0 ) {

      var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1 / det );

    return this;

  },

  translate: function ( v ) {

    console.error( 'THREE.Matrix4: .translate() has been removed.' );

  },

  rotateX: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  },

  rotateY: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  },

  rotateZ: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  },

  rotateByAxis: function ( axis, angle ) {

    console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  },

  scale: function ( v ) {

    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;

    te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    return this;

  },

  getMaxScaleOnAxis: function () {

    var te = this.elements;

    var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

  },

  makeTranslation: function ( x, y, z ) {

    this.set(

      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationX: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      1, 0,  0, 0,
      0, c, - s, 0,
      0, s,  c, 0,
      0, 0,  0, 1

    );

    return this;

  },

  makeRotationY: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

       c, 0, s, 0,
       0, 1, 0, 0,
      - s, 0, c, 0,
       0, 0, 0, 1

    );

    return this;

  },

  makeRotationZ: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      c, - s, 0, 0,
      s,  c, 0, 0,
      0,  0, 1, 0,
      0,  0, 0, 1

    );

    return this;

  },

  makeRotationAxis: function ( axis, angle ) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;

    this.set(

      tx * x + c, tx * y - s * z, tx * z + s * y, 0,
      tx * y + s * z, ty * y + c, ty * z - s * x, 0,
      tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
      0, 0, 0, 1

    );

     return this;

  },

  makeScale: function ( x, y, z ) {

    this.set(

      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1

    );

    return this;

  },

  compose: function ( position, quaternion, scale ) {

    this.makeRotationFromQuaternion( quaternion );
    this.scale( scale );
    this.setPosition( position );

    return this;

  },

  decompose: function () {

    var vector, matrix;

    return function ( position, quaternion, scale ) {

      if ( vector === undefined ) vector = new THREE.Vector3();
      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      var te = this.elements;

      var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
      var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
      var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if ( det < 0 ) {

        sx = - sx;

      }

      position.x = te[ 12 ];
      position.y = te[ 13 ];
      position.z = te[ 14 ];

      // scale the rotation part

      matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[ 0 ] *= invSX;
      matrix.elements[ 1 ] *= invSX;
      matrix.elements[ 2 ] *= invSX;

      matrix.elements[ 4 ] *= invSY;
      matrix.elements[ 5 ] *= invSY;
      matrix.elements[ 6 ] *= invSY;

      matrix.elements[ 8 ] *= invSZ;
      matrix.elements[ 9 ] *= invSZ;
      matrix.elements[ 10 ] *= invSZ;

      quaternion.setFromRotationMatrix( matrix );

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;

    };

  }(),

  makeFrustum: function ( left, right, bottom, top, near, far ) {

    var te = this.elements;
    var x = 2 * near / ( right - left );
    var y = 2 * near / ( top - bottom );

    var a = ( right + left ) / ( right - left );
    var b = ( top + bottom ) / ( top - bottom );
    var c = - ( far + near ) / ( far - near );
    var d = - 2 * far * near / ( far - near );

    te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;
    te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;

    return this;

  },

  makePerspective: function ( fov, aspect, near, far ) {

    var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
    var ymin = - ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

  },

  makeOrthographic: function ( left, right, top, bottom, near, far ) {

    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;

    var x = ( right + left ) / w;
    var y = ( top + bottom ) / h;
    var z = ( far + near ) / p;

    te[ 0 ] = 2 / w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;
    te[ 1 ] = 0;  te[ 5 ] = 2 / h;  te[ 9 ] = 0;  te[ 13 ] = - y;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 / p; te[ 14 ] = - z;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
      te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
      te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
      te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
    ];

  },

  clone: function () {

    return new THREE.Matrix4().fromArray( this.elements );

  }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

  this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
  this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

  constructor: THREE.Ray,

  set: function ( origin, direction ) {

    this.origin.copy( origin );
    this.direction.copy( direction );

    return this;

  },

  copy: function ( ray ) {

    this.origin.copy( ray.origin );
    this.direction.copy( ray.direction );

    return this;

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  },

  recast: function () {

    var v1 = new THREE.Vector3();

    return function ( t ) {

      this.origin.copy( this.at( t, v1 ) );

      return this;

    };

  }(),

  closestPointToPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    result.subVectors( point, this.origin );
    var directionDistance = result.dot( this.direction );

    if ( directionDistance < 0 ) {

      return result.copy( this.origin );

    }

    return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

      // point behind the ray

      if ( directionDistance < 0 ) {

        return this.origin.distanceTo( point );

      }

      v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

      return v1.distanceTo( point );

    };

  }(),

  distanceSqToSegment: function () {

    var segCenter = new THREE.Vector3();
    var segDir = new THREE.Vector3();
    var diff = new THREE.Vector3();

    return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

      // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
      segDir.copy( v1 ).sub( v0 ).normalize();
      diff.copy( this.origin ).sub( segCenter );

      var segExtent = v0.distanceTo( v1 ) * 0.5;
      var a01 = - this.direction.dot( segDir );
      var b0 = diff.dot( this.direction );
      var b1 = - diff.dot( segDir );
      var c = diff.lengthSq();
      var det = Math.abs( 1 - a01 * a01 );
      var s0, s1, sqrDist, extDet;

      if ( det > 0 ) {

        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if ( s0 >= 0 ) {

          if ( s1 >= - extDet ) {

            if ( s1 <= extDet ) {

              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

            } else {

              // region 1

              s1 = segExtent;
              s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

          } else {

            // region 5

            s1 = - segExtent;
            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        } else {

          if ( s1 <= - extDet ) {

            // region 4

            s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          } else if ( s1 <= extDet ) {

            // region 3

            s0 = 0;
            s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = s1 * ( s1 + 2 * b1 ) + c;

          } else {

            // region 2

            s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        }

      } else {

        // Ray and segment are parallel.

        s1 = ( a01 > 0 ) ? - segExtent : segExtent;
        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

      }

      if ( optionalPointOnRay ) {

        optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

      }

      if ( optionalPointOnSegment ) {

        optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

      }

      return sqrDist;

    };

  }(),


  isIntersectionSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) <= sphere.radius;

  },

  intersectSphere: function () {

    // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

    var v1 = new THREE.Vector3();

    return function ( sphere, optionalTarget ) {

      v1.subVectors( sphere.center, this.origin );

      var tca = v1.dot( this.direction );

      var d2 = v1.dot( v1 ) - tca * tca;

      var radius2 = sphere.radius * sphere.radius;

      if ( d2 > radius2 ) return null;

      var thc = Math.sqrt( radius2 - d2 );

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if both t0 and t1 are behind the ray - if so, return null
      if ( t0 < 0 && t1 < 0 ) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if ( t0 < 0 ) return this.at( t1, optionalTarget );

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at( t0, optionalTarget );

    }

  }(),

  isIntersectionPlane: function ( plane ) {

    // check if the ray lies on the plane first

    var distToPoint = plane.distanceToPoint( this.origin );

    if ( distToPoint === 0 ) {

      return true;

    }

    var denominator = plane.normal.dot( this.direction );

    if ( denominator * distToPoint < 0 ) {

      return true;

    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;

  },

  distanceToPlane: function ( plane ) {

    var denominator = plane.normal.dot( this.direction );
    if ( denominator === 0 ) {

      // line is coplanar, return origin
      if ( plane.distanceToPoint( this.origin ) === 0 ) {

        return 0;

      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;

    }

    var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t :  null;

  },

  intersectPlane: function ( plane, optionalTarget ) {

    var t = this.distanceToPlane( plane );

    if ( t === null ) {

      return null;
    }

    return this.at( t, optionalTarget );

  },

  isIntersectionBox: function () {

    var v = new THREE.Vector3();

    return function ( box ) {

      return this.intersectBox( box, v ) !== null;

    };

  }(),

  intersectBox: function ( box, optionalTarget ) {

    // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

    var tmin,tmax,tymin,tymax,tzmin,tzmax;

    var invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if ( invdirx >= 0 ) {

      tmin = ( box.min.x - origin.x ) * invdirx;
      tmax = ( box.max.x - origin.x ) * invdirx;

    } else {

      tmin = ( box.max.x - origin.x ) * invdirx;
      tmax = ( box.min.x - origin.x ) * invdirx;
    }

    if ( invdiry >= 0 ) {

      tymin = ( box.min.y - origin.y ) * invdiry;
      tymax = ( box.max.y - origin.y ) * invdiry;

    } else {

      tymin = ( box.max.y - origin.y ) * invdiry;
      tymax = ( box.min.y - origin.y ) * invdiry;
    }

    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    if ( invdirz >= 0 ) {

      tzmin = ( box.min.z - origin.z ) * invdirz;
      tzmax = ( box.max.z - origin.z ) * invdirz;

    } else {

      tzmin = ( box.max.z - origin.z ) * invdirz;
      tzmax = ( box.min.z - origin.z ) * invdirz;
    }

    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    //return point closest to the ray (positive side)

    if ( tmax < 0 ) return null;

    return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  },

  intersectTriangle: function () {

    // Compute the offset origin, edges, and normal.
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();

    return function ( a, b, c, backfaceCulling, optionalTarget ) {

      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

      edge1.subVectors( b, a );
      edge2.subVectors( c, a );
      normal.crossVectors( edge1, edge2 );

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot( normal );
      var sign;

      if ( DdN > 0 ) {

        if ( backfaceCulling ) return null;
        sign = 1;

      } else if ( DdN < 0 ) {

        sign = - 1;
        DdN = - DdN;

      } else {

        return null;

      }

      diff.subVectors( this.origin, a );
      var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

      // b1 < 0, no intersection
      if ( DdQxE2 < 0 ) {

        return null;

      }

      var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

      // b2 < 0, no intersection
      if ( DdE1xQ < 0 ) {

        return null;

      }

      // b1+b2 > 1, no intersection
      if ( DdQxE2 + DdE1xQ > DdN ) {

        return null;

      }

      // Line intersects triangle, check if ray does.
      var QdN = - sign * diff.dot( normal );

      // t < 0, no intersection
      if ( QdN < 0 ) {

        return null;

      }

      // Ray intersects triangle.
      return this.at( QdN / DdN, optionalTarget );

    };

  }(),

  applyMatrix4: function ( matrix4 ) {

    this.direction.add( this.origin ).applyMatrix4( matrix4 );
    this.origin.applyMatrix4( matrix4 );
    this.direction.sub( this.origin );
    this.direction.normalize();

    return this;
  },

  equals: function ( ray ) {

    return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  },

  clone: function () {

    return new THREE.Ray().copy( this );

  }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

  this.center = ( center !== undefined ) ? center : new THREE.Vector3();
  this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

  constructor: THREE.Sphere,

  set: function ( center, radius ) {

    this.center.copy( center );
    this.radius = radius;

    return this;
  },

  setFromPoints: function () {

    var box = new THREE.Box3();

    return function ( points, optionalCenter ) {

      var center = this.center;

      if ( optionalCenter !== undefined ) {

        center.copy( optionalCenter );

      } else {

        box.setFromPoints( points ).center( center );

      }

      var maxRadiusSq = 0;

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

      }

      this.radius = Math.sqrt( maxRadiusSq );

      return this;

    };

  }(),

  copy: function ( sphere ) {

    this.center.copy( sphere.center );
    this.radius = sphere.radius;

    return this;

  },

  empty: function () {

    return ( this.radius <= 0 );

  },

  containsPoint: function ( point ) {

    return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  },

  distanceToPoint: function ( point ) {

    return ( point.distanceTo( this.center ) - this.radius );

  },

  intersectsSphere: function ( sphere ) {

    var radiusSum = this.radius + sphere.radius;

    return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  },

  clampPoint: function ( point, optionalTarget ) {

    var deltaLengthSq = this.center.distanceToSquared( point );

    var result = optionalTarget || new THREE.Vector3();
    result.copy( point );

    if ( deltaLengthSq > ( this.radius * this.radius ) ) {

      result.sub( this.center ).normalize();
      result.multiplyScalar( this.radius ).add( this.center );

    }

    return result;

  },

  getBoundingBox: function ( optionalTarget ) {

    var box = optionalTarget || new THREE.Box3();

    box.set( this.center, this.center );
    box.expandByScalar( this.radius );

    return box;

  },

  applyMatrix4: function ( matrix ) {

    this.center.applyMatrix4( matrix );
    this.radius = this.radius * matrix.getMaxScaleOnAxis();

    return this;

  },

  translate: function ( offset ) {

    this.center.add( offset );

    return this;

  },

  equals: function ( sphere ) {

    return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  },

  clone: function () {

    return new THREE.Sphere().copy( this );

  }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

  this.planes = [

    ( p0 !== undefined ) ? p0 : new THREE.Plane(),
    ( p1 !== undefined ) ? p1 : new THREE.Plane(),
    ( p2 !== undefined ) ? p2 : new THREE.Plane(),
    ( p3 !== undefined ) ? p3 : new THREE.Plane(),
    ( p4 !== undefined ) ? p4 : new THREE.Plane(),
    ( p5 !== undefined ) ? p5 : new THREE.Plane()

  ];

};

THREE.Frustum.prototype = {

  constructor: THREE.Frustum,

  set: function ( p0, p1, p2, p3, p4, p5 ) {

    var planes = this.planes;

    planes[ 0 ].copy( p0 );
    planes[ 1 ].copy( p1 );
    planes[ 2 ].copy( p2 );
    planes[ 3 ].copy( p3 );
    planes[ 4 ].copy( p4 );
    planes[ 5 ].copy( p5 );

    return this;

  },

  copy: function ( frustum ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      planes[ i ].copy( frustum.planes[ i ] );

    }

    return this;

  },

  setFromMatrix: function ( m ) {

    var planes = this.planes;
    var me = m.elements;
    var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    return this;

  },

  intersectsObject: function () {

    var sphere = new THREE.Sphere();

    return function ( object ) {

      var geometry = object.geometry;

      if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

      sphere.copy( geometry.boundingSphere );
      sphere.applyMatrix4( object.matrixWorld );

      return this.intersectsSphere( sphere );

    };

  }(),

  intersectsSphere: function ( sphere ) {

    var planes = this.planes;
    var center = sphere.center;
    var negRadius = - sphere.radius;

    for ( var i = 0; i < 6; i ++ ) {

      var distance = planes[ i ].distanceToPoint( center );

      if ( distance < negRadius ) {

        return false;

      }

    }

    return true;

  },

  intersectsBox: function () {

    var p1 = new THREE.Vector3(),
      p2 = new THREE.Vector3();

    return function ( box ) {

      var planes = this.planes;

      for ( var i = 0; i < 6 ; i ++ ) {

        var plane = planes[ i ];

        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        var d1 = plane.distanceToPoint( p1 );
        var d2 = plane.distanceToPoint( p2 );

        // if both outside plane, no intersection

        if ( d1 < 0 && d2 < 0 ) {

          return false;

        }
      }

      return true;
    };

  }(),


  containsPoint: function ( point ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      if ( planes[ i ].distanceToPoint( point ) < 0 ) {

        return false;

      }

    }

    return true;

  },

  clone: function () {

    return new THREE.Frustum().copy( this );

  }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

  this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
  this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

  constructor: THREE.Plane,

  set: function ( normal, constant ) {

    this.normal.copy( normal );
    this.constant = constant;

    return this;

  },

  setComponents: function ( x, y, z, w ) {

    this.normal.set( x, y, z );
    this.constant = w;

    return this;

  },

  setFromNormalAndCoplanarPoint: function ( normal, point ) {

    this.normal.copy( normal );
    this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

    return this;

  },

  setFromCoplanarPoints: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( a, b, c ) {

      var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint( normal, a );

      return this;

    };

  }(),


  copy: function ( plane ) {

    this.normal.copy( plane.normal );
    this.constant = plane.constant;

    return this;

  },

  normalize: function () {

    // Note: will lead to a divide by zero if the plane is invalid.

    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar( inverseNormalLength );
    this.constant *= inverseNormalLength;

    return this;

  },

  negate: function () {

    this.constant *= - 1;
    this.normal.negate();

    return this;

  },

  distanceToPoint: function ( point ) {

    return this.normal.dot( point ) + this.constant;

  },

  distanceToSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) - sphere.radius;

  },

  projectPoint: function ( point, optionalTarget ) {

    return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

  },

  orthoPoint: function ( point, optionalTarget ) {

    var perpendicularMagnitude = this.distanceToPoint( point );

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

  },

  isIntersectionLine: function ( line ) {

    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    var startSign = this.distanceToPoint( line.start );
    var endSign = this.distanceToPoint( line.end );

    return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  },

  intersectLine: function () {

    var v1 = new THREE.Vector3();

    return function ( line, optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      var direction = line.delta( v1 );

      var denominator = this.normal.dot( direction );

      if ( denominator === 0 ) {

        // line is coplanar, return origin
        if ( this.distanceToPoint( line.start ) === 0 ) {

          return result.copy( line.start );

        }

        // Unsure if this is the correct method to handle this case.
        return undefined;

      }

      var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

      if ( t < 0 || t > 1 ) {

        return undefined;

      }

      return result.copy( direction ).multiplyScalar( t ).add( line.start );

    };

  }(),


  coplanarPoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( - this.constant );

  },

  applyMatrix4: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var m1 = new THREE.Matrix3();

    return function ( matrix, optionalNormalMatrix ) {

      // compute new normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
      var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

      var newCoplanarPoint = this.coplanarPoint( v2 );
      newCoplanarPoint.applyMatrix4( matrix );

      this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.constant = this.constant - offset.dot( this.normal );

    return this;

  },

  equals: function ( plane ) {

    return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  },

  clone: function () {

    return new THREE.Plane().copy( this );

  }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    var uuid = new Array( 36 );
    var rnd = 0, r;

    return function () {

      for ( var i = 0; i < 36; i ++ ) {

        if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

          uuid[ i ] = '-';

        } else if ( i === 14 ) {

          uuid[ i ] = '4';

        } else {

          if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

        }
      }

      return uuid.join( '' );

    };

  }(),

  // Clamp value to range <a, b>

  clamp: function ( x, a, b ) {

    return ( x < a ) ? a : ( ( x > b ) ? b : x );

  },

  // Clamp value to range <a, inf)

  clampBottom: function ( x, a ) {

    return x < a ? a : x;

  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function ( x, a1, a2, b1, b2 ) {

    return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * ( 3 - 2 * x );

  },

  smootherstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  },

  // Random float from <0, 1> with 16 bits of randomness
  // (standard Math.random() creates repetitive patterns when applied over larger space)

  random16: function () {

    return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

  },

  // Random integer from <low, high> interval

  randInt: function ( low, high ) {

    return Math.floor( this.randFloat( low, high ) );

  },

  // Random float from <low, high> interval

  randFloat: function ( low, high ) {

    return low + Math.random() * ( high - low );

  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function ( range ) {

    return range * ( 0.5 - Math.random() );

  },

  degToRad: function () {

    var degreeToRadiansFactor = Math.PI / 180;

    return function ( degrees ) {

      return degrees * degreeToRadiansFactor;

    };

  }(),

  radToDeg: function () {

    var radianToDegreesFactor = 180 / Math.PI;

    return function ( radians ) {

      return radians * radianToDegreesFactor;

    };

  }(),

  isPowerOfTwo: function ( value ) {

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  },

  nextPowerOfTwo: function ( value ) {

    value --;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value ++;

    return value;

  }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

  this.points = points;

  var c = [], v3 = { x: 0, y: 0, z: 0 },
  point, intPoint, weight, w2, w3,
  pa, pb, pc, pd;

  this.initFromArray = function ( a ) {

    this.points = [];

    for ( var i = 0; i < a.length; i ++ ) {

      this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    }

  };

  this.getPoint = function ( k ) {

    point = ( this.points.length - 1 ) * k;
    intPoint = Math.floor( point );
    weight = point - intPoint;

    c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    c[ 1 ] = intPoint;
    c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    pa = this.points[ c[ 0 ] ];
    pb = this.points[ c[ 1 ] ];
    pc = this.points[ c[ 2 ] ];
    pd = this.points[ c[ 3 ] ];

    w2 = weight * weight;
    w3 = weight * w2;

    v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    return v3;

  };

  this.getControlPointsArray = function () {

    var i, p, l = this.points.length,
      coords = [];

    for ( i = 0; i < l; i ++ ) {

      p = this.points[ i ];
      coords[ i ] = [ p.x, p.y, p.z ];

    }

    return coords;

  };

  // approximate length by summing linear segments

  this.getLength = function ( nSubDivisions ) {

    var i, index, nSamples, position,
      point = 0, intPoint = 0, oldIntPoint = 0,
      oldPosition = new THREE.Vector3(),
      tmpVec = new THREE.Vector3(),
      chunkLengths = [],
      totalLength = 0;

    // first point has 0 length

    chunkLengths[ 0 ] = 0;

    if ( ! nSubDivisions ) nSubDivisions = 100;

    nSamples = this.points.length * nSubDivisions;

    oldPosition.copy( this.points[ 0 ] );

    for ( i = 1; i < nSamples; i ++ ) {

      index = i / nSamples;

      position = this.getPoint( index );
      tmpVec.copy( position );

      totalLength += tmpVec.distanceTo( oldPosition );

      oldPosition.copy( position );

      point = ( this.points.length - 1 ) * index;
      intPoint = Math.floor( point );

      if ( intPoint !== oldIntPoint ) {

        chunkLengths[ intPoint ] = totalLength;
        oldIntPoint = intPoint;

      }

    }

    // last point ends with total length

    chunkLengths[ chunkLengths.length ] = totalLength;

    return { chunks: chunkLengths, total: totalLength };

  };

  this.reparametrizeByArcLength = function ( samplingCoef ) {

    var i, j,
      index, indexCurrent, indexNext,
      realDistance,
      sampling, position,
      newpoints = [],
      tmpVec = new THREE.Vector3(),
      sl = this.getLength();

    newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    for ( i = 1; i < this.points.length; i ++ ) {

      //tmpVec.copy( this.points[ i - 1 ] );
      //linearDistance = tmpVec.distanceTo( this.points[ i ] );

      realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

      sampling = Math.ceil( samplingCoef * realDistance / sl.total );

      indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
      indexNext = i / ( this.points.length - 1 );

      for ( j = 1; j < sampling - 1; j ++ ) {

        index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

        position = this.getPoint( index );
        newpoints.push( tmpVec.copy( position ).clone() );

      }

      newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    }

    this.points = newpoints;

  };

  // Catmull-Rom

  function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    var v0 = ( p2 - p0 ) * 0.5,
      v1 = ( p3 - p1 ) * 0.5;

    return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

  this.a = ( a !== undefined ) ? a : new THREE.Vector3();
  this.b = ( b !== undefined ) ? b : new THREE.Vector3();
  this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

  var v0 = new THREE.Vector3();

  return function ( a, b, c, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    result.subVectors( c, b );
    v0.subVectors( a, b );
    result.cross( v0 );

    var resultLengthSq = result.lengthSq();
    if ( resultLengthSq > 0 ) {

      return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    }

    return result.set( 0, 0, 0 );

  };

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( point, a, b, c, optionalTarget ) {

    v0.subVectors( c, a );
    v1.subVectors( b, a );
    v2.subVectors( point, a );

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var denom = ( dot00 * dot11 - dot01 * dot01 );

    var result = optionalTarget || new THREE.Vector3();

    // colinear or singular triangle
    if ( denom === 0 ) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set( - 2, - 1, - 1 );
    }

    var invDenom = 1 / denom;
    var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    // barycoordinates must always sum to 1
    return result.set( 1 - u - v, v, u );

  };

}();

THREE.Triangle.containsPoint = function () {

  var v1 = new THREE.Vector3();

  return function ( point, a, b, c ) {

    var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

    return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  };

}();

THREE.Triangle.prototype = {

  constructor: THREE.Triangle,

  set: function ( a, b, c ) {

    this.a.copy( a );
    this.b.copy( b );
    this.c.copy( c );

    return this;

  },

  setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    this.a.copy( points[ i0 ] );
    this.b.copy( points[ i1 ] );
    this.c.copy( points[ i2 ] );

    return this;

  },

  copy: function ( triangle ) {

    this.a.copy( triangle.a );
    this.b.copy( triangle.b );
    this.c.copy( triangle.c );

    return this;

  },

  area: function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();

    return function () {

      v0.subVectors( this.c, this.b );
      v1.subVectors( this.a, this.b );

      return v0.cross( v1 ).length() * 0.5;

    };

  }(),

  midpoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  },

  normal: function ( optionalTarget ) {

    return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

  },

  plane: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Plane();

    return result.setFromCoplanarPoints( this.a, this.b, this.c );

  },

  barycoordFromPoint: function ( point, optionalTarget ) {

    return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  },

  containsPoint: function ( point ) {

    return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

  },

  equals: function ( triangle ) {

    return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  },

  clone: function () {

    return new THREE.Triangle().copy( this );

  }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

  this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;

  this.running = false;

};

THREE.Clock.prototype = {

  constructor: THREE.Clock,

  start: function () {

    this.startTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

    this.oldTime = this.startTime;
    this.running = true;
  },

  stop: function () {

    this.getElapsedTime();
    this.running = false;

  },

  getElapsedTime: function () {

    this.getDelta();
    return this.elapsedTime;

  },

  getDelta: function () {

    var diff = 0;

    if ( this.autoStart && ! this.running ) {

      this.start();

    }

    if ( this.running ) {

      var newTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

      diff = 0.001 * ( newTime - this.oldTime );
      this.oldTime = newTime;

      this.elapsedTime += diff;

    }

    return diff;

  }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

  constructor: THREE.EventDispatcher,

  apply: function ( object ) {

    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

  },

  addEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) this._listeners = {};

    var listeners = this._listeners;

    if ( listeners[ type ] === undefined ) {

      listeners[ type ] = [];

    }

    if ( listeners[ type ].indexOf( listener ) === - 1 ) {

      listeners[ type ].push( listener );

    }

  },

  hasEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return false;

    var listeners = this._listeners;

    if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

      return true;

    }

    return false;

  },

  removeEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ type ];

    if ( listenerArray !== undefined ) {

      var index = listenerArray.indexOf( listener );

      if ( index !== - 1 ) {

        listenerArray.splice( index, 1 );

      }

    }

  },

  dispatchEvent: function ( event ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ event.type ];

    if ( listenerArray !== undefined ) {

      event.target = this;

      var array = [];
      var length = listenerArray.length;

      for ( var i = 0; i < length; i ++ ) {

        array[ i ] = listenerArray[ i ];

      }

      for ( var i = 0; i < length; i ++ ) {

        array[ i ].call( this, event );

      }

    }

  }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

  THREE.Raycaster = function ( origin, direction, near, far ) {

    this.ray = new THREE.Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Sprite: {},
      Mesh: {},
      PointCloud: { threshold: 1 },
      LOD: {},
      Line: {}
    };

  };

  var descSort = function ( a, b ) {

    return a.distance - b.distance;

  };

  var intersectObject = function ( object, raycaster, intersects, recursive ) {

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  };

  //

  THREE.Raycaster.prototype = {

    constructor: THREE.Raycaster,

    linePrecision: 1,

    set: function ( origin, direction ) {

      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set( origin, direction );

    },

    setFromCamera: function ( coords, camera ) {

      if ( camera instanceof THREE.PerspectiveCamera ) {

        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

      } else if ( camera instanceof THREE.OrthographicCamera ) {

        this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

      } else {

        console.error( 'THREE.Raycaster: Unsupported camera type.' );

      }

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( descSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( Array.isArray( objects ) === false ) {

        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( descSort );

      return intersects;

    }

  };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

  Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Object3D';

  this.parent = undefined;
  this.children = [];

  this.up = THREE.Object3D.DefaultUp.clone();

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3( 1, 1, 1 );

  var onRotationChange = function () {
    quaternion.setFromEuler( rotation, false );
  };

  var onQuaternionChange = function () {
    rotation.setFromQuaternion( quaternion, undefined, false );
  };

  rotation.onChange( onRotationChange );
  quaternion.onChange( onQuaternionChange );

  Object.defineProperties( this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    }
  } );

  this.rotationAutoUpdate = true;

  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();

  this.matrixAutoUpdate = true;
  this.matrixWorldNeedsUpdate = false;

  this.visible = true;

  this.castShadow = false;
  this.receiveShadow = false;

  this.frustumCulled = true;
  this.renderOrder = 0;

  this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

  constructor: THREE.Object3D,

  get eulerOrder () {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    return this.rotation.order;

  },

  set eulerOrder ( value ) {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    this.rotation.order = value;

  },

  get useQuaternion () {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  set useQuaternion ( value ) {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  applyMatrix: function ( matrix ) {

    this.matrix.multiplyMatrices( matrix, this.matrix );

    this.matrix.decompose( this.position, this.quaternion, this.scale );

  },

  setRotationFromAxisAngle: function ( axis, angle ) {

    // assumes axis is normalized

    this.quaternion.setFromAxisAngle( axis, angle );

  },

  setRotationFromEuler: function ( euler ) {

    this.quaternion.setFromEuler( euler, true );

  },

  setRotationFromMatrix: function ( m ) {

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    this.quaternion.setFromRotationMatrix( m );

  },

  setRotationFromQuaternion: function ( q ) {

    // assumes q is normalized

    this.quaternion.copy( q );

  },

  rotateOnAxis: function () {

    // rotate object on axis in object space
    // axis is assumed to be normalized

    var q1 = new THREE.Quaternion();

    return function ( axis, angle ) {

      q1.setFromAxisAngle( axis, angle );

      this.quaternion.multiply( q1 );

      return this;

    }

  }(),

  rotateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  translateOnAxis: function () {

    // translate object by distance along axis in object space
    // axis is assumed to be normalized

    var v1 = new THREE.Vector3();

    return function ( axis, distance ) {

      v1.copy( axis ).applyQuaternion( this.quaternion );

      this.position.add( v1.multiplyScalar( distance ) );

      return this;

    }

  }(),

  translate: function ( distance, axis ) {

    console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    return this.translateOnAxis( axis, distance );

  },

  translateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  localToWorld: function ( vector ) {

    return vector.applyMatrix4( this.matrixWorld );

  },

  worldToLocal: function () {

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    };

  }(),

  lookAt: function () {

    // This routine does not support objects with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      m1.lookAt( vector, this.position, this.up );

      this.quaternion.setFromRotationMatrix( m1 );

    };

  }(),

  add: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.add( arguments[ i ] );

      }

      return this;

    }

    if ( object === this ) {

      console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
      return this;

    }

    if ( object instanceof THREE.Object3D ) {

      if ( object.parent !== undefined ) {

        object.parent.remove( object );

      }

      object.parent = this;
      object.dispatchEvent( { type: 'added' } );

      this.children.push( object );

    } else {

      console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    }

    return this;

  },

  remove: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.remove( arguments[ i ] );

      }

    }

    var index = this.children.indexOf( object );

    if ( index !== - 1 ) {

      object.parent = undefined;

      object.dispatchEvent( { type: 'removed' } );

      this.children.splice( index, 1 );

    }

  },

  getChildByName: function ( name ) {

    console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    return this.getObjectByName( name );

  },

  getObjectById: function ( id ) {

    return this.getObjectByProperty( 'id', id );

  },

  getObjectByName: function ( name ) {

    return this.getObjectByProperty( 'name', name );

  },

  getObjectByProperty: function ( name, value ) {

    if ( this[ name ] === value ) return this;

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      var child = this.children[ i ];
      var object = child.getObjectByProperty( name, value );

      if ( object !== undefined ) {

        return object;

      }

    }

    return undefined;

  },

  getWorldPosition: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.updateMatrixWorld( true );

    return result.setFromMatrixPosition( this.matrixWorld );

  },

  getWorldQuaternion: function () {

    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Quaternion();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, result, scale );

      return result;

    }

  }(),

  getWorldRotation: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Euler();

      this.getWorldQuaternion( quaternion );

      return result.setFromQuaternion( quaternion, this.rotation.order, false );

    }

  }(),

  getWorldScale: function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, quaternion, result );

      return result;

    }

  }(),

  getWorldDirection: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.getWorldQuaternion( quaternion );

      return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    }

  }(),

  raycast: function () {},

  traverse: function ( callback ) {

    callback( this );

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].traverse( callback );

    }

  },

  traverseVisible: function ( callback ) {

    if ( this.visible === false ) return;

    callback( this );

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].traverseVisible( callback );

    }

  },

  traverseAncestors: function ( callback ) {

    if ( this.parent ) {

      callback( this.parent );

      this.parent.traverseAncestors( callback );

    }

  },

  updateMatrix: function () {

    this.matrix.compose( this.position, this.quaternion, this.scale );

    this.matrixWorldNeedsUpdate = true;

  },

  updateMatrixWorld: function ( force ) {

    if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    if ( this.matrixWorldNeedsUpdate === true || force === true ) {

      if ( this.parent === undefined ) {

        this.matrixWorld.copy( this.matrix );

      } else {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

      }

      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  },

  toJSON: function ( meta ) {

    var isRootObject = ( meta === undefined );

    var data = {};

    // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.
    if ( isRootObject ) {

      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };

      data.metadata = {
        version: 4.4,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };

    }

    // standard Object3D serialization

    data.uuid = this.uuid;
    data.type = this.type;

    if ( this.name !== '' ) data.name = this.name;
    if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
    if ( this.visible !== true ) data.visible = this.visible;

    data.matrix = this.matrix.toArray();

    if ( this.children.length > 0 ) {

      data.children = [];

      for ( var i = 0; i < this.children.length; i ++ ) {

        data.children.push( this.children[ i ].toJSON( meta ).object );

      }

    }

    var output = {};

    if ( isRootObject ) {

      var geometries = extractFromCache( meta.geometries );
      var materials = extractFromCache( meta.materials );
      var textures = extractFromCache( meta.textures );
      var images = extractFromCache( meta.images );

      if ( geometries.length > 0 ) output.geometries = geometries;
      if ( materials.length > 0 ) output.materials = materials;
      if ( textures.length > 0 ) output.textures = textures;
      if ( images.length > 0 ) output.images = images;

    }

    output.object = data;

    return output;

    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache ( cache ) {
      var values = [];
      for ( var key in cache ) {
        var data = cache[ key ];
        delete data.metadata;
        values.push( data );
      }
      return values;
    }

  },

  clone: function ( object, recursive ) {

    if ( object === undefined ) object = new THREE.Object3D();
    if ( recursive === undefined ) recursive = true;

    object.name = this.name;

    object.up.copy( this.up );

    object.position.copy( this.position );
    object.quaternion.copy( this.quaternion );
    object.scale.copy( this.scale );

    object.rotationAutoUpdate = this.rotationAutoUpdate;

    object.matrix.copy( this.matrix );
    object.matrixWorld.copy( this.matrixWorld );

    object.matrixAutoUpdate = this.matrixAutoUpdate;
    object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

    object.visible = this.visible;

    object.castShadow = this.castShadow;
    object.receiveShadow = this.receiveShadow;

    object.frustumCulled = this.frustumCulled;
    object.renderOrder = this.renderOrder;

    object.userData = JSON.parse( JSON.stringify( this.userData ) );

    if ( recursive === true ) {

      for ( var i = 0; i < this.children.length; i ++ ) {

        var child = this.children[ i ];
        object.add( child.clone() );

      }

    }

    return object;

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color ) {

  this.a = a;
  this.b = b;
  this.c = c;

  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = Array.isArray( normal ) ? normal : [];

  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = Array.isArray( color ) ? color : [];

  this.vertexTangents = [];

};

THREE.Face3.prototype = {

  constructor: THREE.Face3,

  clone: function () {

    var face = new THREE.Face3( this.a, this.b, this.c );

    face.normal.copy( this.normal );
    face.color.copy( this.color );

    for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

      face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

    }

    for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

      face.vertexColors[ i ] = this.vertexColors[ i ].clone();

    }

    for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

      face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

    }

    return face;

  }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

  console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
  return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

  this.array = array;
  this.itemSize = itemSize;

  this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

  constructor: THREE.BufferAttribute,

  get length () {

    console.warn( 'THREE.BufferAttribute: .length has been renamed to .count.' );
    return this.count;

  },

  get count() {

    return this.array.length / this.itemSize;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  copyArray: function ( array ) {

    this.array.set( array );

    return this;

  },

  copyColorsArray: function ( colors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = colors.length; i < l; i ++ ) {

      var color = colors[ i ];

      if ( color === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
        color = new THREE.Color();

      }

      array[ offset ++ ] = color.r;
      array[ offset ++ ] = color.g;
      array[ offset ++ ] = color.b;

    }

    return this;

  },

  copyIndicesArray: function ( indices ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = indices.length; i < l; i ++ ) {

      var index = indices[ i ];

      array[ offset ++ ] = index.a;
      array[ offset ++ ] = index.b;
      array[ offset ++ ] = index.c;

    }

    return this;

  },

  copyVector2sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
        vector = new THREE.Vector2();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;

    }

    return this;

  },

  copyVector3sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
        vector = new THREE.Vector3();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;

    }

    return this;

  },

  copyVector4sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
        vector = new THREE.Vector4();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;
      array[ offset ++ ] = vector.w;

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  getX: function ( index ) {

    return this.array[ index * this.itemSize ];

  },

  setX: function ( index, x ) {

    this.array[ index * this.itemSize ] = x;

    return this;

  },

  getY: function ( index ) {

    return this.array[ index * this.itemSize + 1 ];

  },

  setY: function ( index, y ) {

    this.array[ index * this.itemSize + 1 ] = y;

    return this;

  },

  getZ: function ( index ) {

    return this.array[ index * this.itemSize + 2 ];

  },

  setZ: function ( index, z ) {

    this.array[ index * this.itemSize + 2 ] = z;

    return this;

  },

  getW: function ( index ) {

    return this.array[ index * this.itemSize + 3 ];

  },

  setW: function ( index, w ) {

    this.array[ index * this.itemSize + 3 ] = w;

    return this;

  },

  setXY: function ( index, x, y ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;
    this.array[ index + 3 ] = w;

    return this;

  },

  clone: function () {

    return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

  }

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};

// File:src/core/DynamicBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

  THREE.BufferAttribute.call( this, array, itemSize );

  this.updateRange = { offset: 0, count: -1 };

};

THREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;

THREE.DynamicBufferAttribute.prototype.clone = function () {

  return new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function (array, itemSize, meshPerAttribute, dynamic) {

  THREE.DynamicBufferAttribute.call( this, array, itemSize );

  this.dynamic = dynamic || false;
  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.DynamicBufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.clone = function () {

  return new THREE.InstancedBufferAttribute( new this.array.constructor( this.array ), this.itemSize, this.meshPerAttribute, this.dynamic );

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride, dynamic ) {

  this.array = array;
  this.stride = stride;

  this.needsUpdate = false;

  this.dynamic = dynamic || false;
  this.updateRange = { offset: 0, count: -1 };

};

THREE.InterleavedBuffer.prototype = {

  constructor: THREE.InterleavedBuffer,

  get length () {

    return this.array.length;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.stride;
    index2 *= attribute.stride;

    for ( var i = 0, l = this.stride; i < l; i++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  clone: function () {

    return new THREE.InterleavedBuffer( new this.array.constructor( this.array ), this.stride, this.dynamic );

  }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, dynamic, meshPerAttribute ) {

  THREE.InterleavedBuffer.call( this, array, stride, dynamic );

  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.clone = function () {

  return new THREE.InstancedInterleavedBuffer( new this.array.constructor( this.array ), this.stride, this.dynamic, this.meshPerAttribute );

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

  constructor: THREE.InterleavedBufferAttribute,

  get length() {

    console.warn( 'THREE.InterleavedBufferAttribute: .length has been renamed to .count.' );
    return this.count;

  },

  get count() {

    return this.data.array.length / this.data.stride;

  },

  setX: function ( index, x ) {

    this.data.array[ index * this.data.stride + this.offset ] = x;

    return this;

  },

  setY: function ( index, y ) {

    this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    return this;

  },

  setZ: function ( index, z ) {

    this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    return this;

  },

  setW: function ( index, w ) {

    this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    return this;

  },

  getX: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset ];

  },

  getY: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 1 ];

  },

  getZ: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 2 ];

  },

  getW: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 3 ];

  },

  setXY: function ( index, x, y ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;
    this.data.array[ index + 3 ] = w;

    return this;

  }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Geometry';

  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [ [] ];

  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  this.hasTangents = false;

  // update flags

  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.tangentsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;

  this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

  constructor: THREE.Geometry,

  applyMatrix: function ( matrix ) {

    var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

      var vertex = this.vertices[ i ];
      vertex.applyMatrix4( matrix );

    }

    for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

      var face = this.faces[ i ];
      face.normal.applyMatrix3( normalMatrix ).normalize();

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

      }

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;

  },

  fromBufferGeometry: function ( geometry ) {

    var scope = this;

    var attributes = geometry.attributes;

    var vertices = attributes.position.array;
    var indices = attributes.index !== undefined ? attributes.index.array : undefined;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

    var tempNormals = [];
    var tempUVs = [];

    for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

      scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

      if ( normals !== undefined ) {

        tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

      }

      if ( colors !== undefined ) {

        scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

      }

      if ( uvs !== undefined ) {

        tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

      }

    }

    var addFace = function ( a, b, c ) {

      var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
      var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

      scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );

      if ( uvs !== undefined ) {

        scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

      }

    };

    if ( indices !== undefined ) {

      var drawcalls = geometry.drawcalls;

      if ( drawcalls.length > 0 ) {

        for ( var i = 0; i < drawcalls.length; i ++ ) {

          var drawcall = drawcalls[ i ];

          var start = drawcall.start;
          var count = drawcall.count;
          var index = drawcall.index;

          for ( var j = start, jl = start + count; j < jl; j += 3 ) {

            addFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );

          }

        }

      } else {

        for ( var i = 0; i < indices.length; i += 3 ) {

          addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

        }

      }

    } else {

      for ( var i = 0; i < vertices.length / 3; i += 3 ) {

        addFace( i, i + 1, i + 2 );

      }

    }

    this.computeFaceNormals();

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

    return offset;

  },

  normalize: function () {

    this.computeBoundingSphere();

    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;

    var s = radius === 0 ? 1 : 1.0 / radius;

    var matrix = new THREE.Matrix4();
    matrix.set(
      s, 0, 0, -s * center.x,
      0, s, 0, -s * center.y,
      0, 0, s, -s * center.z,
      0, 0, 0, 1
    );

    this.applyMatrix( matrix );

    return this;
  },

  computeFaceNormals: function () {

    var cb = new THREE.Vector3(), ab = new THREE.Vector3();

    for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

      var face = this.faces[ f ];

      var vA = this.vertices[ face.a ];
      var vB = this.vertices[ face.b ];
      var vC = this.vertices[ face.c ];

      cb.subVectors( vC, vB );
      ab.subVectors( vA, vB );
      cb.cross( ab );

      cb.normalize();

      face.normal.copy( cb );

    }

  },

  computeVertexNormals: function ( areaWeighted ) {

    var v, vl, f, fl, face, vertices;

    vertices = new Array( this.vertices.length );

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ] = new THREE.Vector3();

    }

    if ( areaWeighted ) {

      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm

      var vA, vB, vC;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3();

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vA = this.vertices[ face.a ];
        vB = this.vertices[ face.b ];
        vC = this.vertices[ face.c ];

        cb.subVectors( vC, vB );
        ab.subVectors( vA, vB );
        cb.cross( ab );

        vertices[ face.a ].add( cb );
        vertices[ face.b ].add( cb );
        vertices[ face.c ].add( cb );

      }

    } else {

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vertices[ face.a ].add( face.normal );
        vertices[ face.b ].add( face.normal );
        vertices[ face.c ].add( face.normal );

      }

    }

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ].normalize();

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        vertexNormals[ 0 ].copy( vertices[ face.a ] );
        vertexNormals[ 1 ].copy( vertices[ face.b ] );
        vertexNormals[ 2 ].copy( vertices[ face.c ] );

      } else {

        vertexNormals[ 0 ] = vertices[ face.a ].clone();
        vertexNormals[ 1 ] = vertices[ face.b ].clone();
        vertexNormals[ 2 ] = vertices[ face.c ].clone();

      }

    }

  },

  computeMorphNormals: function () {

    var i, il, f, fl, face;

    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      if ( ! face.__originalFaceNormal ) {

        face.__originalFaceNormal = face.normal.clone();

      } else {

        face.__originalFaceNormal.copy( face.normal );

      }

      if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

      for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

        if ( ! face.__originalVertexNormals[ i ] ) {

          face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

        } else {

          face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

        }

      }

    }

    // use temp geometry to compute face and vertex normals for each morph

    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;

    for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

      // create on first access

      if ( ! this.morphNormals[ i ] ) {

        this.morphNormals[ i ] = {};
        this.morphNormals[ i ].faceNormals = [];
        this.morphNormals[ i ].vertexNormals = [];

        var dstNormalsFace = this.morphNormals[ i ].faceNormals;
        var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

        var faceNormal, vertexNormals;

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          faceNormal = new THREE.Vector3();
          vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

          dstNormalsFace.push( faceNormal );
          dstNormalsVertex.push( vertexNormals );

        }

      }

      var morphNormals = this.morphNormals[ i ];

      // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[ i ].vertices;

      // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();

      // store morph normals

      var faceNormal, vertexNormals;

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        faceNormal = morphNormals.faceNormals[ f ];
        vertexNormals = morphNormals.vertexNormals[ f ];

        faceNormal.copy( face.normal );

        vertexNormals.a.copy( face.vertexNormals[ 0 ] );
        vertexNormals.b.copy( face.vertexNormals[ 1 ] );
        vertexNormals.c.copy( face.vertexNormals[ 2 ] );

      }

    }

    // restore original normals

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // tangents go to vertices

    var f, fl, v, vl, i, vertexIndex,
      face, uv, vA, vB, vC, uvA, uvB, uvC,
      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r, t, test,
      tan1 = [], tan2 = [],
      sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
      tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
      n = new THREE.Vector3(), w;

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      tan1[ v ] = new THREE.Vector3();
      tan2[ v ] = new THREE.Vector3();

    }

    function handleTriangle( context, a, b, c, ua, ub, uc ) {

      vA = context.vertices[ a ];
      vB = context.vertices[ b ];
      vC = context.vertices[ c ];

      uvA = uv[ ua ];
      uvB = uv[ ub ];
      uvC = uv[ uc ];

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;
      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;
      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;
      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );
      sdir.set( ( t2 * x1 - t1 * x2 ) * r,
            ( t2 * y1 - t1 * y2 ) * r,
            ( t2 * z1 - t1 * z2 ) * r );
      tdir.set( ( s1 * x2 - s2 * x1 ) * r,
            ( s1 * y2 - s2 * y1 ) * r,
            ( s1 * z2 - s2 * z1 ) * r );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];
      uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

      handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

    }

    var faceIndex = [ 'a', 'b', 'c', 'd' ];

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

        n.copy( face.vertexNormals[ i ] );

        vertexIndex = face[ faceIndex[ i ] ];

        t = tan1[ vertexIndex ];

        // Gram-Schmidt orthogonalize

        tmp.copy( t );
        tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

        // Calculate handedness

        tmp2.crossVectors( face.vertexNormals[ i ], t );
        test = tmp2.dot( tan2[ vertexIndex ] );
        w = ( test < 0.0 ) ? - 1.0 : 1.0;

        face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

      }

    }

    this.hasTangents = true;

  },

  computeLineDistances: function () {

    var d = 0;
    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      if ( i > 0 ) {

        d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

      }

      this.lineDistances[ i ] = d;

    }

  },

  computeBoundingBox: function () {

    if ( this.boundingBox === null ) {

      this.boundingBox = new THREE.Box3();

    }

    this.boundingBox.setFromPoints( this.vertices );

  },

  computeBoundingSphere: function () {

    if ( this.boundingSphere === null ) {

      this.boundingSphere = new THREE.Sphere();

    }

    this.boundingSphere.setFromPoints( this.vertices );

  },

  merge: function ( geometry, matrix ) {

    if ( geometry instanceof THREE.Geometry === false ) {

      console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
      return;

    }

    var normalMatrix,
    vertexOffset = this.vertices.length,
    vertices1 = this.vertices,
    vertices2 = geometry.vertices,
    faces1 = this.faces,
    faces2 = geometry.faces,
    uvs1 = this.faceVertexUvs[ 0 ],
    uvs2 = geometry.faceVertexUvs[ 0 ];

    if ( matrix !== undefined ) {

      normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    }

    // vertices

    for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

      var vertex = vertices2[ i ];

      var vertexCopy = vertex.clone();

      if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

      vertices1.push( vertexCopy );

    }

    // faces

    for ( i = 0, il = faces2.length; i < il; i ++ ) {

      var face = faces2[ i ], faceCopy, normal, color,
      faceVertexNormals = face.vertexNormals,
      faceVertexColors = face.vertexColors;

      faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
      faceCopy.normal.copy( face.normal );

      if ( normalMatrix !== undefined ) {

        faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

      }

      for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

        normal = faceVertexNormals[ j ].clone();

        if ( normalMatrix !== undefined ) {

          normal.applyMatrix3( normalMatrix ).normalize();

        }

        faceCopy.vertexNormals.push( normal );

      }

      faceCopy.color.copy( face.color );

      for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

        color = faceVertexColors[ j ];
        faceCopy.vertexColors.push( color.clone() );

      }

      faces1.push( faceCopy );

    }

    // uvs

    for ( i = 0, il = uvs2.length; i < il; i ++ ) {

      var uv = uvs2[ i ], uvCopy = [];

      if ( uv === undefined ) {

        continue;

      }

      for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

        uvCopy.push( uv[ j ].clone() );

      }

      uvs1.push( uvCopy );

    }

  },

  mergeMesh: function ( mesh ) {

    if ( mesh instanceof THREE.Mesh === false ) {

      console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
      return;

    }

    mesh.matrixAutoUpdate && mesh.updateMatrix();

    this.merge( mesh.geometry, mesh.matrix );

  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */

  mergeVertices: function () {

    var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
    var unique = [], changes = [];

    var v, key;
    var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
    var precision = Math.pow( 10, precisionPoints );
    var i, il, face;
    var indices, j, jl;

    for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

      v = this.vertices[ i ];
      key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

      if ( verticesMap[ key ] === undefined ) {

        verticesMap[ key ] = i;
        unique.push( this.vertices[ i ] );
        changes[ i ] = unique.length - 1;

      } else {

        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[ i ] = changes[ verticesMap[ key ] ];

      }

    }


    // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.
    var faceIndicesToRemove = [];

    for ( i = 0, il = this.faces.length; i < il; i ++ ) {

      face = this.faces[ i ];

      face.a = changes[ face.a ];
      face.b = changes[ face.b ];
      face.c = changes[ face.c ];

      indices = [ face.a, face.b, face.c ];

      var dupIndex = - 1;

      // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved
      for ( var n = 0; n < 3; n ++ ) {
        if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

          dupIndex = n;
          faceIndicesToRemove.push( i );
          break;

        }
      }

    }

    for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
      var idx = faceIndicesToRemove[ i ];

      this.faces.splice( idx, 1 );

      for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

        this.faceVertexUvs[ j ].splice( idx, 1 );

      }

    }

    // Use unique set of vertices

    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;

  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    };

    // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    var vertices = [];

    for ( var i = 0; i < this.vertices.length; i ++ ) {

      var vertex = this.vertices[ i ];
      vertices.push( vertex.x, vertex.y, vertex.z );

    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for ( var i = 0; i < this.faces.length; i ++ ) {

      var face = this.faces[ i ];

      var hasMaterial = false; // face.materialIndex !== undefined;
      var hasFaceUv = false; // deprecated
      var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;

      var faceType = 0;

      faceType = setBit( faceType, 0, 0 );
      faceType = setBit( faceType, 1, hasMaterial );
      faceType = setBit( faceType, 2, hasFaceUv );
      faceType = setBit( faceType, 3, hasFaceVertexUv );
      faceType = setBit( faceType, 4, hasFaceNormal );
      faceType = setBit( faceType, 5, hasFaceVertexNormal );
      faceType = setBit( faceType, 6, hasFaceColor );
      faceType = setBit( faceType, 7, hasFaceVertexColor );

      faces.push( faceType );
      faces.push( face.a, face.b, face.c );

      if ( hasFaceVertexUv ) {

        var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

        faces.push(
          getUvIndex( faceVertexUvs[ 0 ] ),
          getUvIndex( faceVertexUvs[ 1 ] ),
          getUvIndex( faceVertexUvs[ 2 ] )
        );

      }

      if ( hasFaceNormal ) {

        faces.push( getNormalIndex( face.normal ) );

      }

      if ( hasFaceVertexNormal ) {

        var vertexNormals = face.vertexNormals;

        faces.push(
          getNormalIndex( vertexNormals[ 0 ] ),
          getNormalIndex( vertexNormals[ 1 ] ),
          getNormalIndex( vertexNormals[ 2 ] )
        );

      }

      if ( hasFaceColor ) {

        faces.push( getColorIndex( face.color ) );

      }

      if ( hasFaceVertexColor ) {

        var vertexColors = face.vertexColors;

        faces.push(
          getColorIndex( vertexColors[ 0 ] ),
          getColorIndex( vertexColors[ 1 ] ),
          getColorIndex( vertexColors[ 2 ] )
        );

      }

    }

    function setBit( value, position, enabled ) {

      return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

    }

    function getNormalIndex( normal ) {

      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if ( normalsHash[ hash ] !== undefined ) {

        return normalsHash[ hash ];

      }

      normalsHash[ hash ] = normals.length / 3;
      normals.push( normal.x, normal.y, normal.z );

      return normalsHash[ hash ];

    }

    function getColorIndex( color ) {

      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if ( colorsHash[ hash ] !== undefined ) {

        return colorsHash[ hash ];

      }

      colorsHash[ hash ] = colors.length;
      colors.push( color.getHex() );

      return colorsHash[ hash ];

    }

    function getUvIndex( uv ) {

      var hash = uv.x.toString() + uv.y.toString();

      if ( uvsHash[ hash ] !== undefined ) {

        return uvsHash[ hash ];

      }

      uvsHash[ hash ] = uvs.length / 2;
      uvs.push( uv.x, uv.y );

      return uvsHash[ hash ];

    }

    data.data = {};

    data.data.vertices = vertices;
    data.data.normals = normals;
    if ( colors.length > 0 ) data.data.colors = colors;
    if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    data.data.faces = faces;

    return data;

  },

  clone: function () {

    var geometry = new THREE.Geometry();

    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      geometry.vertices.push( vertices[ i ].clone() );

    }

    var faces = this.faces;

    for ( var i = 0, il = faces.length; i < il; i ++ ) {

      geometry.faces.push( faces[ i ].clone() );

    }

    for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {

      var faceVertexUvs = this.faceVertexUvs[ i ];

      if ( geometry.faceVertexUvs[ i ] === undefined ) {

        geometry.faceVertexUvs[ i ] = [];

      }

      for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

        var uvs = faceVertexUvs[ j ], uvsCopy = [];

        for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

          var uv = uvs[ k ];

          uvsCopy.push( uv.clone() );

        }

        geometry.faceVertexUvs[ i ].push( uvsCopy );

      }

    }

    return geometry;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'DirectGeometry';

  this.indices = [];
  this.vertices = [];
  this.colors = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];

  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

  constructor: THREE.DirectGeometry,

  computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
  computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

  computeFaceNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
    return this;

  },

  computeVertexNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
    return this;

  },

  fromGeometry: function ( geometry, material ) {

    material = material || { 'vertexColors': THREE.NoColors };

    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;
    var materialVertexColors = material.vertexColors;

    var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;

    for ( var i = 0; i < morphTargetsLength; i ++ ) {

      this.morphTargets[ i ] = [];

    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;

    for ( var i = 0; i < morphNormalsLength; i ++ ) {

      this.morphNormals[ i ] = [];

    }

    var morphColors = geometry.morphColors;
    var morphColorsLength = morphColors.length;

    for ( var i = 0; i < morphColorsLength; i ++ ) {

      this.morphColors[ i ] = [];

    }

    // skins

    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;

    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;

    //

    for ( var i = 0; i < faces.length; i ++ ) {

      var face = faces[ i ];

      this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

      } else {

        var normal = face.normal;

        this.normals.push( normal, normal, normal );

      }

      var vertexColors = face.vertexColors;

      if ( materialVertexColors === THREE.VertexColors ) {

        this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

      } else if ( materialVertexColors === THREE.FaceColors ) {

        var color = face.color;

        this.colors.push( color, color, color );

      }

      if ( hasFaceVertexUv === true ) {

        var vertexUvs = faceVertexUvs[ 0 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.BufferGeometry.fromGeometry(): Undefined vertexUv', i );

          this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      if ( hasFaceVertexUv2 === true ) {

        var vertexUvs = faceVertexUvs[ 1 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.BufferGeometry.fromGeometry(): Undefined vertexUv2', i );

          this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      // morphs

      for ( var j = 0; j < morphTargetsLength; j ++ ) {

        var morphTarget = morphTargets[ j ].vertices;

        this.morphTargets[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

      }
      /*
      for ( var j = 0; j < morphNormalsLength; j ++ ) {

        var morphNormal = morphNormals[ j ].vertexNormals[ i ];

        this.morphNormals[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

      }

      for ( var j = 0; j < morphColorsLength; j ++ ) {

        var morphColor = morphColors[ j ].colors;

        this.morphColors[ j ].push( morphColor[ face.a ], morphColor[ face.b ], morphColor[ face.c ] );

      }
      */

      // skins

      if ( hasSkinIndices ) {

        this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

      }

      if ( hasSkinWeights ) {

        this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

      }

    }

    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'BufferGeometry';

  this.attributes = {};

  this.morphAttributes = [];

  this.drawcalls = [];
  this.offsets = this.drawcalls; // backwards compatibility

  this.boundingBox = null;
  this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

  constructor: THREE.BufferGeometry,

  addAttribute: function ( name, attribute ) {

    if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

      console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

      this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

      return;

    }

    this.attributes[ name ] = attribute;

  },

  getAttribute: function ( name ) {

    return this.attributes[ name ];

  },

  addDrawCall: function ( start, count, indexOffset ) {

    this.drawcalls.push( {

      start: start,
      count: count,
      index: indexOffset !== undefined ? indexOffset : 0

    } );

  },

  applyMatrix: function ( matrix ) {

    var position = this.attributes.position;

    if ( position !== undefined ) {

      matrix.applyToVector3Array( position.array );
      position.needsUpdate = true;

    }

    var normal = this.attributes.normal;

    if ( normal !== undefined ) {

      var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

      normalMatrix.applyToVector3Array( normal.array );
      normal.needsUpdate = true;

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

  },

  copy: function ( geometry ) {

    var attributes = geometry.attributes;
    var offsets = geometry.offsets;

    for ( var name in attributes ) {

      var attribute = attributes[ name ];

      this.addAttribute( name, attribute.clone() );

    }

    for ( var i = 0, il = offsets.length; i < il; i ++ ) {

      var offset = offsets[ i ];

      this.offsets.push( {

        start: offset.start,
        index: offset.index,
        count: offset.count

      } );

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

    return offset;

  },

  setFromObject: function ( object ) {

    console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    var geometry = object.geometry;
    var material = object.material;

    if ( object instanceof THREE.PointCloud || object instanceof THREE.Line ) {

      var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
      var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

      this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
      this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

      if ( geometry.boundingSphere !== null ) {

        this.boundingSphere = geometry.boundingSphere.clone();

      }

      if ( geometry.boundingBox !== null ) {

        this.boundingBox = geometry.boundingBox.clone();

      }

    } else if ( object instanceof THREE.Mesh ) {

      if ( geometry instanceof THREE.Geometry ) {

        this.fromGeometry( geometry );

      }

    }

    return this;

  },

  updateFromObject: function ( object ) {

    var geometry = object.geometry;

    if ( object instanceof THREE.Mesh ) {

      var direct = geometry.__directGeometry;

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;

      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;

      geometry = direct;

    }

    if ( geometry.verticesNeedUpdate === true ) {

      var attribute = this.attributes.position;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.vertices );
        attribute.needsUpdate = true;

      }

      geometry.verticesNeedUpdate = false;

    }

    if ( geometry.normalsNeedUpdate === true ) {

      var attribute = this.attributes.normal;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.normals );
        attribute.needsUpdate = true;

      }

      geometry.normalsNeedUpdate = false;

    }

    if ( geometry.colorsNeedUpdate === true ) {

      var attribute = this.attributes.color;

      if ( attribute !== undefined ) {

        attribute.copyColorsArray( geometry.colors );
        attribute.needsUpdate = true;

      }

      geometry.colorsNeedUpdate = false;

    }

    return this;

  },

  fromGeometry: function ( geometry, material ) {

    geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry, material );

    return this.fromDirectGeometry( geometry.__directGeometry );

  },

  fromDirectGeometry: function ( geometry ) {

    if ( geometry.indices.length > 0 ) {

      var indices = new Uint16Array( geometry.indices.length * 3 );
      this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    }

    if ( geometry.vertices.length > 0 ) {

      var positions = new Float32Array( geometry.vertices.length * 3 );
      this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    }

    if ( geometry.normals.length > 0 ) {

      var normals = new Float32Array( geometry.normals.length * 3 );
      this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    }

    if ( geometry.colors.length > 0 ) {

      var colors = new Float32Array( geometry.colors.length * 3 );
      this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    }

    if ( geometry.uvs.length > 0 ) {

      var uvs = new Float32Array( geometry.uvs.length * 2 );
      this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    }

    // morphs

    if ( geometry.morphTargets.length > 0 ) {

      var morphTargets = geometry.morphTargets;

      for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

        var morphTarget = morphTargets[ i ];

        var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

        this.morphAttributes.push( attribute.copyVector3sArray( morphTarget ) );

      }

      // TODO normals, colors

    }

    // skinning

    if ( geometry.skinIndices.length > 0 ) {

      var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
      this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    }

    if ( geometry.skinWeights.length > 0 ) {

      var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
      this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    }

    //

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    return this;

  },

  computeBoundingBox: function () {

    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new THREE.Box3();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        var bb = this.boundingBox;
        bb.makeEmpty();

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          bb.expandByPoint( vector );

        }

      }

      if ( positions === undefined || positions.length === 0 ) {

        this.boundingBox.min.set( 0, 0, 0 );
        this.boundingBox.max.set( 0, 0, 0 );

      }

      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

      }

    };

  }(),

  computeBoundingSphere: function () {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingSphere === null ) {

        this.boundingSphere = new THREE.Sphere();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        box.makeEmpty();

        var center = this.boundingSphere.center;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          box.expandByPoint( vector );

        }

        box.center( center );

        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

        }

        this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

        if ( isNaN( this.boundingSphere.radius ) ) {

          console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

        }

      }

    };

  }(),

  computeFaceNormals: function () {

    // backwards compatibility

  },

  computeVertexNormals: function () {

    var attributes = this.attributes;

    if ( attributes.position ) {

      var positions = attributes.position.array;

      if ( attributes.normal === undefined ) {

        this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

      } else {

        // reset existing normals to zero

        var normals = attributes.normal.array;

        for ( var i = 0, il = normals.length; i < il; i ++ ) {

          normals[ i ] = 0;

        }

      }

      var normals = attributes.normal.array;

      var vA, vB, vC,

      pA = new THREE.Vector3(),
      pB = new THREE.Vector3(),
      pC = new THREE.Vector3(),

      cb = new THREE.Vector3(),
      ab = new THREE.Vector3();

      // indexed elements

      if ( attributes.index ) {

        var indices = attributes.index.array;

        var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

        for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

          var start = offsets[ j ].start;
          var count = offsets[ j ].count;
          var index = offsets[ j ].index;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            vA = ( index + indices[ i     ] ) * 3;
            vB = ( index + indices[ i + 1 ] ) * 3;
            vC = ( index + indices[ i + 2 ] ) * 3;

            pA.fromArray( positions, vA );
            pB.fromArray( positions, vB );
            pC.fromArray( positions, vC );

            cb.subVectors( pC, pB );
            ab.subVectors( pA, pB );
            cb.cross( ab );

            normals[ vA     ] += cb.x;
            normals[ vA + 1 ] += cb.y;
            normals[ vA + 2 ] += cb.z;

            normals[ vB     ] += cb.x;
            normals[ vB + 1 ] += cb.y;
            normals[ vB + 2 ] += cb.z;

            normals[ vC     ] += cb.x;
            normals[ vC + 1 ] += cb.y;
            normals[ vC + 2 ] += cb.z;

          }

        }

      } else {

        // non-indexed elements (unconnected triangle soup)

        for ( var i = 0, il = positions.length; i < il; i += 9 ) {

          pA.fromArray( positions, i );
          pB.fromArray( positions, i + 3 );
          pC.fromArray( positions, i + 6 );

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );

          normals[ i     ] = cb.x;
          normals[ i + 1 ] = cb.y;
          normals[ i + 2 ] = cb.z;

          normals[ i + 3 ] = cb.x;
          normals[ i + 4 ] = cb.y;
          normals[ i + 5 ] = cb.z;

          normals[ i + 6 ] = cb.x;
          normals[ i + 7 ] = cb.y;
          normals[ i + 8 ] = cb.z;

        }

      }

      this.normalizeNormals();

      attributes.normal.needsUpdate = true;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if ( this.attributes.index === undefined ||
       this.attributes.position === undefined ||
       this.attributes.normal === undefined ||
       this.attributes.uv === undefined ) {

      console.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
      return;

    }

    var indices = this.attributes.index.array;
    var positions = this.attributes.position.array;
    var normals = this.attributes.normal.array;
    var uvs = this.attributes.uv.array;

    var nVertices = positions.length / 3;

    if ( this.attributes.tangent === undefined ) {

      this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

    }

    var tangents = this.attributes.tangent.array;

    var tan1 = [], tan2 = [];

    for ( var k = 0; k < nVertices; k ++ ) {

      tan1[ k ] = new THREE.Vector3();
      tan2[ k ] = new THREE.Vector3();

    }

    var vA = new THREE.Vector3(),
      vB = new THREE.Vector3(),
      vC = new THREE.Vector3(),

      uvA = new THREE.Vector2(),
      uvB = new THREE.Vector2(),
      uvC = new THREE.Vector2(),

      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r;

    var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

    function handleTriangle( a, b, c ) {

      vA.fromArray( positions, a * 3 );
      vB.fromArray( positions, b * 3 );
      vC.fromArray( positions, c * 3 );

      uvA.fromArray( uvs, a * 2 );
      uvB.fromArray( uvs, b * 2 );
      uvC.fromArray( uvs, c * 2 );

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;

      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;

      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;

      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );

      sdir.set(
        ( t2 * x1 - t1 * x2 ) * r,
        ( t2 * y1 - t1 * y2 ) * r,
        ( t2 * z1 - t1 * z2 ) * r
      );

      tdir.set(
        ( s1 * x2 - s2 * x1 ) * r,
        ( s1 * y2 - s2 * y1 ) * r,
        ( s1 * z2 - s2 * z1 ) * r
      );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    var i, il;
    var j, jl;
    var iA, iB, iC;

    if ( this.drawcalls.length === 0 ) {

      this.addDrawCall( 0, indices.length, 0 );

    }

    var drawcalls = this.drawcalls;

    for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

      var start = drawcalls[ j ].start;
      var count = drawcalls[ j ].count;
      var index = drawcalls[ j ].index;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = index + indices[ i ];
        iB = index + indices[ i + 1 ];
        iC = index + indices[ i + 2 ];

        handleTriangle( iA, iB, iC );

      }

    }

    var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(), n2 = new THREE.Vector3();
    var w, t, test;

    function handleVertex( v ) {

      n.fromArray( normals, v * 3 );
      n2.copy( n );

      t = tan1[ v ];

      // Gram-Schmidt orthogonalize

      tmp.copy( t );
      tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

      // Calculate handedness

      tmp2.crossVectors( n2, t );
      test = tmp2.dot( tan2[ v ] );
      w = ( test < 0.0 ) ? - 1.0 : 1.0;

      tangents[ v * 4     ] = tmp.x;
      tangents[ v * 4 + 1 ] = tmp.y;
      tangents[ v * 4 + 2 ] = tmp.z;
      tangents[ v * 4 + 3 ] = w;

    }

    for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

      var start = drawcalls[ j ].start;
      var count = drawcalls[ j ].count;
      var index = drawcalls[ j ].index;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = index + indices[ i ];
        iB = index + indices[ i + 1 ];
        iC = index + indices[ i + 2 ];

        handleVertex( iA );
        handleVertex( iB );
        handleVertex( iC );

      }

    }

  },

  /*
  Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
  This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
  WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
  size - Defaults to 65535 or 4294967296 if extension OES_element_index_uint supported, but allows for larger or smaller chunks.
  */
  computeOffsets: function ( size ) {

    if ( size === undefined ) size = THREE.BufferGeometry.MaxIndex;

    var indices = this.attributes.index.array;
    var vertices = this.attributes.position.array;

    var facesCount = ( indices.length / 3 );

    var UintArray = ( ( vertices.length / 3 ) > 65535 && THREE.BufferGeometry.MaxIndex > 65535 ) ? Uint32Array : Uint16Array;

    /*
    console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
    console.log("Faces to process: "+(indices.length/3));
    console.log("Reordering "+verticesCount+" vertices.");
    */

    var sortedIndices = new UintArray( indices.length );

    var indexPtr = 0;
    var vertexPtr = 0;

    var offsets = [ { start:0, count:0, index:0 } ];
    var offset = offsets[ 0 ];

    var duplicatedVertices = 0;
    var newVerticeMaps = 0;
    var faceVertices = new Int32Array( 6 );
    var vertexMap = new Int32Array( vertices.length );
    var revVertexMap = new Int32Array( vertices.length );
    for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

    /*
      Traverse every face and reorder vertices in the proper offsets of 65k.
      We can have more than 'size' entries in the index buffer per offset, but only reference 'size' values.
    */
    for ( var findex = 0; findex < facesCount; findex ++ ) {
      newVerticeMaps = 0;

      for ( var vo = 0; vo < 3; vo ++ ) {
        var vid = indices[ findex * 3 + vo ];
        if ( vertexMap[ vid ] === - 1 ) {
          //Unmapped vertice
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = - 1;
          newVerticeMaps ++;
        } else if ( vertexMap[ vid ] < offset.index ) {
          //Reused vertices from previous block (duplicate)
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = - 1;
          duplicatedVertices ++;
        } else {
          //Reused vertice in the current block
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
        }
      }

      var faceMax = vertexPtr + newVerticeMaps;
      if ( faceMax > ( offset.index + size ) ) {
        var new_offset = { start:indexPtr, count:0, index:vertexPtr };
        offsets.push( new_offset );
        offset = new_offset;

        //Re-evaluate reused vertices in light of new offset.
        for ( var v = 0; v < 6; v += 2 ) {
          var new_vid = faceVertices[ v + 1 ];
          if ( new_vid > - 1 && new_vid < offset.index )
            faceVertices[ v + 1 ] = - 1;
        }
      }

      //Reindex the face.
      for ( var v = 0; v < 6; v += 2 ) {
        var vid = faceVertices[ v ];
        var new_vid = faceVertices[ v + 1 ];

        if ( new_vid === - 1 )
          new_vid = vertexPtr ++;

        vertexMap[ vid ] = new_vid;
        revVertexMap[ new_vid ] = vid;
        sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
        offset.count ++;
      }
    }

    /* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
    this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
    this.offsets = offsets; // TODO: Deprecate
    this.drawcalls = offsets;

    /*
    var orderTime = Date.now();
    console.log("Reorder time: "+(orderTime-s)+"ms");
    console.log("Duplicated "+duplicatedVertices+" vertices.");
    console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
    console.log("Draw offsets: "+offsets.length);
    */

    return offsets;

  },

  merge: function ( geometry, offset ) {

    if ( geometry instanceof THREE.BufferGeometry === false ) {

      console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
      return;

    }

    if ( offset === undefined ) offset = 0;

    var attributes = this.attributes;

    for ( var key in attributes ) {

      if ( geometry.attributes[ key ] === undefined ) continue;

      var attribute1 = attributes[ key ];
      var attributeArray1 = attribute1.array;

      var attribute2 = geometry.attributes[ key ];
      var attributeArray2 = attribute2.array;

      var attributeSize = attribute2.itemSize;

      for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

        attributeArray1[ j ] = attributeArray2[ i ];

      }

    }

    return this;

  },

  normalizeNormals: function () {

    var normals = this.attributes.normal.array;

    var x, y, z, n;

    for ( var i = 0, il = normals.length; i < il; i += 3 ) {

      x = normals[ i ];
      y = normals[ i + 1 ];
      z = normals[ i + 2 ];

      n = 1.0 / Math.sqrt( x * x + y * y + z * z );

      normals[ i     ] *= n;
      normals[ i + 1 ] *= n;
      normals[ i + 2 ] *= n;

    }

  },

  /*
    reoderBuffers:
    Reorder attributes based on a new indexBuffer and indexMap.
    indexBuffer - Uint16Array of the new ordered indices.
    indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
    vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
  */
  reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

    /* Create a copy of all attributes for reordering. */
    var sortedAttributes = {};
    for ( var attr in this.attributes ) {
      if ( attr === 'index' )
        continue;
      var sourceArray = this.attributes[ attr ].array;
      sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
    }

    /* Move attribute positions based on the new index map */
    for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
      var vid = indexMap[ new_vid ];
      for ( var attr in this.attributes ) {
        if ( attr === 'index' )
          continue;
        var attrArray = this.attributes[ attr ].array;
        var attrSize = this.attributes[ attr ].itemSize;
        var sortedAttr = sortedAttributes[ attr ];
        for ( var k = 0; k < attrSize; k ++ )
          sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
      }
    }

    /* Carry the new sorted buffers locally */
    this.attributes[ 'index' ].array = indexBuffer;
    for ( var attr in this.attributes ) {
      if ( attr === 'index' )
        continue;
      this.attributes[ attr ].array = sortedAttributes[ attr ];
      this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
    }
  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };

    // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    data.data = { attributes: {} };

    var attributes = this.attributes;
    var offsets = this.offsets;
    var boundingSphere = this.boundingSphere;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];

      var array = Array.prototype.slice.call( attribute.array );

      data.data.attributes[ key ] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array
      }

    }

    if ( offsets.length > 0 ) {

      data.data.offsets = JSON.parse( JSON.stringify( offsets ) );

    }

    if ( boundingSphere !== null ) {

      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      }

    }

    return data;

  },

  clone: function () {

    var geometry = new THREE.BufferGeometry();

    for ( var attr in this.attributes ) {

      var sourceAttr = this.attributes[ attr ];
      geometry.addAttribute( attr, sourceAttr.clone() );

    }

    for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

      var offset = this.offsets[ i ];

      geometry.offsets.push( {

        start: offset.start,
        index: offset.index,
        count: offset.count

      } );

    }

    return geometry;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

  THREE.BufferGeometry.call( this );

  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset, instances ) {

  this.drawcalls.push( {

    start: start,
    count: count,
    index: indexOffset !== undefined ? indexOffset : 0,
    instances: instances

  } );

},

THREE.InstancedBufferGeometry.prototype.clone = function () {

  var geometry = new THREE.InstancedBufferGeometry();

  for ( var attr in this.attributes ) {

    var sourceAttr = this.attributes[attr];
    geometry.addAttribute( attr, sourceAttr.clone() );

  }

  for ( var i = 0, il = this.offsets.length; i < il; i++ ) {

    var offset = this.offsets[i];

    geometry.offsets.push( {

      start: offset.start,
      index: offset.index,
      count: offset.count,
      instances: offset.instances

    } );

  }

  return geometry;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

  THREE.Object3D.call( this );

  this.type = 'Camera';

  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

  var quaternion = new THREE.Quaternion();

  return function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.getWorldQuaternion( quaternion );

    return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  };

}();

THREE.Camera.prototype.lookAt = function () {

  // This routine does not support cameras with rotated and/or translated parent(s)

  var m1 = new THREE.Matrix4();

  return function ( vector ) {

    m1.lookAt( this.position, vector, this.up );

    this.quaternion.setFromRotationMatrix( m1 );

  };

}();

THREE.Camera.prototype.clone = function ( camera ) {

  if ( camera === undefined ) camera = new THREE.Camera();

  THREE.Object3D.prototype.clone.call( this, camera );

  camera.matrixWorldInverse.copy( this.matrixWorldInverse );
  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *  - renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

  THREE.Object3D.call( this );

  this.type = 'CubeCamera';

  var fov = 90, aspect = 1;

  var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPX.up.set( 0, - 1, 0 );
  cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
  this.add( cameraPX );

  var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNX.up.set( 0, - 1, 0 );
  cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
  this.add( cameraNX );

  var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPY.up.set( 0, 0, 1 );
  cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
  this.add( cameraPY );

  var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNY.up.set( 0, 0, - 1 );
  cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
  this.add( cameraNY );

  var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPZ.up.set( 0, - 1, 0 );
  cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
  this.add( cameraPZ );

  var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNZ.up.set( 0, - 1, 0 );
  cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
  this.add( cameraNZ );

  this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

  this.updateCubeMap = function ( renderer, scene ) {

    if ( this.parent === undefined ) this.updateMatrixWorld();

    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.generateMipmaps;

    renderTarget.generateMipmaps = false;

    renderTarget.activeCubeFace = 0;
    renderer.render( scene, cameraPX, renderTarget );

    renderTarget.activeCubeFace = 1;
    renderer.render( scene, cameraNX, renderTarget );

    renderTarget.activeCubeFace = 2;
    renderer.render( scene, cameraPY, renderTarget );

    renderTarget.activeCubeFace = 3;
    renderer.render( scene, cameraNY, renderTarget );

    renderTarget.activeCubeFace = 4;
    renderer.render( scene, cameraPZ, renderTarget );

    renderTarget.generateMipmaps = generateMipmaps;

    renderTarget.activeCubeFace = 5;
    renderer.render( scene, cameraNZ, renderTarget );

    renderer.setRenderTarget( null );

  };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

  THREE.Camera.call( this );

  this.type = 'OrthographicCamera';

  this.zoom = 1;

  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;

  this.near = ( near !== undefined ) ? near : 0.1;
  this.far = ( far !== undefined ) ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

  var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  var cx = ( this.right + this.left ) / 2;
  var cy = ( this.top + this.bottom ) / 2;

  this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

  var camera = new THREE.OrthographicCamera();

  THREE.Camera.prototype.clone.call( this, camera );

  camera.zoom = this.zoom;

  camera.left = this.left;
  camera.right = this.right;
  camera.top = this.top;
  camera.bottom = this.bottom;

  camera.near = this.near;
  camera.far = this.far;

  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;
};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.left = this.left;
  data.object.right = this.right;
  data.object.top = this.top;
  data.object.bottom = this.bottom;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

  THREE.Camera.call( this );

  this.type = 'PerspectiveCamera';

  this.zoom = 1;

  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

  if ( frameHeight === undefined ) frameHeight = 24;

  this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
  this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;

  this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

  var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

  if ( this.fullWidth ) {

    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
    var bottom = - top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs( right - left );
    var height = Math.abs( top - bottom );

    this.projectionMatrix.makeFrustum(
      left + this.x * width / this.fullWidth,
      left + ( this.x + this.width ) * width / this.fullWidth,
      top - ( this.y + this.height ) * height / this.fullHeight,
      top - this.y * height / this.fullHeight,
      this.near,
      this.far
    );

  } else {

    this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

  }

};

THREE.PerspectiveCamera.prototype.clone = function () {

  var camera = new THREE.PerspectiveCamera();

  THREE.Camera.prototype.clone.call( this, camera );

  camera.zoom = this.zoom;

  camera.fov = this.fov;
  camera.aspect = this.aspect;
  camera.near = this.near;
  camera.far = this.far;

  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.fov = this.fov;
  data.object.aspect = this.aspect;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

  THREE.Object3D.call( this );

  this.type = 'Light';

  this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.clone = function ( light ) {

  if ( light === undefined ) light = new THREE.Light();

  THREE.Object3D.prototype.clone.call( this, light );

  light.color.copy( this.color );

  return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

  THREE.Light.call( this, color );

  this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.clone = function () {

  var light = new THREE.AmbientLight();

  THREE.Light.prototype.clone.call( this, light );

  return light;

};

THREE.AmbientLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();

  return data;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'AreaLight';

  this.normal = new THREE.Vector3( 0, - 1, 0 );
  this.right = new THREE.Vector3( 1, 0, 0 );

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.width = 1.0;
  this.height = 1.0;

  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
THREE.AreaLight.prototype.constructor = THREE.AreaLight;


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'DirectionalLight';

  this.position.set( 0, 1, 0 );
  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.castShadow = false;
  this.onlyShadow = false;

  //

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;

  this.shadowCameraLeft = - 500;
  this.shadowCameraRight = 500;
  this.shadowCameraTop = 500;
  this.shadowCameraBottom = - 500;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  //

  this.shadowCascade = false;

  this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
  this.shadowCascadeCount = 2;

  this.shadowCascadeBias = [ 0, 0, 0 ];
  this.shadowCascadeWidth = [ 512, 512, 512 ];
  this.shadowCascadeHeight = [ 512, 512, 512 ];

  this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
  this.shadowCascadeFarZ = [ 0.990, 0.998, 1.000 ];

  this.shadowCascadeArray = [];

  //

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.clone = function () {

  var light = new THREE.DirectionalLight();

  THREE.Light.prototype.clone.call( this, light );

  light.target = this.target.clone();

  light.intensity = this.intensity;

  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;

  //

  light.shadowCameraNear = this.shadowCameraNear;
  light.shadowCameraFar = this.shadowCameraFar;

  light.shadowCameraLeft = this.shadowCameraLeft;
  light.shadowCameraRight = this.shadowCameraRight;
  light.shadowCameraTop = this.shadowCameraTop;
  light.shadowCameraBottom = this.shadowCameraBottom;

  light.shadowCameraVisible = this.shadowCameraVisible;

  light.shadowBias = this.shadowBias;
  light.shadowDarkness = this.shadowDarkness;

  light.shadowMapWidth = this.shadowMapWidth;
  light.shadowMapHeight = this.shadowMapHeight;

  //

  light.shadowCascade = this.shadowCascade;

  light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
  light.shadowCascadeCount = this.shadowCascadeCount;

  light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
  light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
  light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

  light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
  light.shadowCascadeFarZ = this.shadowCascadeFarZ.slice( 0 );

  return light;

};

THREE.DirectionalLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;

  return data;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

  THREE.Light.call( this, skyColor );

  this.type = 'HemisphereLight';

  this.position.set( 0, 100, 0 );

  this.groundColor = new THREE.Color( groundColor );
  this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.clone = function () {

  var light = new THREE.HemisphereLight();

  THREE.Light.prototype.clone.call( this, light );

  light.groundColor.copy( this.groundColor );
  light.intensity = this.intensity;

  return light;

};

THREE.HemisphereLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.groundColor = this.groundColor.getHex();

  return data;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance, decay ) {

  THREE.Light.call( this, color );

  this.type = 'PointLight';

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.clone = function () {

  var light = new THREE.PointLight();

  THREE.Light.prototype.clone.call( this, light );

  light.intensity = this.intensity;
  light.distance = this.distance;
  light.decay = this.decay;

  return light;

};

THREE.PointLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  data.object.distance = this.distance;
  data.object.decay = this.decay;

  return data;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

  THREE.Light.call( this, color );

  this.type = 'SpotLight';

  this.position.set( 0, 1, 0 );
  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  this.exponent = ( exponent !== undefined ) ? exponent : 10;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

  this.castShadow = false;
  this.onlyShadow = false;

  //

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  //

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.clone = function () {

  var light = new THREE.SpotLight();

  THREE.Light.prototype.clone.call( this, light );

  light.target = this.target.clone();

  light.intensity = this.intensity;
  light.distance = this.distance;
  light.angle = this.angle;
  light.exponent = this.exponent;
  light.decay = this.decay;

  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;

  //

  light.shadowCameraNear = this.shadowCameraNear;
  light.shadowCameraFar = this.shadowCameraFar;
  light.shadowCameraFov = this.shadowCameraFov;

  light.shadowCameraVisible = this.shadowCameraVisible;

  light.shadowBias = this.shadowBias;
  light.shadowDarkness = this.shadowDarkness;

  light.shadowMapWidth = this.shadowMapWidth;
  light.shadowMapHeight = this.shadowMapHeight;

  return light;

};

THREE.SpotLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  data.object.distance = this.distance;
  data.object.angle = this.angle;
  data.object.exponent = this.exponent;
  data.object.decay = this.decay;

  return data;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

  files: {},

  add: function ( key, file ) {

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[ key ] = file;

  },

  get: function ( key ) {

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[ key ];

  },

  remove: function ( key ) {

    delete this.files[ key ];

  },

  clear: function () {

    this.files = {}

  }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

  this.showStatus = showStatus;
  this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

  this.imageLoader = new THREE.ImageLoader();

  this.onLoadStart = function () {};
  this.onLoadProgress = function () {};
  this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

  constructor: THREE.Loader,

  crossOrigin: undefined,

  addStatusElement: function () {

    var e = document.createElement( 'div' );

    e.style.position = 'absolute';
    e.style.right = '0px';
    e.style.top = '0px';
    e.style.fontSize = '0.8em';
    e.style.textAlign = 'left';
    e.style.background = 'rgba(0,0,0,0.25)';
    e.style.color = '#fff';
    e.style.width = '120px';
    e.style.padding = '0.5em 0.5em 0.5em 0.5em';
    e.style.zIndex = 1000;

    e.innerHTML = 'Loading ...';

    return e;

  },

  updateProgress: function ( progress ) {

    var message = 'Loaded ';

    if ( progress.total ) {

      message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


    } else {

      message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

    }

    this.statusDomElement.innerHTML = message;

  },

  extractUrlBase: function ( url ) {

    var parts = url.split( '/' );

    if ( parts.length === 1 ) return './';

    parts.pop();

    return parts.join( '/' ) + '/';

  },

  initMaterials: function ( materials, texturePath ) {

    var array = [];

    for ( var i = 0; i < materials.length; ++ i ) {

      array[ i ] = this.createMaterial( materials[ i ], texturePath );

    }

    return array;

  },

  needsTangents: function ( materials ) {

    for ( var i = 0, il = materials.length; i < il; i ++ ) {

      var m = materials[ i ];

      if ( m instanceof THREE.ShaderMaterial ) return true;

    }

    return false;

  },

  createMaterial: function ( m, texturePath ) {

    var scope = this;

    function nearest_pow2( n ) {

      var l = Math.log( n ) / Math.LN2;
      return Math.pow( 2, Math.round(  l ) );

    }

    function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

      var fullPath = texturePath + sourceFile;

      var texture;

      var loader = THREE.Loader.Handlers.get( fullPath );

      if ( loader !== null ) {

        texture = loader.load( fullPath );

      } else {

        texture = new THREE.Texture();

        loader = scope.imageLoader;
        loader.crossOrigin = scope.crossOrigin;
        loader.load( fullPath, function ( image ) {

          if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
             THREE.Math.isPowerOfTwo( image.height ) === false ) {

            var width = nearest_pow2( image.width );
            var height = nearest_pow2( image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = width;
            canvas.height = height;

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, width, height );

            texture.image = canvas;

          } else {

            texture.image = image;

          }

          texture.needsUpdate = true;

        } );

      }

      texture.sourceFile = sourceFile;

      if ( repeat ) {

        texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

        if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
        if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

      }

      if ( offset ) {

        texture.offset.set( offset[ 0 ], offset[ 1 ] );

      }

      if ( wrap ) {

        var wrapMap = {
          'repeat': THREE.RepeatWrapping,
          'mirror': THREE.MirroredRepeatWrapping
        };

        if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
        if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

      }

      if ( anisotropy ) {

        texture.anisotropy = anisotropy;

      }

      where[ name ] = texture;

    }

    function rgb2hex( rgb ) {

      return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

    }

    // defaults

    var mtype = 'MeshLambertMaterial';
    var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

    // parameters from model file

    if ( m.shading ) {

      var shading = m.shading.toLowerCase();

      if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
      else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

    }

    if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

      mpars.blending = THREE[ m.blending ];

    }

    if ( m.transparent !== undefined ) {

      mpars.transparent = m.transparent;

    }

    if ( m.opacity !== undefined && m.opacity < 1.0 ) {

      mpars.transparent = true;

    }

    if ( m.depthTest !== undefined ) {

      mpars.depthTest = m.depthTest;

    }

    if ( m.depthWrite !== undefined ) {

      mpars.depthWrite = m.depthWrite;

    }

    if ( m.visible !== undefined ) {

      mpars.visible = m.visible;

    }

    if ( m.flipSided !== undefined ) {

      mpars.side = THREE.BackSide;

    }

    if ( m.doubleSided !== undefined ) {

      mpars.side = THREE.DoubleSide;

    }

    if ( m.wireframe !== undefined ) {

      mpars.wireframe = m.wireframe;

    }

    if ( m.vertexColors !== undefined ) {

      if ( m.vertexColors === 'face' ) {

        mpars.vertexColors = THREE.FaceColors;

      } else if ( m.vertexColors ) {

        mpars.vertexColors = THREE.VertexColors;

      }

    }

    // colors

    if ( m.colorDiffuse ) {

      mpars.color = rgb2hex( m.colorDiffuse );

    } else if ( m.DbgColor ) {

      mpars.color = m.DbgColor;

    }

    if ( m.colorSpecular ) {

      mpars.specular = rgb2hex( m.colorSpecular );

    }

    if ( m.colorEmissive ) {

      mpars.emissive = rgb2hex( m.colorEmissive );

    }

    // modifiers

    if ( m.transparency !== undefined ) {

      console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
      m.opacity = m.transparency;

    }

    if ( m.opacity !== undefined ) {

      mpars.opacity = m.opacity;

    }

    if ( m.specularCoef ) {

      mpars.shininess = m.specularCoef;

    }

    // textures

    if ( m.mapDiffuse && texturePath ) {

      create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

    }

    if ( m.mapLight && texturePath ) {

      create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

    }

    if ( m.mapAO && texturePath ) {

      create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

    }

    if ( m.mapBump && texturePath ) {

      create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

    }

    if ( m.mapNormal && texturePath ) {

      create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

    }

    if ( m.mapSpecular && texturePath ) {

      create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

    }

    if ( m.mapAlpha && texturePath ) {

      create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

    }

    //

    if ( m.mapBumpScale ) {

      mpars.bumpScale = m.mapBumpScale;

    }

    if ( m.mapNormalFactor ) {

      mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

    }

    var material = new THREE[ mtype ]( mpars );

    if ( m.DbgName !== undefined ) material.name = m.DbgName;

    return material;

  }

};

THREE.Loader.Handlers = {

  handlers: [],

  add: function ( regex, loader ) {

    this.handlers.push( regex, loader );

  },

  get: function ( file ) {

    for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

      var regex = this.handlers[ i ];
      var loader  = this.handlers[ i + 1 ];

      if ( regex.test( file ) ) {

        return loader;

      }

    }

    return null;

  }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

  constructor: THREE.XHRLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) onLoad( cached );
      return cached;

    }

    var request = new XMLHttpRequest();
    request.open( 'GET', url, true );

    request.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this.response );

      if ( onLoad ) onLoad( this.response );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      request.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      request.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
    if ( this.responseType !== undefined ) request.responseType = this.responseType;

    request.send( null );

    scope.manager.itemStart( url );

    return request;

  },

  setResponseType: function ( value ) {

    this.responseType = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

  constructor: THREE.ImageLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) onLoad( cached );
      return cached;

    }

    var image = document.createElement( 'img' );

    image.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this );

      if ( onLoad ) onLoad( this );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      image.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      image.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

    scope.manager.itemStart( url );

    image.src = url;

    return image;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

  THREE.Loader.call( this, showStatus );

  this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

  // todo: unify load API to for easier SceneLoader use

  texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

  this.onLoadStart();
  this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

  var xhr = new XMLHttpRequest();

  var length = 0;

  xhr.onreadystatechange = function () {

    if ( xhr.readyState === xhr.DONE ) {

      if ( xhr.status === 200 || xhr.status === 0 ) {

        if ( xhr.responseText ) {

          var json = JSON.parse( xhr.responseText );
          var metadata = json.metadata;

          if ( metadata !== undefined ) {

            if ( metadata.type === 'object' ) {

              console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
              return;

            }

            if ( metadata.type === 'scene' ) {

              console.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );
              return;

            }

          }

          var result = context.parse( json, texturePath );
          callback( result.geometry, result.materials );

        } else {

          console.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );

        }

        // in context of more complex asset initialization
        // do not block on single failed file
        // maybe should go even one more level up

        context.onLoadComplete();

      } else {

        console.error( 'THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')' );

      }

    } else if ( xhr.readyState === xhr.LOADING ) {

      if ( callbackProgress ) {

        if ( length === 0 ) {

          length = xhr.getResponseHeader( 'Content-Length' );

        }

        callbackProgress( { total: length, loaded: xhr.responseText.length } );

      }

    } else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

      if ( callbackProgress !== undefined ) {

        length = xhr.getResponseHeader( 'Content-Length' );

      }

    }

  };

  xhr.open( 'GET', url, true );
  xhr.withCredentials = this.withCredentials;
  xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

  var geometry = new THREE.Geometry(),
  scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

  parseModel( scale );

  parseSkin();
  parseMorphing( scale );

  geometry.computeFaceNormals();
  geometry.computeBoundingSphere();

  function parseModel( scale ) {

    function isBitSet( value, position ) {

      return value & ( 1 << position );

    }

    var i, j, fi,

    offset, zLength,

    colorIndex, normalIndex, uvIndex,

    type,
    isQuad,
    hasMaterial,
    hasFaceVertexUv,
    hasFaceNormal, hasFaceVertexNormal,
    hasFaceColor, hasFaceVertexColor,

    vertex, face, faceA, faceB, hex, normal,

    uvLayer, uv, u, v,

    faces = json.faces,
    vertices = json.vertices,
    normals = json.normals,
    colors = json.colors,

    nUvLayers = 0;

    if ( json.uvs !== undefined ) {

      // disregard empty arrays

      for ( i = 0; i < json.uvs.length; i ++ ) {

        if ( json.uvs[ i ].length ) nUvLayers ++;

      }

      for ( i = 0; i < nUvLayers; i ++ ) {

        geometry.faceVertexUvs[ i ] = [];

      }

    }

    offset = 0;
    zLength = vertices.length;

    while ( offset < zLength ) {

      vertex = new THREE.Vector3();

      vertex.x = vertices[ offset ++ ] * scale;
      vertex.y = vertices[ offset ++ ] * scale;
      vertex.z = vertices[ offset ++ ] * scale;

      geometry.vertices.push( vertex );

    }

    offset = 0;
    zLength = faces.length;

    while ( offset < zLength ) {

      type = faces[ offset ++ ];


      isQuad              = isBitSet( type, 0 );
      hasMaterial         = isBitSet( type, 1 );
      hasFaceVertexUv     = isBitSet( type, 3 );
      hasFaceNormal       = isBitSet( type, 4 );
      hasFaceVertexNormal = isBitSet( type, 5 );
      hasFaceColor       = isBitSet( type, 6 );
      hasFaceVertexColor  = isBitSet( type, 7 );

      // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

      if ( isQuad ) {

        faceA = new THREE.Face3();
        faceA.a = faces[ offset ];
        faceA.b = faces[ offset + 1 ];
        faceA.c = faces[ offset + 3 ];

        faceB = new THREE.Face3();
        faceB.a = faces[ offset + 1 ];
        faceB.b = faces[ offset + 2 ];
        faceB.c = faces[ offset + 3 ];

        offset += 4;

        if ( hasMaterial ) {

          offset ++;

        }

        // to get face <=> uv index correspondence

        fi = geometry.faces.length;

        if ( hasFaceVertexUv ) {

          for ( i = 0; i < nUvLayers; i ++ ) {

            uvLayer = json.uvs[ i ];

            geometry.faceVertexUvs[ i ][ fi ] = [];
            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

            for ( j = 0; j < 4; j ++ ) {

              uvIndex = faces[ offset ++ ];

              u = uvLayer[ uvIndex * 2 ];
              v = uvLayer[ uvIndex * 2 + 1 ];

              uv = new THREE.Vector2( u, v );

              if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
              if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

            }

          }

        }

        if ( hasFaceNormal ) {

          normalIndex = faces[ offset ++ ] * 3;

          faceA.normal.set(
            normals[ normalIndex ++ ],
            normals[ normalIndex ++ ],
            normals[ normalIndex ]
          );

          faceB.normal.copy( faceA.normal );

        }

        if ( hasFaceVertexNormal ) {

          for ( i = 0; i < 4; i ++ ) {

            normalIndex = faces[ offset ++ ] * 3;

            normal = new THREE.Vector3(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );


            if ( i !== 2 ) faceA.vertexNormals.push( normal );
            if ( i !== 0 ) faceB.vertexNormals.push( normal );

          }

        }


        if ( hasFaceColor ) {

          colorIndex = faces[ offset ++ ];
          hex = colors[ colorIndex ];

          faceA.color.setHex( hex );
          faceB.color.setHex( hex );

        }


        if ( hasFaceVertexColor ) {

          for ( i = 0; i < 4; i ++ ) {

            colorIndex = faces[ offset ++ ];
            hex = colors[ colorIndex ];

            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

          }

        }

        geometry.faces.push( faceA );
        geometry.faces.push( faceB );

      } else {

        face = new THREE.Face3();
        face.a = faces[ offset ++ ];
        face.b = faces[ offset ++ ];
        face.c = faces[ offset ++ ];

        if ( hasMaterial ) {

          offset ++;

        }

        // to get face <=> uv index correspondence

        fi = geometry.faces.length;

        if ( hasFaceVertexUv ) {

          for ( i = 0; i < nUvLayers; i ++ ) {

            uvLayer = json.uvs[ i ];

            geometry.faceVertexUvs[ i ][ fi ] = [];

            for ( j = 0; j < 3; j ++ ) {

              uvIndex = faces[ offset ++ ];

              u = uvLayer[ uvIndex * 2 ];
              v = uvLayer[ uvIndex * 2 + 1 ];

              uv = new THREE.Vector2( u, v );

              geometry.faceVertexUvs[ i ][ fi ].push( uv );

            }

          }

        }

        if ( hasFaceNormal ) {

          normalIndex = faces[ offset ++ ] * 3;

          face.normal.set(
            normals[ normalIndex ++ ],
            normals[ normalIndex ++ ],
            normals[ normalIndex ]
          );

        }

        if ( hasFaceVertexNormal ) {

          for ( i = 0; i < 3; i ++ ) {

            normalIndex = faces[ offset ++ ] * 3;

            normal = new THREE.Vector3(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

            face.vertexNormals.push( normal );

          }

        }


        if ( hasFaceColor ) {

          colorIndex = faces[ offset ++ ];
          face.color.setHex( colors[ colorIndex ] );

        }


        if ( hasFaceVertexColor ) {

          for ( i = 0; i < 3; i ++ ) {

            colorIndex = faces[ offset ++ ];
            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

          }

        }

        geometry.faces.push( face );

      }

    }

  }

  function parseSkin() {
    var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    if ( json.skinWeights ) {

      for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

        var x =                               json.skinWeights[ i     ];
        var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
        var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
        var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

        geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

      }

    }

    if ( json.skinIndices ) {

      for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

        var a =                               json.skinIndices[ i     ];
        var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
        var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
        var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

        geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

      }

    }

    geometry.bones = json.bones;

    if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

      console.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
          geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    }


    // could change this to json.animations[0] or remove completely

    geometry.animation = json.animation;
    geometry.animations = json.animations;

  }

  function parseMorphing( scale ) {

    if ( json.morphTargets !== undefined ) {

      var i, l, v, vl, dstVertices, srcVertices;

      for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

        geometry.morphTargets[ i ] = {};
        geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
        geometry.morphTargets[ i ].vertices = [];

        dstVertices = geometry.morphTargets[ i ].vertices;
        srcVertices = json.morphTargets [ i ].vertices;

        for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

          var vertex = new THREE.Vector3();
          vertex.x = srcVertices[ v ] * scale;
          vertex.y = srcVertices[ v + 1 ] * scale;
          vertex.z = srcVertices[ v + 2 ] * scale;

          dstVertices.push( vertex );

        }

      }

    }

    if ( json.morphColors !== undefined ) {

      var i, l, c, cl, dstColors, srcColors, color;

      for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

        geometry.morphColors[ i ] = {};
        geometry.morphColors[ i ].name = json.morphColors[ i ].name;
        geometry.morphColors[ i ].colors = [];

        dstColors = geometry.morphColors[ i ].colors;
        srcColors = json.morphColors [ i ].colors;

        for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

          color = new THREE.Color( 0xffaa00 );
          color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
          dstColors.push( color );

        }

      }

    }

  }

  if ( json.materials === undefined || json.materials.length === 0 ) {

    return { geometry: geometry };

  } else {

    var materials = this.initMaterials( json.materials, texturePath );

    if ( this.needsTangents( materials ) ) {

      geometry.computeTangents();

    }

    return { geometry: geometry, materials: materials };

  }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

  var scope = this;

  var loaded = 0, total = 0;

  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function ( url ) {

    total ++;

  };

  this.itemEnd = function ( url ) {

    loaded ++;

    if ( scope.onProgress !== undefined ) {

      scope.onProgress( url, loaded, total );

    }

    if ( loaded === total && scope.onLoad !== undefined ) {

      scope.onLoad();

    }

  };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

  constructor: THREE.BufferGeometryLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var geometry = new THREE.BufferGeometry();

    var attributes = json.data.attributes;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];
      var typedArray = new self[ attribute.type ]( attribute.array );

      geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

    }

    var offsets = json.data.offsets;

    if ( offsets !== undefined ) {

      geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

    }

    var boundingSphere = json.data.boundingSphere;

    if ( boundingSphere !== undefined ) {

      var center = new THREE.Vector3();

      if ( boundingSphere.center !== undefined ) {

        center.fromArray( boundingSphere.center );

      }

      geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

    }

    return geometry;

  }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

  constructor: THREE.MaterialLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var material = new THREE[ json.type ];

    if ( json.color !== undefined ) material.color.setHex( json.color );
    if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    if ( json.shininess !== undefined ) material.shininess = json.shininess;
    if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    if ( json.attributes !== undefined ) material.attributes = json.attributes;
    if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    if ( json.shading !== undefined ) material.shading = json.shading;
    if ( json.blending !== undefined ) material.blending = json.blending;
    if ( json.side !== undefined ) material.side = json.side;
    if ( json.opacity !== undefined ) material.opacity = json.opacity;
    if ( json.transparent !== undefined ) material.transparent = json.transparent;
    if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;

    // for PointCloudMaterial
    if ( json.size !== undefined ) material.size = json.size;
    if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    if ( json.materials !== undefined ) {

      for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

        material.materials.push( this.parse( json.materials[ i ] ) );

      }

    }

    return material;

  }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
  this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

  constructor: THREE.ObjectLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    if ( this.texturePath === '' ) {

      this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    }

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      scope.parse( JSON.parse( text ), onLoad );

    }, onProgress, onError );

  },

  setTexturePath: function ( value ) {

    this.texturePath = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json, onLoad ) {

    var geometries = this.parseGeometries( json.geometries );

    var images = this.parseImages( json.images, function () {

      if ( onLoad !== undefined ) onLoad( object );

    } );

    var textures  = this.parseTextures( json.textures, images );
    var materials = this.parseMaterials( json.materials, textures );
    var object = this.parseObject( json.object, geometries, materials );

    if ( json.images === undefined || json.images.length === 0 ) {

      if ( onLoad !== undefined ) onLoad( object );

    }

    return object;

  },

  parseGeometries: function ( json ) {

    var geometries = {};

    if ( json !== undefined ) {

      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var geometry;
        var data = json[ i ];

        switch ( data.type ) {

          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':

            geometry = new THREE[ data.type ](
              data.width,
              data.height,
              data.widthSegments,
              data.heightSegments
            );

            break;

          case 'BoxGeometry':
          case 'CubeGeometry': // backwards compatible

            geometry = new THREE.BoxGeometry(
              data.width,
              data.height,
              data.depth,
              data.widthSegments,
              data.heightSegments,
              data.depthSegments
            );

            break;

          case 'CircleGeometry':

            geometry = new THREE.CircleGeometry(
              data.radius,
              data.segments
            );

            break;

          case 'CylinderGeometry':

            geometry = new THREE.CylinderGeometry(
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded
            );

            break;

          case 'SphereGeometry':

            geometry = new THREE.SphereGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'IcosahedronGeometry':

            geometry = new THREE.IcosahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'TorusGeometry':

            geometry = new THREE.TorusGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.arc
            );

            break;

          case 'TorusKnotGeometry':

            geometry = new THREE.TorusKnotGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.p,
              data.q,
              data.heightScale
            );

            break;

          case 'BufferGeometry':

            geometry = bufferGeometryLoader.parse( data );

            break;

          case 'Geometry':

            geometry = geometryLoader.parse( data.data ).geometry;

            break;

          case 'TextGeometry':

            geometry = new THREE.TextGeometry(
              data.text,
              data.data
            );

            break;

        }

        geometry.uuid = data.uuid;

        if ( data.name !== undefined ) geometry.name = data.name;

        geometries[ data.uuid ] = geometry;

      }

    }

    return geometries;

  },

  parseMaterials: function ( json, textures ) {

    var materials = {};

    if ( json !== undefined ) {

      var getTexture = function ( name ) {

        if ( textures[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined texture', name );

        }

        return textures[ name ];

      };

      var loader = new THREE.MaterialLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];
        var material = loader.parse( data );

        material.uuid = data.uuid;

        if ( data.depthTest !== undefined ) material.depthTest = data.depthTest;
        if ( data.depthWrite !== undefined ) material.depthWrite = data.depthWrite;

        if ( data.name !== undefined ) material.name = data.name;

        if ( data.map !== undefined ) material.map = getTexture( data.map );

        if ( data.alphaMap !== undefined ) {

          material.alphaMap = getTexture( data.alphaMap );
          material.transparent = true;

        }

        if ( data.bumpMap !== undefined ) material.bumpMap = getTexture( data.bumpMap );
        if ( data.bumpScale !== undefined ) material.bumpScale = data.bumpScale;

        if ( data.normalMap !== undefined ) material.normalMap = getTexture( data.normalMap );
        if ( data.normalScale ) material.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );

        if ( data.specularMap !== undefined ) material.specularMap = getTexture( data.specularMap );

        if ( data.envMap !== undefined ) {

          material.envMap = getTexture( data.envMap );
          material.combine = THREE.MultiplyOperation;

        }

        if ( data.reflectivity ) material.reflectivity = data.reflectivity;

        if ( data.lightMap !== undefined ) material.lightMap = getTexture( data.lightMap );
        if ( data.lightMapIntensity !== undefined ) material.lightMapIntensity = data.lightMapIntensity;

        if ( data.aoMap !== undefined ) material.aoMap = getTexture( data.aoMap );
        if ( data.aoMapIntensity !== undefined ) material.aoMapIntensity = data.aoMapIntensity;

        materials[ data.uuid ] = material;

      }

    }

    return materials;

  },

  parseImages: function ( json, onLoad ) {

    var scope = this;
    var images = {};

    if ( json !== undefined && json.length > 0 ) {

      var manager = new THREE.LoadingManager( onLoad );

      var loader = new THREE.ImageLoader( manager );
      loader.setCrossOrigin( this.crossOrigin );

      var loadImage = function ( url ) {

        scope.manager.itemStart( url );

        return loader.load( url, function () {

          scope.manager.itemEnd( url );

        } );

      };

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var image = json[ i ];
        images[ image.uuid ] = loadImage( image.url );

      }

    }

    return images;

  },

  parseTextures: function ( json, images ) {

    function parseConstant( value ) {

      if ( typeof( value ) === 'number' ) return value;

      console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

      return THREE[ value ];

    }

    var textures = {};

    if ( json !== undefined ) {

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];

        if ( data.image === undefined ) {

          console.warn( 'THREE.ObjectLoader: No "image" speficied for', data.uuid );

        }

        if ( images[ data.image ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

        }

        var texture = new THREE.Texture( images[ data.image ] );
        texture.needsUpdate = true;

        texture.uuid = data.uuid;

        if ( data.name !== undefined ) texture.name = data.name;
        if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
        if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
        if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
        if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
        if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
        if ( Array.isArray( data.wrap ) ) {

          texture.wrapS = parseConstant( data.wrap[ 0 ] );
          texture.wrapT = parseConstant( data.wrap[ 1 ] );

        }

        textures[ data.uuid ] = texture;

      }

    }

    return textures;

  },

  parseObject: function () {

    var matrix = new THREE.Matrix4();

    return function ( data, geometries, materials ) {

      var object;

      var getGeometry = function ( name ) {

        if ( geometries[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

        }

        return geometries[ name ];

      };

      var getMaterial = function ( name ) {

        if ( materials[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined material', name );

        }

        return materials[ name ];

      };

      switch ( data.type ) {

        case 'Scene':

          object = new THREE.Scene();

          break;

        case 'PerspectiveCamera':

          object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

          break;

        case 'OrthographicCamera':

          object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

          break;

        case 'AmbientLight':

          object = new THREE.AmbientLight( data.color );

          break;

        case 'DirectionalLight':

          object = new THREE.DirectionalLight( data.color, data.intensity );

          break;

        case 'PointLight':

          object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

          break;

        case 'SpotLight':

          object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

          break;

        case 'HemisphereLight':

          object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

          break;

        case 'Mesh':

          object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Line':

          object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

          break;

        case 'PointCloud':

          object = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Sprite':

          object = new THREE.Sprite( getMaterial( data.material ) );

          break;

        case 'Group':

          object = new THREE.Group();

          break;

        default:

          object = new THREE.Object3D();

      }

      object.uuid = data.uuid;

      if ( data.name !== undefined ) object.name = data.name;
      if ( data.matrix !== undefined ) {

        matrix.fromArray( data.matrix );
        matrix.decompose( object.position, object.quaternion, object.scale );

      } else {

        if ( data.position !== undefined ) object.position.fromArray( data.position );
        if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
        if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

      }

      if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
      if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

      if ( data.visible !== undefined ) object.visible = data.visible;
      if ( data.userData !== undefined ) object.userData = data.userData;

      if ( data.children !== undefined ) {

        for ( var child in data.children ) {

          object.add( this.parseObject( data.children[ child ], geometries, materials ) );

        }

      }

      return object;

    }

  }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

  constructor: THREE.TextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.ImageLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( image ) {

      var texture = new THREE.Texture( image );
      texture.needsUpdate = true;

      if ( onLoad !== undefined ) {

        onLoad( texture );

      }

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {

  // override in sub classes
  this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

  constructor: THREE.BinaryTextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texture = new THREE.DataTexture( );

    var loader = new THREE.XHRLoader();
    loader.setResponseType( 'arraybuffer' );

    loader.load( url, function ( buffer ) {

      var texData = scope._parser( buffer );

      if ( !texData ) return;

      if ( undefined !== texData.image ) {

        texture.image = texData.image;

      } else if ( undefined !== texData.data ) {

        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;

      }

      texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
      texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

      texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
      texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

      texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

      if ( undefined !== texData.format ) {

        texture.format = texData.format;

      }
      if ( undefined !== texData.type ) {

        texture.type = texData.type;

      }

      if ( undefined !== texData.mipmaps ) {

        texture.mipmaps = texData.mipmaps;

      }

      if ( 1 === texData.mipmapCount ) {

        texture.minFilter = THREE.LinearFilter;

      }

      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture, texData );

    }, onProgress, onError );


    return texture;

  }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

  // override in sub classes
  this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

  constructor: THREE.CompressedTextureLoader,

  load: function ( url, onLoad, onError ) {

    var scope = this;

    var images = [];

    var texture = new THREE.CompressedTexture();
    texture.image = images;

    var loader = new THREE.XHRLoader();
    loader.setResponseType( 'arraybuffer' );

    if ( Array.isArray( url ) ) {

      var loaded = 0;

      var loadTexture = function ( i ) {

        loader.load( url[ i ], function ( buffer ) {

          var texDatas = scope._parser( buffer, true );

          images[ i ] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };

          loaded += 1;

          if ( loaded === 6 ) {

            if (texDatas.mipmapCount === 1)
              texture.minFilter = THREE.LinearFilter;

            texture.format = texDatas.format;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

          }

        } );

      };

      for ( var i = 0, il = url.length; i < il; ++ i ) {

        loadTexture( i );

      }

    } else {

      // compressed cubemap texture stored in a single DDS file

      loader.load( url, function ( buffer ) {

        var texDatas = scope._parser( buffer, true );

        if ( texDatas.isCubemap ) {

          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for ( var f = 0; f < faces; f ++ ) {

            images[ f ] = { mipmaps : [] };

            for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

              images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
              images[ f ].format = texDatas.format;
              images[ f ].width = texDatas.width;
              images[ f ].height = texDatas.height;

            }

          }

        } else {

          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;

        }

        if ( texDatas.mipmapCount === 1 ) {

          texture.minFilter = THREE.LinearFilter;

        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;

        if ( onLoad ) onLoad( texture );

      } );

    }

    return texture;

  }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

  Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Material';

  this.side = THREE.FrontSide;

  this.opacity = 1;
  this.transparent = false;

  this.blending = THREE.NormalBlending;

  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;

  this.depthFunc = THREE.LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;

  this.colorWrite = true;

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;

  this.alphaTest = 0;

  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  this.visible = true;

  this._needsUpdate = true;

};

THREE.Material.prototype = {

  constructor: THREE.Material,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  setValues: function ( values ) {

    if ( values === undefined ) return;

    for ( var key in values ) {

      var newValue = values[ key ];

      if ( newValue === undefined ) {

        console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
        continue;

      }

      if ( key in this ) {

        var currentValue = this[ key ];

        if ( currentValue instanceof THREE.Color ) {

          currentValue.set( newValue );

        } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

          currentValue.copy( newValue );

        } else if ( key === 'overdraw' ) {

          // ensure overdraw is backwards-compatable with legacy boolean type
          this[ key ] = Number( newValue );

        } else {

          this[ key ] = newValue;

        }

      }

    }

  },

  toJSON: function ( meta ) {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    };

    // standard Material serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
    if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
    if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
    if ( this.shininess !== undefined ) data.shininess = this.shininess;

    if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
    if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    if ( this.bumpMap instanceof THREE.Texture ) {
      data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
      data.bumpScale = this.bumpScale;
    }
    if ( this.normalMap instanceof THREE.Texture ) {
      data.normalMap = this.normalMap.toJSON( meta ).uuid;
      data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js
    }
    if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
    if ( this.envMap instanceof THREE.Texture ) {
      data.envMap = this.envMap.toJSON( meta ).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap
    }

    if ( this.size !== undefined ) data.size = this.size;
    if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
    if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
    if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
    if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

    if ( this.opacity < 1 ) data.opacity = this.opacity;
    if ( this.transparent === true ) data.transparent = this.transparent;
    if ( this.wireframe === true ) data.wireframe = this.wireframe;

    return data;

  },

  clone: function ( material ) {

    if ( material === undefined ) material = new THREE.Material();

    material.name = this.name;

    material.side = this.side;

    material.opacity = this.opacity;
    material.transparent = this.transparent;

    material.blending = this.blending;

    material.blendSrc = this.blendSrc;
    material.blendDst = this.blendDst;
    material.blendEquation = this.blendEquation;
    material.blendSrcAlpha = this.blendSrcAlpha;
    material.blendDstAlpha = this.blendDstAlpha;
    material.blendEquationAlpha = this.blendEquationAlpha;

    material.depthFunc = this.depthFunc;
    material.depthTest = this.depthTest;
    material.depthWrite = this.depthWrite;

    material.polygonOffset = this.polygonOffset;
    material.polygonOffsetFactor = this.polygonOffsetFactor;
    material.polygonOffsetUnits = this.polygonOffsetUnits;

    material.alphaTest = this.alphaTest;

    material.overdraw = this.overdraw;

    material.visible = this.visible;

    return material;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineBasicMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.clone = function () {

  var material = new THREE.LineBasicMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.linewidth = this.linewidth;
  material.linecap = this.linecap;
  material.linejoin = this.linejoin;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineDashedMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;

  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;

  this.vertexColors = false;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.clone = function () {

  var material = new THREE.LineDashedMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.linewidth = this.linewidth;

  material.scale = this.scale;
  material.dashSize = this.dashSize;
  material.gapSize = this.gapSize;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshBasicMaterial';

  this.color = new THREE.Color( 0xffffff ); // emissive

  this.map = null;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.clone = function () {

  var material = new THREE.MeshBasicMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.map = this.map;

  material.aoMap = this.aoMap;
  material.aoMapIntensity = this.aoMapIntensity;

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;

  return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshLambertMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );

  this.map = null;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.clone = function () {

  var material = new THREE.MeshLambertMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.emissive.copy( this.emissive );

  material.map = this.map;

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshPhongMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );
  this.specular = new THREE.Color( 0x111111 );
  this.shininess = 30;

  this.metal = false;

  this.map = null;

  this.lightMap = null;
  this.lightMapIntensity = 1.0;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.bumpMap = null;
  this.bumpScale = 1;

  this.normalMap = null;
  this.normalScale = new THREE.Vector2( 1, 1 );

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.clone = function () {

  var material = new THREE.MeshPhongMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.emissive.copy( this.emissive );
  material.specular.copy( this.specular );
  material.shininess = this.shininess;

  material.metal = this.metal;

  material.map = this.map;

  material.lightMap = this.lightMap;
  material.lightMapIntensity = this.lightMapIntensity;

  material.aoMap = this.aoMap;
  material.aoMapIntensity = this.aoMapIntensity;

  material.bumpMap = this.bumpMap;
  material.bumpScale = this.bumpScale;

  material.normalMap = this.normalMap;
  material.normalScale.copy( this.normalScale );

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshDepthMaterial';

  this.morphTargets = false;
  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.clone = function () {

  var material = new THREE.MeshDepthMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

  THREE.Material.call( this, parameters );

  this.type = 'MeshNormalMaterial';

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.clone = function () {

  var material = new THREE.MeshNormalMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

  console.error( 'THREE.MeshFaceMaterial has been removed.' );

  var material = Array.isArray( materials ) ? materials[ 0 ] : new THREE.MeshBasicMaterial();
  material.materials = []; // temporal workaround

  return material;

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'PointCloudMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.map = null;

  this.size = 1;
  this.sizeAttenuation = true;

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

THREE.PointCloudMaterial.prototype.clone = function () {

  var material = new THREE.PointCloudMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.map = this.map;

  material.size = this.size;
  material.sizeAttenuation = this.sizeAttenuation;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'ShaderMaterial';

  this.defines = {};
  this.uniforms = {};
  this.attributes = [];

  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  this.shading = THREE.SmoothShading;

  this.linewidth = 1;

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets
  this.morphNormals = false; // set to use morph normals

  this.derivatives = false; // set to use derivatives

  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [ 1, 1, 1 ],
    'uv': [ 0, 0 ],
    'uv2': [ 0, 0 ]
  };

  this.index0AttributeName = undefined;

  if ( parameters !== undefined ) {

    if ( parameters.attributes !== undefined && Array.isArray( parameters.attributes ) === false ) {

      console.warn( 'THREE.ShaderMaterial: attributes should now be an array of attribute names.' );
      parameters.attributes = Object.keys( parameters.attributes );

    }

    this.setValues( parameters );

  }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.clone = function ( material ) {

  if ( material === undefined ) material = new THREE.ShaderMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.fragmentShader = this.fragmentShader;
  material.vertexShader = this.vertexShader;

  material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

  material.attributes = this.attributes;
  material.defines = this.defines;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  material.fog = this.fog;

  material.lights = this.lights;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;

  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

  var data = THREE.Material.prototype.toJSON.call( this, meta );

  data.uniforms = this.uniforms;
  data.attributes = this.attributes;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;

  return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

  THREE.ShaderMaterial.call( this, parameters );

  this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

THREE.RawShaderMaterial.prototype.clone = function () {

  var material = new THREE.RawShaderMaterial();

  THREE.ShaderMaterial.prototype.clone.call( this, material );

  return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  uvOffset: new THREE.Vector2(),
 *  uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'SpriteMaterial';

  this.color = new THREE.Color( 0xffffff );
  this.map = null;

  this.rotation = 0;

  this.fog = false;

  // set parameters

  this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.clone = function () {

  var material = new THREE.SpriteMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.map = this.map;

  material.rotation = this.rotation;

  material.fog = this.fog;

  return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.sourceFile = '';

  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];

  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  this._needsUpdate = false;
  this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

  constructor: THREE.Texture,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  clone: function ( texture ) {

    if ( texture === undefined ) texture = new THREE.Texture();

    texture.image = this.image;
    texture.mipmaps = this.mipmaps.slice( 0 );

    texture.mapping = this.mapping;

    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;

    texture.magFilter = this.magFilter;
    texture.minFilter = this.minFilter;

    texture.anisotropy = this.anisotropy;

    texture.format = this.format;
    texture.type = this.type;

    texture.offset.copy( this.offset );
    texture.repeat.copy( this.repeat );

    texture.generateMipmaps = this.generateMipmaps;
    texture.premultiplyAlpha = this.premultiplyAlpha;
    texture.flipY = this.flipY;
    texture.unpackAlignment = this.unpackAlignment;

    return texture;

  },

  toJSON: function ( meta ) {

    if ( meta.textures[ this.uuid ] !== undefined ) {

      return meta.textures[ this.uuid ];

    }

    var output = {
      metadata: {
        version: 4.4,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },

      uuid: this.uuid,
      name: this.name,

      mapping: this.mapping,

      repeat: [ this.repeat.x, this.repeat.y ],
      offset: [ this.offset.x, this.offset.y ],
      wrap: [ this.wrapS, this.wrapT ],

      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy
    };

    if ( this.image !== undefined ) {

      // TODO: Move to THREE.Image

      var image = this.image;

      if ( image.uuid === undefined ) {

        image.uuid = THREE.Math.generateUUID(); // UGH

      }

      if ( meta.images[ this.image.uuid ] === undefined ) {

        var canvas = document.createElement( 'canvas' );
        canvas.width = image.width;
        canvas.height = image.height;

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0, image.width, image.height );

        var src;

        if ( image.width > 2048 || image.height > 2048 ) {

          src = canvas.toDataURL( 'image/jpeg', 0.6 );

        } else {

          src = canvas.toDataURL( 'image/png' );

        }

        meta.images[ this.image.uuid ] = { uuid: this.image.uuid, url: src };

      }

      output.image = image.uuid;

    }

    meta.textures[ this.uuid ] = output;

    return output;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

  THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.clone = function ( texture ) {

  if ( texture === undefined ) texture = new THREE.CubeTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  texture.images = this.images;

  return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { width: width, height: height };
  this.mipmaps = mipmaps;

  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false;

  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

THREE.CompressedTexture.prototype.clone = function () {

  var texture = new THREE.CompressedTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

THREE.DataTexture.prototype.clone = function () {

  var texture = new THREE.DataTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.generateMipmaps = false;

  var scope = this;

  var update = function () {

    requestAnimationFrame( update );

    if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

      scope.needsUpdate = true;

    }

  };

  update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

  THREE.Object3D.call( this );

  this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'PointCloud';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
THREE.PointCloud.prototype.constructor = THREE.PointCloud;

THREE.PointCloud.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();

  return function ( raycaster, intersects ) {

    var object = this;
    var geometry = object.geometry;
    var threshold = raycaster.params.PointCloud.threshold;

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    var position = new THREE.Vector3();

    var testPoint = function ( point, index ) {

      var rayPointDistance = ray.distanceToPoint( point );

      if ( rayPointDistance < localThreshold ) {

        var intersectPoint = ray.closestPointToPoint( point );
        intersectPoint.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) return;

        intersects.push( {

          distance: distance,
          distanceToRay: rayPointDistance,
          point: intersectPoint.clone(),
          index: index,
          face: null,
          object: object

        } );

      }

    };

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          var offset = {
            start: 0,
            count: indices.length,
            index: 0
          };

          offsets = [ offset ];

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start, il = start + count; i < il; i ++ ) {

            var a = index + indices[ i ];

            position.fromArray( positions, a * 3 );

            testPoint( position, a );

          }

        }

      } else {

        var pointCount = positions.length / 3;

        for ( var i = 0; i < pointCount; i ++ ) {

          position.set(
            positions[ 3 * i ],
            positions[ 3 * i + 1 ],
            positions[ 3 * i + 2 ]
          );

          testPoint( position, i );

        }

      }

    } else {

      var vertices = this.geometry.vertices;

      for ( var i = 0; i < vertices.length; i ++ ) {

        testPoint( vertices[ i ], i );

      }

    }

  };

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

THREE.PointCloud.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();
  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON();
  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

  console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
  return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

  if ( mode === 1 ) {

    console.error( 'THREE.Line: THREE.LinePieces mode has been removed. Use THREE.LineSegments instead.' );

  }

  THREE.Object3D.call( this );

  this.type = 'Line';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  return function ( raycaster, intersects ) {

    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;

    var geometry = this.geometry;

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    // Checking boundingSphere distance to ray

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    var vStart = new THREE.Vector3();
    var vEnd = new THREE.Vector3();
    var interSegment = new THREE.Vector3();
    var interRay = new THREE.Vector3();
    var step = this instanceof THREE.LineSegments ? 2 : 1;

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          offsets = [ { start: 0, count: indices.length, index: 0 } ];

        }

        for ( var oi = 0; oi < offsets.length; oi ++) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start; i < start + count - 1; i += step ) {

            var a = index + indices[ i ];
            var b = index + indices[ i + 1 ];

            vStart.fromArray( positions, a * 3 );
            vEnd.fromArray( positions, b * 3 );

            var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

            if ( distSq > precisionSq ) continue;

            var distance = ray.origin.distanceTo( interRay );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4( this.matrixWorld ),
              index: i,
              offsetIndex: oi,
              face: null,
              faceIndex: null,
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0; i < positions.length / 3 - 1; i += step ) {

          vStart.fromArray( positions, 3 * i );
          vEnd.fromArray( positions, 3 * i + 3 );

          var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

          if ( distSq > precisionSq ) continue;

          var distance = ray.origin.distanceTo( interRay );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
            index: i,
            face: null,
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var vertices = geometry.vertices;
      var nbVertices = vertices.length;

      for ( var i = 0; i < nbVertices - 1; i += step ) {

        var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

        if ( distSq > precisionSq ) continue;

        var distance = ray.origin.distanceTo( interRay );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4( this.matrixWorld ),
          index: i,
          face: null,
          faceIndex: null,
          object: this

        } );

      }

    }

  };

}() );

THREE.Line.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE[ this.type ]( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

THREE.Line.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();
  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON();
  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

  THREE.Line.call( this, geometry, material );

  this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'Mesh';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

  if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

    this.morphTargetBase = - 1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};

    for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

      this.morphTargetInfluences.push( 0 );
      this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

    }

  }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

  if ( this.morphTargetDictionary[ name ] !== undefined ) {

    return this.morphTargetDictionary[ name ];

  }

  console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

  return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    var geometry = this.geometry;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    // Check boundingBox before continuing

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    if ( geometry instanceof THREE.BufferGeometry ) {

      var material = this.material;

      if ( material === undefined ) return;

      var attributes = geometry.attributes;

      var a, b, c;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          offsets = [ { start: 0, count: indices.length, index: 0 } ];

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            a = index + indices[ i ];
            b = index + indices[ i + 1 ];
            c = index + indices[ i + 2 ];

            vA.fromArray( positions, a * 3 );
            vB.fromArray( positions, b * 3 );
            vC.fromArray( positions, c * 3 );

            if ( material.side === THREE.BackSide ) {

              var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

            } else {

              var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

            }

            if ( intersectionPoint === null ) continue;

            intersectionPoint.applyMatrix4( this.matrixWorld );

            var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              point: intersectionPoint,
              face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
              faceIndex: null,
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

          a = i;
          b = i + 1;
          c = i + 2;

          vA.fromArray( positions, j );
          vB.fromArray( positions, j + 3 );
          vC.fromArray( positions, j + 6 );

          if ( material.side === THREE.BackSide ) {

            var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

          } else {

            var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

          }

          if ( intersectionPoint === null ) continue;

          intersectionPoint.applyMatrix4( this.matrixWorld );

          var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            point: intersectionPoint,
            face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
      var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

      var a, b, c;

      var vertices = geometry.vertices;

      for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

        var face = geometry.faces[ f ];

        var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

        if ( material === undefined ) continue;

        a = vertices[ face.a ];
        b = vertices[ face.b ];
        c = vertices[ face.c ];

        if ( material.morphTargets === true ) {

          var morphTargets = geometry.morphTargets;
          var morphInfluences = this.morphTargetInfluences;

          vA.set( 0, 0, 0 );
          vB.set( 0, 0, 0 );
          vC.set( 0, 0, 0 );

          for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

            var influence = morphInfluences[ t ];

            if ( influence === 0 ) continue;

            var targets = morphTargets[ t ].vertices;

            vA.x += ( targets[ face.a ].x - a.x ) * influence;
            vA.y += ( targets[ face.a ].y - a.y ) * influence;
            vA.z += ( targets[ face.a ].z - a.z ) * influence;

            vB.x += ( targets[ face.b ].x - b.x ) * influence;
            vB.y += ( targets[ face.b ].y - b.y ) * influence;
            vB.z += ( targets[ face.b ].z - b.z ) * influence;

            vC.x += ( targets[ face.c ].x - c.x ) * influence;
            vC.y += ( targets[ face.c ].y - c.y ) * influence;
            vC.z += ( targets[ face.c ].z - c.z ) * influence;

          }

          vA.add( a );
          vB.add( b );
          vC.add( c );

          a = vA;
          b = vB;
          c = vC;

        }

        if ( material.side === THREE.BackSide ) {

          var intersectionPoint = ray.intersectTriangle( c, b, a, true );

        } else {

          var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

        }

        if ( intersectionPoint === null ) continue;

        intersectionPoint.applyMatrix4( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          point: intersectionPoint,
          face: face,
          faceIndex: f,
          object: this

        } );

      }

    }

  };

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

  if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object, recursive );

  return object;

};

THREE.Mesh.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

  THREE.Object3D.call( this );

  this.type = 'Bone';

  this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

  this.identityMatrix = new THREE.Matrix4();

  // copy the bone array

  bones = bones || [];

  this.bones = bones.slice( 0 );

  // create a bone texture or an array of floats

  if ( this.useVertexTexture ) {

    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
    //       16x16 pixel texture max   64 bones (16 * 16 / 4)
    //       32x32 pixel texture max  256 bones (32 * 32 / 4)
    //       64x64 pixel texture max 1024 bones (64 * 64 / 4)

    var size;

    if ( this.bones.length > 256 )
      size = 64;
    else if ( this.bones.length > 64 )
      size = 32;
    else if ( this.bones.length > 16 )
      size = 16;
    else
      size = 8;

    this.boneTextureWidth = size;
    this.boneTextureHeight = size;

    this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
    this.boneTexture.minFilter = THREE.NearestFilter;
    this.boneTexture.magFilter = THREE.NearestFilter;
    this.boneTexture.generateMipmaps = false;
    this.boneTexture.flipY = false;

  } else {

    this.boneMatrices = new Float32Array( 16 * this.bones.length );

  }

  // use the supplied bone inverses or calculate the inverses

  if ( boneInverses === undefined ) {

    this.calculateInverses();

  } else {

    if ( this.bones.length === boneInverses.length ) {

      this.boneInverses = boneInverses.slice( 0 );

    } else {

      console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

      this.boneInverses = [];

      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        this.boneInverses.push( new THREE.Matrix4() );

      }

    }

  }

};

THREE.Skeleton.prototype.calculateInverses = function () {

  this.boneInverses = [];

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    var inverse = new THREE.Matrix4();

    if ( this.bones[ b ] ) {

      inverse.getInverse( this.bones[ b ].matrixWorld );

    }

    this.boneInverses.push( inverse );

  }

};

THREE.Skeleton.prototype.pose = function () {

  var bone;

  // recover the bind-time world matrices

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    }

  }

  // compute the local matrices, positions, rotations and scales

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      if ( bone.parent ) {

        bone.matrix.getInverse( bone.parent.matrixWorld );
        bone.matrix.multiply( bone.matrixWorld );

      } else {

        bone.matrix.copy( bone.matrixWorld );

      }

      bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    }

  }

};

THREE.Skeleton.prototype.update = ( function () {

  var offsetMatrix = new THREE.Matrix4();

  return function () {

    // flatten bone matrices to array

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

      // compute the offset between the current and the original transform

      var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

      offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
      offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

    }

    if ( this.useVertexTexture ) {

      this.boneTexture.needsUpdate = true;

    }

  };

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'SkinnedMesh';

  this.bindMode = "attached";
  this.bindMatrix = new THREE.Matrix4();
  this.bindMatrixInverse = new THREE.Matrix4();

  // init bones

  // TODO: remove bone creation as there is no reason (other than
  // convenience) for THREE.SkinnedMesh to do this.

  var bones = [];

  if ( this.geometry && this.geometry.bones !== undefined ) {

    var bone, gbone, p, q, s;

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      p = gbone.pos;
      q = gbone.rotq;
      s = gbone.scl;

      bone = new THREE.Bone( this );
      bones.push( bone );

      bone.name = gbone.name;
      bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
      bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

      if ( s !== undefined ) {

        bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

      } else {

        bone.scale.set( 1, 1, 1 );

      }

    }

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      if ( gbone.parent !== - 1 ) {

        bones[ gbone.parent ].add( bones[ b ] );

      } else {

        this.add( bones[ b ] );

      }

    }

  }

  this.normalizeSkinWeights();

  this.updateMatrixWorld( true );
  this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

  this.skeleton = skeleton;

  if ( bindMatrix === undefined ) {

    this.updateMatrixWorld( true );

    bindMatrix = this.matrixWorld;

  }

  this.bindMatrix.copy( bindMatrix );
  this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

  this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

  if ( this.geometry instanceof THREE.Geometry ) {

    for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

      var sw = this.geometry.skinWeights[ i ];

      var scale = 1.0 / sw.lengthManhattan();

      if ( scale !== Infinity ) {

        sw.multiplyScalar( scale );

      } else {

        sw.set( 1 ); // this will be normalized by the shader anyway

      }

    }

  } else {

    // skinning weights assumed to be normalized for THREE.BufferGeometry

  }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

  THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

  if ( this.bindMode === "attached" ) {

    this.bindMatrixInverse.getInverse( this.matrixWorld );

  } else if ( this.bindMode === "detached" ) {

    this.bindMatrixInverse.getInverse( this.bindMatrix );

  } else {

    console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

  }

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

  if ( object === undefined ) {

    object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

  }

  THREE.Mesh.prototype.clone.call( this, object );

  return object;

};


// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'MorphAnimMesh';

  // API

  this.duration = 1000; // milliseconds
  this.mirroredLoop = false;
  this.time = 0;

  // internals

  this.lastKeyframe = 0;
  this.currentKeyframe = 0;

  this.direction = 1;
  this.directionBackwards = false;

  this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

  this.startKeyframe = start;
  this.endKeyframe = end;

  this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

  this.direction = 1;
  this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

  this.direction = - 1;
  this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

  var geometry = this.geometry;

  if ( ! geometry.animations ) geometry.animations = {};

  var firstAnimation, animations = geometry.animations;

  var pattern = /([a-z]+)_?(\d+)/;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var parts = morph.name.match( pattern );

    if ( parts && parts.length > 1 ) {

      var label = parts[ 1 ];

      if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

      var animation = animations[ label ];

      if ( i < animation.start ) animation.start = i;
      if ( i > animation.end ) animation.end = i;

      if ( ! firstAnimation ) firstAnimation = label;

    }

  }

  geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

  if ( ! this.geometry.animations ) this.geometry.animations = {};

  this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

  var animation = this.geometry.animations[ label ];

  if ( animation ) {

    this.setFrameRange( animation.start, animation.end );
    this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
    this.time = 0;

  } else {

    console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

  }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

  var frameTime = this.duration / this.length;

  this.time += this.direction * delta;

  if ( this.mirroredLoop ) {

    if ( this.time > this.duration || this.time < 0 ) {

      this.direction *= - 1;

      if ( this.time > this.duration ) {

        this.time = this.duration;
        this.directionBackwards = true;

      }

      if ( this.time < 0 ) {

        this.time = 0;
        this.directionBackwards = false;

      }

    }

  } else {

    this.time = this.time % this.duration;

    if ( this.time < 0 ) this.time += this.duration;

  }

  var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

  if ( keyframe !== this.currentKeyframe ) {

    this.morphTargetInfluences[ this.lastKeyframe ] = 0;
    this.morphTargetInfluences[ this.currentKeyframe ] = 1;

    this.morphTargetInfluences[ keyframe ] = 0;

    this.lastKeyframe = this.currentKeyframe;
    this.currentKeyframe = keyframe;

  }

  var mix = ( this.time % frameTime ) / frameTime;

  if ( this.directionBackwards ) {

    mix = 1 - mix;

  }

  this.morphTargetInfluences[ this.currentKeyframe ] = mix;
  this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

  var influences = this.morphTargetInfluences;

  for ( var i = 0, l = influences.length; i < l; i ++ ) {

    influences[ i ] = 0;

  }

  if ( a > -1 ) influences[ a ] = 1 - t;
  if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

  object.duration = this.duration;
  object.mirroredLoop = this.mirroredLoop;
  object.time = this.time;

  object.lastKeyframe = this.lastKeyframe;
  object.currentKeyframe = this.currentKeyframe;

  object.direction = this.direction;
  object.directionBackwards = this.directionBackwards;

  THREE.Mesh.prototype.clone.call( this, object );

  return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

  THREE.Object3D.call( this );

  this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

  if ( distance === undefined ) distance = 0;

  distance = Math.abs( distance );

  for ( var l = 0; l < this.objects.length; l ++ ) {

    if ( distance < this.objects[ l ].distance ) {

      break;

    }

  }

  this.objects.splice( l, 0, { distance: distance, object: object } );
  this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

  for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

    if ( distance < this.objects[ i ].distance ) {

      break;

    }

  }

  return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  };

}() );

THREE.LOD.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( camera ) {

    if ( this.objects.length > 1 ) {

      v1.setFromMatrixPosition( camera.matrixWorld );
      v2.setFromMatrixPosition( this.matrixWorld );

      var distance = v1.distanceTo( v2 );

      this.objects[ 0 ].object.visible = true;

      for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

        if ( distance >= this.objects[ i ].distance ) {

          this.objects[ i - 1 ].object.visible = false;
          this.objects[ i     ].object.visible = true;

        } else {

          break;

        }

      }

      for ( ; i < l; i ++ ) {

        this.objects[ i ].object.visible = false;

      }

    }

  };

}();

THREE.LOD.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.LOD();

  THREE.Object3D.prototype.clone.call( this, object );

  for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
    var x = this.objects[ i ].object.clone();
    x.visible = i === 0;
    object.addLevel( x, this.objects[ i ].distance );
  }

  return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

  var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
  var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
  var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  return function ( material ) {

    THREE.Object3D.call( this );

    this.type = 'Sprite';

    this.geometry = geometry;
    this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

  };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.distanceToPoint( matrixPosition );

    if ( distance > this.scale.x ) {

      return;

    }

    intersects.push( {

      distance: distance,
      point: this.position,
      face: null,
      object: this

    } );

  };

}() );

THREE.Sprite.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Sprite( this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

THREE.Sprite.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON();
  }

  data.object.material = this.material.uuid;

  return data;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

  THREE.Object3D.call( this );

  this.lensFlares = [];

  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;

  if ( texture !== undefined ) {

    this.add( texture, size, distance, blending, color );

  }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

  if ( size === undefined ) size = - 1;
  if ( distance === undefined ) distance = 0;
  if ( opacity === undefined ) opacity = 1;
  if ( color === undefined ) color = new THREE.Color( 0xffffff );
  if ( blending === undefined ) blending = THREE.NormalBlending;

  distance = Math.min( distance, Math.max( 0, distance ) );

  this.lensFlares.push( {
    texture: texture,       // THREE.Texture
    size: size,         // size in pixels (-1 = use texture.width)
    distance: distance,     // distance (0-1) from light source (0=at light source)
    x: 0, y: 0, z: 0,     // screen position (-1 => 1) z = 0 is ontop z = 1 is back
    scale: 1,           // scale
    rotation: 1,        // rotation
    opacity: opacity,     // opacity
    color: color,       // color
    blending: blending      // blending
  } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = - this.positionScreen.x * 2;
  var vecY = - this.positionScreen.y * 2;

  for ( f = 0; f < fl; f ++ ) {

    flare = this.lensFlares[ f ];

    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;

    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  }

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

  THREE.Object3D.call( this );

  this.type = 'Scene';

  this.fog = null;
  this.overrideMaterial = null;

  this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Scene();

  THREE.Object3D.prototype.clone.call( this, object );

  if ( this.fog !== null ) object.fog = this.fog.clone();
  if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

  object.autoUpdate = this.autoUpdate;
  object.matrixAutoUpdate = this.matrixAutoUpdate;

  return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

  this.name = '';

  this.color = new THREE.Color( color );

  this.near = ( near !== undefined ) ? near : 1;
  this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

  return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

  this.name = '';

  this.color = new THREE.Color( color );
  this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

  return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n  diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n  if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n  totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n  uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n  uniform float bumpScale;\n\n  // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n    vec2 dSTdx = dFdx( vUv );\n   vec2 dSTdy = dFdy( vUv );\n\n   float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n    float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n    float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n    return vec2( dBx, dBy );\n\n  }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n    vec3 vSigmaX = dFdx( surf_pos );\n    vec3 vSigmaY = dFdy( surf_pos );\n    vec3 vN = surf_norm;    // normalized\n\n   vec3 R1 = cross( vSigmaY, vN );\n   vec3 R2 = cross( vN, vSigmaX );\n\n   float fDet = dot( vSigmaX, R1 );\n\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n  }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n  diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n  vColor.xyz = inputToLinear( color.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n  float distance = dot( planeNormal, point - pointOnPlane );\n\n  return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n  return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n if ( decayExponent > 0.0 ) {\n\n    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n }\n\n return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n return ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 ) + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n // geometry term is (nl)(nv) / 4(nl)(nv)\n\n  return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n // factor of 1/PI in distribution term omitted\n\n  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n  vec3 halfDir = normalize( lightDir + viewDir );\n\n //float dotNL = saturate( dot( normal, lightDir ) );\n  //float dotNV = saturate( dot( normal, viewDir ) );\n float dotNH = saturate( dot( normal, halfDir ) );\n float dotLH = saturate( dot( lightDir, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n  float D = D_BlinnPhong( shininess, dotNH );\n\n return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n #ifdef GAMMA_INPUT\n\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n #else\n\n   return a;\n\n #endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n #ifdef GAMMA_OUTPUT\n\n   return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n #else\n\n   return a;\n\n #endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "#ifdef USE_SKINNING\n\n vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n vec3 objectNormal = morphedNormal;\n\n#else\n\n vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n  objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n   // Transforming Normal Vectors with the Inverse Transformation\n    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n   #ifdef ENVMAP_MODE_REFLECTION\n\n     vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n   #else\n\n     vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n  #else\n\n   vec3 reflectVec = vReflect;\n\n #endif\n\n  #ifdef DOUBLE_SIDED\n   float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n #else\n   float flipNormal = 1.0;\n #endif\n\n  #ifdef ENVMAP_TYPE_CUBE\n   vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n    vec2 sampleUV;\n    sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n   sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n   vec4 envColor = texture2D( envMap, sampleUV );\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n   vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n    vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n  #endif\n\n  envColor.xyz = inputToLinear( envColor.xyz );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n   outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n  #elif defined( ENVMAP_BLENDING_MIX )\n\n    outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n  #elif defined( ENVMAP_BLENDING_ADD )\n\n    outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n uniform float reflectivity;\n #ifdef ENVMAP_TYPE_CUBE\n   uniform samplerCube envMap;\n #else\n   uniform sampler2D envMap;\n #endif\n  uniform float flipEnvMap;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    uniform float refractionRatio;\n\n  #else\n\n   varying vec3 vReflect;\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n varying vec3 vReflect;\n\n  uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n  vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n #else\n\n   float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  #endif\n\n  #ifdef FOG_EXP2\n\n   float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n  #else\n\n   float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n #endif\n  \n  outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n\n  #ifdef FOG_EXP2\n\n   uniform float fogDensity;\n\n #else\n\n   uniform float fogNear;\n    uniform float fogFar;\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n  totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n  vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec3 lightColor = pointLightColor[ i ];\n\n   vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n    vec3 lightDir = normalize( lVector );\n\n   // attenuation\n\n    float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n    #endif\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec3 lightColor = spotLightColor[ i ];\n\n    vec3 lightPosition = spotLightPosition[ i ];\n    vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n    vec3 lightDir = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( lightPosition - worldPosition.xyz ) );\n\n    if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n     // attenuation\n\n      float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     attenuation *= spotEffect;\n\n      // diffuse\n\n      float dotProduct = dot( normal, lightDir );\n\n     vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n     #ifdef DOUBLE_SIDED\n\n       vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n      #endif\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n   vec3 lightColor = directionalLightColor[ i ];\n\n   vec3 lightDir = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   vLightFront += lightColor * saturate( dotProduct );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += lightColor * saturate( - dotProduct );\n\n    #endif\n\n  }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n    vec3 lightDir = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n    // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n   #ifdef DOUBLE_SIDED\n\n     float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n     vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n    #endif\n\n  }\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n vLightBack += ambientLightColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n  vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n   normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n #endif\n\n#else\n\n vec3 fdx = dFdx( vViewPosition );\n vec3 fdy = dFdy( vViewPosition );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec3 lightColor = pointLightColor[ i ];\n\n   vec3 lightPosition = pointLightPosition[ i ];\n   vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n   vec3 lightDir = normalize( lVector );\n\n   // attenuation\n\n    float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n   // diffuse\n\n    float cosineTerm = saturate( dot( normal, lightDir ) );\n\n   totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n   // specular\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec3 lightColor = spotLightColor[ i ];\n\n    vec3 lightPosition = spotLightPosition[ i ];\n    vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n   vec3 lightDir = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( lightPosition - vWorldPosition ) );\n\n   if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n     // attenuation\n\n      float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     attenuation *= spotEffect;\n\n      // diffuse\n\n      float cosineTerm = saturate( dot( normal, lightDir ) );\n\n     totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n     // specular\n\n     vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n      totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n    vec3 lightColor = directionalLightColor[ i ];\n\n   vec3 lightDir = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n   // diffuse\n\n    float cosineTerm = saturate( dot( normal, lightDir ) );\n\n   totalDiffuseLight += lightColor * cosineTerm;\n\n   // specular\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n  }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n   vec3 lightDir = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n    // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n    totalDiffuseLight += lightColor;\n\n    // specular (sky term only)\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n  }\n\n#endif\n\n#ifdef METAL\n\n outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + emissive;\n\n#else\n\n  outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + emissive;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n  varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n  outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n  gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n uniform float logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    #extension GL_EXT_frag_depth : enable\n   varying float vFragDepth;\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n    varying float vFragDepth;\n\n #endif\n\n  uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n  gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n    gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n  #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n  vec4 texelColor = texture2D( map, vUv );\n\n  texelColor.xyz = inputToLinear( texelColor.xyz );\n\n diffuseColor *= texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n  uniform vec4 offsetRepeat;\n  uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n vec3 morphedNormal = vec3( 0.0 );\n\n morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n  morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n  morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n  morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n  morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n  #ifndef USE_MORPHNORMALS\n\n  uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n vec3 morphed = vec3( 0.0 );\n morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n  #ifndef USE_MORPHNORMALS\n\n  morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n  #endif\n\n  morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n // Per-Pixel Tangent Space Normal Mapping\n // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n    vec3 q0 = dFdx( eye_pos.xyz );\n    vec3 q1 = dFdy( eye_pos.xyz );\n    vec2 st0 = dFdx( vUv.st );\n    vec2 st1 = dFdy( vUv.st );\n\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n   vec3 N = normalize( surf_norm );\n\n    vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n    mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n   return normalize( tsn * mapN );\n\n }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n  #ifdef SHADOWMAP_DEBUG\n\n    vec3 frustumColors[3];\n    frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n   frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n   frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n #endif\n\n  #ifdef SHADOWMAP_CASCADE\n\n    int inFrustumCount = 0;\n\n #endif\n\n  float fDepth;\n vec3 shadowColor = vec3( 1.0 );\n\n for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n       // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n\n       // don't shadow pixels outside of light frustum\n       // use just first frustum (for cascades)\n        // don't shadow pixels behind far plane of light frustum\n\n    #ifdef SHADOWMAP_CASCADE\n\n      inFrustumCount += int( inFrustum );\n     bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n   #else\n\n     bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n    #endif\n\n    bool frustumTest = all( frustumTestVec );\n\n   if ( frustumTest ) {\n\n      shadowCoord.z += shadowBias[ i ];\n\n     #if defined( SHADOWMAP_TYPE_PCF )\n\n           // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n   /*\n            // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n            // must enroll loop manually\n\n        for ( float y = -1.25; y <= 1.25; y += 1.25 )\n         for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n           vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n               //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n           float fDepth = unpackDepth( rgbaDepth );\n\n            if ( fDepth < shadowCoord.z )\n             shadow += 1.0;\n\n        }\n\n       shadow /= 9.0;\n\n    */\n\n        const float shadowDelta = 1.0 / 9.0;\n\n        float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.25 * xPixelOffset;\n       float dy0 = -1.25 * yPixelOffset;\n       float dx1 = 1.25 * xPixelOffset;\n        float dy1 = 1.25 * yPixelOffset;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n        if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n       float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.0 * xPixelOffset;\n        float dy0 = -1.0 * yPixelOffset;\n        float dx1 = 1.0 * xPixelOffset;\n       float dy1 = 1.0 * yPixelOffset;\n\n       mat3 shadowKernel;\n        mat3 depthKernel;\n\n       depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n        depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n        depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n        depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n        depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n       depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n        depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n        depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n        depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n        vec3 shadowZ = vec3( shadowCoord.z );\n       shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n       shadowKernel[0] *= vec3(0.25);\n\n        shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n       shadowKernel[1] *= vec3(0.25);\n\n        shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n       shadowKernel[2] *= vec3(0.25);\n\n        vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n       shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n       shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n       vec4 shadowValues;\n        shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n        shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n        shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n        shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n        shadow = dot( shadowValues, vec4( 1.0 ) );\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #else\n\n       vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n       float fDepth = unpackDepth( rgbaDepth );\n\n        if ( fDepth < shadowCoord.z )\n\n   // spot with multiple shadows is darker\n\n         shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n    // spot with multiple shadows has the same color as single shadow spot\n\n    //          shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n      #endif\n\n    }\n\n\n   #ifdef SHADOWMAP_DEBUG\n\n      #ifdef SHADOWMAP_CASCADE\n\n        if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n      #else\n\n       if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n     #endif\n\n    #endif\n\n  }\n\n // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n shadowColor = inputToLinear( shadowColor );\n\n outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n uniform sampler2D shadowMap[ MAX_SHADOWS ];\n uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n  uniform float shadowDarkness[ MAX_SHADOWS ];\n  uniform float shadowBias[ MAX_SHADOWS ];\n\n  varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n float unpackDepth( const in vec4 rgba_depth ) {\n\n   const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n    float depth = dot( rgba_depth, bit_shift );\n   return depth;\n\n }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n varying vec4 vShadowCoord[ MAX_SHADOWS ];\n uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n  for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n uniform mat4 bindMatrix;\n  uniform mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n   uniform sampler2D boneTexture;\n    uniform int boneTextureWidth;\n   uniform int boneTextureHeight;\n\n    mat4 getBoneMatrix( const in float i ) {\n\n      float j = i * 4.0;\n      float x = mod( j, float( boneTextureWidth ) );\n      float y = floor( j / float( boneTextureWidth ) );\n\n     float dx = 1.0 / float( boneTextureWidth );\n     float dy = 1.0 / float( boneTextureHeight );\n\n      y = dy * ( y + 0.5 );\n\n     vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n      vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n      vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n      vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n      mat4 bone = mat4( v1, v2, v3, v4 );\n\n     return bone;\n\n    }\n\n #else\n\n   uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n   mat4 getBoneMatrix( const in float i ) {\n\n      mat4 bone = boneGlobalMatrices[ int(i) ];\n     return bone;\n\n    }\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n  #ifdef USE_MORPHTARGETS\n\n vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n #endif\n\n  vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n  skinned += boneMatY * skinVertex * skinWeight.y;\n  skinned += boneMatZ * skinVertex * skinWeight.z;\n  skinned += boneMatW * skinVertex * skinWeight.w;\n  skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 skinMatrix = mat4( 0.0 );\n  skinMatrix += skinWeight.x * boneMatX;\n  skinMatrix += skinWeight.y * boneMatY;\n  skinMatrix += skinWeight.z * boneMatZ;\n  skinMatrix += skinWeight.w * boneMatW;\n  skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n  #ifdef USE_MORPHNORMALS\n\n vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n #else\n\n vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n  specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n  varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n  attribute vec2 uv2;\n varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n varying vec2 vUv;\n uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n  vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n #ifdef USE_SKINNING\n\n   vec4 worldPosition = modelMatrix * skinned;\n\n #elif defined( USE_MORPHTARGETS )\n\n   vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n   vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

  merge: function ( uniforms ) {

    var merged = {};

    for ( var u = 0; u < uniforms.length; u ++ ) {

      var tmp = this.clone( uniforms[ u ] );

      for ( var p in tmp ) {

        merged[ p ] = tmp[ p ];

      }

    }

    return merged;

  },

  clone: function ( uniforms_src ) {

    var uniforms_dst = {};

    for ( var u in uniforms_src ) {

      uniforms_dst[ u ] = {};

      for ( var p in uniforms_src[ u ] ) {

        var parameter_src = uniforms_src[ u ][ p ];

        if ( parameter_src instanceof THREE.Color ||
           parameter_src instanceof THREE.Vector2 ||
           parameter_src instanceof THREE.Vector3 ||
           parameter_src instanceof THREE.Vector4 ||
           parameter_src instanceof THREE.Matrix3 ||
           parameter_src instanceof THREE.Matrix4 ||
           parameter_src instanceof THREE.Texture ) {

          uniforms_dst[ u ][ p ] = parameter_src.clone();

        } else if ( Array.isArray( parameter_src ) ) {

          uniforms_dst[ u ][ p ] = parameter_src.slice();

        } else {

          uniforms_dst[ u ][ p ] = parameter_src;

        }

      }

    }

    return uniforms_dst;

  }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

  common: {

    "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },

    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "specularMap" : { type: "t", value: null },
    "alphaMap" : { type: "t", value: null },

    "envMap" : { type: "t", value: null },
    "flipEnvMap" : { type: "f", value: - 1 },
    "reflectivity" : { type: "f", value: 1.0 },
    "refractionRatio" : { type: "f", value: 0.98 }

  },

  aomap: {

    "aoMap" : { type: "t", value: null },
    "aoMapIntensity" : { type: "f", value: 1 },

  },

  lightmap: {

    "lightMap" : { type: "t", value: null },
    "lightMapIntensity" : { type: "f", value: 1 },

  },

  bump: {

    "bumpMap" : { type: "t", value: null },
    "bumpScale" : { type: "f", value: 1 }

  },

  normalmap: {

    "normalMap" : { type: "t", value: null },
    "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
  },

  fog : {

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  lights: {

    "ambientLightColor" : { type: "fv", value: [] },

    "directionalLightDirection" : { type: "fv", value: [] },
    "directionalLightColor" : { type: "fv", value: [] },

    "hemisphereLightDirection" : { type: "fv", value: [] },
    "hemisphereLightSkyColor" : { type: "fv", value: [] },
    "hemisphereLightGroundColor" : { type: "fv", value: [] },

    "pointLightColor" : { type: "fv", value: [] },
    "pointLightPosition" : { type: "fv", value: [] },
    "pointLightDistance" : { type: "fv1", value: [] },
    "pointLightDecay" : { type: "fv1", value: [] },

    "spotLightColor" : { type: "fv", value: [] },
    "spotLightPosition" : { type: "fv", value: [] },
    "spotLightDirection" : { type: "fv", value: [] },
    "spotLightDistance" : { type: "fv1", value: [] },
    "spotLightAngleCos" : { type: "fv1", value: [] },
    "spotLightExponent" : { type: "fv1", value: [] },
    "spotLightDecay" : { type: "fv1", value: [] }

  },

  particle: {

    "psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },
    "size" : { type: "f", value: 1.0 },
    "scale" : { type: "f", value: 1.0 },
    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  shadowmap: {

    "shadowMap": { type: "tv", value: [] },
    "shadowMapSize": { type: "v2v", value: [] },

    "shadowBias" : { type: "fv1", value: [] },
    "shadowDarkness": { type: "fv1", value: [] },

    "shadowMatrix" : { type: "m4v", value: [] }

  }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

  'basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],

      " #ifdef USE_ENVMAP",

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      " #endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "aomap_fragment" ],

      " outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],    // TODO: Shadows on an otherwise unlit surface doesn't make sense.

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'lambert': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
      }

    ] ),

    vertexShader: [

      "#define LAMBERT",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_lambert_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform float opacity;",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],

      " #ifdef DOUBLE_SIDED",

          //"float isFront = float( gl_FrontFacing );",
          //"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

      "   if ( gl_FrontFacing )",
      "     outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
      "   else",
      "     outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

      " #else",

      "   outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

      " #endif",

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'phong': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "lightmap" ],
      THREE.UniformsLib[ "bump" ],
      THREE.UniformsLib[ "normalmap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
        "shininess": { type: "f", value: 30 }
      }

    ] ),

    vertexShader: [

      "#define PHONG",

      "varying vec3 vViewPosition;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

      " vNormal = normalize( transformedNormal );",

      "#endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      " vViewPosition = -mvPosition.xyz;",

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_phong_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "#define PHONG",

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform vec3 specular;",
      "uniform float shininess;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
      THREE.ShaderChunk[ "normalmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = ambientLightColor;",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "lightmap_fragment" ],
        THREE.ShaderChunk[ "aomap_fragment" ],

        THREE.ShaderChunk[ "lights_phong_fragment" ],

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'particle_basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "particle" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      "uniform float size;",
      "uniform float scale;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

      " #ifdef USE_SIZEATTENUATION",
      "   gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
      " #else",
      "   gl_PointSize = size;",
      " #endif",

      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],
        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 psColor;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_particle_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( psColor, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_particle_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "shadowmap_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'dashed': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],

      {
        "scale"    : { type: "f", value: 1 },
        "dashSize" : { type: "f", value: 1 },
        "totalSize": { type: "f", value: 2 }
      }

    ] ),

    vertexShader: [

      "uniform float scale;",
      "attribute float lineDistance;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vLineDistance = scale * lineDistance;",

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "uniform float dashSize;",
      "uniform float totalSize;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " if ( mod( vLineDistance, totalSize ) > dashSize ) {",

      "   discard;",

      " }",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'depth': {

    uniforms: {

      "mNear": { type: "f", value: 1.0 },
      "mFar" : { type: "f", value: 2000.0 },
      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float mNear;",
      "uniform float mFar;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   float depth = gl_FragDepthEXT / gl_FragCoord.w;",

      " #else",

      "   float depth = gl_FragCoord.z / gl_FragCoord.w;",

      " #endif",

      " float color = 1.0 - smoothstep( mNear, mFar, depth );",
      " gl_FragColor = vec4( vec3( color ), opacity );",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'normal': {

    uniforms: {

      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vNormal = normalize( normalMatrix * normal );",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float opacity;",
      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'cube': {

    uniforms: { "tCube": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform samplerCube tCube;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'equirect': {

    uniforms: { "tEquirect": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform sampler2D tEquirect;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        // "  gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
        "vec3 direction = normalize( vWorldPosition );",
        "vec2 sampleUV;",
        "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
        "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
        "gl_FragColor = texture2D( tEquirect, sampleUV );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* Depth encoding into RGBA texture
   *
   * based on SpiderGL shadow map example
   * http://spidergl.org/example.php?id=6
   *
   * originally from
   * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
   *
   * see also
   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
   */

  'depthRGBA': {

    uniforms: {},

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "vec4 pack_depth( const in float depth ) {",

      " const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
      " const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
      " vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "  vec4 res = fract( depth * bit_shift );",
      " res -= res.xxyz * bit_mask;",
      " return res;",

      "}",

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

      " #else",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

      " #endif",

        //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
        //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
        //"gl_FragData[ 0 ] = pack_depth( z );",
        //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

      "}"

    ].join("\n")

  }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

  console.log( 'THREE.WebGLRenderer', THREE.REVISION );

  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
  _context = parameters.context !== undefined ? parameters.context : null,

  _width = _canvas.width,
  _height = _canvas.height,

  pixelRatio = 1,

  _precision = parameters.precision !== undefined ? parameters.precision : 'highp',

  _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  _depth = parameters.depth !== undefined ? parameters.depth : true,
  _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

  _clearColor = new THREE.Color( 0x000000 ),
  _clearAlpha = 0;

  var lights = [];

  var opaqueObjects = [];
  var transparentObjects = [];

  var sprites = [];
  var lensFlares = [];

  // public properties

  this.domElement = _canvas;
  this.context = null;

  // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;

  // scene graph

  this.sortObjects = true;

  // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility
  this.gammaInput = false;
  this.gammaOutput = false;

  // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;

  // flags

  this.autoScaleCubemaps = true;

  // info

  this.info = {

    memory: {

      programs: 0,
      geometries: 0,
      textures: 0

    },

    render: {

      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0

    }

  };

  // internal properties

  var _this = this,

  _programs = [],

  // internal state cache

  _currentProgram = null,
  _currentFramebuffer = null,
  _currentMaterialId = - 1,
  _currentGeometryProgram = '',
  _currentCamera = null,

  _usedTextureUnits = 0,

  _viewportX = 0,
  _viewportY = 0,
  _viewportWidth = _canvas.width,
  _viewportHeight = _canvas.height,
  _currentWidth = 0,
  _currentHeight = 0,

  // frustum

  _frustum = new THREE.Frustum(),

   // camera matrices cache

  _projScreenMatrix = new THREE.Matrix4(),

  _vector3 = new THREE.Vector3(),

  // light arrays cache

  _direction = new THREE.Vector3(),

  _lightsNeedUpdate = true,

  _lights = {

    ambient: [ 0, 0, 0 ],
    directional: { length: 0, colors:[], positions: [] },
    point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
    spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
    hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

  };

  // initialize

  var _gl;

  try {

    var attributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };

    _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    if ( _gl === null ) {

      if ( _canvas.getContext( 'webgl') !== null ) {

        throw 'Error creating WebGL context with your selected attributes.';

      } else {

        throw 'Error creating WebGL context.';

      }

    }

    _canvas.addEventListener( 'webglcontextlost', function ( event ) {

      event.preventDefault();

      resetGLState();
      setDefaultGLState();

      objects.objects = {};

    }, false);

  } catch ( error ) {

    console.error( 'THREE.WebGLRenderer: ' + error );

  }

  var state = new THREE.WebGLState( _gl, paramThreeToGL );

  if ( _gl.getShaderPrecisionFormat === undefined ) {

    _gl.getShaderPrecisionFormat = function () {

      return {
        'rangeMin': 1,
        'rangeMax': 1,
        'precision': 1
      };

    }

  }

  var extensions = new THREE.WebGLExtensions( _gl );
  var objects = new THREE.WebGLObjects( _gl, this.info );

  extensions.get( 'OES_texture_float' );
  extensions.get( 'OES_texture_float_linear' );
  extensions.get( 'OES_texture_half_float' );
  extensions.get( 'OES_texture_half_float_linear' );
  extensions.get( 'OES_standard_derivatives' );
  extensions.get( 'ANGLE_instanced_arrays' );

  if ( extensions.get( 'OES_element_index_uint' ) ) {

    THREE.BufferGeometry.MaxIndex = 4294967296;

  }

  if ( _logarithmicDepthBuffer ) {

    extensions.get( 'EXT_frag_depth' );

  }

  //

  var glClearColor = function ( r, g, b, a ) {

    if ( _premultipliedAlpha === true ) {

      r *= a; g *= a; b *= a;

    }

    _gl.clearColor( r, g, b, a );

  };

  var setDefaultGLState = function () {

    _gl.clearColor( 0, 0, 0, 1 );
    _gl.clearDepth( 1 );
    _gl.clearStencil( 0 );

    _gl.enable( _gl.DEPTH_TEST );
    _gl.depthFunc( _gl.LEQUAL );

    _gl.frontFace( _gl.CCW );
    _gl.cullFace( _gl.BACK );
    _gl.enable( _gl.CULL_FACE );

    _gl.enable( _gl.BLEND );
    _gl.blendEquation( _gl.FUNC_ADD );
    _gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  var resetGLState = function () {

    _currentProgram = null;
    _currentCamera = null;

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;

    _lightsNeedUpdate = true;

    state.reset();

  };

  setDefaultGLState();

  this.context = _gl;
  this.extensions = extensions;
  this.state = state;

  // shadow map

  var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

  this.shadowMap = shadowMap;

  // GPU capabilities

  var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
  var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
  var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );
  var _supportsInstancedArrays = extensions.get( 'ANGLE_instanced_arrays' );

  //

  var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
  var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );

  var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
  var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );

  var getCompressedTextureFormats = ( function () {

    var array;

    return function () {

      if ( array !== undefined ) {

        return array;

      }

      array = [];

      if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

        var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

        for ( var i = 0; i < formats.length; i ++ ) {

          array.push( formats[ i ] );

        }

      }

      return array;

    };

  } )();

  // clamp precision to maximum available

  var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
  var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

  if ( _precision === 'highp' && ! highpAvailable ) {

    if ( mediumpAvailable ) {

      _precision = 'mediump';
      console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

    } else {

      _precision = 'lowp';
      console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

    }

  }

  if ( _precision === 'mediump' && ! mediumpAvailable ) {

    _precision = 'lowp';
    console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

  }

  // Plugins

  var spritePlugin = new THREE.SpritePlugin( this, sprites );
  var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

  // API

  this.getContext = function () {

    return _gl;

  };

  this.forceContextLoss = function () {

    extensions.get( 'WEBGL_lose_context' ).loseContext();

  };

  this.supportsVertexTextures = function () {

    return _supportsVertexTextures;

  };

  this.supportsInstancedArrays = function () {

    return _supportsInstancedArrays;

  };

  this.supportsFloatTextures = function () {

    return extensions.get( 'OES_texture_float' );

  };

  this.supportsHalfFloatTextures = function () {

    return extensions.get( 'OES_texture_half_float' );

  };

  this.supportsStandardDerivatives = function () {

    return extensions.get( 'OES_standard_derivatives' );

  };

  this.supportsCompressedTextureS3TC = function () {

    return extensions.get( 'WEBGL_compressed_texture_s3tc' );

  };

  this.supportsCompressedTexturePVRTC = function () {

    return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  };

  this.supportsBlendMinMax = function () {

    return extensions.get( 'EXT_blend_minmax' );

  };

  this.getMaxAnisotropy = ( function () {

    var value;

    return function () {

      if ( value !== undefined ) return value;

      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      if ( extension !== null ) {

        value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

      } else {

        value = 0;

      }

      return value;

    }

  } )();

  this.getPrecision = function () {

    return _precision;

  };

  this.getPixelRatio = function () {

    return pixelRatio;

  };

  this.setPixelRatio = function ( value ) {

    if ( value !== undefined ) pixelRatio = value;

  };

  this.getSize = function () {

    return {
      width: _width,
      height: _height
    };

  };

  this.setSize = function ( width, height, updateStyle ) {

    _width = width;
    _height = height;

    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;

    if ( updateStyle !== false ) {

      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';

    }

    this.setViewport( 0, 0, width, height );

  };

  this.setViewport = function ( x, y, width, height ) {

    _viewportX = x * pixelRatio;
    _viewportY = y * pixelRatio;

    _viewportWidth = width * pixelRatio;
    _viewportHeight = height * pixelRatio;

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

  };

  this.setScissor = function ( x, y, width, height ) {

    _gl.scissor(
      x * pixelRatio,
      y * pixelRatio,
      width * pixelRatio,
      height * pixelRatio
    );

  };

  this.enableScissorTest = function ( enable ) {

    enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

  };

  // Clearing

  this.getClearColor = function () {

    return _clearColor;

  };

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );

    _clearAlpha = alpha !== undefined ? alpha : 1;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.getClearAlpha = function () {

    return _clearAlpha;

  };

  this.setClearAlpha = function ( alpha ) {

    _clearAlpha = alpha;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.clear = function ( color, depth, stencil ) {

    var bits = 0;

    if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    _gl.clear( bits );

  };

  this.clearColor = function () {

    _gl.clear( _gl.COLOR_BUFFER_BIT );

  };

  this.clearDepth = function () {

    _gl.clear( _gl.DEPTH_BUFFER_BIT );

  };

  this.clearStencil = function () {

    _gl.clear( _gl.STENCIL_BUFFER_BIT );

  };

  this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    this.setRenderTarget( renderTarget );
    this.clear( color, depth, stencil );

  };

  // Reset

  this.resetGLState = resetGLState;

  // Events

  var onTextureDispose = function ( event ) {

    var texture = event.target;

    texture.removeEventListener( 'dispose', onTextureDispose );

    deallocateTexture( texture );

    _this.info.memory.textures --;


  };

  var onRenderTargetDispose = function ( event ) {

    var renderTarget = event.target;

    renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    deallocateRenderTarget( renderTarget );

    _this.info.memory.textures --;

  };

  var onMaterialDispose = function ( event ) {

    var material = event.target;

    material.removeEventListener( 'dispose', onMaterialDispose );

    deallocateMaterial( material );

  };

  // Buffer deallocation

  var deallocateTexture = function ( texture ) {

    if ( texture.image && texture.image.__webglTextureCube ) {

      // cube texture

      _gl.deleteTexture( texture.image.__webglTextureCube );

      delete texture.image.__webglTextureCube;

    } else {

      // 2D texture

      if ( texture.__webglInit === undefined ) return;

      _gl.deleteTexture( texture.__webglTexture );

      delete texture.__webglTexture;
      delete texture.__webglInit;

    }

  };

  var deallocateRenderTarget = function ( renderTarget ) {

    if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

    _gl.deleteTexture( renderTarget.__webglTexture );

    delete renderTarget.__webglTexture;

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      for ( var i = 0; i < 6; i ++ ) {

        _gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
        _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

      }

    } else {

      _gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
      _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

    }

    delete renderTarget.__webglFramebuffer;
    delete renderTarget.__webglRenderbuffer;

  };

  var deallocateMaterial = function ( material ) {

    var program = material.program.program;

    if ( program === undefined ) return;

    material.program = undefined;

    // only deallocate GL program if this was the last use of shared program
    // assumed there is only single copy of any program in the _programs list
    // (that's how it's constructed)

    var i, il, programInfo;
    var deleteProgram = false;

    for ( i = 0, il = _programs.length; i < il; i ++ ) {

      programInfo = _programs[ i ];

      if ( programInfo.program === program ) {

        programInfo.usedTimes --;

        if ( programInfo.usedTimes === 0 ) {

          deleteProgram = true;

        }

        break;

      }

    }

    if ( deleteProgram === true ) {

      // avoid using array.splice, this is costlier than creating new array from scratch

      var newPrograms = [];

      for ( i = 0, il = _programs.length; i < il; i ++ ) {

        programInfo = _programs[ i ];

        if ( programInfo.program !== program ) {

          newPrograms.push( programInfo );

        }

      }

      _programs = newPrograms;

      _gl.deleteProgram( program );

      _this.info.memory.programs --;

    }

  };

  // Buffer rendering

  this.renderBufferImmediate = function ( object, program, material ) {

    state.initAttributes();

    if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
    if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
    if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
    if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

    var attributes = program.getAttributes();

    if ( object.hasPositions ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.position );
      _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasNormals ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

      if ( material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading ) {

        var nx, ny, nz,
          nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
          normalArray,
          i, il = object.count * 3;

        for ( i = 0; i < il; i += 9 ) {

          normalArray = object.normalArray;

          nax = normalArray[ i ];
          nay = normalArray[ i + 1 ];
          naz = normalArray[ i + 2 ];

          nbx = normalArray[ i + 3 ];
          nby = normalArray[ i + 4 ];
          nbz = normalArray[ i + 5 ];

          ncx = normalArray[ i + 6 ];
          ncy = normalArray[ i + 7 ];
          ncz = normalArray[ i + 8 ];

          nx = ( nax + nbx + ncx ) / 3;
          ny = ( nay + nby + ncy ) / 3;
          nz = ( naz + nbz + ncz ) / 3;

          normalArray[ i     ] = nx;
          normalArray[ i + 1 ] = ny;
          normalArray[ i + 2 ] = nz;

          normalArray[ i + 3 ] = nx;
          normalArray[ i + 4 ] = ny;
          normalArray[ i + 5 ] = nz;

          normalArray[ i + 6 ] = nx;
          normalArray[ i + 7 ] = ny;
          normalArray[ i + 8 ] = nz;

        }

      }

      _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.normal );

      _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasUvs && material.map ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.uv );

      _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.color );

      _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    }

    state.disableUnusedAttributes();

    _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    object.count = 0;

  };

  function setupVertexAttributes( material, program, geometry, startIndex ) {

    var extension;

    if ( geometry instanceof THREE.InstancedBufferGeometry ) {

      extension = extensions.get( 'ANGLE_instanced_arrays' );

      if ( extension === null ) {

        console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
        return;

      }

    }

    var geometryAttributes = geometry.attributes;

    var programAttributes = program.getAttributes();

    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for ( var name in programAttributes ) {

      var programAttribute = programAttributes[ name ];

      if ( programAttribute >= 0 ) {

        var geometryAttribute = geometryAttributes[ name ];

        if ( geometryAttribute !== undefined ) {

          var size = geometryAttribute.itemSize;
          state.enableAttribute( programAttribute );

          if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.data.buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

            if ( data instanceof THREE.InstancedInterleavedBuffer ) {

              if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

              }

              extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = data.meshPerAttribute * ( data.array.length / data.stride );

              }

            }

          } else {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

            if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

              if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

              }

              extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * ( geometryAttribute.array.length / geometryAttribute.itemSize );

              }

            }

          }

        } else if ( materialDefaultAttributeValues !== undefined ) {

          var value = materialDefaultAttributeValues[ name ];
          if ( value !== undefined ) {

            switch ( value.length ) {

              case 2:
                _gl.vertexAttrib2fv( programAttribute, value );
                break;

              case 3:
                _gl.vertexAttrib3fv( programAttribute, value );
                break;

              case 4:
                _gl.vertexAttrib4fv( programAttribute, value );
                break;

              default:
                _gl.vertexAttrib1fv( programAttribute, value );

            }

          }

        }

      }

    }

    state.disableUnusedAttributes();

  }

  this.renderBufferDirect = function ( camera, lights, fog, material, object ) {

    if ( material.visible === false ) return;

    var geometry = objects.geometries.get( object );
    var program = setProgram( camera, lights, fog, material, object );

    var updateBuffers = false,
      wireframeBit = material.wireframe ? 1 : 0,
      geometryProgram = geometry.id + '_' + program.id + '_' + wireframeBit;

    if ( geometryProgram !== _currentGeometryProgram ) {

      _currentGeometryProgram = geometryProgram;
      updateBuffers = true;

    }

    if ( updateBuffers ) {

      state.initAttributes();

    }

    if ( object instanceof THREE.Mesh ) {

      renderMesh( material, geometry, object, program, updateBuffers );

    } else if ( object instanceof THREE.Line ) {

      renderLine( material, geometry, object, program, updateBuffers );

    } else if ( object instanceof THREE.PointCloud ) {

      renderPointCloud( material, geometry, object, program, updateBuffers );

    }

  };

  function renderMesh( material, geometry, object, program, updateBuffers ) {

    var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

    var index = geometry.attributes.index;

    if ( index ) {

      // indexed triangles

      var type, size;

      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

        type = _gl.UNSIGNED_INT;
        size = 4;

      } else {

        type = _gl.UNSIGNED_SHORT;
        size = 2;

      }

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );
          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

        }

        if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

          var extension = extensions.get( 'ANGLE_instanced_arrays' );

          if ( extension === null ) {

            console.error( 'THREE.WebGLRenderer.renderMesh: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

          }

          extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount ); // Draw the instanced meshes

        } else {

          _gl.drawElements( mode, index.array.length, type, 0 );

        }
        _this.info.render.calls ++;
        _this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
        _this.info.render.faces += index.array.length / 3;

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        updateBuffers = true;

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          var startIndex = offsets[ i ].index;

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, startIndex );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          // render indexed triangles

          if ( geometry instanceof THREE.InstancedBufferGeometry && offsets[i].instances > 0 ) {

            var extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

              console.error( 'THREE.WebGLRenderer.renderMesh: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
              return;

            }

            extension.drawElementsInstancedANGLE( mode, offsets[i].count, type, offsets[i].start * size, offsets[i].count, type, offsets[i].instances ); // Draw the instanced meshes

          } else {

            _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

          }

          _this.info.render.calls ++;
          _this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
          _this.info.render.faces += offsets[ i ].count / 3;

        }

      }

    } else {

      // non-indexed triangles

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );

        }

        var position = geometry.attributes.position;

        // render non-indexed triangles

        if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

          var extension = extensions.get( 'ANGLE_instanced_arrays' );

          if ( extension === null ) {

            console.error( 'THREE.WebGLRenderer.renderMesh: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

          }

          if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.array.length / position.data.stride, geometry.maxInstancedCount ); // Draw the instanced meshes

          } else {

            extension.drawArraysInstancedANGLE( mode, 0, position.array.length / position.itemSize, geometry.maxInstancedCount ); // Draw the instanced meshes

          }

        } else {

          if ( position instanceof THREE.InterleavedBufferAttribute ) {

            _gl.drawArrays( mode, 0, position.data.array.length / position.data.stride );

          } else {

            _gl.drawArrays( mode, 0, position.array.length / position.itemSize );

          }

        }

        _this.info.render.calls++;
        _this.info.render.vertices += position.array.length / position.itemSize;
        _this.info.render.faces += position.array.length / ( 3 * position.itemSize );

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );

        }

        for ( var i = 0, il = offsets.length; i < il; i++ ) {

          // render non-indexed triangles

          if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            console.error( 'THREE.WebGLRenderer.renderMesh: cannot use drawCalls with THREE.InstancedBufferGeometry.' );
            return;

          } else {

            _gl.drawArrays( mode, offsets[ i ].start, offsets[ i ].count );

          }

          _this.info.render.calls++;
          _this.info.render.vertices += offsets[ i ].count;
          _this.info.render.faces += ( offsets[ i ].count  ) / 3;

        }
      }
    }

  }

  function renderLine( material, geometry, object, program, updateBuffers ) {

    var mode = object instanceof THREE.LineSegments ? _gl.LINES : _gl.LINE_STRIP;

    // In case user is not using Line*Material by mistake
    var lineWidth = material.linewidth !== undefined ? material.linewidth : 1;

    state.setLineWidth( lineWidth * pixelRatio );

    var index = geometry.attributes.index;

    if ( index ) {

      // indexed lines

      var type, size;

      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

        type = _gl.UNSIGNED_INT;
        size = 4;

      } else {

        type = _gl.UNSIGNED_SHORT;
        size = 2;

      }

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );
          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

        }

        _gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

        _this.info.render.calls ++;
        _this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        if ( offsets.length > 1 ) updateBuffers = true;

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          var startIndex = offsets[ i ].index;

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, startIndex );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          // render indexed lines

          _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

          _this.info.render.calls ++;
          _this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

        }

      }

    } else {

      // non-indexed lines

      if ( updateBuffers ) {

        setupVertexAttributes( material, program, geometry, 0 );

      }

      var position = geometry.attributes.position;
      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        _gl.drawArrays( mode, 0, position.array.length / 3 );

        _this.info.render.calls ++;
        _this.info.render.vertices += position.array.length / 3;

      } else {

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          _gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

          _this.info.render.calls ++;
          _this.info.render.vertices += offsets[ i ].count;

        }

      }

    }

  }

  function renderPointCloud( material, geometry, object, program, updateBuffers ) {

    var mode = _gl.POINTS;

    var index = geometry.attributes.index;

    if ( index ) {

      // indexed points

      var type, size;

      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

        type = _gl.UNSIGNED_INT;
        size = 4;

      } else {

        type = _gl.UNSIGNED_SHORT;
        size = 2;

      }

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );
          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

        }

        _gl.drawElements( mode, index.array.length, type, 0);

        _this.info.render.calls ++;
        _this.info.render.points += index.array.length;

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        if ( offsets.length > 1 ) updateBuffers = true;

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          var startIndex = offsets[ i ].index;

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, startIndex );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          // render indexed points

          _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

          _this.info.render.calls ++;
          _this.info.render.points += offsets[ i ].count;

        }

      }

    } else {

      // non-indexed points

      if ( updateBuffers ) {

        setupVertexAttributes( material, program, geometry, 0 );

      }

      var position = geometry.attributes.position;
      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        _gl.drawArrays( mode, 0, position.array.length / 3 );

        _this.info.render.calls ++;
        _this.info.render.points += position.array.length / 3;

      } else {

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          _gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

          _this.info.render.calls ++;
          _this.info.render.points += offsets[ i ].count;

        }

      }

    }

  }

  // Sorting

  function painterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } else if ( a.object.material.id !== b.object.material.id ) {

      return a.object.material.id - b.object.material.id;

    } else if ( a.z !== b.z ) {

      return a.z - b.z;

    } else {

      return a.id - b.id;

    }

  }

  function reversePainterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return a.id - b.id;

    }

  }

  // Rendering

  this.render = function ( scene, camera, renderTarget, forceClear ) {

    if ( camera instanceof THREE.Camera === false ) {

      console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var fog = scene.fog;

    // reset caching for this frame

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;
    _currentCamera = null;
    _lightsNeedUpdate = true;

    // update scene graph

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    // update camera matrices and frustum

    if ( camera.parent === undefined ) camera.updateMatrixWorld();

    camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    _frustum.setFromMatrix( _projScreenMatrix );

    lights.length = 0;
    opaqueObjects.length = 0;
    transparentObjects.length = 0;

    sprites.length = 0;
    lensFlares.length = 0;

    projectObject( scene );

    if ( _this.sortObjects === true ) {

      opaqueObjects.sort( painterSortStable );
      transparentObjects.sort( reversePainterSortStable );

    }

    objects.update( opaqueObjects );
    objects.update( transparentObjects );

    //

    shadowMap.render( scene, camera );

    //

    _this.info.render.calls = 0;
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _this.info.render.points = 0;

    this.setRenderTarget( renderTarget );

    if ( this.autoClear || forceClear ) {

      this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    }

    // set matrices for immediate objects

    for ( var i = 0, il = objects.objectsImmediate.length; i < il; i ++ ) {

      var webglObject = objects.objectsImmediate[ i ];
      var object = webglObject.object;

      if ( object.visible === true ) {

        setupMatrices( object, camera );

        var material = object.material;

        if ( material.transparent ) {

          webglObject.transparent = material;
          webglObject.opaque = null;

        } else {

          webglObject.opaque = material;
          webglObject.transparent = null;

        }

      }

    }

    if ( scene.overrideMaterial ) {

      var overrideMaterial = scene.overrideMaterial;

      setMaterial( overrideMaterial );

      renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
      renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
      renderObjectsImmediate( objects.objectsImmediate, '', camera, lights, fog, overrideMaterial );

    } else {

      // opaque pass (front-to-back order)

      state.setBlending( THREE.NoBlending );

      renderObjects( opaqueObjects, camera, lights, fog, null );
      renderObjectsImmediate( objects.objectsImmediate, 'opaque', camera, lights, fog, null );

      // transparent pass (back-to-front order)

      renderObjects( transparentObjects, camera, lights, fog, null );
      renderObjectsImmediate( objects.objectsImmediate, 'transparent', camera, lights, fog, null );

    }

    // custom render plugins (post pass)

    spritePlugin.render( scene, camera );
    lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

    // Generate mipmap if we're using any kind of mipmap filtering

    if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

      updateRenderTargetMipmap( renderTarget );

    }

    // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.setDepthTest( true );
    state.setDepthWrite( true );
    state.setColorWrite( true );

    // _gl.finish();

  };

  function projectObject( object ) {

    if ( object.visible === true ) {

      if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

        // skip

      } else {

        // update Skeleton objects
        if ( object instanceof THREE.SkinnedMesh ) {

          object.skeleton.update();

        }

        objects.init( object );

        if ( object instanceof THREE.Light ) {

          lights.push( object );

        } else if ( object instanceof THREE.Sprite ) {

          sprites.push( object );

        } else if ( object instanceof THREE.LensFlare ) {

          lensFlares.push( object );

        } else {

          var webglObject = objects.objects[ object.id ];

          if ( webglObject && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

            var material = object.material;

            if ( material.transparent ) {

              transparentObjects.push( webglObject );

            } else {

              opaqueObjects.push( webglObject );

            }

            if ( _this.sortObjects === true ) {

              _vector3.setFromMatrixPosition( object.matrixWorld );
              _vector3.applyProjection( _projScreenMatrix );

              webglObject.z = _vector3.z;

            }

          }

        }

      }

      for ( var i = 0, l = object.children.length; i < l; i ++ ) {

        projectObject( object.children[ i ] );

      }

    }

  }

  function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

    var material;

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var webglObject = renderList[ i ];

      var object = webglObject.object;

      setupMatrices( object, camera );

      if ( overrideMaterial ) {

        material = overrideMaterial;

      } else {

        material = object.material;

        if ( ! material ) continue;

        setMaterial( material );

      }

      _this.setMaterialFaces( material );
      _this.renderBufferDirect( camera, lights, fog, material, object );

    }

  }

  function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {

    var material;

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var webglObject = renderList[ i ];
      var object = webglObject.object;

      if ( object.visible === true ) {

        if ( overrideMaterial ) {

          material = overrideMaterial;

        } else {

          material = webglObject[ materialType ];

          if ( ! material ) continue;

          setMaterial( material );

        }

        _this.renderImmediateObject( camera, lights, fog, material, object );

      }

    }

  }

  this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

    var program = setProgram( camera, lights, fog, material, object );

    _currentGeometryProgram = '';

    _this.setMaterialFaces( material );

    if ( object.immediateRenderCallback ) {

      object.immediateRenderCallback( program, _gl, _frustum );

    } else {

      object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

    }

  };

  // Materials

  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointCloudMaterial: 'particle_basic'
  };

  function initMaterial( material, lights, fog, object ) {

    var shaderID = shaderIDs[ material.type ];

    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxLightCount = allocateLights( lights );
    var maxShadows = allocateShadows( lights );
    var maxBones = allocateBones( object );

    var parameters = {

      precision: _precision,
      supportsVertexTextures: _supportsVertexTextures,

      map: !! material.map,
      envMap: !! material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      lightMap: !! material.lightMap,
      aoMap: !! material.aoMap,
      bumpMap: !! material.bumpMap,
      normalMap: !! material.normalMap,
      specularMap: !! material.specularMap,
      alphaMap: !! material.alphaMap,

      combine: material.combine,

      vertexColors: material.vertexColors,

      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,

      flatShading: material.shading === THREE.FlatShading,

      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: _logarithmicDepthBuffer,

      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: _this.maxMorphTargets,
      maxMorphNormals: _this.maxMorphNormals,

      maxDirLights: maxLightCount.directional,
      maxPointLights: maxLightCount.point,
      maxSpotLights: maxLightCount.spot,
      maxHemiLights: maxLightCount.hemi,

      maxShadows: maxShadows,
      shadowMapEnabled: shadowMap.enabled && object.receiveShadow && maxShadows > 0,
      shadowMapType: shadowMap.type,
      shadowMapDebug: shadowMap.debug,
      shadowMapCascade: shadowMap.cascade,

      alphaTest: material.alphaTest,
      metal: material.metal,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide

    };

    // Generate code

    var chunks = [];

    if ( shaderID ) {

      chunks.push( shaderID );

    } else {

      chunks.push( material.fragmentShader );
      chunks.push( material.vertexShader );

    }

    if ( material.defines !== undefined ) {

      for ( var name in material.defines ) {

        chunks.push( name );
        chunks.push( material.defines[ name ] );

      }

    }

    for ( var name in parameters ) {

      chunks.push( name );
      chunks.push( parameters[ name ] );

    }

    var code = chunks.join();

    if ( !material.program ) {

      // new material
      material.addEventListener( 'dispose', onMaterialDispose );

    } else if ( material.program.code !== code ) {

      // changed glsl or parameters
      deallocateMaterial( material );

    } else if ( shaderID !== undefined ) {

      // same glsl
      return;

    } else if ( material.__webglShader.uniforms === material.uniforms ) {

      // same uniforms (container object)
      return;

    }

    if ( shaderID ) {

      var shader = THREE.ShaderLib[ shaderID ];

      material.__webglShader = {
        uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      }

    } else {

      material.__webglShader = {
        uniforms: material.uniforms,
        vertexShader: material.vertexShader,
        fragmentShader: material.fragmentShader
      }

    }

    var program;

    // Check if code has been already compiled

    for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

      var programInfo = _programs[ p ];

      if ( programInfo.code === code ) {

        program = programInfo;
        program.usedTimes ++;

        break;

      }

    }

    if ( program === undefined ) {

      program = new THREE.WebGLProgram( _this, code, material, parameters );
      _programs.push( program );

      _this.info.memory.programs = _programs.length;

    }

    material.program = program;

    var attributes = program.getAttributes();

    if ( material.morphTargets ) {

      material.numSupportedMorphTargets = 0;

      for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

        if ( attributes[ 'morphTarget' + i ] >= 0 ) {

          material.numSupportedMorphTargets ++;

        }

      }

    }

    if ( material.morphNormals ) {

      material.numSupportedMorphNormals = 0;

      for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

        if ( attributes[ 'morphNormal' + i ] >= 0 ) {

          material.numSupportedMorphNormals ++;

        }

      }

    }

    material.uniformsList = [];

    var uniformLocations = material.program.getUniforms();
    for ( var u in material.__webglShader.uniforms ) {

      var location = uniformLocations[ u ];

      if ( location ) {
        material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
      }

    }

  }

  function setMaterial( material ) {

    if ( material.transparent === true ) {

      state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

    } else {

      state.setBlending( THREE.NoBlending );

    }

    state.setDepthFunc( material.depthFunc );
    state.setDepthTest( material.depthTest );
    state.setDepthWrite( material.depthWrite );
    state.setColorWrite( material.colorWrite );
    state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  }

  function setProgram( camera, lights, fog, material, object ) {

    _usedTextureUnits = 0;

    if ( material.needsUpdate ) {

      initMaterial( material, lights, fog, object );
      material.needsUpdate = false;

    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;

    var program = material.program,
      p_uniforms = program.getUniforms(),
      m_uniforms = material.__webglShader.uniforms;

    if ( program.id !== _currentProgram ) {

      _gl.useProgram( program.program );
      _currentProgram = program.id;

      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;

    }

    if ( material.id !== _currentMaterialId ) {

      if ( _currentMaterialId === -1 ) refreshLights = true;
      _currentMaterialId = material.id;

      refreshMaterial = true;

    }

    if ( refreshProgram || camera !== _currentCamera ) {

      _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

      if ( _logarithmicDepthBuffer ) {

        _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

      }


      if ( camera !== _currentCamera ) _currentCamera = camera;

      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)

      if ( material instanceof THREE.ShaderMaterial ||
         material instanceof THREE.MeshPhongMaterial ||
         material.envMap ) {

        if ( p_uniforms.cameraPosition !== null ) {

          _vector3.setFromMatrixPosition( camera.matrixWorld );
          _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

        }

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.ShaderMaterial ||
         material.skinning ) {

        if ( p_uniforms.viewMatrix !== null ) {

          _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

        }

      }

    }

    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen

    if ( material.skinning ) {

      if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

      }

      if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

      }

      if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

        if ( p_uniforms.boneTexture !== null ) {

          var textureUnit = getTextureUnit();

          _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
          _this.setTexture( object.skeleton.boneTexture, textureUnit );

        }

        if ( p_uniforms.boneTextureWidth !== null ) {

          _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

        }

        if ( p_uniforms.boneTextureHeight !== null ) {

          _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

        }

      } else if ( object.skeleton && object.skeleton.boneMatrices ) {

        if ( p_uniforms.boneGlobalMatrices !== null ) {

          _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

        }

      }

    }

    if ( refreshMaterial ) {

      // refresh uniforms common to several materials

      if ( fog && material.fog ) {

        refreshUniformsFog( m_uniforms, fog );

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material.lights ) {

        if ( _lightsNeedUpdate ) {

          refreshLights = true;
          setupLights( lights );
          _lightsNeedUpdate = false;
        }

        if ( refreshLights ) {
          refreshUniformsLights( m_uniforms, _lights );
          markUniformsLightsNeedsUpdate( m_uniforms, true );
        } else {
          markUniformsLightsNeedsUpdate( m_uniforms, false );
        }

      }

      if ( material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsCommon( m_uniforms, material );

      }

      // refresh single material specific uniforms

      if ( material instanceof THREE.LineBasicMaterial ) {

        refreshUniformsLine( m_uniforms, material );

      } else if ( material instanceof THREE.LineDashedMaterial ) {

        refreshUniformsLine( m_uniforms, material );
        refreshUniformsDash( m_uniforms, material );

      } else if ( material instanceof THREE.PointCloudMaterial ) {

        refreshUniformsParticle( m_uniforms, material );

      } else if ( material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsPhong( m_uniforms, material );

      } else if ( material instanceof THREE.MeshLambertMaterial ) {

        refreshUniformsLambert( m_uniforms, material );

      } else if ( material instanceof THREE.MeshBasicMaterial ) {

        refreshUniformsBasic( m_uniforms, material );

      } else if ( material instanceof THREE.MeshDepthMaterial ) {

        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;

      } else if ( material instanceof THREE.MeshNormalMaterial ) {

        m_uniforms.opacity.value = material.opacity;

      }

      if ( object.receiveShadow && ! material._shadowPass ) {

        refreshUniformsShadow( m_uniforms, lights );

      }

      // load common uniforms

      loadUniformsGeneric( material.uniformsList );

    }

    loadUniformsMatrices( p_uniforms, object );

    if ( p_uniforms.modelMatrix !== null ) {

      _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

    }

    return program;

  }

  // Uniforms (refresh uniforms objects)

  function refreshUniformsCommon ( uniforms, material ) {

    uniforms.opacity.value = material.opacity;

    uniforms.diffuse.value = material.color;

    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;

    if ( material.bumpMap ) {

      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;

    }

    if ( material.normalMap ) {

      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy( material.normalScale );

    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map

    var uvScaleMap;

    if ( material.map ) {

      uvScaleMap = material.map;

    } else if ( material.specularMap ) {

      uvScaleMap = material.specularMap;

    } else if ( material.normalMap ) {

      uvScaleMap = material.normalMap;

    } else if ( material.bumpMap ) {

      uvScaleMap = material.bumpMap;

    } else if ( material.alphaMap ) {

      uvScaleMap = material.alphaMap;

    }

    if ( uvScaleMap !== undefined ) {

      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;

  }

  function refreshUniformsLine ( uniforms, material ) {

    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;

  }

  function refreshUniformsDash ( uniforms, material ) {

    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;

  }

  function refreshUniformsParticle ( uniforms, material ) {

    uniforms.psColor.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

    uniforms.map.value = material.map;

    if ( material.map !== null ) {

      var offset = material.map.offset;
      var repeat = material.map.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

  }

  function refreshUniformsFog ( uniforms, fog ) {

    uniforms.fogColor.value = fog.color;

    if ( fog instanceof THREE.Fog ) {

      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;

    } else if ( fog instanceof THREE.FogExp2 ) {

      uniforms.fogDensity.value = fog.density;

    }

  }

  function refreshUniformsPhong ( uniforms, material ) {

    uniforms.shininess.value = material.shininess;

    uniforms.emissive.value = material.emissive;
    uniforms.specular.value = material.specular;

    uniforms.lightMap.value = material.lightMap;
    uniforms.lightMapIntensity.value = material.lightMapIntensity;

    uniforms.aoMap.value = material.aoMap;
    uniforms.aoMapIntensity.value = material.aoMapIntensity;

  }

  function refreshUniformsLambert ( uniforms, material ) {

    uniforms.emissive.value = material.emissive;

  }

  function refreshUniformsBasic ( uniforms, material ) {

    uniforms.aoMap.value = material.aoMap;
    uniforms.aoMapIntensity.value = material.aoMapIntensity;

  }

  function refreshUniformsLights ( uniforms, lights ) {

    uniforms.ambientLightColor.value = lights.ambient;

    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;

    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;
    uniforms.pointLightDecay.value = lights.point.decays;

    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;
    uniforms.spotLightDecay.value = lights.spot.decays;

    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;

  }

  // If uniforms are marked as clean, they don't need to be loaded to the GPU.

  function markUniformsLightsNeedsUpdate ( uniforms, value ) {

    uniforms.ambientLightColor.needsUpdate = value;

    uniforms.directionalLightColor.needsUpdate = value;
    uniforms.directionalLightDirection.needsUpdate = value;

    uniforms.pointLightColor.needsUpdate = value;
    uniforms.pointLightPosition.needsUpdate = value;
    uniforms.pointLightDistance.needsUpdate = value;
    uniforms.pointLightDecay.needsUpdate = value;

    uniforms.spotLightColor.needsUpdate = value;
    uniforms.spotLightPosition.needsUpdate = value;
    uniforms.spotLightDistance.needsUpdate = value;
    uniforms.spotLightDirection.needsUpdate = value;
    uniforms.spotLightAngleCos.needsUpdate = value;
    uniforms.spotLightExponent.needsUpdate = value;
    uniforms.spotLightDecay.needsUpdate = value;

    uniforms.hemisphereLightSkyColor.needsUpdate = value;
    uniforms.hemisphereLightGroundColor.needsUpdate = value;
    uniforms.hemisphereLightDirection.needsUpdate = value;

  }

  function refreshUniformsShadow ( uniforms, lights ) {

    if ( uniforms.shadowMatrix ) {

      var j = 0;

      for ( var i = 0, il = lights.length; i < il; i ++ ) {

        var light = lights[ i ];

        if ( ! light.castShadow ) continue;

        if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

          uniforms.shadowMap.value[ j ] = light.shadowMap;
          uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

          uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

          uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
          uniforms.shadowBias.value[ j ] = light.shadowBias;

          j ++;

        }

      }

    }

  }

  // Uniforms (load to GPU)

  function loadUniformsMatrices ( uniforms, object ) {

    _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

    if ( uniforms.normalMatrix ) {

      _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

    }

  }

  function getTextureUnit() {

    var textureUnit = _usedTextureUnits;

    if ( textureUnit >= _maxTextures ) {

      console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

    }

    _usedTextureUnits += 1;

    return textureUnit;

  }

  function loadUniformsGeneric ( uniforms ) {

    var texture, textureUnit, offset;

    for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

      var uniform = uniforms[ j ][ 0 ];

      // needsUpdate property is not added to all uniforms.
      if ( uniform.needsUpdate === false ) continue;

      var type = uniform.type;
      var value = uniform.value;
      var location = uniforms[ j ][ 1 ];

      switch ( type ) {

        case '1i':
          _gl.uniform1i( location, value );
          break;

        case '1f':
          _gl.uniform1f( location, value );
          break;

        case '2f':
          _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
          break;

        case '3f':
          _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
          break;

        case '4f':
          _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
          break;

        case '1iv':
          _gl.uniform1iv( location, value );
          break;

        case '3iv':
          _gl.uniform3iv( location, value );
          break;

        case '1fv':
          _gl.uniform1fv( location, value );
          break;

        case '2fv':
          _gl.uniform2fv( location, value );
          break;

        case '3fv':
          _gl.uniform3fv( location, value );
          break;

        case '4fv':
          _gl.uniform4fv( location, value );
          break;

        case 'Matrix3fv':
          _gl.uniformMatrix3fv( location, false, value );
          break;

        case 'Matrix4fv':
          _gl.uniformMatrix4fv( location, false, value );
          break;

        //

        case 'i':

          // single integer
          _gl.uniform1i( location, value );

          break;

        case 'f':

          // single float
          _gl.uniform1f( location, value );

          break;

        case 'v2':

          // single THREE.Vector2
          _gl.uniform2f( location, value.x, value.y );

          break;

        case 'v3':

          // single THREE.Vector3
          _gl.uniform3f( location, value.x, value.y, value.z );

          break;

        case 'v4':

          // single THREE.Vector4
          _gl.uniform4f( location, value.x, value.y, value.z, value.w );

          break;

        case 'c':

          // single THREE.Color
          _gl.uniform3f( location, value.r, value.g, value.b );

          break;

        case 'iv1':

          // flat array of integers (JS or typed array)
          _gl.uniform1iv( location, value );

          break;

        case 'iv':

          // flat array of integers with 3 x N size (JS or typed array)
          _gl.uniform3iv( location, value );

          break;

        case 'fv1':

          // flat array of floats (JS or typed array)
          _gl.uniform1fv( location, value );

          break;

        case 'fv':

          // flat array of floats with 3 x N size (JS or typed array)
          _gl.uniform3fv( location, value );

          break;

        case 'v2v':

          // array of THREE.Vector2

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 2 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 2;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;

          }

          _gl.uniform2fv( location, uniform._array );

          break;

        case 'v3v':

          // array of THREE.Vector3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 3 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 3;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;

          }

          _gl.uniform3fv( location, uniform._array );

          break;

        case 'v4v':

          // array of THREE.Vector4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 4 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 4;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;
            uniform._array[ offset + 3 ] = value[ i ].w;

          }

          _gl.uniform4fv( location, uniform._array );

          break;

        case 'm3':

          // single THREE.Matrix3
          _gl.uniformMatrix3fv( location, false, value.elements );

          break;

        case 'm3v':

          // array of THREE.Matrix3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 9 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

          }

          _gl.uniformMatrix3fv( location, false, uniform._array );

          break;

        case 'm4':

          // single THREE.Matrix4
          _gl.uniformMatrix4fv( location, false, value.elements );

          break;

        case 'm4v':

          // array of THREE.Matrix4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 16 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

          }

          _gl.uniformMatrix4fv( location, false, uniform._array );

          break;

        case 't':

          // single THREE.Texture (2d or cube)

          texture = value;
          textureUnit = getTextureUnit();

          _gl.uniform1i( location, textureUnit );

          if ( ! texture ) continue;

          if ( texture instanceof THREE.CubeTexture ||
             ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

            setCubeTexture( texture, textureUnit );

          } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

            setCubeTextureDynamic( texture, textureUnit );

          } else {

            _this.setTexture( texture, textureUnit );

          }

          break;

        case 'tv':

          // array of THREE.Texture (2d)

          if ( uniform._array === undefined ) {

            uniform._array = [];

          }

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            uniform._array[ i ] = getTextureUnit();

          }

          _gl.uniform1iv( location, uniform._array );

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            texture = uniform.value[ i ];
            textureUnit = uniform._array[ i ];

            if ( ! texture ) continue;

            _this.setTexture( texture, textureUnit );

          }

          break;

        default:

          console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

      }

    }

  }

  function setupMatrices ( object, camera ) {

    object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

  }

  function setColorLinear( array, offset, color, intensity ) {

    array[ offset + 0 ] = color.r * intensity;
    array[ offset + 1 ] = color.g * intensity;
    array[ offset + 2 ] = color.b * intensity;

  }

  function setupLights ( lights ) {

    var l, ll, light,
    r = 0, g = 0, b = 0,
    color, skyColor, groundColor,
    intensity,
    distance,

    zlights = _lights,

    dirColors = zlights.directional.colors,
    dirPositions = zlights.directional.positions,

    pointColors = zlights.point.colors,
    pointPositions = zlights.point.positions,
    pointDistances = zlights.point.distances,
    pointDecays = zlights.point.decays,

    spotColors = zlights.spot.colors,
    spotPositions = zlights.spot.positions,
    spotDistances = zlights.spot.distances,
    spotDirections = zlights.spot.directions,
    spotAnglesCos = zlights.spot.anglesCos,
    spotExponents = zlights.spot.exponents,
    spotDecays = zlights.spot.decays,

    hemiSkyColors = zlights.hemi.skyColors,
    hemiGroundColors = zlights.hemi.groundColors,
    hemiPositions = zlights.hemi.positions,

    dirLength = 0,
    pointLength = 0,
    spotLength = 0,
    hemiLength = 0,

    dirCount = 0,
    pointCount = 0,
    spotCount = 0,
    hemiCount = 0,

    dirOffset = 0,
    pointOffset = 0,
    spotOffset = 0,
    hemiOffset = 0;

    for ( l = 0, ll = lights.length; l < ll; l ++ ) {

      light = lights[ l ];

      if ( light.onlyShadow ) continue;

      color = light.color;
      intensity = light.intensity;
      distance = light.distance;

      if ( light instanceof THREE.AmbientLight ) {

        if ( ! light.visible ) continue;

        r += color.r;
        g += color.g;
        b += color.b;

      } else if ( light instanceof THREE.DirectionalLight ) {

        dirCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        dirOffset = dirLength * 3;

        dirPositions[ dirOffset + 0 ] = _direction.x;
        dirPositions[ dirOffset + 1 ] = _direction.y;
        dirPositions[ dirOffset + 2 ] = _direction.z;

        setColorLinear( dirColors, dirOffset, color, intensity );

        dirLength += 1;

      } else if ( light instanceof THREE.PointLight ) {

        pointCount += 1;

        if ( ! light.visible ) continue;

        pointOffset = pointLength * 3;

        setColorLinear( pointColors, pointOffset, color, intensity );

        _vector3.setFromMatrixPosition( light.matrixWorld );

        pointPositions[ pointOffset + 0 ] = _vector3.x;
        pointPositions[ pointOffset + 1 ] = _vector3.y;
        pointPositions[ pointOffset + 2 ] = _vector3.z;

        // distance is 0 if decay is 0, because there is no attenuation at all.
        pointDistances[ pointLength ] = distance;
        pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

        pointLength += 1;

      } else if ( light instanceof THREE.SpotLight ) {

        spotCount += 1;

        if ( ! light.visible ) continue;

        spotOffset = spotLength * 3;

        setColorLinear( spotColors, spotOffset, color, intensity );

        _direction.setFromMatrixPosition( light.matrixWorld );

        spotPositions[ spotOffset + 0 ] = _direction.x;
        spotPositions[ spotOffset + 1 ] = _direction.y;
        spotPositions[ spotOffset + 2 ] = _direction.z;

        spotDistances[ spotLength ] = distance;

        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        spotDirections[ spotOffset + 0 ] = _direction.x;
        spotDirections[ spotOffset + 1 ] = _direction.y;
        spotDirections[ spotOffset + 2 ] = _direction.z;

        spotAnglesCos[ spotLength ] = Math.cos( light.angle );
        spotExponents[ spotLength ] = light.exponent;
        spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

        spotLength += 1;

      } else if ( light instanceof THREE.HemisphereLight ) {

        hemiCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _direction.normalize();

        hemiOffset = hemiLength * 3;

        hemiPositions[ hemiOffset + 0 ] = _direction.x;
        hemiPositions[ hemiOffset + 1 ] = _direction.y;
        hemiPositions[ hemiOffset + 2 ] = _direction.z;

        skyColor = light.color;
        groundColor = light.groundColor;

        setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
        setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

        hemiLength += 1;

      }

    }

    // null eventual remains from removed lights
    // (this is to avoid if in shader)

    for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
    for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
    for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;

    zlights.ambient[ 0 ] = r;
    zlights.ambient[ 1 ] = g;
    zlights.ambient[ 2 ] = b;

  }

  // GL state setting

  this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    if ( cullFace === THREE.CullFaceNone ) {

      _gl.disable( _gl.CULL_FACE );

    } else {

      if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

        _gl.frontFace( _gl.CW );

      } else {

        _gl.frontFace( _gl.CCW );

      }

      if ( cullFace === THREE.CullFaceBack ) {

        _gl.cullFace( _gl.BACK );

      } else if ( cullFace === THREE.CullFaceFront ) {

        _gl.cullFace( _gl.FRONT );

      } else {

        _gl.cullFace( _gl.FRONT_AND_BACK );

      }

      _gl.enable( _gl.CULL_FACE );

    }

  };

  this.setMaterialFaces = function ( material ) {

    state.setDoubleSided( material.side === THREE.DoubleSide );
    state.setFlipSided( material.side === THREE.BackSide );

  };

  // Textures

  function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

    var extension;

    if ( isImagePowerOfTwo ) {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    } else {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

      if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

      }

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

      if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

      }

    }

    extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {

      if ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {

        _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
        texture.__currentAnisotropy = texture.anisotropy;

      }

    }

  }

  this.uploadTexture = function ( texture, slot ) {

    if ( texture.__webglInit === undefined ) {

      texture.__webglInit = true;

      texture.addEventListener( 'dispose', onTextureDispose );

      texture.__webglTexture = _gl.createTexture();

      _this.info.memory.textures ++;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

    _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    texture.image = clampToMaxSize( texture.image, _maxTextureSize );

    var image = texture.image,
    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
    glFormat = paramThreeToGL( texture.format ),
    glType = paramThreeToGL( texture.type );

    setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

    var mipmap, mipmaps = texture.mipmaps;

    if ( texture instanceof THREE.DataTexture ) {

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

      }

    } else if ( texture instanceof THREE.CompressedTexture ) {

      for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

        mipmap = mipmaps[ i ];

        if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

          if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

            state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

          } else {

            console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

          }

        } else {

          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

      }

    } else { // regular Texture (image, video, canvas)

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

      }

    }

    if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

    texture.needsUpdate = false;

    if ( texture.onUpdate ) texture.onUpdate( texture );

  };

  this.setTexture = function ( texture, slot ) {

    if ( texture.needsUpdate === true ) {

      var image = texture.image;

      if ( image === undefined ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
        return;

      }

      if ( image.complete === false ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
        return;

      }

      _this.uploadTexture( texture, slot );
      return;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

  };

  function clampToMaxSize ( image, maxSize ) {

    if ( image.width > maxSize || image.height > maxSize ) {

      // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.

      var scale = maxSize / Math.max( image.width, image.height );

      var canvas = document.createElement( 'canvas' );
      canvas.width = Math.floor( image.width * scale );
      canvas.height = Math.floor( image.height * scale );

      var context = canvas.getContext( '2d' );
      context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

      console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

      return canvas;

    }

    return image;

  }

  function setCubeTexture ( texture, slot ) {

    if ( texture.image.length === 6 ) {

      if ( texture.needsUpdate ) {

        if ( ! texture.image.__webglTextureCube ) {

          texture.addEventListener( 'dispose', onTextureDispose );

          texture.image.__webglTextureCube = _gl.createTexture();

          _this.info.memory.textures ++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

        var isCompressed = texture instanceof THREE.CompressedTexture;
        var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

        var cubeImage = [];

        for ( var i = 0; i < 6; i ++ ) {

          if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

            cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

          } else {

            cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

          }

        }

        var image = cubeImage[ 0 ],
        isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
        glFormat = paramThreeToGL( texture.format ),
        glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          if ( ! isCompressed ) {

            if ( isDataTexture ) {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

            } else {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

            }

          } else {

            var mipmap, mipmaps = cubeImage[ i ].mipmaps;

            for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

              mipmap = mipmaps[ j ];

              if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                  state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                } else {

                  console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                }

              } else {

                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

              }

            }

          }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) {

          _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

        }

        texture.needsUpdate = false;

        if ( texture.onUpdate ) texture.onUpdate( texture );

      } else {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

      }

    }

  }

  function setCubeTextureDynamic ( texture, slot ) {

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

  }

  // Render targets

  function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

    _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

  }

  function setupRenderBuffer ( renderbuffer, renderTarget ) {

    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    /* For some reason this is not working. Defaulting to RGBA4.
    } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
    */
    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    } else {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    }

  }

  this.setRenderTarget = function ( renderTarget ) {

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

    if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

      if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
      if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

      renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

      renderTarget.__webglTexture = _gl.createTexture();

      _this.info.memory.textures ++;

      // Setup texture, create render and frame buffers

      var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
        glFormat = paramThreeToGL( renderTarget.format ),
        glType = paramThreeToGL( renderTarget.type );

      if ( isCube ) {

        renderTarget.__webglFramebuffer = [];
        renderTarget.__webglRenderbuffer = [];

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
          renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

          state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

          setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
          setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

        }

        if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

      } else {

        renderTarget.__webglFramebuffer = _gl.createFramebuffer();

        if ( renderTarget.shareDepthFrom ) {

          renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

        } else {

          renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

        }

        state.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
        setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

        setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

        if ( renderTarget.shareDepthFrom ) {

          if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

          } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

          }

        } else {

          setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

        }

        if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

      }

      // Release everything

      if ( isCube ) {

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

      } else {

        state.bindTexture( _gl.TEXTURE_2D, null );

      }

      _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    }

    var framebuffer, width, height, vx, vy;

    if ( renderTarget ) {

      if ( isCube ) {

        framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

      } else {

        framebuffer = renderTarget.__webglFramebuffer;

      }

      width = renderTarget.width;
      height = renderTarget.height;

      vx = 0;
      vy = 0;

    } else {

      framebuffer = null;

      width = _viewportWidth;
      height = _viewportHeight;

      vx = _viewportX;
      vy = _viewportY;

    }

    if ( framebuffer !== _currentFramebuffer ) {

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
      _gl.viewport( vx, vy, width, height );

      _currentFramebuffer = framebuffer;

    }

    _currentWidth = width;
    _currentHeight = height;

  };

  this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

    if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

      console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
      return;

    }

    if ( renderTarget.__webglFramebuffer ) {

      if ( renderTarget.format !== THREE.RGBAFormat ) {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
        return;

      }

      var restore = false;

      if ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );

        restore = true;

      }

      if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

        _gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

      } else {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

      }

      if ( restore ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

      }

    }

  };

  function updateRenderTargetMipmap ( renderTarget ) {

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
      state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    } else {

      state.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_2D );
      state.bindTexture( _gl.TEXTURE_2D, null );

    }

  }

  // Fallback filters for non-power-of-2 textures

  function filterFallback ( f ) {

    if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

      return _gl.NEAREST;

    }

    return _gl.LINEAR;

  }

  // Map three.js constants to WebGL constants

  function paramThreeToGL ( p ) {

    var extension;

    if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
    if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    if ( p === THREE.NearestFilter ) return _gl.NEAREST;
    if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    if ( p === THREE.LinearFilter ) return _gl.LINEAR;
    if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    if ( p === THREE.ByteType ) return _gl.BYTE;
    if ( p === THREE.ShortType ) return _gl.SHORT;
    if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    if ( p === THREE.IntType ) return _gl.INT;
    if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
    if ( p === THREE.FloatType ) return _gl.FLOAT;

    extension = extensions.get( 'OES_texture_half_float' );

    if ( extension !== null ) {

      if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

    }

    if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
    if ( p === THREE.RGBFormat ) return _gl.RGB;
    if ( p === THREE.RGBAFormat ) return _gl.RGBA;
    if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
    if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

    if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
    if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
    if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    if ( p === THREE.ZeroFactor ) return _gl.ZERO;
    if ( p === THREE.OneFactor ) return _gl.ONE;
    if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
    if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
    if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
    if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
    if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    }

    extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    }

    extension = extensions.get( 'EXT_blend_minmax' );

    if ( extension !== null ) {

      if ( p === THREE.MinEquation ) return extension.MIN_EXT;
      if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

    }

    return 0;

  }

  // Allocations

  function allocateBones ( object ) {

    if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

      return 1024;

    } else {

      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)

      var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
      var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

      var maxBones = nVertexMatrices;

      if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

        maxBones = Math.min( object.skeleton.bones.length, maxBones );

        if ( maxBones < object.skeleton.bones.length ) {

          console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

        }

      }

      return maxBones;

    }

  }

  function allocateLights( lights ) {

    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( light.onlyShadow || light.visible === false ) continue;

      if ( light instanceof THREE.DirectionalLight ) dirLights ++;
      if ( light instanceof THREE.PointLight ) pointLights ++;
      if ( light instanceof THREE.SpotLight ) spotLights ++;
      if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

    }

    return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

  }

  function allocateShadows( lights ) {

    var maxShadows = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( ! light.castShadow ) continue;

      if ( light instanceof THREE.SpotLight ) maxShadows ++;
      if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

    }

    return maxShadows;

  }

  // DEPRECATED

  this.initMaterial = function () {

    console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  };

  this.addPrePlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  };

  this.addPostPlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  };

  this.updateShadowMap = function () {

    console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  };

  Object.defineProperties( this, {
    shadowMapEnabled: {
      get: function () {
        return shadowMap.enabled;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
        shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function () {
        return shadowMap.type;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
        shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function () {
        return shadowMap.cullFace;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
        shadowMap.cullFace = value;
      }
    },
    shadowMapDebug: {
      get: function () {
        return shadowMap.debug;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
        shadowMap.debug = value;
      }
    },
    shadowMapCascade: {
      get: function () {
        return shadowMap.cascade;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapCascade is now .shadowMap.cascade.' );
        shadowMap.cascade = value;
      }
    }
  } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

  this.width = width;
  this.height = height;

  options = options || {};

  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

  this.generateMipmaps = true;

  this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

  constructor: THREE.WebGLRenderTarget,

  setSize: function ( width, height ) {

    if ( this.width !== width || this.height !== height ) {

      this.width = width;
      this.height = height;

      this.dispose();

    }
  },

  clone: function () {

    var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

    tmp.wrapS = this.wrapS;
    tmp.wrapT = this.wrapT;

    tmp.magFilter = this.magFilter;
    tmp.minFilter = this.minFilter;

    tmp.anisotropy = this.anisotropy;

    tmp.offset.copy( this.offset );
    tmp.repeat.copy( this.repeat );

    tmp.format = this.format;
    tmp.type = this.type;

    tmp.depthBuffer = this.depthBuffer;
    tmp.stencilBuffer = this.stencilBuffer;

    tmp.generateMipmaps = this.generateMipmaps;

    tmp.shareDepthFrom = this.shareDepthFrom;

    return tmp;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

  THREE.WebGLRenderTarget.call( this, width, height, options );

  this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

  var extensions = {};

  this.get = function ( name ) {

    if ( extensions[ name ] !== undefined ) {

      return extensions[ name ];

    }

    var extension;

    switch ( name ) {

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
        break;

      default:
        extension = gl.getExtension( name );

    }

    if ( extension === null ) {

      console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    }

    extensions[ name ] = extension;

    return extension;

  };

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, info ) {

  var geometries = {};

  this.get = function ( object ) {

    var geometry = object.geometry;

    if ( geometries[ geometry.id ] !== undefined ) {

      return geometries[ geometry.id ];

    }

    geometry.addEventListener( 'dispose', onGeometryDispose );

    if ( geometry instanceof THREE.BufferGeometry ) {

      geometries[ geometry.id ] = geometry;

    } else {

      geometries[ geometry.id ] = new THREE.BufferGeometry().setFromObject( object );

    }

    info.memory.geometries ++;

    return geometries[ geometry.id ];

  };

  function onGeometryDispose( event ) {

    var geometry = event.target;

    geometry.removeEventListener( 'dispose', onGeometryDispose );

    geometry = geometries[ geometry.id ];

    for ( var name in geometry.attributes ) {

      var attribute = geometry.attributes[ name ];

      if ( attribute.buffer !== undefined ) {

        gl.deleteBuffer( attribute.buffer );

        delete attribute.buffer;

      }

    }

    info.memory.geometries --;

  }

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, info ) {

  var objects = {};
  var objectsImmediate = [];

  var morphInfluences = new Float32Array( 8 );

  var geometries = new THREE.WebGLGeometries( gl, info );

  //

  function onObjectRemoved( event ) {

    var object = event.target;

    object.traverse( function ( child ) {

      child.removeEventListener( 'remove', onObjectRemoved );
      removeObject( child );

    } );

  }

  function removeObject( object ) {

    if ( object instanceof THREE.Mesh ||
       object instanceof THREE.PointCloud ||
       object instanceof THREE.Line ) {

      delete objects[ object.id ];

    } else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

      removeInstances( objectsImmediate, object );

    }

    delete object.__webglInit;
    delete object._modelViewMatrix;
    delete object._normalMatrix;

    delete object.__webglActive;

  }

  function removeInstances( objlist, object ) {

    for ( var o = objlist.length - 1; o >= 0; o -- ) {

      if ( objlist[ o ].object === object ) {

        objlist.splice( o, 1 );

      }

    }

  }

  //

  this.objects = objects;
  this.objectsImmediate = objectsImmediate;

  this.geometries = geometries;

  this.init = function ( object ) {

    if ( object.__webglInit === undefined ) {

      object.__webglInit = true;
      object._modelViewMatrix = new THREE.Matrix4();
      object._normalMatrix = new THREE.Matrix3();

      object.addEventListener( 'removed', onObjectRemoved );

    }

    if ( object.__webglActive === undefined ) {

      object.__webglActive = true;

      if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

        objects[ object.id ] = {
          id: object.id,
          object: object,
          z: 0
        };

      } else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

        objectsImmediate.push( {
          id: null,
          object: object,
          opaque: null,
          transparent: null,
          z: 0
        } );

      }

    }

  };

  function numericalSort ( a, b ) {

    return b[ 0 ] - a[ 0 ];

  }

  function updateObject( object ) {

    var geometry = geometries.get( object );

    if ( object.geometry.dynamic === true ) {

      geometry.updateFromObject( object );

    }

    // morph targets

    if ( object.morphTargetInfluences !== undefined ) {

      var activeInfluences = [];
      var morphTargetInfluences = object.morphTargetInfluences;

      for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

        var influence = morphTargetInfluences[ i ];
        activeInfluences.push( [ influence, i ] );

      }

      activeInfluences.sort( numericalSort );

      if ( activeInfluences.length > 8 ) {

        activeInfluences.length = 8;

      }

      for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

        morphInfluences[ i ] = activeInfluences[ i ][ 0 ];

        var attribute = geometry.morphAttributes[ activeInfluences[ i ][ 1 ] ];
        geometry.addAttribute( 'morphTarget' + i, attribute );

      }

      var material = object.material;

      if ( material.program !== undefined ) {

        if ( material.program.uniforms.morphTargetInfluences !== null ) {

          gl.uniform1fv( material.program.uniforms.morphTargetInfluences, morphInfluences );

        }

      } else {

        console.warn( 'TOFIX: material.program is undefined' );

      }

    }

    //

    var attributes = geometry.attributes;

    for ( var name in attributes ) {

      var attribute = attributes[ name ];

      var bufferType = ( name === 'index' ) ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;

      var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

      if ( data.buffer === undefined ) {

        data.buffer = gl.createBuffer();
        gl.bindBuffer( bufferType, data.buffer );

        var usage = gl.STATIC_DRAW;

        if ( data instanceof THREE.DynamicBufferAttribute
             || ( data instanceof THREE.InstancedBufferAttribute && data.dynamic === true )
             || ( data instanceof THREE.InterleavedBuffer && data.dynamic === true ) ) {

          usage = gl.DYNAMIC_DRAW;

        }

        gl.bufferData( bufferType, data.array, usage );

        data.needsUpdate = false;

      } else if ( data.needsUpdate === true ) {

        gl.bindBuffer( bufferType, data.buffer );

        if ( data.updateRange === undefined || data.updateRange.count === -1 ) { // Not using update ranges

          gl.bufferSubData( bufferType, 0, data.array );

        } else if ( data.updateRange.count === 0 ) {

          console.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );

        } else {

          gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                   data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

          data.updateRange.count = 0; // reset range

        }

        data.needsUpdate = false;

      }

    }

  };

  this.update = function ( renderList ) {

    for ( var i = 0, ul = renderList.length; i < ul; i++ ) {

      var object = renderList[i].object;

      if ( object.material.visible !== false ) {

        updateObject( object );

      }

    }

  };

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

  var programIdCount = 0;

  function generateDefines( defines ) {

    var chunks = [];

    for ( var name in defines ) {

      var value = defines[ name ];

      if ( value === false ) continue;

      chunks.push( '#define ' + name + ' ' + value );

    }

    return chunks.join( '\n' );

  }

  function fetchUniformLocations( gl, program, identifiers ) {


    var uniforms = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveUniform( program , i );
      var name = info.name;
      var location = gl.getUniformLocation( program, name );

      //console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

      var suffixPos = name.lastIndexOf( '[0]' );
      if ( suffixPos !== -1 && suffixPos === name.length - 3 ) {

        uniforms[ name.substr( 0, suffixPos ) ] = location;

      }

      uniforms[ name ] = location;

    }

    return uniforms;

  }

  function fetchAttributeLocations( gl, program, identifiers ) {

    var attributes = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveAttrib( program , i );
      var name = info.name;

      //console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name);

      attributes[ name ] = gl.getAttribLocation( program, name );

    }

    return attributes;

  }

  function filterEmptyLine( string ) {

    return string !== '';

  }

  return function ( renderer, code, material, parameters ) {

    var gl = renderer.context;

    var defines = material.defines;
    var uniforms = material.__webglShader.uniforms;
    var attributes = material.attributes;

    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;

    var index0AttributeName = material.index0AttributeName;

    /*
    if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

      // programs with morphTargets displace position out of attribute 0

      index0AttributeName = 'position';

    }
    */

    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    }

    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    if ( parameters.envMap ) {

      switch ( material.envMap.mapping ) {

        case THREE.CubeReflectionMapping:
        case THREE.CubeRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          break;

        case THREE.EquirectangularReflectionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
          break;

        case THREE.SphericalReflectionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
          break;

      }

      switch ( material.envMap.mapping ) {

        case THREE.CubeRefractionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
          break;

      }

      switch ( material.combine ) {

        case THREE.MultiplyOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
          break;

        case THREE.MixOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
          break;

        case THREE.AddOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
          break;

      }

    }

    var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    // console.log( 'building new program ' );

    //

    var customDefines = generateDefines( defines );

    //

    var program = gl.createProgram();

    var prefixVertex, prefixFragment;

    if ( material instanceof THREE.RawShaderMaterial ) {

      prefixVertex = '';
      prefixFragment = '';

    } else {

      prefixVertex = [

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        customDefines,

        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

        '#define MAX_SHADOWS ' + parameters.maxShadows,

        '#define MAX_BONES ' + parameters.maxBones,

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED': '',

        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',


        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',

        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',

        '#ifdef USE_COLOR',

        ' attribute vec3 color;',

        '#endif',

        '#ifdef USE_MORPHTARGETS',

        ' attribute vec3 morphTarget0;',
        ' attribute vec3 morphTarget1;',
        ' attribute vec3 morphTarget2;',
        ' attribute vec3 morphTarget3;',

        ' #ifdef USE_MORPHNORMALS',

        '   attribute vec3 morphNormal0;',
        '   attribute vec3 morphNormal1;',
        '   attribute vec3 morphNormal2;',
        '   attribute vec3 morphNormal3;',

        ' #else',

        '   attribute vec3 morphTarget4;',
        '   attribute vec3 morphTarget5;',
        '   attribute vec3 morphTarget6;',
        '   attribute vec3 morphTarget7;',

        ' #endif',

        '#endif',

        '#ifdef USE_SKINNING',

        ' attribute vec4 skinIndex;',
        ' attribute vec4 skinWeight;',

        '#endif',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

      prefixFragment = [

        ( parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ) ? '#extension GL_OES_standard_derivatives : enable' : '',

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        customDefines,

        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

        '#define MAX_SHADOWS ' + parameters.maxShadows,

        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED': '',

        parameters.metal ? '#define METAL' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',

        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

    }

    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;

    var glVertexShader = new THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    var glFragmentShader = new THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    gl.attachShader( program, glVertexShader );
    gl.attachShader( program, glFragmentShader );

    if ( index0AttributeName !== undefined ) {

      // Force a particular attribute to index 0.
      // because potentially expensive emulation is done by browser if attribute 0 is disabled.
      // And, color, for example is often automatically bound to index 0 so disabling it

      gl.bindAttribLocation( program, 0, index0AttributeName );

    }

    gl.linkProgram( program );

    var programLogInfo = gl.getProgramInfoLog( program );
    var vertexErrorLogInfo = gl.getShaderInfoLog( glVertexShader );
    var fragmentErrorLogInfo = gl.getShaderInfoLog( glFragmentShader );

    if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

      console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLogInfo, vertexErrorLogInfo, fragmentErrorLogInfo );

    }

    if ( programLogInfo !== '' ) {

      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLogInfo );

    }

    // clean up

    gl.deleteShader( glVertexShader );
    gl.deleteShader( glFragmentShader );

    // set up caching for uniform locations

    var getUniforms = function() { return this._cachedUniforms; };

    this.getUniforms = function() {

      // fetch, cache, and next time just use a dumb accessor
      var uniforms = fetchUniformLocations( gl, program );
      this._cachedUniforms = uniforms;
      this.getUniforms = getUniforms;
      return uniforms;

    };

    // set up caching for attribute locations

    var getAttributes = function() { return this._cachedAttributes; };

    this.getAttributes = function() {

      var attributes = fetchAttributeLocations( gl, program );
      this._cachedAttributes = attributes;
      this.getAttributes = getAttributes;
      return attributes;

    };

    // DEPRECATED

    Object.defineProperties( this, {

      uniforms: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
          return this.getUniforms();

        }
      },

      attributes: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
          return this.getAttributes();

        }
      }

    });


    //

    this.id = programIdCount ++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;

    return this;

  };

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

  var addLineNumbers = function ( string ) {

    var lines = string.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    }

    return lines.join( '\n' );

  };

  return function ( gl, type, string ) {

    var shader = gl.createShader( type );

    gl.shaderSource( shader, string );
    gl.compileShader( shader );

    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

      console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    }

    if ( gl.getShaderInfoLog( shader ) !== '' ) {

      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    }

    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    return shader;

  };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

  var _gl = _renderer.context,
  _frustum = new THREE.Frustum(),
  _projScreenMatrix = new THREE.Matrix4(),

  _min = new THREE.Vector3(),
  _max = new THREE.Vector3(),

  _webglObjects = _objects.objects,
  _webglObjectsImmediate = _objects.objectsImmediate,

  _matrixPosition = new THREE.Vector3(),

  _renderList = [];

  // init

  var depthShader = THREE.ShaderLib[ "depthRGBA" ];
  var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

  var _depthMaterial = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader
   } );

  var _depthMaterialMorph = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true
  } );

  var _depthMaterialSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    skinning: true
  } );

  var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true,
    skinning: true
  } );

  _depthMaterial._shadowPass = true;
  _depthMaterialMorph._shadowPass = true;
  _depthMaterialSkin._shadowPass = true;
  _depthMaterialMorphSkin._shadowPass = true;

  //

  var scope = this;

  this.enabled = false;
  this.type = THREE.PCFShadowMap;
  this.cullFace = THREE.CullFaceFront;
  this.debug = false;
  this.cascade = false;

  this.render = function ( scene, camera ) {

    if ( scope.enabled === false ) return;

    var i, il, j, jl, n,

    shadowMap, shadowMatrix, shadowCamera,
    webglObject, object, material, light,

    lights = [],
    k = 0,

    fog = null;

    // set GL state for depth map

    _gl.clearColor( 1, 1, 1, 1 );
    _gl.disable( _gl.BLEND );

    _gl.enable( _gl.CULL_FACE );
    _gl.frontFace( _gl.CCW );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.FRONT );

    } else {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.state.setDepthTest( true );

    // preprocess lights
    //  - skip lights that are not casting shadows
    //  - create virtual lights for cascaded shadow maps

    for ( i = 0, il = _lights.length; i < il; i ++ ) {

      light = _lights[ i ];

      if ( ! light.castShadow ) continue;

      if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

        for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

          var virtualLight;

          if ( ! light.shadowCascadeArray[ n ] ) {

            virtualLight = createVirtualLight( light, n );
            virtualLight.originalCamera = camera;

            var gyro = new THREE.Gyroscope();
            gyro.position.copy( light.shadowCascadeOffset );

            gyro.add( virtualLight );
            gyro.add( virtualLight.target );

            camera.add( gyro );

            light.shadowCascadeArray[ n ] = virtualLight;

            //console.log( "Created virtualLight", virtualLight );

          } else {

            virtualLight = light.shadowCascadeArray[ n ];

          }

          updateVirtualLight( light, n );

          lights[ k ] = virtualLight;
          k ++;

        }

      } else {

        lights[ k ] = light;
        k ++;

      }

    }

    // render depth map

    for ( i = 0, il = lights.length; i < il; i ++ ) {

      light = lights[ i ];

      if ( ! light.shadowMap ) {

        var shadowFilter = THREE.LinearFilter;

        if ( scope.type === THREE.PCFSoftShadowMap ) {

          shadowFilter = THREE.NearestFilter;

        }

        var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

        light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
        light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

        light.shadowMatrix = new THREE.Matrix4();

      }

      if ( ! light.shadowCamera ) {

        if ( light instanceof THREE.SpotLight ) {

          light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

        } else if ( light instanceof THREE.DirectionalLight ) {

          light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

        } else {

          console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
          continue;

        }

        scene.add( light.shadowCamera );

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

      }

      if ( light.shadowCameraVisible && ! light.cameraHelper ) {

        light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
        scene.add( light.cameraHelper );

      }

      if ( light.isVirtual && virtualLight.originalCamera == camera ) {

        updateShadowCamera( camera, light );

      }

      shadowMap = light.shadowMap;
      shadowMatrix = light.shadowMatrix;
      shadowCamera = light.shadowCamera;

      //

      shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
      _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
      shadowCamera.lookAt( _matrixPosition );
      shadowCamera.updateMatrixWorld();

      shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

      //

      if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
      if ( light.shadowCameraVisible ) light.cameraHelper.update();

      // compute shadow matrix

      shadowMatrix.set(
        0.5, 0.0, 0.0, 0.5,
        0.0, 0.5, 0.0, 0.5,
        0.0, 0.0, 0.5, 0.5,
        0.0, 0.0, 0.0, 1.0
      );

      shadowMatrix.multiply( shadowCamera.projectionMatrix );
      shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

      // update camera matrices and frustum

      _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );

      // render shadow map

      _renderer.setRenderTarget( shadowMap );
      _renderer.clear();

      // set object matrices & frustum culling

      _renderList.length = 0;

      projectObject( scene, shadowCamera );


      // render regular objects

      var objectMaterial, useMorphing, useSkinning;

      for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

        webglObject = _renderList[ j ];

        object = webglObject.object;

        // culling is overriden globally for all objects
        // while rendering depth map

        // need to deal with MeshFaceMaterial somehow
        // in that case just use the first of material.materials for now
        // (proper solution would require to break objects by materials
        //  similarly to regular rendering and then set corresponding
        //  depth materials per each chunk instead of just once per object)

        objectMaterial = getObjectMaterial( object );

        useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
        useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

        if ( object.customDepthMaterial ) {

          material = object.customDepthMaterial;

        } else if ( useSkinning ) {

          material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

        } else if ( useMorphing ) {

          material = _depthMaterialMorph;

        } else {

          material = _depthMaterial;

        }

        _renderer.setMaterialFaces( objectMaterial );
        _renderer.renderBufferDirect( shadowCamera, _lights, fog, material, object );

      }

      // set matrices and render immediate objects

      for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

        webglObject = _webglObjectsImmediate[ j ];
        object = webglObject.object;

        if ( object.visible && object.castShadow ) {

          object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

          _renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

        }

      }

    }

    // restore GL state

    var clearColor = _renderer.getClearColor(),
    clearAlpha = _renderer.getClearAlpha();

    _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
    _gl.enable( _gl.BLEND );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.resetGLState();

  };

  function projectObject( object, shadowCamera ) {

    if ( object.visible === true ) {

      var webglObject = _objects.objects[ object.id ];

      if ( webglObject && object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

        object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
        _renderList.push( webglObject );

      }

      for ( var i = 0, l = object.children.length; i < l; i ++ ) {

        projectObject( object.children[ i ], shadowCamera );

      }

    }

  }

  function createVirtualLight( light, cascade ) {

    var virtualLight = new THREE.DirectionalLight();

    virtualLight.isVirtual = true;

    virtualLight.onlyShadow = true;
    virtualLight.castShadow = true;

    virtualLight.shadowCameraNear = light.shadowCameraNear;
    virtualLight.shadowCameraFar = light.shadowCameraFar;

    virtualLight.shadowCameraLeft = light.shadowCameraLeft;
    virtualLight.shadowCameraRight = light.shadowCameraRight;
    virtualLight.shadowCameraBottom = light.shadowCameraBottom;
    virtualLight.shadowCameraTop = light.shadowCameraTop;

    virtualLight.shadowCameraVisible = light.shadowCameraVisible;

    virtualLight.shadowDarkness = light.shadowDarkness;

    virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
    virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
    virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

    virtualLight.pointsWorld = [];
    virtualLight.pointsFrustum = [];

    var pointsWorld = virtualLight.pointsWorld,
      pointsFrustum = virtualLight.pointsFrustum;

    for ( var i = 0; i < 8; i ++ ) {

      pointsWorld[ i ] = new THREE.Vector3();
      pointsFrustum[ i ] = new THREE.Vector3();

    }

    var nearZ = light.shadowCascadeNearZ[ cascade ];
    var farZ = light.shadowCascadeFarZ[ cascade ];

    pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
    pointsFrustum[ 1 ].set(  1, - 1, nearZ );
    pointsFrustum[ 2 ].set( - 1,  1, nearZ );
    pointsFrustum[ 3 ].set(  1,  1, nearZ );

    pointsFrustum[ 4 ].set( - 1, - 1, farZ );
    pointsFrustum[ 5 ].set(  1, - 1, farZ );
    pointsFrustum[ 6 ].set( - 1,  1, farZ );
    pointsFrustum[ 7 ].set(  1,  1, farZ );

    return virtualLight;

  }

  // Synchronize virtual light with the original light

  function updateVirtualLight( light, cascade ) {

    var virtualLight = light.shadowCascadeArray[ cascade ];

    virtualLight.position.copy( light.position );
    virtualLight.target.position.copy( light.target.position );
    virtualLight.lookAt( virtualLight.target );

    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;

    virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

    var nearZ = light.shadowCascadeNearZ[ cascade ];
    var farZ = light.shadowCascadeFarZ[ cascade ];

    var pointsFrustum = virtualLight.pointsFrustum;

    pointsFrustum[ 0 ].z = nearZ;
    pointsFrustum[ 1 ].z = nearZ;
    pointsFrustum[ 2 ].z = nearZ;
    pointsFrustum[ 3 ].z = nearZ;

    pointsFrustum[ 4 ].z = farZ;
    pointsFrustum[ 5 ].z = farZ;
    pointsFrustum[ 6 ].z = farZ;
    pointsFrustum[ 7 ].z = farZ;

  }

  // Fit shadow camera's ortho frustum to camera frustum

  function updateShadowCamera( camera, light ) {

    var shadowCamera = light.shadowCamera,
      pointsFrustum = light.pointsFrustum,
      pointsWorld = light.pointsWorld;

    _min.set( Infinity, Infinity, Infinity );
    _max.set( - Infinity, - Infinity, - Infinity );

    for ( var i = 0; i < 8; i ++ ) {

      var p = pointsWorld[ i ];

      p.copy( pointsFrustum[ i ] );
      p.unproject( camera );

      p.applyMatrix4( shadowCamera.matrixWorldInverse );

      if ( p.x < _min.x ) _min.x = p.x;
      if ( p.x > _max.x ) _max.x = p.x;

      if ( p.y < _min.y ) _min.y = p.y;
      if ( p.y > _max.y ) _max.y = p.y;

      if ( p.z < _min.z ) _min.z = p.z;
      if ( p.z > _max.z ) _max.z = p.z;

    }

    shadowCamera.left = _min.x;
    shadowCamera.right = _max.x;
    shadowCamera.top = _max.y;
    shadowCamera.bottom = _min.y;

    // can't really fit near/far
    //shadowCamera.near = _min.z;
    //shadowCamera.far = _max.z;

    shadowCamera.updateProjectionMatrix();

  }

  // For the moment just ignore objects that have multiple materials with different animation methods
  // Only the first material will be taken into account for deciding which depth material to use for shadow maps

  function getObjectMaterial( object ) {

    return object.material instanceof THREE.MeshFaceMaterial
      ? object.material.materials[ 0 ]
      : object.material;

  }

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, paramThreeToGL ) {

  var _this = this;

  var newAttributes = new Uint8Array( 16 );
  var enabledAttributes = new Uint8Array( 16 );

  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;

  var currentDepthFunc = null;
  var currentDepthTest = null;
  var currentDepthWrite = null;

  var currentColorWrite = null;

  var currentDoubleSided = null;
  var currentFlipSided = null;

  var currentLineWidth = null;

  var currentPolygonOffset = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;

  var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

  var currentTextureSlot = undefined;
  var currentBoundTextures = {};

  this.initAttributes = function () {

    for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

      newAttributes[ i ] = 0;

    }

  };

  this.enableAttribute = function ( attribute ) {

    newAttributes[ attribute ] = 1;

    if ( enabledAttributes[ attribute ] === 0 ) {

      gl.enableVertexAttribArray( attribute );
      enabledAttributes[ attribute ] = 1;

    }

  };

  this.disableUnusedAttributes = function () {

    for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

      if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

  };

  this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

    if ( blending !== currentBlending ) {

      if ( blending === THREE.NoBlending ) {

        gl.disable( gl.BLEND );

      } else if ( blending === THREE.AdditiveBlending ) {

        gl.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

      } else if ( blending === THREE.SubtractiveBlending ) {

        // TODO: Find blendFuncSeparate() combination
        gl.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

      } else if ( blending === THREE.MultiplyBlending ) {

        // TODO: Find blendFuncSeparate() combination
        gl.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

      } else if ( blending === THREE.CustomBlending ) {

        gl.enable( gl.BLEND );

      } else {

        gl.enable( gl.BLEND );
        gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
        gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

      }

      currentBlending = blending;

    }

    if ( blending === THREE.CustomBlending ) {

      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;

      if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

        gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;

      }

      if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

        gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;

      }

    } else {

      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;

    }

  };

  this.setDepthFunc = function ( depthFunc ) {

      if ( currentDepthFunc !== depthFunc ) {

          if ( depthFunc ) {

              switch ( depthFunc ) {

                  case THREE.NeverDepth:

                      gl.depthFunc( gl.NEVER );
                      break;

                  case THREE.AlwaysDepth:

                      gl.depthFunc( gl.ALWAYS );
                      break;

                  case THREE.LessDepth:

                      gl.depthFunc( gl.LESS );
                      break;

                  case THREE.LessEqualDepth:

                      gl.depthFunc( gl.LEQUAL );
                      break;

                  case THREE.EqualDepth:

                      gl.depthFunc( gl.EQUAL );
                      break;

                  case THREE.GreaterEqualDepth:

                      gl.depthFunc( gl.GEQUAL );
                      break;

                  case THREE.GreaterDepth:

                      gl.depthFunc( gl.GREATER );
                      break;

                  case THREE.NotEqualDepth:

                      gl.depthFunc( gl.NOTEQUAL );
                      break;

                  default:

                        gl.depthFunc( gl.LEQUAL );
              }

          } else {

              gl.depthFunc( gl.LEQUAL );

          }

          currentDepthFunc = depthFunc;

      }

  };

  this.setDepthTest = function ( depthTest ) {

    if ( currentDepthTest !== depthTest ) {

      if ( depthTest ) {

        gl.enable( gl.DEPTH_TEST );

      } else {

        gl.disable( gl.DEPTH_TEST );

      }

      currentDepthTest = depthTest;

    }

  };

  this.setDepthWrite = function ( depthWrite ) {

    if ( currentDepthWrite !== depthWrite ) {

      gl.depthMask( depthWrite );
      currentDepthWrite = depthWrite;

    }

  };

  this.setColorWrite = function ( colorWrite ) {

    if ( currentColorWrite !== colorWrite ) {

      gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
      currentColorWrite = colorWrite;

    }

  };

  this.setDoubleSided = function ( doubleSided ) {

    if ( currentDoubleSided !== doubleSided ) {

      if ( doubleSided ) {

        gl.disable( gl.CULL_FACE );

      } else {

        gl.enable( gl.CULL_FACE );

      }

      currentDoubleSided = doubleSided;

    }

  };

  this.setFlipSided = function ( flipSided ) {

    if ( currentFlipSided !== flipSided ) {

      if ( flipSided ) {

        gl.frontFace( gl.CW );

      } else {

        gl.frontFace( gl.CCW );

      }

      currentFlipSided = flipSided;

    }

  };

  this.setLineWidth = function ( width ) {

    if ( width !== currentLineWidth ) {

      gl.lineWidth( width );

      currentLineWidth = width;

    }

  };

  this.setPolygonOffset = function ( polygonoffset, factor, units ) {

    if ( currentPolygonOffset !== polygonoffset ) {

      if ( polygonoffset ) {

        gl.enable( gl.POLYGON_OFFSET_FILL );

      } else {

        gl.disable( gl.POLYGON_OFFSET_FILL );

      }

      currentPolygonOffset = polygonoffset;

    }

    if ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

      gl.polygonOffset( factor, units );

      currentPolygonOffsetFactor = factor;
      currentPolygonOffsetUnits = units;

    }

  };

  // texture

  this.activeTexture = function ( webglSlot ) {

    if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    if ( currentTextureSlot !== webglSlot ) {

      gl.activeTexture( webglSlot );
      currentTextureSlot = webglSlot;

    }

  }

  this.bindTexture = function ( webglType, webglTexture ) {

    if ( currentTextureSlot === undefined ) {

      _this.activeTexture();

    }

    var boundTexture = currentBoundTextures[currentTextureSlot];

    if ( boundTexture === undefined ) {

      boundTexture = { type: undefined, texture: undefined };
      currentBoundTextures[currentTextureSlot] = boundTexture;

    }

    if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

      gl.bindTexture( webglType, webglTexture );

      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;

    }

  };

  this.compressedTexImage2D = function () {

    try {

      gl.compressedTexImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  this.texImage2D = function () {

    try {

      gl.texImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  //

  this.reset = function () {

    for ( var i = 0; i < enabledAttributes.length; i ++ ) {

      if ( enabledAttributes[ i ] === 1 ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

    currentBlending = null;
    currentDepthTest = null;
    currentDepthWrite = null;
    currentColorWrite = null;
    currentDoubleSided = null;
    currentFlipSided = null;

  };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

  var gl = renderer.context;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var hasVertexTexture;

  var tempTexture, occlusionTexture;

  var init = function () {

    var vertices = new Float32Array( [
      -1, -1,  0, 0,
       1, -1,  1, 0,
       1,  1,  1, 1,
      -1,  1,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    // buffers

    vertexBuffer     = gl.createBuffer();
    elementBuffer    = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    // textures

    tempTexture      = gl.createTexture();
    occlusionTexture = gl.createTexture();

    renderer.state.bindTexture( gl.TEXTURE_2D, tempTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    renderer.state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

    var shader;

    if ( hasVertexTexture ) {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "uniform sampler2D occlusionMap;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

              "vVisibility =        visibility.r / 9.0;",
              "vVisibility *= 1.0 - visibility.g / 9.0;",
              "vVisibility *=       visibility.b / 9.0;",
              "vVisibility *= 1.0 - visibility.a / 9.0;",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * vVisibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    } else {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "precision mediump float;",

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform sampler2D occlusionMap;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
              "visibility = ( 1.0 - visibility / 4.0 );",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * visibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    }

    program = createProgram( shader );

    attributes = {
      vertex: gl.getAttribLocation ( program, "position" ),
      uv:     gl.getAttribLocation ( program, "uv" )
    };

    uniforms = {
      renderType:     gl.getUniformLocation( program, "renderType" ),
      map:            gl.getUniformLocation( program, "map" ),
      occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
      opacity:        gl.getUniformLocation( program, "opacity" ),
      color:          gl.getUniformLocation( program, "color" ),
      scale:          gl.getUniformLocation( program, "scale" ),
      rotation:       gl.getUniformLocation( program, "rotation" ),
      screenPosition: gl.getUniformLocation( program, "screenPosition" )
    };

  };

  /*
   * Render lens flares
   * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
   *         reads these back and calculates occlusion.
   */

  this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

    if ( flares.length === 0 ) return;

    var tempPosition = new THREE.Vector3();

    var invAspect = viewportHeight / viewportWidth,
      halfViewportWidth = viewportWidth * 0.5,
      halfViewportHeight = viewportHeight * 0.5;

    var size = 16 / viewportHeight,
      scale = new THREE.Vector2( size * invAspect, size );

    var screenPosition = new THREE.Vector3( 1, 1, 0 ),
      screenPositionPixels = new THREE.Vector2( 1, 1 );

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    renderer.state.initAttributes();
    renderer.state.enableAttribute( attributes.vertex );
    renderer.state.enableAttribute( attributes.uv );
    renderer.state.disableUnusedAttributes();

    // loop through all lens flares to update their occlusion and positions
    // setup gl and common used attribs/unforms

    gl.uniform1i( uniforms.occlusionMap, 0 );
    gl.uniform1i( uniforms.map, 1 );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.disable( gl.CULL_FACE );
    gl.depthMask( false );

    for ( var i = 0, l = flares.length; i < l; i ++ ) {

      size = 16 / viewportHeight;
      scale.set( size * invAspect, size );

      // calc object screen position

      var flare = flares[ i ];

      tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

      tempPosition.applyMatrix4( camera.matrixWorldInverse );
      tempPosition.applyProjection( camera.projectionMatrix );

      // setup arrays for gl programs

      screenPosition.copy( tempPosition );

      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

      // screen cull

      if ( hasVertexTexture || (
        screenPositionPixels.x > 0 &&
        screenPositionPixels.x < viewportWidth &&
        screenPositionPixels.y > 0 &&
        screenPositionPixels.y < viewportHeight ) ) {

        // save current RGB to temp texture

        renderer.state.activeTexture( gl.TEXTURE1 );
        renderer.state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // render pink quad

        gl.uniform1i( uniforms.renderType, 0 );
        gl.uniform2f( uniforms.scale, scale.x, scale.y );
        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

        gl.disable( gl.BLEND );
        gl.enable( gl.DEPTH_TEST );

        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // copy result to occlusionMap

        renderer.state.activeTexture( gl.TEXTURE0 );
        renderer.state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // restore graphics

        gl.uniform1i( uniforms.renderType, 1 );
        gl.disable( gl.DEPTH_TEST );

        renderer.state.activeTexture( gl.TEXTURE1 );
        renderer.state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // update object positions

        flare.positionScreen.copy( screenPosition );

        if ( flare.customUpdateCallback ) {

          flare.customUpdateCallback( flare );

        } else {

          flare.updateLensFlares();

        }

        // render flares

        gl.uniform1i( uniforms.renderType, 2 );
        gl.enable( gl.BLEND );

        for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

          var sprite = flare.lensFlares[ j ];

          if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;

            size = sprite.size * sprite.scale / viewportHeight;

            scale.x = size * invAspect;
            scale.y = size;

            gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
            gl.uniform2f( uniforms.scale, scale.x, scale.y );
            gl.uniform1f( uniforms.rotation, sprite.rotation );

            gl.uniform1f( uniforms.opacity, sprite.opacity );
            gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

            renderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
            renderer.setTexture( sprite.texture, 1 );

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

          }

        }

      }

    }

    // restore gl

    gl.enable( gl.CULL_FACE );
    gl.enable( gl.DEPTH_TEST );
    gl.depthMask( true );

    renderer.resetGLState();

  };

  function createProgram ( shader ) {

    var program = gl.createProgram();

    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    var prefix = "precision " + renderer.getPrecision() + " float;\n";

    gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    gl.compileShader( fragmentShader );
    gl.compileShader( vertexShader );

    gl.attachShader( program, fragmentShader );
    gl.attachShader( program, vertexShader );

    gl.linkProgram( program );

    return program;

  }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

  var gl = renderer.context;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;

  var texture;

  // decompose matrixWorld

  var spritePosition = new THREE.Vector3();
  var spriteRotation = new THREE.Quaternion();
  var spriteScale = new THREE.Vector3();

  var init = function () {

    var vertices = new Float32Array( [
      - 0.5, - 0.5,  0, 0,
        0.5, - 0.5,  1, 0,
        0.5,   0.5,  1, 1,
      - 0.5,   0.5,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    vertexBuffer  = gl.createBuffer();
    elementBuffer = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    program = createProgram();

    attributes = {
      position:     gl.getAttribLocation ( program, 'position' ),
      uv:         gl.getAttribLocation ( program, 'uv' )
    };

    uniforms = {
      uvOffset:     gl.getUniformLocation( program, 'uvOffset' ),
      uvScale:      gl.getUniformLocation( program, 'uvScale' ),

      rotation:     gl.getUniformLocation( program, 'rotation' ),
      scale:        gl.getUniformLocation( program, 'scale' ),

      color:        gl.getUniformLocation( program, 'color' ),
      map:        gl.getUniformLocation( program, 'map' ),
      opacity:      gl.getUniformLocation( program, 'opacity' ),

      modelViewMatrix:  gl.getUniformLocation( program, 'modelViewMatrix' ),
      projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

      fogType:      gl.getUniformLocation( program, 'fogType' ),
      fogDensity:     gl.getUniformLocation( program, 'fogDensity' ),
      fogNear:      gl.getUniformLocation( program, 'fogNear' ),
      fogFar:       gl.getUniformLocation( program, 'fogFar' ),
      fogColor:     gl.getUniformLocation( program, 'fogColor' ),

      alphaTest:      gl.getUniformLocation( program, 'alphaTest' )
    };

    var canvas = document.createElement( 'canvas' );
    canvas.width = 8;
    canvas.height = 8;

    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 0, 8, 8 );

    texture = new THREE.Texture( canvas );
    texture.needsUpdate = true;

  };

  this.render = function ( scene, camera ) {

    if ( sprites.length === 0 ) return;

    // setup gl

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    renderer.state.initAttributes();
    renderer.state.enableAttribute( attributes.position );
    renderer.state.enableAttribute( attributes.uv );
    renderer.state.disableUnusedAttributes();

    gl.disable( gl.CULL_FACE );
    gl.enable( gl.BLEND );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    renderer.state.activeTexture( gl.TEXTURE0 );
    gl.uniform1i( uniforms.map, 0 );

    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;

    if ( fog ) {

      gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

      if ( fog instanceof THREE.Fog ) {

        gl.uniform1f( uniforms.fogNear, fog.near );
        gl.uniform1f( uniforms.fogFar, fog.far );

        gl.uniform1i( uniforms.fogType, 1 );
        oldFogType = 1;
        sceneFogType = 1;

      } else if ( fog instanceof THREE.FogExp2 ) {

        gl.uniform1f( uniforms.fogDensity, fog.density );

        gl.uniform1i( uniforms.fogType, 2 );
        oldFogType = 2;
        sceneFogType = 2;

      }

    } else {

      gl.uniform1i( uniforms.fogType, 0 );
      oldFogType = 0;
      sceneFogType = 0;

    }


    // update positions and sort

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];

      sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
      sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

    }

    sprites.sort( painterSortStable );

    // render all sprites

    var scale = [];

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];
      var material = sprite.material;

      gl.uniform1f( uniforms.alphaTest, material.alphaTest );
      gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

      sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

      scale[ 0 ] = spriteScale.x;
      scale[ 1 ] = spriteScale.y;

      var fogType = 0;

      if ( scene.fog && material.fog ) {

        fogType = sceneFogType;

      }

      if ( oldFogType !== fogType ) {

        gl.uniform1i( uniforms.fogType, fogType );
        oldFogType = fogType;

      }

      if ( material.map !== null ) {

        gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
        gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

      } else {

        gl.uniform2f( uniforms.uvOffset, 0, 0 );
        gl.uniform2f( uniforms.uvScale, 1, 1 );

      }

      gl.uniform1f( uniforms.opacity, material.opacity );
      gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

      gl.uniform1f( uniforms.rotation, material.rotation );
      gl.uniform2fv( uniforms.scale, scale );

      renderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
      renderer.state.setDepthTest( material.depthTest );
      renderer.state.setDepthWrite( material.depthWrite );

      if ( material.map && material.map.image && material.map.image.width ) {

        renderer.setTexture( material.map, 0 );

      } else {

        renderer.setTexture( texture, 0 );

      }

      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    }

    // restore gl

    gl.enable( gl.CULL_FACE );

    renderer.resetGLState();

  };

  function createProgram () {

    var program = gl.createProgram();

    var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    gl.shaderSource( vertexShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',

      'attribute vec2 position;',
      'attribute vec2 uv;',

      'varying vec2 vUV;',

      'void main() {',

        'vUV = uvOffset + uv * uvScale;',

        'vec2 alignedPosition = position * scale;',

        'vec2 rotatedPosition;',
        'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

        'vec4 finalPosition;',

        'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        'finalPosition.xy += rotatedPosition;',
        'finalPosition = projectionMatrix * finalPosition;',

        'gl_Position = finalPosition;',

      '}'

    ].join( '\n' ) );

    gl.shaderSource( fragmentShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',

      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',

      'varying vec2 vUV;',

      'void main() {',

        'vec4 texture = texture2D( map, vUV );',

        'if ( texture.a < alphaTest ) discard;',

        'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

        'if ( fogType > 0 ) {',

          'float depth = gl_FragCoord.z / gl_FragCoord.w;',
          'float fogFactor = 0.0;',

          'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

          '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

          '}',

          'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

        '}',

      '}'

    ].join( '\n' ) );

    gl.compileShader( vertexShader );
    gl.compileShader( fragmentShader );

    gl.attachShader( program, vertexShader );
    gl.attachShader( program, fragmentShader );

    gl.linkProgram( program );

    return program;

  }

  function painterSortStable ( a, b ) {

    if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return b.id - a.id;

    }

  }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

  merge: function ( geometry1, geometry2, materialIndexOffset ) {

    console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    var matrix;

    if ( geometry2 instanceof THREE.Mesh ) {

      geometry2.matrixAutoUpdate && geometry2.updateMatrix();

      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;

    }

    geometry1.merge( geometry2, matrix, materialIndexOffset );

  },

  center: function ( geometry ) {

    console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    return geometry.center();

  }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

  crossOrigin: undefined,

  loadTexture: function ( url, mapping, onLoad, onError ) {

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.Texture( undefined, mapping );

    loader.load( url, function ( image ) {

      texture.image = image;
      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture );

    }, undefined, function ( event ) {

      if ( onError ) onError( event );

    } );

    texture.sourceFile = url;

    return texture;

  },

  loadTextureCube: function ( array, mapping, onLoad, onError ) {

    var images = [];

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.CubeTexture( images, mapping );

    // no flipping needed for cube textures

    texture.flipY = false;

    var loaded = 0;

    var loadTexture = function ( i ) {

      loader.load( array[ i ], function ( image ) {

        texture.images[ i ] = image;

        loaded += 1;

        if ( loaded === 6 ) {

          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }

      }, undefined, onError );

    };

    for ( var i = 0, il = array.length; i < il; ++ i ) {

      loadTexture( i );

    }

    return texture;

  },

  loadCompressedTexture: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

  },

  loadCompressedTextureCube: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

  },

  getNormalMap: function ( image, depth ) {

    // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

    var cross = function ( a, b ) {

      return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

    };

    var subtract = function ( a, b ) {

      return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

    };

    var normalize = function ( a ) {

      var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
      return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

    };

    depth = depth | 1;

    var width = image.width;
    var height = image.height;

    var canvas = document.createElement( 'canvas' );
    canvas.width = width;
    canvas.height = height;

    var context = canvas.getContext( '2d' );
    context.drawImage( image, 0, 0 );

    var data = context.getImageData( 0, 0, width, height ).data;
    var imageData = context.createImageData( width, height );
    var output = imageData.data;

    for ( var x = 0; x < width; x ++ ) {

      for ( var y = 0; y < height; y ++ ) {

        var ly = y - 1 < 0 ? 0 : y - 1;
        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
        var lx = x - 1 < 0 ? 0 : x - 1;
        var ux = x + 1 > width - 1 ? width - 1 : x + 1;

        var points = [];
        var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
        points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

        var normals = [];
        var num_points = points.length;

        for ( var i = 0; i < num_points; i ++ ) {

          var v1 = points[ i ];
          var v2 = points[ ( i + 1 ) % num_points ];
          v1 = subtract( v1, origin );
          v2 = subtract( v2, origin );
          normals.push( normalize( cross( v1, v2 ) ) );

        }

        var normal = [ 0, 0, 0 ];

        for ( var i = 0; i < normals.length; i ++ ) {

          normal[ 0 ] += normals[ i ][ 0 ];
          normal[ 1 ] += normals[ i ][ 1 ];
          normal[ 2 ] += normals[ i ][ 2 ];

        }

        normal[ 0 ] /= normals.length;
        normal[ 1 ] /= normals.length;
        normal[ 2 ] /= normals.length;

        var idx = ( y * width + x ) * 4;

        output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
        output[ idx + 3 ] = 255;

      }

    }

    context.putImageData( imageData, 0, 0 );

    return canvas;

  },

  generateDataTexture: function ( width, height, color ) {

    var size = width * height;
    var data = new Uint8Array( 3 * size );

    var r = Math.floor( color.r * 255 );
    var g = Math.floor( color.g * 255 );
    var b = Math.floor( color.b * 255 );

    for ( var i = 0; i < size; i ++ ) {

      data[ i * 3 ]      = r;
      data[ i * 3 + 1 ] = g;
      data[ i * 3 + 2 ] = b;

    }

    var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
    texture.needsUpdate = true;

    return texture;

  }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

  createMultiMaterialObject: function ( geometry, materials ) {

    var group = new THREE.Object3D();

    for ( var i = 0, l = materials.length; i < l; i ++ ) {

      group.add( new THREE.Mesh( geometry, materials[ i ] ) );

    }

    return group;

  },

  detach: function ( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  },

  attach: function ( child, scene, parent ) {

    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse( parent.matrixWorld );
    child.applyMatrix( matrixWorldInverse );

    scene.remove( child );
    parent.add( child );

  }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *  Triangulation ported from AS3
 *    Simple Polygon Triangulation
 *    http://actionsnippet.com/?p=1462
 *
 *  A Method to triangulate shapes with holes
 *    http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

  faces: {},

  // Just for now. face[weight][style]

  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,

  getFace: function () {

    try {

      return this.faces[ this.face ][ this.weight ][ this.style ];

    } catch (e) {

      throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

    }

  },

  loadFace: function ( data ) {

    var family = data.familyName.toLowerCase();

    var ThreeFont = this;

    ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

    ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    return data;

  },

  drawText: function ( text ) {

    // RenderText

    var i,
      face = this.getFace(),
      scale = this.size / face.resolution,
      offset = 0,
      chars = String( text ).split( '' ),
      length = chars.length;

    var fontPaths = [];

    for ( i = 0; i < length; i ++ ) {

      var path = new THREE.Path();

      var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
      offset += ret.offset;

      fontPaths.push( ret.path );

    }

    // get the width

    var width = offset / 2;
    //
    // for ( p = 0; p < allPts.length; p++ ) {
    //
    //  allPts[ p ].x -= width;
    //
    // }

    //var extract = this.extractPoints( allPts, characterPts );
    //extract.contour = allPts;

    //extract.paths = fontPaths;
    //extract.offset = width;

    return { paths: fontPaths, offset: width };

  },




  extractGlyphPoints: function ( c, face, scale, offset, path ) {

    var pts = [];

    var i, i2, divisions,
      outline, action, length,
      scaleX, scaleY,
      x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
      laste,
      glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

    if ( ! glyph ) return;

    if ( glyph.o ) {

      outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
      length = outline.length;

      scaleX = scale;
      scaleY = scale;

      for ( i = 0; i < length; ) {

        action = outline[ i ++ ];

        //console.log( action );

        switch ( action ) {

        case 'm':

          // Move To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;

          path.moveTo( x, y );
          break;

        case 'l':

          // Line To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;
          path.lineTo( x, y );
          break;

        case 'q':

          // QuadraticCurveTo

          cpx  = outline[ i ++ ] * scaleX + offset;
          cpy  = outline[ i ++ ] * scaleY;
          cpx1 = outline[ i ++ ] * scaleX + offset;
          cpy1 = outline[ i ++ ] * scaleY;

          path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
              THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
            }

          }

          break;

        case 'b':

          // Cubic Bezier Curve

          cpx  = outline[ i ++ ] *  scaleX + offset;
          cpy  = outline[ i ++ ] *  scaleY;
          cpx1 = outline[ i ++ ] *  scaleX + offset;
          cpy1 = outline[ i ++ ] *  scaleY;
          cpx2 = outline[ i ++ ] *  scaleX + offset;
          cpy2 = outline[ i ++ ] *  scaleY;

          path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
              THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

            }

          }

          break;

        }

      }
    }



    return { offset: glyph.ha * scale, path:path };
  }

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

  // Parameters

  parameters = parameters || {};

  var size = parameters.size !== undefined ? parameters.size : 100;
  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
  var style = parameters.style !== undefined ? parameters.style : 'normal';

  THREE.FontUtils.size = size;
  THREE.FontUtils.divisions = curveSegments;

  THREE.FontUtils.face = font;
  THREE.FontUtils.weight = weight;
  THREE.FontUtils.style = style;

  // Get a Font data json object

  var data = THREE.FontUtils.drawText( text );

  var paths = data.paths;
  var shapes = [];

  for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  }

  return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

  var EPSILON = 0.0000000001;

  // takes in an contour array and returns

  var process = function ( contour, indices ) {

    var n = contour.length;

    if ( n < 3 ) return null;

    var result = [],
      verts = [],
      vertIndices = [];

    /* we want a counter-clockwise polygon in verts */

    var u, v, w;

    if ( area( contour ) > 0.0 ) {

      for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    } else {

      for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    }

    var nv = n;

    /*  remove nv - 2 vertices, creating 1 triangle every time */

    var count = 2 * nv;   /* error detection */

    for ( v = nv - 1; nv > 2; ) {

      /* if we loop, it is probably a non-simple polygon */

      if ( ( count -- ) <= 0 ) {

        //** Triangulate: ERROR - probable bad polygon!

        //throw ( "Warning, unable to triangulate polygon!" );
        //return null;
        // Sometimes warning is fine, especially polygons are triangulated in reverse.
        console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

        if ( indices ) return vertIndices;
        return result;

      }

      /* three consecutive vertices in current polygon, <u,v,w> */

      u = v;    if ( nv <= u ) u = 0;     /* previous */
      v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
      w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

      if ( snip( contour, u, v, w, nv, verts ) ) {

        var a, b, c, s, t;

        /* true names of the vertices */

        a = verts[ u ];
        b = verts[ v ];
        c = verts[ w ];

        /* output Triangle */

        result.push( [ contour[ a ],
          contour[ b ],
          contour[ c ] ] );


        vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

        /* remove v from the remaining polygon */

        for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

          verts[ s ] = verts[ t ];

        }

        nv --;

        /* reset error detection counter */

        count = 2 * nv;

      }

    }

    if ( indices ) return vertIndices;
    return result;

  };

  // calculate area of the contour polygon

  var area = function ( contour ) {

    var n = contour.length;
    var a = 0.0;

    for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

      a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    }

    return a * 0.5;

  };

  var snip = function ( contour, u, v, w, n, verts ) {

    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;

    ax = contour[ verts[ u ] ].x;
    ay = contour[ verts[ u ] ].y;

    bx = contour[ verts[ v ] ].x;
    by = contour[ verts[ v ] ].y;

    cx = contour[ verts[ w ] ].x;
    cy = contour[ verts[ w ] ].y;

    if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;

    aX = cx - bx;  aY = cy - by;
    bX = ax - cx;  bY = ay - cy;
    cX = bx - ax;  cY = by - ay;

    for ( p = 0; p < n; p ++ ) {

      px = contour[ verts[ p ] ].x;
      py = contour[ verts[ p ] ].y;

      if ( ( ( px === ax ) && ( py === ay ) ) ||
         ( ( px === bx ) && ( py === by ) ) ||
         ( ( px === cx ) && ( py === cy ) ) ) continue;

      apx = px - ax;  apy = py - ay;
      bpx = px - bx;  bpy = py - by;
      cpx = px - cx;  cpy = py - cy;

      // see if p is inside triangle abc

      aCROSSbp = aX * bpy - aY * bpx;
      cCROSSap = cX * apy - cY * apx;
      bCROSScp = bX * cpy - bY * cpx;

      if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

    }

    return true;

  };


  namespace.Triangulate = process;
  namespace.Triangulate.area = area;

  return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API

THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

  THREE.Object3D.call( this );

  this.type = 'Audio';

  this.context = listener.context;
  this.source = this.context.createBufferSource();
  this.source.onended = this.onEnded.bind(this);

  this.gain = this.context.createGain();
  this.gain.connect( this.context.destination );

  this.panner = this.context.createPanner();
  this.panner.connect( this.gain );

  this.autoplay = false;

  this.startTime = 0;
  this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

  var scope = this;

  var request = new XMLHttpRequest();
  request.open( 'GET', file, true );
  request.responseType = 'arraybuffer';
  request.onload = function ( e ) {

    scope.context.decodeAudioData( this.response, function ( buffer ) {

      scope.source.buffer = buffer;

      if( scope.autoplay ) scope.play();

    } );

  };
  request.send();

  return this;

};

THREE.Audio.prototype.play = function () {

  if ( this.isPlaying === true ) {

    console.warn( 'THREE.Audio: Audio is already playing.' );
    return;

  }

  var source = this.context.createBufferSource();

  source.buffer = this.source.buffer;
  source.loop = this.source.loop;
  source.onended = this.source.onended;
  source.connect( this.panner );
  source.start( 0, this.startTime );

  this.isPlaying = true;

  this.source = source;

};

THREE.Audio.prototype.pause = function () {

  this.source.stop();
  this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

  this.source.stop();
  this.startTime = 0;

};

THREE.Audio.prototype.onEnded = function() {

  this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

  this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

  this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

  this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.setVolume = function ( value ) {

  this.gain.gain.value = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();

  return function ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    position.setFromMatrixPosition( this.matrixWorld );

    this.panner.setPosition( position.x, position.y, position.z );

  };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

  THREE.Object3D.call( this );

  this.type = 'AudioListener';

  this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3();

  var orientation = new THREE.Vector3();

  return function ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    var listener = this.context.listener;
    var up = this.up;

    this.matrixWorld.decompose( position, quaternion, scale );

    orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );

    listener.setPosition( position.x, position.y, position.z );
    listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *  Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//  - t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

  console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
  return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPoint( d / divisions ) );

  }

  return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPointAt( d / divisions ) );

  }

  return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

  var lengths = this.getLengths();
  return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

  if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;

  if ( this.cacheArcLengths
    && ( this.cacheArcLengths.length === divisions + 1 )
    && ! this.needsUpdate) {

    //console.log( "cached", this.cacheArcLengths );
    return this.cacheArcLengths;

  }

  this.needsUpdate = false;

  var cache = [];
  var current, last = this.getPoint( 0 );
  var p, sum = 0;

  cache.push( 0 );

  for ( p = 1; p <= divisions; p ++ ) {

    current = this.getPoint ( p / divisions );
    sum += current.distanceTo( last );
    cache.push( sum );
    last = current;

  }

  this.cacheArcLengths = cache;

  return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
  this.needsUpdate = true;
  this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

  var arcLengths = this.getLengths();

  var i = 0, il = arcLengths.length;

  var targetArcLength; // The targeted u distance value to get

  if ( distance ) {

    targetArcLength = distance;

  } else {

    targetArcLength = u * arcLengths[ il - 1 ];

  }

  //var time = Date.now();

  // binary search for the index with largest value smaller than target u distance

  var low = 0, high = il - 1, comparison;

  while ( low <= high ) {

    i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    comparison = arcLengths[ i ] - targetArcLength;

    if ( comparison < 0 ) {

      low = i + 1;

    } else if ( comparison > 0 ) {

      high = i - 1;

    } else {

      high = i;
      break;

      // DONE

    }

  }

  i = high;

  //console.log('b' , i, low, high, Date.now()- time);

  if ( arcLengths[ i ] === targetArcLength ) {

    var t = i / ( il - 1 );
    return t;

  }

  // we could get finer grain at lengths, or use simple interpolatation between two points

  var lengthBefore = arcLengths[ i ];
  var lengthAfter = arcLengths[ i + 1 ];

  var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

  var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

  var t = ( i + segmentFraction ) / ( il - 1 );

  return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

  var delta = 0.0001;
  var t1 = t - delta;
  var t2 = t + delta;

  // Capping in case of danger

  if ( t1 < 0 ) t1 = 0;
  if ( t2 > 1 ) t2 = 1;

  var pt1 = this.getPoint( t1 );
  var pt2 = this.getPoint( t2 );

  var vec = pt2.clone().sub(pt1);
  return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getTangent( t );

};





/**************************************************************
 *  Utils
 **************************************************************/

THREE.Curve.Utils = {

  tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

  },

  // Puay Bing, thanks for helping with this derivative!

  tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

    return - 3 * p0 * (1 - t) * (1 - t)  +
      3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
      6 * t *  p2 * (1 - t) - 3 * t * t * p2 +
      3 * t * t * p3;

  },

  tangentSpline: function ( t, p0, p1, p2, p3 ) {

    // To check if my formulas are correct

    var h00 = 6 * t * t - 6 * t;  // derived from 2t^3  3t^2 + 1
    var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
    var h01 = - 6 * t * t + 6 * t;  //  2t3 + 3t2
    var h11 = 3 * t * t - 2 * t;  // t3  t2

    return h00 + h10 + h01 + h11;

  },

  // Catmull-Rom

  interpolate: function( p0, p1, p2, p3, t ) {

    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};


// TODO: Transformation for Curves?

/**************************************************************
 *  3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

  constructor.prototype = Object.create( THREE.Curve.prototype );
  constructor.prototype.constructor = constructor;
  constructor.prototype.getPoint = getPointFunc;

  return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *  Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

  this.curves = [];
  this.bends = [];

  this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

  this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
  // TODO
  // If the ending of curve is not connected to the starting
  // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
  // TODO Test
  // and verify for vector3 (needs to implement equals)
  // Add a line curve if start and end of lines are not connected
  var startPoint = this.curves[0].getPoint(0);
  var endPoint = this.curves[this.curves.length - 1].getPoint(1);

  if (! startPoint.equals(endPoint)) {
    this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
  }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0, diff, curve;

  // To think about boundaries points.

  while ( i < curveLengths.length ) {

    if ( curveLengths[ i ] >= d ) {

      diff = curveLengths[ i ] - d;
      curve = this.curves[ i ];

      var u = 1 - diff / curve.getLength();

      return curve.getPointAt( u );

    }

    i ++;

  }

  return null;

  // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

  var lens = this.getCurveLengths();
  return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

  // We use cache values if curves and cache array are same length

  if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    return this.cacheLengths;

  }

  // Get length of subsurve
  // Push sums into cached array

  var lengths = [], sums = 0;
  var i, il = this.curves.length;

  for ( i = 0; i < il; i ++ ) {

    sums += this.curves[ i ].getLength();
    lengths.push( sums );

  }

  this.cacheLengths = lengths;

  return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

  var points = this.getPoints();

  var maxX, maxY, maxZ;
  var minX, minY, minZ;

  maxX = maxY = Number.NEGATIVE_INFINITY;
  minX = minY = Number.POSITIVE_INFINITY;

  var p, i, il, sum;

  var v3 = points[0] instanceof THREE.Vector3;

  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

  for ( i = 0, il = points.length; i < il; i ++ ) {

    p = points[ i ];

    if ( p.x > maxX ) maxX = p.x;
    else if ( p.x < minX ) minX = p.x;

    if ( p.y > maxY ) maxY = p.y;
    else if ( p.y < minY ) minY = p.y;

    if ( v3 ) {

      if ( p.z > maxZ ) maxZ = p.z;
      else if ( p.z < minZ ) minZ = p.z;

    }

    sum.add( p );

  }

  var ret = {

    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY

  };

  if ( v3 ) {

    ret.maxZ = maxZ;
    ret.minZ = minZ;

  }

  return ret;

};

/**************************************************************
 *  Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

  var pts = this.getPoints( divisions, true );
  return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

  var pts = this.getSpacedPoints( divisions, true );
  return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < points.length; i ++ ) {

    geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

  }

  return geometry;

};


/**************************************************************
 *  Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

  this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

  var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

  var oldPts = this.getSpacedPoints( segments );

  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

  var bounds = this.getBoundingBox();

  var i, il, p, oldX, oldY, xNorm;

  for ( i = 0, il = oldPts.length; i < il; i ++ ) {

    p = oldPts[ i ];

    oldX = p.x;
    oldY = p.y;

    xNorm = oldX / bounds.maxX;

    // If using actual distance, for length > path, requires line extrusions
    //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

    xNorm = path.getUtoTmapping( xNorm, oldX );

    // check for out of bounds?

    var pathPt = path.getPoint( xNorm );
    var normal = path.getTangent( xNorm );
    normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

    p.x = pathPt.x + normal.x;
    p.y = pathPt.y + normal.y;

  }

  return oldPts;

};

// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

  THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

  var translationObject = new THREE.Vector3();
  var quaternionObject = new THREE.Quaternion();
  var scaleObject = new THREE.Vector3();

  var translationWorld = new THREE.Vector3();
  var quaternionWorld = new THREE.Quaternion();
  var scaleWorld = new THREE.Vector3();

  return function ( force ) {

    this.matrixAutoUpdate && this.updateMatrix();

    // update matrixWorld

    if ( this.matrixWorldNeedsUpdate || force ) {

      if ( this.parent ) {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

        this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
        this.matrix.decompose( translationObject, quaternionObject, scaleObject );

        this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


      } else {

        this.matrixWorld.copy( this.matrix );

      }


      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  };

}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

  THREE.CurvePath.call(this);

  this.actions = [];

  if ( points ) {

    this.fromPoints( points );

  }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
  BEZIER_CURVE_TO: 'bezierCurveTo',     // Bezier cubic curve
  CSPLINE_THRU: 'splineThru',       // Catmull-rom spline
  ARC: 'arc',               // Circle
  ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

  this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

    this.lineTo( vectors[ v ].x, vectors[ v ].y );

  }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );
  this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
                        new THREE.Vector2( aCPx, aCPy ),
                        new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
                         aCP2x, aCP2y,
                         aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
                      new THREE.Vector2( aCP1x, aCP1y ),
                      new THREE.Vector2( aCP2x, aCP2y ),
                      new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

  var args = Array.prototype.slice.call( arguments );
  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];
//---
  var npts = [ new THREE.Vector2( x0, y0 ) ];
  Array.prototype.push.apply( npts, pts );

  var curve = new THREE.SplineCurve( npts );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absarc(aX + x0, aY + y0, aRadius,
    aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {
  this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var args = Array.prototype.slice.call( arguments );
  var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
                  aStartAngle, aEndAngle, aClockwise );
  this.curves.push( curve );

  var lastPoint = curve.getPoint(1);
  args.push(lastPoint.x);
  args.push(lastPoint.y);

  this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

  if ( ! divisions ) divisions = 40;

  var points = [];

  for ( var i = 0; i < divisions; i ++ ) {

    points.push( this.getPoint( i / divisions ) );

    //if( !this.getPoint( i / divisions ) ) throw "DIE";

  }

  // if ( closedPath ) {
  //
  //  points.push( points[ 0 ] );
  //
  // }

  return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

  if (this.useSpacedPoints) {
    console.log('tata');
    return this.getSpacedPoints( divisions, closedPath );
  }

  divisions = divisions || 12;

  var points = [];

  var i, il, item, action, args;
  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
    laste, j,
    t, tx, ty;

  for ( i = 0, il = this.actions.length; i < il; i ++ ) {

    item = this.actions[ i ];

    action = item.action;
    args = item.args;

    switch ( action ) {

    case THREE.PathActions.MOVE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.LINE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.QUADRATIC_CURVE_TO:

      cpx  = args[ 2 ];
      cpy  = args[ 3 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }

      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
        ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.BEZIER_CURVE_TO:

      cpx  = args[ 4 ];
      cpy  = args[ 5 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      cpx2 = args[ 2 ];
      cpy2 = args[ 3 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }


      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
        ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.CSPLINE_THRU:

      laste = this.actions[ i - 1 ].args;

      var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
      var spts = [ last ];

      var n = divisions * args[ 0 ].length;

      spts = spts.concat( args[ 0 ] );

      var spline = new THREE.SplineCurve( spts );

      for ( j = 1; j <= n; j ++ ) {

        points.push( spline.getPointAt( j / n ) ) ;

      }

      break;

    case THREE.PathActions.ARC:

      var aX = args[ 0 ], aY = args[ 1 ],
        aRadius = args[ 2 ],
        aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
        aClockwise = !! args[ 5 ];

      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + aRadius * Math.cos( angle );
        ty = aY + aRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    case THREE.PathActions.ELLIPSE:

      var aX = args[ 0 ], aY = args[ 1 ],
        xRadius = args[ 2 ],
        yRadius = args[ 3 ],
        aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
        aClockwise = !! args[ 6 ];


      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + xRadius * Math.cos( angle );
        ty = aY + yRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    } // end switch

  }



  // Normalize to remove the closing point by default.
  var lastPoint = points[ points.length - 1];
  var EPSILON = 0.0000000001;
  if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
       Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
    points.splice( points.length - 1, 1);
  if ( closedPath ) {

    points.push( points[ 0 ] );

  }

  return points;

};

//
// Breaks path into shapes
//
//  Assumptions (if parameter isCCW==true the opposite holds):
//  - solid shapes are defined clockwise (CW)
//  - holes are defined counterclockwise (CCW)
//
//  If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

  function extractSubpaths( inActions ) {

    var i, il, item, action, args;

    var subPaths = [], lastPath = new THREE.Path();

    for ( i = 0, il = inActions.length; i < il; i ++ ) {

      item = inActions[ i ];

      args = item.args;
      action = item.action;

      if ( action === THREE.PathActions.MOVE_TO ) {

        if ( lastPath.actions.length !== 0 ) {

          subPaths.push( lastPath );
          lastPath = new THREE.Path();

        }

      }

      lastPath[ action ].apply( lastPath, args );

    }

    if ( lastPath.actions.length !== 0 ) {

      subPaths.push( lastPath );

    }

    // console.log(subPaths);

    return  subPaths;
  }

  function toShapesNoHoles( inSubpaths ) {

    var shapes = [];

    for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

      var tmpPath = inSubpaths[ i ];

      var tmpShape = new THREE.Shape();
      tmpShape.actions = tmpPath.actions;
      tmpShape.curves = tmpPath.curves;

      shapes.push( tmpShape );
    }

    //console.log("shape", shapes);

    return shapes;
  }

  function isPointInsidePolygon( inPt, inPolygon ) {
    var EPSILON = 0.0000000001;

    var polyLen = inPolygon.length;

    // inPt on polygon contour => immediate success    or
    // toggling of inside/outside at every single! intersection point of an edge
    //  with the horizontal line through inPt, left of inPt
    //  not counting lowerY endpoints of edges and whole edges on that line
    var inside = false;
    for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
      var edgeLowPt  = inPolygon[ p ];
      var edgeHighPt = inPolygon[ q ];

      var edgeDx = edgeHighPt.x - edgeLowPt.x;
      var edgeDy = edgeHighPt.y - edgeLowPt.y;

      if ( Math.abs(edgeDy) > EPSILON ) {     // not parallel
        if ( edgeDy < 0 ) {
          edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
          edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
        }
        if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;

        if ( inPt.y === edgeLowPt.y ) {
          if ( inPt.x === edgeLowPt.x )   return  true;   // inPt is on contour ?
          // continue;        // no intersection or edgeLowPt => doesn't count !!!
        } else {
          var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
          if ( perpEdge === 0 )       return  true;   // inPt is on contour ?
          if ( perpEdge < 0 )         continue;
          inside = ! inside;    // true intersection left of inPt
        }
      } else {    // parallel or colinear
        if ( inPt.y !== edgeLowPt.y )     continue;     // parallel
        // egde lies on the same horizontal line as inPt
        if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
           ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !
        // continue;
      }
    }

    return  inside;
  }


  var subPaths = extractSubpaths( this.actions );
  if ( subPaths.length === 0 ) return [];

  if ( noHoles === true ) return  toShapesNoHoles( subPaths );


  var solid, tmpPath, tmpShape, shapes = [];

  if ( subPaths.length === 1) {

    tmpPath = subPaths[0];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push( tmpShape );
    return shapes;

  }

  var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
  holesFirst = isCCW ? ! holesFirst : holesFirst;

  // console.log("Holes first", holesFirst);

  var betterShapeHoles = [];
  var newShapes = [];
  var newShapeHoles = [];
  var mainIdx = 0;
  var tmpPoints;

  newShapes[mainIdx] = undefined;
  newShapeHoles[mainIdx] = [];

  var i, il;

  for ( i = 0, il = subPaths.length; i < il; i ++ ) {

    tmpPath = subPaths[ i ];
    tmpPoints = tmpPath.getPoints();
    solid = THREE.Shape.Utils.isClockWise( tmpPoints );
    solid = isCCW ? ! solid : solid;

    if ( solid ) {

      if ( (! holesFirst ) && ( newShapes[mainIdx] ) )  mainIdx ++;

      newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
      newShapes[mainIdx].s.actions = tmpPath.actions;
      newShapes[mainIdx].s.curves = tmpPath.curves;

      if ( holesFirst ) mainIdx ++;
      newShapeHoles[mainIdx] = [];

      //console.log('cw', i);

    } else {

      newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

      //console.log('ccw', i);

    }

  }

  // only Holes? -> probably all Shapes with wrong orientation
  if ( ! newShapes[0] ) return  toShapesNoHoles( subPaths );


  if ( newShapes.length > 1 ) {
    var ambigious = false;
    var toChange = [];

    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
      betterShapeHoles[sIdx] = [];
    }
    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
      var sho = newShapeHoles[sIdx];
      for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
        var ho = sho[hIdx];
        var hole_unassigned = true;
        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
          if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
            if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
            if ( hole_unassigned ) {
              hole_unassigned = false;
              betterShapeHoles[s2Idx].push( ho );
            } else {
              ambigious = true;
            }
          }
        }
        if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
      }
    }
    // console.log("ambigious: ", ambigious);
    if ( toChange.length > 0 ) {
      // console.log("to change: ", toChange);
      if (! ambigious)  newShapeHoles = betterShapeHoles;
    }
  }

  var tmpHoles, j, jl;
  for ( i = 0, il = newShapes.length; i < il; i ++ ) {
    tmpShape = newShapes[i].s;
    shapes.push( tmpShape );
    tmpHoles = newShapeHoles[i];
    for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
      tmpShape.holes.push( tmpHoles[j].h );
    }
  }

  //console.log("shape", shapes);

  return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

  THREE.Path.apply( this, arguments );
  this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

  var extruded = new THREE.ExtrudeGeometry( this, options );
  return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

  var geometry = new THREE.ShapeGeometry( this, options );
  return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

  }

  return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

  }

  return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

  return {

    shape: this.getTransformedPoints( divisions ),
    holes: this.getPointsHoles( divisions )

  };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

  if (this.useSpacedPoints) {
    return this.extractAllSpacedPoints(divisions);
  }

  return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
//  return {
//
//    shape: this.transform( bend, divisions ),
//    holes: this.getPointsHoles( divisions, bend )
//
//  };
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

  return {

    shape: this.getTransformedSpacedPoints( divisions ),
    holes: this.getSpacedPointsHoles( divisions )

  };

};

/**************************************************************
 *  Utils
 **************************************************************/

THREE.Shape.Utils = {

  triangulateShape: function ( contour, holes ) {

    function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
      // inOtherPt needs to be colinear to the inSegment
      if ( inSegPt1.x !== inSegPt2.x ) {
        if ( inSegPt1.x < inSegPt2.x ) {
          return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
        } else {
          return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
        }
      } else {
        if ( inSegPt1.y < inSegPt2.y ) {
          return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
        } else {
          return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
        }
      }
    }

    function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
      var EPSILON = 0.0000000001;

      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

      var limit   = seg1dy * seg2dx - seg1dx * seg2dy;
      var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

      if ( Math.abs(limit) > EPSILON ) {      // not parallel

        var perpSeg2;
        if ( limit > 0 ) {
          if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];
        } else {
          if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];
        }

        // i.e. to reduce rounding errors
        // intersection at endpoint of segment#1?
        if ( perpSeg2 === 0 ) {
          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt1 ];
        }
        if ( perpSeg2 === limit ) {
          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt2 ];
        }
        // intersection at endpoint of segment#2?
        if ( perpSeg1 === 0 )   return [ inSeg2Pt1 ];
        if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

        // return real intersection point
        var factorSeg1 = perpSeg2 / limit;
        return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

      } else {    // parallel or colinear
        if ( ( perpSeg1 !== 0 ) ||
           ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) )      return [];

        // they are collinear or degenerate
        var seg1Pt = ( (seg1dx === 0) && (seg1dy === 0) );  // segment1 ist just a point?
        var seg2Pt = ( (seg2dx === 0) && (seg2dy === 0) );  // segment2 ist just a point?
        // both segments are points
        if ( seg1Pt && seg2Pt ) {
          if ( (inSeg1Pt1.x !== inSeg2Pt1.x) ||
             (inSeg1Pt1.y !== inSeg2Pt1.y) )    return [];  // they are distinct  points
          return [ inSeg1Pt1 ];                             // they are the same point
        }
        // segment#1  is a single point
        if ( seg1Pt ) {
          if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )    return [];    // but not in segment#2
          return [ inSeg1Pt1 ];
        }
        // segment#2  is a single point
        if ( seg2Pt ) {
          if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )    return [];    // but not in segment#1
          return [ inSeg2Pt1 ];
        }

        // they are collinear segments, which might overlap
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if (seg1dx !== 0) {   // the segments are NOT on a vertical line
          if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
          } else {
            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
          }
          if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
          } else {
            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
          }
        } else {        // the segments are on a vertical line
          if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
          } else {
            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
          }
          if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
          } else {
            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
          }
        }
        if ( seg1minVal <= seg2minVal ) {
          if ( seg1maxVal <  seg2minVal ) return [];
          if ( seg1maxVal === seg2minVal )  {
            if ( inExcludeAdjacentSegs )    return [];
            return [ seg2min ];
          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
          return  [ seg2min, seg2max ];
        } else {
          if ( seg1minVal >  seg2maxVal ) return [];
          if ( seg1minVal === seg2maxVal )  {
            if ( inExcludeAdjacentSegs )    return [];
            return [ seg1min ];
          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
          return  [ seg1min, seg2max ];
        }
      }
    }

    function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
      // The order of legs is important

      var EPSILON = 0.0000000001;

      // translation of all points, so that Vertex is at (0,0)
      var legFromPtX  = inLegFromPt.x - inVertex.x,  legFromPtY = inLegFromPt.y - inVertex.y;
      var legToPtX  = inLegToPt.x - inVertex.x,  legToPtY   = inLegToPt.y - inVertex.y;
      var otherPtX  = inOtherPt.x - inVertex.x,  otherPtY   = inOtherPt.y - inVertex.y;

      // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
      var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;
      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

      if ( Math.abs(from2toAngle) > EPSILON ) {     // angle != 180 deg.

        var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;
        // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

        if ( from2toAngle > 0 ) {       // main angle < 180 deg.
          return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
        } else {                // main angle > 180 deg.
          return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
        }
      } else {                    // angle == 180 deg.
        // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
        return  ( from2otherAngle > 0 );
      }
    }


    function removeHoles( contour, holes ) {

      var shape = contour.concat(); // work on this shape
      var hole;

      function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
        // Check if hole point lies within angle around shape point
        var lastShapeIdx = shape.length - 1;

        var prevShapeIdx = inShapeIdx - 1;
        if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;

        var nextShapeIdx = inShapeIdx + 1;
        if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;

        var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
        if (! insideAngle ) {
          // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
          return  false;
        }

        // Check if shape point lies within angle around hole point
        var lastHoleIdx = hole.length - 1;

        var prevHoleIdx = inHoleIdx - 1;
        if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;

        var nextHoleIdx = inHoleIdx + 1;
        if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;

        insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
        if (! insideAngle ) {
          // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
          return  false;
        }

        return  true;
      }

      function intersectsShapeEdge( inShapePt, inHolePt ) {
        // checks for intersections with shape edges
        var sIdx, nextIdx, intersection;
        for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
          nextIdx = sIdx + 1; nextIdx %= shape.length;
          intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
          if ( intersection.length > 0 )    return  true;
        }

        return  false;
      }

      var indepHoles = [];

      function intersectsHoleEdge( inShapePt, inHolePt ) {
        // checks for intersections with hole edges
        var ihIdx, chkHole,
          hIdx, nextIdx, intersection;
        for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
          chkHole = holes[indepHoles[ihIdx]];
          for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
            nextIdx = hIdx + 1; nextIdx %= chkHole.length;
            intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
            if ( intersection.length > 0 )    return  true;
          }
        }
        return  false;
      }

      var holeIndex, shapeIndex,
        shapePt, holePt,
        holeIdx, cutKey, failedCuts = [],
        tmpShape1, tmpShape2,
        tmpHole1, tmpHole2;

      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

        indepHoles.push( h );

      }

      var minShapeIndex = 0;
      var counter = indepHoles.length * 2;
      while ( indepHoles.length > 0 ) {
        counter --;
        if ( counter < 0 ) {
          console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
          break;
        }

        // search for shape-vertex and hole-vertex,
        // which can be connected without intersections
        for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

          shapePt = shape[ shapeIndex ];
          holeIndex = - 1;

          // search for hole which can be reached without intersections
          for ( var h = 0; h < indepHoles.length; h ++ ) {
            holeIdx = indepHoles[h];

            // prevent multiple checks
            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
            if ( failedCuts[cutKey] !== undefined )     continue;

            hole = holes[holeIdx];
            for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
              holePt = hole[ h2 ];
              if (! isCutLineInsideAngles( shapeIndex, h2 ) )   continue;
              if ( intersectsShapeEdge( shapePt, holePt ) )   continue;
              if ( intersectsHoleEdge( shapePt, holePt ) )    continue;

              holeIndex = h2;
              indepHoles.splice(h, 1);

              tmpShape1 = shape.slice( 0, shapeIndex + 1 );
              tmpShape2 = shape.slice( shapeIndex );
              tmpHole1 = hole.slice( holeIndex );
              tmpHole2 = hole.slice( 0, holeIndex + 1 );

              shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

              minShapeIndex = shapeIndex;

              // Debug only, to show the selected cuts
              // glob_CutLines.push( [ shapePt, holePt ] );

              break;
            }
            if ( holeIndex >= 0 ) break;    // hole-vertex found

            failedCuts[cutKey] = true;      // remember failure
          }
          if ( holeIndex >= 0 ) break;    // hole-vertex found
        }
      }

      return shape;       /* shape with no holes */
    }


    var i, il, f, face,
      key, index,
      allPointsMap = {};

    // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    var allpoints = contour.concat();

    for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

      Array.prototype.push.apply( allpoints, holes[h] );

    }

    //console.log( "allpoints",allpoints, allpoints.length );

    // prepare all points map

    for ( i = 0, il = allpoints.length; i < il; i ++ ) {

      key = allpoints[ i ].x + ":" + allpoints[ i ].y;

      if ( allPointsMap[ key ] !== undefined ) {

        console.warn( "THREE.Shape: Duplicate point", key );

      }

      allPointsMap[ key ] = i;

    }

    // remove holes by cutting paths to holes and adding them to the shape
    var shapeWithoutHoles = removeHoles( contour, holes );

    var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    //console.log( "triangles",triangles, triangles.length );

    // check all face vertices against all points map

    for ( i = 0, il = triangles.length; i < il; i ++ ) {

      face = triangles[ i ];

      for ( f = 0; f < 3; f ++ ) {

        key = face[ f ].x + ":" + face[ f ].y;

        index = allPointsMap[ key ];

        if ( index !== undefined ) {

          face[ f ] = index;

        }

      }

    }

    return triangles.concat();

  },

  isClockWise: function ( pts ) {

    return THREE.FontUtils.Triangulate.area( pts ) < 0;

  },

  // Bezier Curves formulas obtained from
  // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

  // Quad Bezier Functions

  b2p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * p;

  },

  b2p1: function ( t, p ) {

    return 2 * ( 1 - t ) * t * p;

  },

  b2p2: function ( t, p ) {

    return t * t * p;

  },

  b2: function ( t, p0, p1, p2 ) {

    return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

  },

  // Cubic Bezier Functions

  b3p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * k * p;

  },

  b3p1: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * k * t * p;

  },

  b3p2: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * t * t * p;

  },

  b3p3: function ( t, p ) {

    return t * t * t * p;

  },

  b3: function ( t, p0, p1, p2, p3 ) {

    return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

  }

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *  Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

  this.v1 = v1;
  this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

  var point = this.v2.clone().sub(this.v1);
  point.multiplyScalar( t ).add( this.v1 );

  return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

  return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

  var tangent = this.v2.clone().sub(this.v1);

  return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *  Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

  return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

  // returns unit vector

  return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *  Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

  var tx, ty;

  tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

  var tx, ty;

  tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  var tangent = new THREE.Vector2( tx, ty );
  tangent.normalize();

  return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *  Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

  this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

  var points = this.points;
  var point = ( points.length - 1 ) * t;

  var intPoint = Math.floor( point );
  var weight = point - intPoint;

  var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  var point1 = points[ intPoint ];
  var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
  vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

  return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *  Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

  this.aX = aX;
  this.aY = aY;

  this.xRadius = xRadius;
  this.yRadius = yRadius;

  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;

  this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

  var deltaAngle = this.aEndAngle - this.aStartAngle;

  if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
  if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

  var angle;

  if ( this.aClockwise === true ) {

    angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

  } else {

    angle = this.aStartAngle + t * deltaAngle;

  }

  var vector = new THREE.Vector2();

  vector.x = this.aX + this.xRadius * Math.cos( angle );
  vector.y = this.aY + this.yRadius * Math.sin( angle );

  return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *  Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *  Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

  function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.subVectors( this.v2, this.v1 ); // diff
    vector.multiplyScalar( t );
    vector.add( this.v1 );

    return vector;

  }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *  Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
    vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

    return vector;

  }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *  Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
    vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

    return vector;

  }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *  Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */) {

    console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

  var
    tmp = new THREE.Vector3(),
    px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

  }

  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */
  CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    this.c0 = x0;
    this.c1 = t0;
    this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

  };

  CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    // compute tangents when parameterized in [t1,t2]
    var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    // rescale tangents for parametrization in [0,1]
    t1 *= dt1;
    t2 *= dt1;

    // initCubicPoly
    this.init( x1, x2, t1, t2 );

  };

  // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
  CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  };

  CubicPoly.prototype.calc = function( t ) {

    var t2 = t * t;
    var t3 = t2 * t;
    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

  };

  // Subclass Three.js curve
  return THREE.Curve.create(

    function ( p /* array of Vector3 */ ) {

      this.points = p || [];

    },

    function ( t ) {

      var points = this.points,
        point, intPoint, weight, l;

      l = points.length;

      if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

      point = ( l - 1 ) * t;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      if ( weight === 0 && intPoint === l - 1 ) {

        intPoint = l - 2;
        weight = 1;

      }

      var p0, p1, p2, p3;

      if ( intPoint === 0 ) {

        // extrapolate first point
        tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
        p0 = tmp;

      } else {

        p0 = points[ intPoint - 1 ];

      }

      p1 = points[ intPoint ];
      p2 = points[ intPoint + 1 ];

      if ( intPoint + 2 < l ) {

        p3 = points[ intPoint + 2 ]

      } else {

        // extrapolate last point
        tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
        p3 = tmp;

      }

      if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

        // init Centripetal / Chordal Catmull-Rom
        var pow = this.type === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
        var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
        var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

        // safety check for repeated points
        if ( dt1 < 1e-4 ) dt1 = 1.0;
        if ( dt0 < 1e-4 ) dt0 = dt1;
        if ( dt2 < 1e-4 ) dt2 = dt1;

        px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
        py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
        pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

      } else if ( this.type === 'catmullrom' ) {

        var tension = this.tension !== undefined ? this.tension : 0.5;
        px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
        py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
        pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

      }

      var v = new THREE.Vector3(
        px.calc( weight ),
        py.calc( weight ),
        pz.calc( weight )
      );

      return v;

    }

  );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *  Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */) {

    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    var point0 = points[ ( intPoint - 1 ) % points.length ];
    var point1 = points[ ( intPoint     ) % points.length ];
    var point2 = points[ ( intPoint + 1 ) % points.length ];
    var point3 = points[ ( intPoint + 2 ) % points.length ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

  LINEAR: 0,
  CATMULLROM: 1,
  CATMULLROM_FORWARD: 2,

  //

  add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
  get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
  remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

  //

  animations: [],

  init: function ( data ) {

    if ( data.initialized === true ) return data;

    // loop through all keys

    for ( var h = 0; h < data.hierarchy.length; h ++ ) {

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        // remove minus times

        if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

           data.hierarchy[ h ].keys[ k ].time = 0;

        }

        // create quaternions

        if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
          ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

          var quat = data.hierarchy[ h ].keys[ k ].rot;
          data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

        }

      }

      // prepare morph target keys

      if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

        // get all used

        var usedMorphTargets = {};

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

            var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
            usedMorphTargets[ morphTargetName ] = - 1;

          }

        }

        data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


        // set all used on all frames

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          var influences = {};

          for ( var morphTargetName in usedMorphTargets ) {

            for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

              if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                break;

              }

            }

            if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

              influences[ morphTargetName ] = 0;

            }

          }

          data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

        }

      }


      // remove all keys that are on the same time

      for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

        if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

          data.hierarchy[ h ].keys.splice( k, 1 );
          k --;

        }

      }


      // set index

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        data.hierarchy[ h ].keys[ k ].index = k;

      }

    }

    data.initialized = true;

    return data;

  },

  parse: function ( root ) {

    var parseRecurseHierarchy = function ( root, hierarchy ) {

      hierarchy.push( root );

      for ( var c = 0; c < root.children.length; c ++ )
        parseRecurseHierarchy( root.children[ c ], hierarchy );

    };

    // setup hierarchy

    var hierarchy = [];

    if ( root instanceof THREE.SkinnedMesh ) {

      for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

        hierarchy.push( root.skeleton.bones[ b ] );

      }

    } else {

      parseRecurseHierarchy( root, hierarchy );

    }

    return hierarchy;

  },

  play: function ( animation ) {

    if ( this.animations.indexOf( animation ) === - 1 ) {

      this.animations.push( animation );

    }

  },

  stop: function ( animation ) {

    var index = this.animations.indexOf( animation );

    if ( index !== - 1 ) {

      this.animations.splice( index, 1 );

    }

  },

  update: function ( deltaTimeMS ) {

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].resetBlendWeights( );

    }

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].update( deltaTimeMS );

    }

  }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

  this.root = root;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( root );

  this.currentTime = 0;
  this.timeScale = 1;

  this.isPlaying = false;
  this.loop = true;
  this.weight = 0;

  this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype = {

  constructor: THREE.Animation,

  keyTypes:  [ "pos", "rot", "scl" ],

  play: function ( startTime, weight ) {

    this.currentTime = startTime !== undefined ? startTime : 0;
    this.weight = weight !== undefined ? weight : 1;

    this.isPlaying = true;

    this.reset();

    THREE.AnimationHandler.play( this );

  },

  stop: function() {

    this.isPlaying = false;

    THREE.AnimationHandler.stop( this );

  },

  reset: function () {

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];

      if ( object.animationCache === undefined ) {

        object.animationCache = {
          animations: {},
          blending: {
            positionWeight: 0.0,
            quaternionWeight: 0.0,
            scaleWeight: 0.0
          }
        };
      }

      var name = this.data.name;
      var animations = object.animationCache.animations;
      var animationCache = animations[ name ];

      if ( animationCache === undefined ) {

        animationCache = {
          prevKey: { pos: 0, rot: 0, scl: 0 },
          nextKey: { pos: 0, rot: 0, scl: 0 },
          originalMatrix: object.matrix
        };

        animations[ name ] = animationCache;

      }

      // Get keys to match our current time

      for ( var t = 0; t < 3; t ++ ) {

        var type = this.keyTypes[ t ];

        var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
        var nextKey = this.getNextKeyWith( type, h, 1 );

        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

          prevKey = nextKey;
          nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

        }

        animationCache.prevKey[ type ] = prevKey;
        animationCache.nextKey[ type ] = nextKey;

      }

    }

  },

  resetBlendWeights: function () {

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var animationCache = object.animationCache;

      if ( animationCache !== undefined ) {

        var blending = animationCache.blending;

        blending.positionWeight = 0.0;
        blending.quaternionWeight = 0.0;
        blending.scaleWeight = 0.0;

      }

    }

  },

  update: ( function() {

    var points = [];
    var target = new THREE.Vector3();
    var newVector = new THREE.Vector3();
    var newQuat = new THREE.Quaternion();

    // Catmull-Rom spline

    var interpolateCatmullRom = function ( points, scale ) {

      var c = [], v3 = [],
      point, intPoint, weight, w2, w3,
      pa, pb, pc, pd;

      point = ( points.length - 1 ) * scale;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
      c[ 1 ] = intPoint;
      c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
      c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

      pa = points[ c[ 0 ] ];
      pb = points[ c[ 1 ] ];
      pc = points[ c[ 2 ] ];
      pd = points[ c[ 3 ] ];

      w2 = weight * weight;
      w3 = weight * w2;

      v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
      v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
      v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

      return v3;

    };

    var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

      var v0 = ( p2 - p0 ) * 0.5,
        v1 = ( p3 - p1 ) * 0.5;

      return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    };

    return function ( delta ) {

      if ( this.isPlaying === false ) return;

      this.currentTime += delta * this.timeScale;

      if ( this.weight === 0 )
        return;

      //

      var duration = this.data.length;

      if ( this.currentTime > duration || this.currentTime < 0 ) {

        if ( this.loop ) {

          this.currentTime %= duration;

          if ( this.currentTime < 0 )
            this.currentTime += duration;

          this.reset();

        } else {

          this.stop();

        }

      }

      for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

        var object = this.hierarchy[ h ];
        var animationCache = object.animationCache.animations[this.data.name];
        var blending = object.animationCache.blending;

        // loop through pos/rot/scl

        for ( var t = 0; t < 3; t ++ ) {

          // get keys

          var type    = this.keyTypes[ t ];
          var prevKey = animationCache.prevKey[ type ];
          var nextKey = animationCache.nextKey[ type ];

          if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
            ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

            prevKey = this.data.hierarchy[ h ].keys[ 0 ];
            nextKey = this.getNextKeyWith( type, h, 1 );

            while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

              prevKey = nextKey;
              nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

            }

            animationCache.prevKey[ type ] = prevKey;
            animationCache.nextKey[ type ] = nextKey;

          }

          var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

          var prevXYZ = prevKey[ type ];
          var nextXYZ = nextKey[ type ];

          if ( scale < 0 ) scale = 0;
          if ( scale > 1 ) scale = 1;

          // interpolate

          if ( type === "pos" ) {

            if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

              newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
              newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
              newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

              // blend
              var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
              object.position.lerp( newVector, proportionalWeight );
              blending.positionWeight += this.weight;

            } else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                  this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

              points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
              points[ 1 ] = prevXYZ;
              points[ 2 ] = nextXYZ;
              points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

              scale = scale * 0.33 + 0.33;

              var currentPoint = interpolateCatmullRom( points, scale );
              var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
              blending.positionWeight += this.weight;

              // blend

              var vector = object.position;

              vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
              vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
              vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

              if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

                target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
                target.sub( vector );
                target.y = 0;
                target.normalize();

                var angle = Math.atan2( target.x, target.z );
                object.rotation.set( 0, angle, 0 );

              }

            }

          } else if ( type === "rot" ) {

            THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

            // Avoid paying the cost of an additional slerp if we don't have to
            if ( blending.quaternionWeight === 0 ) {

              object.quaternion.copy(newQuat);
              blending.quaternionWeight = this.weight;

            } else {

              var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
              THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
              blending.quaternionWeight += this.weight;

            }

          } else if ( type === "scl" ) {

            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

            var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
            object.scale.lerp( newVector, proportionalWeight );
            blending.scaleWeight += this.weight;

          }

        }

      }

      return true;

    };

  } )(),

  getNextKeyWith: function ( type, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;

    if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
       this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

      key = key < keys.length - 1 ? key : keys.length - 1;

    } else {

      key = key % keys.length;

    }

    for ( ; key < keys.length; key ++ ) {

      if ( keys[ key ][ type ] !== undefined ) {

        return keys[ key ];

      }

    }

    return this.data.hierarchy[ h ].keys[ 0 ];

  },

  getPrevKeyWith: function ( type, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;

    if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
      this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

      key = key > 0 ? key : 0;

    } else {

      key = key >= 0 ? key : key + keys.length;

    }


    for ( ; key >= 0; key -- ) {

      if ( keys[ key ][ type ] !== undefined ) {

        return keys[ key ];

      }

    }

    return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

  }

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

  this.root = data.node;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( this.root );
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;

  // initialize to first keyframes

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var keys = this.data.hierarchy[h].keys,
      sids = this.data.hierarchy[h].sids,
      obj = this.hierarchy[h];

    if ( keys.length && sids ) {

      for ( var s = 0; s < sids.length; s ++ ) {

        var sid = sids[ s ],
          next = this.getNextKeyWith( sid, h, 0 );

        if ( next ) {

          next.apply( sid );

        }

      }

      obj.matrixAutoUpdate = false;
      this.data.hierarchy[h].node.updateMatrix();
      obj.matrixWorldNeedsUpdate = true;

    }

  }

};

THREE.KeyFrameAnimation.prototype = {

  constructor: THREE.KeyFrameAnimation,

  play: function ( startTime ) {

    this.currentTime = startTime !== undefined ? startTime : 0;

    if ( this.isPlaying === false ) {

      this.isPlaying = true;

      // reset key cache

      var h, hl = this.hierarchy.length,
        object,
        node;

      for ( h = 0; h < hl; h ++ ) {

        object = this.hierarchy[ h ];
        node = this.data.hierarchy[ h ];

        if ( node.animationCache === undefined ) {

          node.animationCache = {};
          node.animationCache.prevKey = null;
          node.animationCache.nextKey = null;
          node.animationCache.originalMatrix = object.matrix;

        }

        var keys = this.data.hierarchy[h].keys;

        if (keys.length) {

          node.animationCache.prevKey = keys[ 0 ];
          node.animationCache.nextKey = keys[ 1 ];

          this.startTime = Math.min( keys[0].time, this.startTime );
          this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

        }

      }

      this.update( 0 );

    }

    this.isPaused = false;

    THREE.AnimationHandler.play( this );

  },

  stop: function () {

    this.isPlaying = false;
    this.isPaused  = false;

    THREE.AnimationHandler.stop( this );

    // reset JIT matrix and remove cache

    for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

      var obj = this.hierarchy[ h ];
      var node = this.data.hierarchy[ h ];

      if ( node.animationCache !== undefined ) {

        var original = node.animationCache.originalMatrix;

        original.copy( obj.matrix );
        obj.matrix = original;

        delete node.animationCache;

      }

    }

  },

  update: function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta * this.timeScale;

    //

    var duration = this.data.length;

    if ( this.loop === true && this.currentTime > duration ) {

      this.currentTime %= duration;

    }

    this.currentTime = Math.min( this.currentTime, duration );

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var node = this.data.hierarchy[ h ];

      var keys = node.keys,
        animationCache = node.animationCache;


      if ( keys.length ) {

        var prevKey = animationCache.prevKey;
        var nextKey = animationCache.nextKey;

        if ( nextKey.time <= this.currentTime ) {

          while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

            prevKey = nextKey;
            nextKey = keys[ prevKey.index + 1 ];

          }

          animationCache.prevKey = prevKey;
          animationCache.nextKey = nextKey;

        }

        if ( nextKey.time >= this.currentTime ) {

          prevKey.interpolate( nextKey, this.currentTime );

        } else {

          prevKey.interpolate( nextKey, nextKey.time );

        }

        this.data.hierarchy[ h ].node.updateMatrix();
        object.matrixWorldNeedsUpdate = true;

      }

    }

  },

  getNextKeyWith: function ( sid, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;
    key = key % keys.length;

    for ( ; key < keys.length; key ++ ) {

      if ( keys[ key ].hasTarget( sid ) ) {

        return keys[ key ];

      }

    }

    return keys[ 0 ];

  },

  getPrevKeyWith: function ( sid, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;
    key = key >= 0 ? key : key + keys.length;

    for ( ; key >= 0; key -- ) {

      if ( keys[ key ].hasTarget( sid ) ) {

        return keys[ key ];

      }

    }

    return keys[ keys.length - 1 ];

  }

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function ( mesh ) {

  this.mesh = mesh;
  this.frames = mesh.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = true;
  this.lastFrame = 0;
  this.currentFrame = 0;

  this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

  constructor: THREE.MorphAnimation,

  play: function () {

    this.isPlaying = true;

  },

  pause: function () {

    this.isPlaying = false;

  },

  update: function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta;

    if ( this.loop === true && this.currentTime > this.duration ) {

      this.currentTime %= this.duration;

    }

    this.currentTime = Math.min( this.currentTime, this.duration );

    var interpolation = this.duration / this.frames;
    var frame = Math.floor( this.currentTime / interpolation );

    var influences = this.mesh.morphTargetInfluences;

    if ( frame !== this.currentFrame ) {

      influences[ this.lastFrame ] = 0;
      influences[ this.currentFrame ] = 1;
      influences[ frame ] = 0;

      this.lastFrame = this.currentFrame;
      this.currentFrame = frame;

    }

    influences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
    influences[ this.lastFrame ] = 1 - influences[ frame ];

  }

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  THREE.Geometry.call( this );

  this.type = 'BoxGeometry';

  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };

  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;

  var scope = this;

  var width_half = width / 2;
  var height_half = height / 2;
  var depth_half = depth / 2;

  buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half ); // px
  buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half ); // nx
  buildPlane( 'x', 'z',   1,   1, width, depth, height_half ); // py
  buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half ); // ny
  buildPlane( 'x', 'y',   1, - 1, width, height, depth_half ); // pz
  buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half ); // nz

  function buildPlane( u, v, udir, vdir, width, height, depth ) {

    var w, ix, iy,
    gridX = scope.widthSegments,
    gridY = scope.heightSegments,
    width_half = width / 2,
    height_half = height / 2,
    offset = scope.vertices.length;

    if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

      w = 'z';

    } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

      w = 'y';
      gridY = scope.depthSegments;

    } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

      w = 'x';
      gridX = scope.depthSegments;

    }

    var gridX1 = gridX + 1,
    gridY1 = gridY + 1,
    segment_width = width / gridX,
    segment_height = height / gridY,
    normal = new THREE.Vector3();

    normal[ w ] = depth > 0 ? 1 : - 1;

    for ( iy = 0; iy < gridY1; iy ++ ) {

      for ( ix = 0; ix < gridX1; ix ++ ) {

        var vector = new THREE.Vector3();
        vector[ u ] = ( ix * segment_width - width_half ) * udir;
        vector[ v ] = ( iy * segment_height - height_half ) * vdir;
        vector[ w ] = depth;

        scope.vertices.push( vector );

      }

    }

    for ( iy = 0; iy < gridY; iy ++ ) {

      for ( ix = 0; ix < gridX; ix ++ ) {

        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * ( iy + 1 );
        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
        var d = ( ix + 1 ) + gridX1 * iy;

        var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
        var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
        var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
        var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

        var face = new THREE.Face3( a + offset, b + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

        face = new THREE.Face3( b + offset, c + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

      }

    }

  }

  this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CircleGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var i, uvs = [],
  center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

  this.vertices.push(center);
  uvs.push( centerUV );

  for ( i = 0; i <= segments; i ++ ) {

    var vertex = new THREE.Vector3();
    var segment = thetaStart + i / segments * thetaLength;

    vertex.x = radius * Math.cos( segment );
    vertex.y = radius * Math.sin( segment );

    this.vertices.push( vertex );
    uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 1; i <= segments; i ++ ) {

    this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
    this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'CircleBufferGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var vertices = segments + 2;

  var positions = new Float32Array( vertices * 3 );
  var normals = new Float32Array( vertices * 3 );
  var uvs = new Float32Array( vertices * 2 );

  // center data is already zero, but need to set a few extras
  normals[3] = 1.0;
  uvs[0] = 0.5;
  uvs[1] = 0.5;

  for ( var s = 0, i = 3, ii = 2 ; s <= segments; s++, i += 3, ii += 2 ) {

    var segment = thetaStart + s / segments * thetaLength;

    positions[i] = radius * Math.cos( segment );
    positions[i + 1] = radius * Math.sin( segment );

    normals[i + 2] = 1; // normal z

    uvs[ii] = ( positions[i] / radius + 1 ) / 2;
    uvs[ii + 1] = ( positions[i + 1] / radius + 1 ) / 2;

  }

  var indices = [];

  for ( var i = 1; i <= segments; i ++ ) {

    indices.push( i );
    indices.push( i + 1 );
    indices.push( 0 );

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CylinderGeometry';

  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;

  radialSegments = radialSegments || 8;
  heightSegments = heightSegments || 1;

  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

  var heightHalf = height / 2;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    var v = y / heightSegments;
    var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    for ( x = 0; x <= radialSegments; x ++ ) {

      var u = x / radialSegments;

      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
      vertex.y = - v * height + heightHalf;
      vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  var tanTheta = ( radiusBottom - radiusTop ) / height;
  var na, nb;

  for ( x = 0; x < radialSegments; x ++ ) {

    if ( radiusTop !== 0 ) {

      na = this.vertices[ vertices[ 0 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

    } else {

      na = this.vertices[ vertices[ 1 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

    }

    na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
    nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

    for ( y = 0; y < heightSegments; y ++ ) {

      var v1 = vertices[ y ][ x ];
      var v2 = vertices[ y + 1 ][ x ];
      var v3 = vertices[ y + 1 ][ x + 1 ];
      var v4 = vertices[ y ][ x + 1 ];

      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();

      var uv1 = uvs[ y ][ x ].clone();
      var uv2 = uvs[ y + 1 ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
      var uv4 = uvs[ y ][ x + 1 ].clone();

      this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

      this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

    }

  }

  // top cap

  if ( openEnded === false && radiusTop > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ 0 ][ x ];
      var v2 = vertices[ 0 ][ x + 1 ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, 1, 0 );
      var n2 = new THREE.Vector3( 0, 1, 0 );
      var n3 = new THREE.Vector3( 0, 1, 0 );

      var uv1 = uvs[ 0 ][ x ].clone();
      var uv2 = uvs[ 0 ][ x + 1 ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 0 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  // bottom cap

  if ( openEnded === false && radiusBottom > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ heightSegments ][ x + 1 ];
      var v2 = vertices[ heightSegments ][ x ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, - 1, 0 );
      var n2 = new THREE.Vector3( 0, - 1, 0 );
      var n3 = new THREE.Vector3( 0, - 1, 0 );

      var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
      var uv2 = uvs[ heightSegments ][ x ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 1 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

  THREE.BufferGeometry.call( this );

  thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) { return a - b };

  var keys = [ 'a', 'b', 'c' ];

  var geometry2;

  if ( geometry instanceof THREE.BufferGeometry ) {

    geometry2 = new THREE.Geometry();
    geometry2.fromBufferGeometry( geometry );

  } else {

    geometry2 = geometry.clone();

  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();

  var vertices = geometry2.vertices;
  var faces = geometry2.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0; j < 3; j ++ ) {

      edge[ 0 ] = face[ keys[ j ] ];
      edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
      edge.sort( sortFunction );

      var key = edge.toString();

      if ( hash[ key ] === undefined ) {

        hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

      } else {

        hash[ key ].face2 = i;

      }

    }

  }

  var coords = [];

  for ( var key in hash ) {

    var h = hash[ key ];

    if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

      var vertex = vertices[ h.vert1 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

      vertex = vertices[ h.vert2 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

    }

  }

  this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

  if ( typeof( shapes ) === "undefined" ) {
    shapes = [];
    return;
  }

  THREE.Geometry.call( this );

  this.type = 'ExtrudeGeometry';

  shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

  // can't really use automatic vertex normals
  // as then front and back sides get smoothed too
  // should do separate smoothing just for sides

  //this.computeVertexNormals();

  //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
  var sl = shapes.length;

  for ( var s = 0; s < sl; s ++ ) {
    var shape = shapes[ s ];
    this.addShape( shape, options );
  }
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

  var amount = options.amount !== undefined ? options.amount : 100;

  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var steps = options.steps !== undefined ? options.steps : 1;

  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;

  // Use default WorldUVGenerator if no UV generators are specified.
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

  var splineTube, binormal, normal, position2;
  if ( extrudePath ) {

    extrudePts = extrudePath.getSpacedPoints( steps );

    extrudeByPath = true;
    bevelEnabled = false; // bevels not supported for path extrusion

    // SETUP TNB variables

    // Reuse TNB from TubeGeomtry for now.
    // TODO1 - have a .isClosed in spline?

    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();

  }

  // Safeguards if bevels are not enabled

  if ( ! bevelEnabled ) {

    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;

  }

  // Variables initalization

  var ahole, h, hl; // looping of holes
  var scope = this;

  var shapesOffset = this.vertices.length;

  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe ...

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

        holes[ h ] = ahole.reverse();

      }

    }

    reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

  }


  var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

  /* Vertices */

  var contour = vertices; // vertices has all points but contour has only points of circumference

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    vertices = vertices.concat( ahole );

  }


  function scalePt2 ( pt, vec, size ) {

    if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    return vec.clone().multiplyScalar( size ).add( pt );

  }

  var b, bs, t, z,
    vert, vlen = vertices.length,
    face, flen = faces.length;


  // Find directions for point movement


  function getBevelVec( inPt, inPrev, inNext ) {

    var EPSILON = 0.0000000001;

    // computes for inPt the corresponding point inPt' on a new contour
    //   shiftet by 1 unit (length of normalized vector) to the left
    // if we walk along contour clockwise, this new contour is outside the old one
    //
    // inPt' is the intersection of the two lines parallel to the two
    //  adjacent edges of inPt at a distance of 1 unit on the left side.

    var v_trans_x, v_trans_y, shrink_by = 1;    // resulting translation vector for inPt

    // good reading for geometry algorithms (here: line-line intersection)
    // http://geomalgorithms.com/a05-_intersect-1.html

    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    // check for colinear edges
    var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    if ( Math.abs( colinear0 ) > EPSILON ) {    // not colinear

      // length of vectors for normalizing

      var v_prev_len = Math.sqrt( v_prev_lensq );
      var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

      // shift adjacent points by unit vectors to the left

      var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
      var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

      var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
      var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

      // scaling factor for v_prev to intersection point

      var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
            ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
            ( v_prev_x * v_next_y - v_prev_y * v_next_x );

      // vector from inPt to intersection point

      v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
      v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

      // Don't normalize!, otherwise sharp corners become ugly
      //  but prevent crazy spikes
      var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
      if ( v_trans_lensq <= 2 ) {
        return  new THREE.Vector2( v_trans_x, v_trans_y );
      } else {
        shrink_by = Math.sqrt( v_trans_lensq / 2 );
      }

    } else {    // handle special case of colinear edges

      var direction_eq = false;   // assumes: opposite
      if ( v_prev_x > EPSILON ) {
        if ( v_next_x > EPSILON ) { direction_eq = true; }
      } else {
        if ( v_prev_x < - EPSILON ) {
          if ( v_next_x < - EPSILON ) { direction_eq = true; }
        } else {
          if ( Math.sign(v_prev_y) === Math.sign(v_next_y) ) { direction_eq = true; }
        }
      }

      if ( direction_eq ) {
        // console.log("Warning: lines are a straight sequence");
        v_trans_x = - v_prev_y;
        v_trans_y =  v_prev_x;
        shrink_by = Math.sqrt( v_prev_lensq );
      } else {
        // console.log("Warning: lines are a straight spike");
        v_trans_x = v_prev_x;
        v_trans_y = v_prev_y;
        shrink_by = Math.sqrt( v_prev_lensq / 2 );
      }

    }

    return  new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  }


  var contourMovements = [];

  for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    if ( j === il ) j = 0;
    if ( k === il ) k = 0;

    //  (j)---(i)---(k)
    // console.log('i,j,k', i, j , k)

    contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  }

  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    oneHoleMovements = [];

    for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

      if ( j === il ) j = 0;
      if ( k === il ) k = 0;

      //  (j)---(i)---(k)
      oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    }

    holesMovements.push( oneHoleMovements );
    verticesMovements = verticesMovements.concat( oneHoleMovements );

  }


  // Loop bevelSegments, 1 for the front, 1 for the back

  for ( b = 0; b < bevelSegments; b ++ ) {
  //for ( b = bevelSegments; b > 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );

    //z = bevelThickness * t;
    bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved
    //bs = bevelSize * t ; // linear

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

      v( vert.x, vert.y,  - z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        v( vert.x, vert.y,  - z );

      }

    }

  }

  bs = bevelSize;

  // Back facing vertices

  for ( i = 0; i < vlen; i ++ ) {

    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    if ( ! extrudeByPath ) {

      v( vert.x, vert.y, 0 );

    } else {

      // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

      normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
      binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

      position2.copy( extrudePts[0] ).add(normal).add(binormal);

      v( position2.x, position2.y, position2.z );

    }

  }

  // Add stepped vertices...
  // Including front facing vertices

  var s;

  for ( s = 1; s <= steps; s ++ ) {

    for ( i = 0; i < vlen; i ++ ) {

      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

      if ( ! extrudeByPath ) {

        v( vert.x, vert.y, amount / steps * s );

      } else {

        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

        normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
        binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

        position2.copy( extrudePts[s] ).add( normal ).add( binormal );

        v( position2.x, position2.y, position2.z );

      }

    }

  }


  // Add bevel segments planes

  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for ( b = bevelSegments - 1; b >= 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );
    //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
    bs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
      v( vert.x, vert.y,  amount + z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        if ( ! extrudeByPath ) {

          v( vert.x, vert.y,  amount + z );

        } else {

          v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

        }

      }

    }

  }

  /* Faces */

  // Top and bottom faces

  buildLidFaces();

  // Sides faces

  buildSideFaces();


  /////  Internal functions

  function buildLidFaces() {

    if ( bevelEnabled ) {

      var layer = 0 ; // steps + 1
      var offset = vlen * layer;

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

      }

      layer = steps + bevelSegments * 2;
      offset = vlen * layer;

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

      }

    } else {

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ], face[ 1 ], face[ 0 ] );

      }

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

      }
    }

  }

  // Create faces for the z-sides of the shape

  function buildSideFaces() {

    var layeroffset = 0;
    sidewalls( contour, layeroffset );
    layeroffset += contour.length;

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      sidewalls( ahole, layeroffset );

      //, true
      layeroffset += ahole.length;

    }

  }

  function sidewalls( contour, layeroffset ) {

    var j, k;
    i = contour.length;

    while ( -- i >= 0 ) {

      j = i;
      k = i - 1;
      if ( k < 0 ) k = contour.length - 1;

      //console.log('b', i,j, i-1, k,vertices.length);

      var s = 0, sl = steps  + bevelSegments * 2;

      for ( s = 0; s < sl; s ++ ) {

        var slen1 = vlen * s;
        var slen2 = vlen * ( s + 1 );

        var a = layeroffset + j + slen1,
          b = layeroffset + k + slen1,
          c = layeroffset + k + slen2,
          d = layeroffset + j + slen2;

        f4( a, b, c, d, contour, s, sl, j, k );

      }
    }

  }


  function v( x, y, z ) {

    scope.vertices.push( new THREE.Vector3( x, y, z ) );

  }

  function f3( a, b, c ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, c ) );

    var uvs = uvgen.generateTopUV( scope, a, b, c );

    scope.faceVertexUvs[ 0 ].push( uvs );

  }

  function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, d ) );
    scope.faces.push( new THREE.Face3( b, c, d ) );

    var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

  }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

  generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];

    return [
      new THREE.Vector2( a.x, a.y ),
      new THREE.Vector2( b.x, b.y ),
      new THREE.Vector2( c.x, c.y )
    ];

  },

  generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];
    var d = vertices[ indexD ];

    if ( Math.abs( a.y - b.y ) < 0.01 ) {
      return [
        new THREE.Vector2( a.x, 1 - a.z ),
        new THREE.Vector2( b.x, 1 - b.z ),
        new THREE.Vector2( c.x, 1 - c.z ),
        new THREE.Vector2( d.x, 1 - d.z )
      ];
    } else {
      return [
        new THREE.Vector2( a.y, 1 - a.z ),
        new THREE.Vector2( b.y, 1 - b.z ),
        new THREE.Vector2( c.y, 1 - c.z ),
        new THREE.Vector2( d.y, 1 - d.z )
      ];
    }
  }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *  material: <int> // material index for front and back faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

  THREE.Geometry.call( this );

  this.type = 'ShapeGeometry';

  if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

  for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    this.addShape( shapes[ i ], options );

  }

  return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

  if ( options === undefined ) options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

  //

  var i, l, hole;

  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe...

    for ( i = 0, l = holes.length; i < l; i ++ ) {

      hole = holes[ i ];

      if ( THREE.Shape.Utils.isClockWise( hole ) ) {

        holes[ i ] = hole.reverse();

      }

    }

    reverse = false;

  }

  var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

  // Vertices

  var contour = vertices;

  for ( i = 0, l = holes.length; i < l; i ++ ) {

    hole = holes[ i ];
    vertices = vertices.concat( hole );

  }

  //

  var vert, vlen = vertices.length;
  var face, flen = faces.length;

  for ( i = 0; i < vlen; i ++ ) {

    vert = vertices[ i ];

    this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

  }

  for ( i = 0; i < flen; i ++ ) {

    face = faces[ i ];

    var a = face[ 0 ] + shapesOffset;
    var b = face[ 1 ] + shapesOffset;
    var c = face[ 2 ] + shapesOffset;

    this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
    this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

  }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

  THREE.Geometry.call( this );

  this.type = 'LatheGeometry';

  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };

  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  var inversePointLength = 1.0 / ( points.length - 1 );
  var inverseSegments = 1.0 / segments;

  for ( var i = 0, il = segments; i <= il; i ++ ) {

    var phi = phiStart + i * inverseSegments * phiLength;

    var c = Math.cos( phi ),
      s = Math.sin( phi );

    for ( var j = 0, jl = points.length; j < jl; j ++ ) {

      var pt = points[ j ];

      var vertex = new THREE.Vector3();

      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;

      this.vertices.push( vertex );

    }

  }

  var np = points.length;

  for ( var i = 0, il = segments; i < il; i ++ ) {

    for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;

      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;

      this.faces.push( new THREE.Face3( a, b, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u0, v0 ),
        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u0, v1 )

      ] );

      this.faces.push( new THREE.Face3( b, c, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u1, v1 ),
        new THREE.Vector2( u0, v1 )

      ] );


    }

  }

  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

  console.log( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

  THREE.Geometry.call( this );

  this.type = 'PlaneGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.BufferGeometry.call( this );

  this.type = 'PlaneBufferGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  var width_half = width / 2;
  var height_half = height / 2;

  var gridX = Math.floor( widthSegments ) || 1;
  var gridY = Math.floor( heightSegments ) || 1;

  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;

  var segment_width = width / gridX;
  var segment_height = height / gridY;

  var vertices = new Float32Array( gridX1 * gridY1 * 3 );
  var normals = new Float32Array( gridX1 * gridY1 * 3 );
  var uvs = new Float32Array( gridX1 * gridY1 * 2 );

  var offset = 0;
  var offset2 = 0;

  for ( var iy = 0; iy < gridY1; iy ++ ) {

    var y = iy * segment_height - height_half;

    for ( var ix = 0; ix < gridX1; ix ++ ) {

      var x = ix * segment_width - width_half;

      vertices[ offset     ] = x;
      vertices[ offset + 1 ] = - y;

      normals[ offset + 2 ] = 1;

      uvs[ offset2     ] = ix / gridX;
      uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

      offset += 3;
      offset2 += 2;

    }

  }

  offset = 0;

  var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

  for ( var iy = 0; iy < gridY; iy ++ ) {

    for ( var ix = 0; ix < gridX; ix ++ ) {

      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * ( iy + 1 );
      var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
      var d = ( ix + 1 ) + gridX1 * iy;

      indices[ offset     ] = a;
      indices[ offset + 1 ] = b;
      indices[ offset + 2 ] = d;

      indices[ offset + 3 ] = b;
      indices[ offset + 4 ] = c;
      indices[ offset + 5 ] = d;

      offset += 6;

    }

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'RingGeometry';

  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

  var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

  for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

    for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos( segment );
      vertex.y = radius * Math.sin( segment );

      this.vertices.push( vertex );
      uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
    }

    radius += radiusStep;

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

    var thetaSegment = i * (thetaSegments + 1);

    for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

      var segment = o + thetaSegment;

      var v1 = segment;
      var v2 = segment + thetaSegments + 1;
      var v3 = segment + thetaSegments + 2;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

      v1 = segment;
      v2 = segment + thetaSegments + 2;
      v3 = segment + 1;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

    }
  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  console.log( 'THREE.SphereGeometry: Consider using THREE.SphereBufferGeometry for lower memory footprint.' );

  THREE.Geometry.call( this );

  this.type = 'SphereGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 2, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    for ( x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;
      var v = y / heightSegments;

      var vertex = new THREE.Vector3();
      vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
      vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  for ( y = 0; y < heightSegments; y ++ ) {

    for ( x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = vertices[ y + 1 ][ x ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      var n1 = this.vertices[ v1 ].clone().normalize();
      var n2 = this.vertices[ v2 ].clone().normalize();
      var n3 = this.vertices[ v3 ].clone().normalize();
      var n4 = this.vertices[ v4 ].clone().normalize();

      var uv1 = uvs[ y ][ x + 1 ].clone();
      var uv2 = uvs[ y ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x ].clone();
      var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

      if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

        uv1.x = ( uv1.x + uv2.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

      } else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

        uv3.x = ( uv3.x + uv4.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

      } else {

        this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

        this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

      }

    }

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'SphereBufferGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 2, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

  var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
  var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3);
  var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

  var index = 0, vertices = [], normal = new THREE.Vector3();

  for ( var y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];

    var v = y / heightSegments;

    for ( var x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;

      var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      var py = radius * Math.cos( thetaStart + v * thetaLength );
      var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      normal.set( px, py, pz ).normalize();

      positions.setXYZ( index, px, py, pz );
      normals.setXYZ( index, normal.x, normal.y, normal.z );
      uvs.setXY( index, u, 1 - v );

      verticesRow.push( index );

      index++;

    }

    vertices.push( verticesRow );

  }

  var indices = [];

  for ( var y = 0; y < heightSegments; y ++ ) {

    for ( var x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y     ][ x + 1 ];
      var v2 = vertices[ y     ][ x     ];
      var v3 = vertices[ y + 1 ][ x     ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      if ( y !== 0 ) indices.push( v1, v2, v4 );
      if ( y !== heightSegments - 1 ) indices.push( v2, v3, v4 );

    }

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', positions );
  this.addAttribute( 'normal', normals );
  this.addAttribute( 'uv', uvs );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size:       <float>,  // size of the text
 *  height:     <float>,  // thickness to extrude text
 *  curveSegments:  <int>,    // number of points on the curves
 *
 *  font:       <string>,   // font name
 *  weight:     <string>,   // font weight (normal, bold)
 *  style:      <string>,   // font style  (normal, italics)
 *
 *  bevelEnabled: <bool>,     // turn on bevel
 *  bevelThickness: <float>,    // how deep into text bevel goes
 *  bevelSize:    <float>,    // how far from text outline is bevel
 *  }
 *
 */

/*  Usage Examples

  // TextGeometry wrapper

  var text3d = new TextGeometry( text, options );

  // Complete manner

  var textShapes = THREE.FontUtils.generateShapes( text, options );
  var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

  parameters = parameters || {};

  var textShapes = THREE.FontUtils.generateShapes( text, parameters );

  // translate parameters to ExtrudeGeometry API

  parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  // defaults

  if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  THREE.ExtrudeGeometry.call( this, textShapes, parameters );

  this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

  THREE.Geometry.call( this );

  this.type = 'TorusGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 8;
  tubularSegments = tubularSegments || 6;
  arc = arc || Math.PI * 2;

  var center = new THREE.Vector3(), uvs = [], normals = [];

  for ( var j = 0; j <= radialSegments; j ++ ) {

    for ( var i = 0; i <= tubularSegments; i ++ ) {

      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;

      center.x = radius * Math.cos( u );
      center.y = radius * Math.sin( u );

      var vertex = new THREE.Vector3();
      vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
      vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
      vertex.z = tube * Math.sin( v );

      this.vertices.push( vertex );

      uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
      normals.push( vertex.clone().sub( center ).normalize() );

    }

  }

  for ( var j = 1; j <= radialSegments; j ++ ) {

    for ( var i = 1; i <= tubularSegments; i ++ ) {

      var a = ( tubularSegments + 1 ) * j + i - 1;
      var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
      var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
      var d = ( tubularSegments + 1 ) * j + i;

      var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

      face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

    }

  }

  this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

  THREE.Geometry.call( this );

  this.type = 'TorusKnotGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    p: p,
    q: q,
    heightScale: heightScale
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 64;
  tubularSegments = tubularSegments || 8;
  p = p || 2;
  q = q || 3;
  heightScale = heightScale || 1;

  var grid = new Array( radialSegments );
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();

  for ( var i = 0; i < radialSegments; ++ i ) {

    grid[ i ] = new Array( tubularSegments );
    var u = i / radialSegments * 2 * p * Math.PI;
    var p1 = getPos( u, q, p, radius, heightScale );
    var p2 = getPos( u + 0.01, q, p, radius, heightScale );
    tang.subVectors( p2, p1 );
    n.addVectors( p2, p1 );

    bitan.crossVectors( tang, n );
    n.crossVectors( bitan, tang );
    bitan.normalize();
    n.normalize();

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var v = j / tubularSegments * 2 * Math.PI;
      var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      var cy = tube * Math.sin( v );

      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;

      grid[ i ][ j ] = this.vertices.push( pos ) - 1;

    }

  }

  for ( var i = 0; i < radialSegments; ++ i ) {

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var ip = ( i + 1 ) % radialSegments;
      var jp = ( j + 1 ) % tubularSegments;

      var a = grid[ i ][ j ];
      var b = grid[ ip ][ j ];
      var c = grid[ ip ][ jp ];
      var d = grid[ i ][ jp ];

      var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
      var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
      var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
      var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }
  }

  this.computeFaceNormals();
  this.computeVertexNormals();

  function getPos( u, in_q, in_p, radius, heightScale ) {

    var cu = Math.cos( u );
    var su = Math.sin( u );
    var quOverP = in_q / in_p * u;
    var cs = Math.cos( quOverP );

    var tx = radius * ( 2 + cs ) * 0.5 * cu;
    var ty = radius * ( 2 + cs ) * su * 0.5;
    var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

    return new THREE.Vector3( tx, ty, tz );

  }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

  THREE.Geometry.call( this );

  this.type = 'TubeGeometry';

  this.parameters = {
    path: path,
    segments: segments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };

  segments = segments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  taper = taper || THREE.TubeGeometry.NoTaper;

  var grid = [];

  var scope = this,

    tangent,
    normal,
    binormal,

    numpoints = segments + 1,

    u, v, r,

    cx, cy,
    pos, pos2 = new THREE.Vector3(),
    i, j,
    ip, jp,
    a, b, c, d,
    uva, uvb, uvc, uvd;

  var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
    tangents = frames.tangents,
    normals = frames.normals,
    binormals = frames.binormals;

  // proxy internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  function vert( x, y, z ) {

    return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

  }

  // consruct the grid

  for ( i = 0; i < numpoints; i ++ ) {

    grid[ i ] = [];

    u = i / ( numpoints - 1 );

    pos = path.getPointAt( u );

    tangent = tangents[ i ];
    normal = normals[ i ];
    binormal = binormals[ i ];

    r = radius * taper( u );

    for ( j = 0; j < radialSegments; j ++ ) {

      v = j / radialSegments * 2 * Math.PI;

      cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      cy = r * Math.sin( v );

      pos2.copy( pos );
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;

      grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    }
  }


  // construct the mesh

  for ( i = 0; i < segments; i ++ ) {

    for ( j = 0; j < radialSegments; j ++ ) {

      ip = ( closed ) ? (i + 1) % segments : i + 1;
      jp = (j + 1) % radialSegments;

      a = grid[ i ][ j ];   // *** NOT NECESSARILY PLANAR ! ***
      b = grid[ ip ][ j ];
      c = grid[ ip ][ jp ];
      d = grid[ i ][ jp ];

      uva = new THREE.Vector2( i / segments, j / radialSegments );
      uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
      uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
      uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }
  }

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function ( u ) {

  return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

  return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

  var normal = new THREE.Vector3(),

    tangents = [],
    normals = [],
    binormals = [],

    vec = new THREE.Vector3(),
    mat = new THREE.Matrix4(),

    numpoints = segments + 1,
    theta,
    epsilon = 0.0001,
    smallest,

    tx, ty, tz,
    i, u;


  // expose internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  // compute the tangent vectors for each segment on the path

  for ( i = 0; i < numpoints; i ++ ) {

    u = i / ( numpoints - 1 );

    tangents[ i ] = path.getTangentAt( u );
    tangents[ i ].normalize();

  }

  initialNormal3();

  /*
  function initialNormal1(lastBinormal) {
    // fixed start binormal. Has dangers of 0 vectors
    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
  }

  function initialNormal2() {

    // This uses the Frenet-Serret formula for deriving binormal
    var t2 = path.getTangentAt( epsilon );

    normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

  }
  */

  function initialNormal3() {
    // select an initial normal vector perpenicular to the first tangent vector,
    // and in the direction of the smallest tangent xyz component

    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs( tangents[ 0 ].x );
    ty = Math.abs( tangents[ 0 ].y );
    tz = Math.abs( tangents[ 0 ].z );

    if ( tx <= smallest ) {
      smallest = tx;
      normal.set( 1, 0, 0 );
    }

    if ( ty <= smallest ) {
      smallest = ty;
      normal.set( 0, 1, 0 );
    }

    if ( tz <= smallest ) {
      normal.set( 0, 0, 1 );
    }

    vec.crossVectors( tangents[ 0 ], normal ).normalize();

    normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
  }


  // compute the slowly-varying normal and binormal vectors for each segment on the path

  for ( i = 1; i < numpoints; i ++ ) {

    normals[ i ] = normals[ i - 1 ].clone();

    binormals[ i ] = binormals[ i - 1 ].clone();

    vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    if ( vec.length() > epsilon ) {

      vec.normalize();

      theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

      normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    }

    binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  }


  // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  if ( closed ) {

    theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    theta /= ( numpoints - 1 );

    if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

      theta = - theta;

    }

    for ( i = 1; i < numpoints; i ++ ) {

      // twist a little...
      normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
      binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }

  }
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

  THREE.Geometry.call( this );

  this.type = 'PolyhedronGeometry';

  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };

  radius = radius || 1;
  detail = detail || 0;

  var that = this;

  for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

  }

  var p = this.vertices;

  var faces = [];

  for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    var v1 = p[ indices[ i     ] ];
    var v2 = p[ indices[ i + 1 ] ];
    var v3 = p[ indices[ i + 2 ] ];

    faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

  }

  var centroid = new THREE.Vector3();

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    subdivide( faces[ i ], detail );

  }


  // Handle case when face straddles the seam

  for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    var uvs = this.faceVertexUvs[ 0 ][ i ];

    var x0 = uvs[ 0 ].x;
    var x1 = uvs[ 1 ].x;
    var x2 = uvs[ 2 ].x;

    var max = Math.max( x0, Math.max( x1, x2 ) );
    var min = Math.min( x0, Math.min( x1, x2 ) );

    if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

      if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
      if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
      if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    }

  }


  // Apply radius

  for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    this.vertices[ i ].multiplyScalar( radius );

  }


  // Merge vertices

  this.mergeVertices();

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


  // Project vector onto sphere's surface

  function prepare( vector ) {

    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push( vertex ) - 1;

    // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    var v = inclination( vector ) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2( u, 1 - v );

    return vertex;

  }


  // Approximate a curved face with recursively sub-divided triangles.

  function make( v1, v2, v3 ) {

    var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    that.faces.push( face );

    centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    var azi = azimuth( centroid );

    that.faceVertexUvs[ 0 ].push( [
      correctUV( v1.uv, v1, azi ),
      correctUV( v2.uv, v2, azi ),
      correctUV( v3.uv, v3, azi )
    ] );

  }


  // Analytically subdivide a face to the required detail level.

  function subdivide( face, detail ) {

    var cols = Math.pow(2, detail);
    var a = prepare( that.vertices[ face.a ] );
    var b = prepare( that.vertices[ face.b ] );
    var c = prepare( that.vertices[ face.c ] );
    var v = [];

    // Construct all of the vertices for this subdivision.

    for ( var i = 0 ; i <= cols; i ++ ) {

      v[ i ] = [];

      var aj = prepare( a.clone().lerp( c, i / cols ) );
      var bj = prepare( b.clone().lerp( c, i / cols ) );
      var rows = cols - i;

      for ( var j = 0; j <= rows; j ++) {

        if ( j === 0 && i === cols ) {

          v[ i ][ j ] = aj;

        } else {

          v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

        }

      }

    }

    // Construct all of the faces.

    for ( var i = 0; i < cols ; i ++ ) {

      for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

        var k = Math.floor( j / 2 );

        if ( j % 2 === 0 ) {

          make(
            v[ i ][ k + 1],
            v[ i + 1 ][ k ],
            v[ i ][ k ]
          );

        } else {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1][ k + 1],
            v[ i + 1 ][ k ]
          );

        }

      }

    }

  }


  // Angle around the Y axis, counter-clockwise when looking from above.

  function azimuth( vector ) {

    return Math.atan2( vector.z, - vector.x );

  }


  // Angle above the XZ plane.

  function inclination( vector ) {

    return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  }


  // Texture fixing helper. Spheres have some odd behaviours.

  function correctUV( uv, vector, azimuth ) {

    if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
    if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    return uv.clone();

  }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

  this.parameters = {
    radius: radius,
    detail: detail
  };

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  var r = 1 / t;

  var vertices = [

    // (1, 1, 1)
    -1, -1, -1,    -1, -1,  1,
    -1,  1, -1,    -1,  1,  1,
     1, -1, -1,     1, -1,  1,
     1,  1, -1,     1,  1,  1,

    // (0, 1/, )
     0, -r, -t,     0, -r,  t,
     0,  r, -t,     0,  r,  t,

    // (1/, , 0)
    -r, -t,  0,    -r,  t,  0,
     r, -t,  0,     r,  t,  0,

    // (, 0, 1/)
    -t,  0, -r,     t,  0, -r,
    -t,  0,  r,     t,  0,  r
  ];

  var indices = [
     3, 11,  7,      3,  7, 15,      3, 15, 13,
     7, 19, 17,      7, 17,  6,      7,  6, 15,
    17,  4,  8,     17,  8, 10,     17, 10,  6,
     8,  0, 16,      8, 16,  2,      8,  2, 10,
     0, 12,  1,      0,  1, 18,      0, 18, 16,
     6, 10,  2,      6,  2, 13,      6, 13, 15,
     2, 16, 18,      2, 18,  3,      2,  3, 13,
    18,  1,  9,     18,  9, 11,     18, 11,  3,
     4, 14, 12,      4, 12,  0,      4,  0,  8,
    11,  9,  5,     11,  5, 19,     11, 19,  7,
    19,  5, 14,     19, 14,  4,     19,  4, 17,
     1, 12, 14,      1, 14,  5,      1,  5,  9
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  var vertices = [
    - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
     0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
     t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  ];

  var indices = [
     0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
     1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
     3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
     4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'IcosahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

  this.parameters = {
    radius: radius,
    detail: detail
  };

  var vertices = [
    1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
  ];

  var indices = [
    0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'OctahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

  var vertices = [
     1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
  ];

  var indices = [
     2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'TetrahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

  THREE.Geometry.call( this );

  this.type = 'ParametricGeometry';

  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };

  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[ 0 ];

  var i, j, p;
  var u, v;

  var sliceCount = slices + 1;

  for ( i = 0; i <= stacks; i ++ ) {

    v = i / stacks;

    for ( j = 0; j <= slices; j ++ ) {

      u = j / slices;

      p = func( u, v );
      verts.push( p );

    }
  }

  var a, b, c, d;
  var uva, uvb, uvc, uvd;

  for ( i = 0; i < stacks; i ++ ) {

    for ( j = 0; j < slices; j ++ ) {

      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = (i + 1) * sliceCount + j + 1;
      d = (i + 1) * sliceCount + j;

      uva = new THREE.Vector2( j / slices, i / stacks );
      uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
      uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
      uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

      faces.push( new THREE.Face3( a, b, d ) );
      uvs.push( [ uva, uvb, uvd ] );

      faces.push( new THREE.Face3( b, c, d ) );
      uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  // console.log(this);

  // magic bullet
  // var diff = this.mergeVertices();
  // console.log('removed ', diff, ' vertices by merging');

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

  THREE.BufferGeometry.call( this );

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) { return a - b };

  var keys = [ 'a', 'b', 'c' ];

  if ( geometry instanceof THREE.Geometry ) {

    var vertices = geometry.vertices;
    var faces = geometry.faces;
    var numEdges = 0;

    // allocate maximal size
    var edges = new Uint32Array( 6 * faces.length );

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0; j < 3; j ++ ) {

        edge[ 0 ] = face[ keys[ j ] ];
        edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
        edge.sort( sortFunction );

        var key = edge.toString();

        if ( hash[ key ] === undefined ) {

          edges[ 2 * numEdges ] = edge[ 0 ];
          edges[ 2 * numEdges + 1 ] = edge[ 1 ];
          hash[ key ] = true;
          numEdges ++;

        }

      }

    }

    var coords = new Float32Array( numEdges * 2 * 3 );

    for ( var i = 0, l = numEdges; i < l; i ++ ) {

      for ( var j = 0; j < 2; j ++ ) {

        var vertex = vertices[ edges [ 2 * i + j] ];

        var index = 6 * i + 3 * j;
        coords[ index + 0 ] = vertex.x;
        coords[ index + 1 ] = vertex.y;
        coords[ index + 2 ] = vertex.z;

      }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

  } else if ( geometry instanceof THREE.BufferGeometry ) {

    if ( geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

      var vertices = geometry.attributes.position;
      var indices = geometry.attributes.index.array;
      var drawcalls = geometry.drawcalls;
      var numEdges = 0;

      if ( drawcalls.length === 0 ) {

        drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

      }

      // allocate maximal size
      var edges = new Uint32Array( 2 * indices.length );

      for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

        var start = drawcalls[ o ].start;
        var count = drawcalls[ o ].count;
        var index = drawcalls[ o ].index;

        for ( var i = start, il = start + count; i < il; i += 3 ) {

          for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = index + indices[ i + j ];
            edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

              edges[ 2 * numEdges ] = edge[ 0 ];
              edges[ 2 * numEdges + 1 ] = edge[ 1 ];
              hash[ key ] = true;
              numEdges ++;

            }

          }

        }

      }

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numEdges; i < l; i ++ ) {

        for ( var j = 0; j < 2; j ++ ) {

          var index = 6 * i + 3 * j;
          var index2 = edges[2 * i + j];

          coords[ index + 0 ] = vertices.getX( index2 );
          coords[ index + 1 ] = vertices.getY( index2 );
          coords[ index + 2 ] = vertices.getZ( index2 );

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else { // non-indexed BufferGeometry

      var vertices = geometry.attributes.position.array;
      var numEdges = vertices.length / 3;
      var numTris = numEdges / 3;

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numTris; i < l; i ++ ) {

        for ( var j = 0; j < 3; j ++ ) {

          var index = 18 * i + 6 * j;

          var index1 = 9 * i + 3 * j;
          coords[ index + 0 ] = vertices[ index1 ];
          coords[ index + 1 ] = vertices[ index1 + 1 ];
          coords[ index + 2 ] = vertices[ index1 + 2 ];

          var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
          coords[ index + 3 ] = vertices[ index2 ];
          coords[ index + 4 ] = vertices[ index2 + 1 ];
          coords[ index + 5 ] = vertices[ index2 + 2 ];

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }

  }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

  size = size || 1;

  var vertices = new Float32Array( [
    0, 0, 0,  size, 0, 0,
    0, 0, 0,  0, size, 0,
    0, 0, 0,  0, 0, size
  ] );

  var colors = new Float32Array( [
    1, 0, 0,  1, 0.6, 0,
    0, 1, 0,  0.6, 1, 0,
    0, 0, 1,  0, 0.6, 1
  ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

  var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
  coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

  return function ( dir, origin, length, color, headLength, headWidth ) {

    // dir is assumed to be normalized

    THREE.Object3D.call( this );

    if ( color === undefined ) color = 0xffff00;
    if ( length === undefined ) length = 1;
    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    this.position.copy( origin );

    this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
    this.line.matrixAutoUpdate = false;
    this.add( this.line );

    this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
    this.cone.matrixAutoUpdate = false;
    this.add( this.cone );

    this.setDirection( dir );
    this.setLength( length, headLength, headWidth );

  }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

  var axis = new THREE.Vector3();
  var radians;

  return function ( dir ) {

    // dir is assumed to be normalized

    if ( dir.y > 0.99999 ) {

      this.quaternion.set( 0, 0, 0, 1 );

    } else if ( dir.y < - 0.99999 ) {

      this.quaternion.set( 1, 0, 0, 0 );

    } else {

      axis.set( dir.z, 0, - dir.x ).normalize();

      radians = Math.acos( dir.y );

      this.quaternion.setFromAxisAngle( axis, radians );

    }

  };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  if ( headLength === undefined ) headLength = 0.2 * length;
  if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  this.line.scale.set( 1, length - headLength, 1 );
  this.line.updateMatrix();

  this.cone.scale.set( headWidth, headLength, headWidth );
  this.cone.position.y = length;
  this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

  this.line.material.color.set( color );
  this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

  if ( object !== undefined ) {

    this.update( object );

  }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = function ( object ) {

  var geometry = object.geometry;

  if ( geometry.boundingBox === null ) {

    geometry.computeBoundingBox();

  }

  var min = geometry.boundingBox.min;
  var max = geometry.boundingBox.max;

  /*
    5____4
  1/___0/|
  | 6__|_7
  2/___3/

  0: max.x, max.y, max.z
  1: min.x, max.y, max.z
  2: min.x, min.y, max.z
  3: max.x, min.y, max.z
  4: max.x, max.y, min.z
  5: min.x, max.y, min.z
  6: min.x, min.y, min.z
  7: max.x, min.y, min.z
  */

  var vertices = this.geometry.attributes.position.array;

  vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
  vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

  vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
  vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

  vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
  vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

  vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
  vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

  //

  vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
  vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

  vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
  vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

  vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
  vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

  vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
  vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

  //

  vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
  vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

  vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
  vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

  vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
  vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

  vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
  vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

  this.geometry.attributes.position.needsUpdate = true;

  this.geometry.computeBoundingSphere();

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0x888888;

  this.object = object;

  this.box = new THREE.Box3();

  THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

  this.box.setFromObject( this.object );

  this.box.size( this.scale );

  this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *  - shows frustum, line of sight and up of the camera
 *  - suitable for fast updates
 *  - based on frustum visualization in lightgl.js shadowmap example
 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

  var pointMap = {};

  // colors

  var hexFrustum = 0xffaa00;
  var hexCone = 0xff0000;
  var hexUp = 0x00aaff;
  var hexTarget = 0xffffff;
  var hexCross = 0x333333;

  // near

  addLine( "n1", "n2", hexFrustum );
  addLine( "n2", "n4", hexFrustum );
  addLine( "n4", "n3", hexFrustum );
  addLine( "n3", "n1", hexFrustum );

  // far

  addLine( "f1", "f2", hexFrustum );
  addLine( "f2", "f4", hexFrustum );
  addLine( "f4", "f3", hexFrustum );
  addLine( "f3", "f1", hexFrustum );

  // sides

  addLine( "n1", "f1", hexFrustum );
  addLine( "n2", "f2", hexFrustum );
  addLine( "n3", "f3", hexFrustum );
  addLine( "n4", "f4", hexFrustum );

  // cone

  addLine( "p", "n1", hexCone );
  addLine( "p", "n2", hexCone );
  addLine( "p", "n3", hexCone );
  addLine( "p", "n4", hexCone );

  // up

  addLine( "u1", "u2", hexUp );
  addLine( "u2", "u3", hexUp );
  addLine( "u3", "u1", hexUp );

  // target

  addLine( "c", "t", hexTarget );
  addLine( "p", "c", hexCross );

  // cross

  addLine( "cn1", "cn2", hexCross );
  addLine( "cn3", "cn4", hexCross );

  addLine( "cf1", "cf2", hexCross );
  addLine( "cf3", "cf4", hexCross );

  function addLine( a, b, hex ) {

    addPoint( a, hex );
    addPoint( b, hex );

  }

  function addPoint( id, hex ) {

    geometry.vertices.push( new THREE.Vector3() );
    geometry.colors.push( new THREE.Color( hex ) );

    if ( pointMap[ id ] === undefined ) {

      pointMap[ id ] = [];

    }

    pointMap[ id ].push( geometry.vertices.length - 1 );

  }

  THREE.LineSegments.call( this, geometry, material );

  this.camera = camera;
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;

  this.pointMap = pointMap;

  this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

  var geometry, pointMap;

  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();

  var setPoint = function ( point, x, y, z ) {

    vector.set( x, y, z ).unproject( camera );

    var points = pointMap[ point ];

    if ( points !== undefined ) {

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        geometry.vertices[ points[ i ] ].copy( vector );

      }

    }

  };

  return function () {

    geometry = this.geometry;
    pointMap = this.pointMap;

    var w = 1, h = 1;

    // we need just camera projection matrix
    // world matrix must be identity

    camera.projectionMatrix.copy( this.camera.projectionMatrix );

    // center / target

    setPoint( "c", 0, 0, - 1 );
    setPoint( "t", 0, 0,  1 );

    // near

    setPoint( "n1", - w, - h, - 1 );
    setPoint( "n2",   w, - h, - 1 );
    setPoint( "n3", - w,   h, - 1 );
    setPoint( "n4",   w,   h, - 1 );

    // far

    setPoint( "f1", - w, - h, 1 );
    setPoint( "f2",   w, - h, 1 );
    setPoint( "f3", - w,   h, 1 );
    setPoint( "f4",   w,   h, 1 );

    // up

    setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    setPoint( "u3",         0, h * 2,   - 1 );

    // cross

    setPoint( "cf1", - w,   0, 1 );
    setPoint( "cf2",   w,   0, 1 );
    setPoint( "cf3",   0, - h, 1 );
    setPoint( "cf4",   0,   h, 1 );

    setPoint( "cn1", - w,   0, - 1 );
    setPoint( "cn2",   w,   0, - 1 );
    setPoint( "cn3",   0, - h, - 1 );
    setPoint( "cn4",   0,   h, - 1 );

    geometry.verticesNeedUpdate = true;

  };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  size = size || 1;

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3( - size,   size, 0 ),
    new THREE.Vector3(   size,   size, 0 ),
    new THREE.Vector3(   size, - size, 0 ),
    new THREE.Vector3( - size, - size, 0 ),
    new THREE.Vector3( - size,   size, 0 )
  );

  var material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.lightPlane = new THREE.Line( geometry, material );
  this.add( this.lightPlane );

  geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(),
    new THREE.Vector3()
  );

  material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.targetLine = new THREE.Line( geometry, material );
  this.add( this.targetLine );

  this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var v3 = new THREE.Vector3();

  return function () {

    v1.setFromMatrixPosition( this.light.matrixWorld );
    v2.setFromMatrixPosition( this.light.target.matrixWorld );
    v3.subVectors( v2, v1 );

    this.lightPlane.lookAt( v3 );
    this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine.geometry.vertices[ 1 ].copy( v3 );
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy( this.lightPlane.material.color );

  };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimim angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xffff00;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = this.object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

  }

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  this.matrixAutoUpdate = false;

  this.normalMatrix = new THREE.Matrix3();

  this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = function () {

  var vertices = this.geometry.vertices;

  var object = this.object;
  var objectVertices = object.geometry.vertices;
  var objectFaces = object.geometry.faces;
  var objectWorldMatrix = object.matrixWorld;

  object.updateMatrixWorld( true );

  this.normalMatrix.getNormalMatrix( objectWorldMatrix );

  for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

    var face = objectFaces[ i ];

    vertices[ i2 ].copy( objectVertices[ face.a ] )
      .add( objectVertices[ face.b ] )
      .add( objectVertices[ face.c ] )
      .divideScalar( 3 )
      .applyMatrix4( objectWorldMatrix );

    vertices[ i2 + 1 ].copy( face.normal )
      .applyMatrix3( this.normalMatrix )
      .normalize()
      .multiplyScalar( this.size )
      .add( vertices[ i2 ] );

  }

  this.geometry.verticesNeedUpdate = true;

  return this;

};

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  this.color1 = new THREE.Color( 0x444444 );
  this.color2 = new THREE.Color( 0x888888 );

  for ( var i = - size; i <= size; i += step ) {

    geometry.vertices.push(
      new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
      new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
    );

    var color = i === 0 ? this.color1 : this.color2;

    geometry.colors.push( color, color, color, color );

  }

  THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

  this.color1.set( colorCenterLine );
  this.color2.set( colorGrid );

  this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  this.colors = [ new THREE.Color(), new THREE.Color() ];

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  for ( var i = 0, il = 8; i < il; i ++ ) {

    geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

  }

  var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

  this.lightSphere = new THREE.Mesh( geometry, material );
  this.add( this.lightSphere );

  this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();

  return function () {

    this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    this.lightSphere.geometry.colorsNeedUpdate = true;

  }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

  this.light = light;
  this.light.updateMatrixWorld();

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  THREE.Mesh.call( this, geometry, material );

  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;

  /*
  var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  var d = light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.scale.set( d, d, d );

  }

  this.add( this.lightDistance );
  */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

  this.geometry.dispose();
  this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

  this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  /*
  var d = this.light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.visible = true;
    this.lightDistance.scale.set( d, d, d );

  }
  */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

  this.bones = this.getBoneList( object );

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );
      geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
      geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

    }

  }

  geometry.dynamic = true;

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  THREE.LineSegments.call( this, geometry, material );

  this.root = object;

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

  this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

  var boneList = [];

  if ( object instanceof THREE.Bone ) {

    boneList.push( object );

  }

  for ( var i = 0; i < object.children.length; i ++ ) {

    boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

  }

  return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

  var geometry = this.geometry;

  var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

  var boneMatrix = new THREE.Matrix4();

  var j = 0;

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
      geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
      geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

      j += 2;

    }

  }

  geometry.verticesNeedUpdate = true;

  geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

  geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

  this.cone = new THREE.Mesh( geometry, material );
  this.add( this.cone );

  this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();

  return function () {

    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan( this.light.angle );

    this.cone.scale.set( coneWidth, coneWidth, coneLength );

    vector.setFromMatrixPosition( this.light.matrixWorld );
    vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    this.cone.lookAt( vector2.sub( vector ) );

    this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xff0000;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

      geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

    }

  }

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  this.matrixAutoUpdate = false;

  this.normalMatrix = new THREE.Matrix3();

  this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();

  return function( object ) {

    var keys = [ 'a', 'b', 'c', 'd' ];

    this.object.updateMatrixWorld( true );

    this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var vertices = this.geometry.vertices;

    var verts = this.object.geometry.vertices;

    var faces = this.object.geometry.faces;

    var worldMatrix = this.object.matrixWorld;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        var vertexId = face[ keys[ j ] ];
        var vertex = verts[ vertexId ];

        var normal = face.vertexNormals[ j ];

        vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

        v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

        v1.add( vertices[ idx ] );
        idx = idx + 1;

        vertices[ idx ].copy( v1 );
        idx = idx + 1;

      }

    }

    this.geometry.verticesNeedUpdate = true;

    return this;

  }

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0x0000ff;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );

    }

  }

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  this.matrixAutoUpdate = false;

  this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();

  return function( object ) {

    var keys = [ 'a', 'b', 'c', 'd' ];

    this.object.updateMatrixWorld( true );

    var vertices = this.geometry.vertices;

    var verts = this.object.geometry.vertices;

    var faces = this.object.geometry.faces;

    var worldMatrix = this.object.matrixWorld;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

        var vertexId = face[ keys[ j ] ];
        var vertex = verts[ vertexId ];

        var tangent = face.vertexTangents[ j ];

        vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

        v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

        v1.add( vertices[ idx ] );
        idx = idx + 1;

        vertices[ idx ].copy( v1 );
        idx = idx + 1;

      }

    }

    this.geometry.verticesNeedUpdate = true;

    return this;

  }

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

  THREE.Object3D.call( this );

  this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.animationsMap = {};
  this.animationsList = [];

  // prepare default animation
  // (all frames played together in 1 second)

  var numFrames = this.geometry.morphTargets.length;

  var name = "__default";

  var startFrame = 0;
  var endFrame = numFrames - 1;

  var fps = numFrames / 1;

  this.createAnimation( name, startFrame, endFrame, fps );
  this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

  var animation = {

    startFrame: start,
    endFrame: end,

    length: end - start + 1,

    fps: fps,
    duration: ( end - start ) / fps,

    lastFrame: 0,
    currentFrame: 0,

    active: false,

    time: 0,
    direction: 1,
    weight: 1,

    directionBackwards: false,
    mirroredLoop: false

  };

  this.animationsMap[ name ] = animation;
  this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

  var pattern = /([a-z]+)_?(\d+)/;

  var firstAnimation, frameRanges = {};

  var geometry = this.geometry;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var chunks = morph.name.match( pattern );

    if ( chunks && chunks.length > 1 ) {

      var name = chunks[ 1 ];

      if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

      var range = frameRanges[ name ];

      if ( i < range.start ) range.start = i;
      if ( i > range.end ) range.end = i;

      if ( ! firstAnimation ) firstAnimation = name;

    }

  }

  for ( var name in frameRanges ) {

    var range = frameRanges[ name ];
    this.createAnimation( name, range.start, range.end, fps );

  }

  this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = 1;
    animation.directionBackwards = false;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = - 1;
    animation.directionBackwards = true;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.fps = fps;
    animation.duration = ( animation.end - animation.start ) / animation.fps;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.duration = duration;
    animation.fps = ( animation.end - animation.start ) / animation.duration;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.weight = weight;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = time;

  }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

  var time = 0;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    time = animation.time;

  }

  return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

  var duration = - 1;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    duration = animation.duration;

  }

  return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = 0;
    animation.active = true;

  } else {

    console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

  }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.active = false;

  }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

  for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    var animation = this.animationsList[ i ];

    if ( ! animation.active ) continue;

    var frameTime = animation.duration / animation.length;

    animation.time += animation.direction * delta;

    if ( animation.mirroredLoop ) {

      if ( animation.time > animation.duration || animation.time < 0 ) {

        animation.direction *= - 1;

        if ( animation.time > animation.duration ) {

          animation.time = animation.duration;
          animation.directionBackwards = true;

        }

        if ( animation.time < 0 ) {

          animation.time = 0;
          animation.directionBackwards = false;

        }

      }

    } else {

      animation.time = animation.time % animation.duration;

      if ( animation.time < 0 ) animation.time += animation.duration;

    }

    var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    var weight = animation.weight;

    if ( keyframe !== animation.currentFrame ) {

      this.morphTargetInfluences[ animation.lastFrame ] = 0;
      this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

      this.morphTargetInfluences[ keyframe ] = 0;

      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;

    }

    var mix = ( animation.time % frameTime ) / frameTime;

    if ( animation.directionBackwards ) mix = 1 - mix;

    this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

  }

};


/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 *
 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
 *
 * Firefox: http://mozvr.com/downloads/
 * Chromium: https://drive.google.com/folderview?id=0BzudLt22BqGRbW9WTHMtOWMzNjQ&usp=sharing#list
 *
 */

THREE.VREffect = function ( renderer, onError ) {

  var vrHMD;
  var eyeTranslationL, eyeFOVL;
  var eyeTranslationR, eyeFOVR;

  function gotVRDevices( devices ) {

    for ( var i = 0; i < devices.length; i ++ ) {

      if ( devices[ i ] instanceof HMDVRDevice ) {

        vrHMD = devices[ i ];

        if ( vrHMD.getEyeParameters !== undefined ) {

          var eyeParamsL = vrHMD.getEyeParameters( 'left' );
          var eyeParamsR = vrHMD.getEyeParameters( 'right' );

          eyeTranslationL = eyeParamsL.eyeTranslation;
          eyeTranslationR = eyeParamsR.eyeTranslation;
          eyeFOVL = eyeParamsL.recommendedFieldOfView;
          eyeFOVR = eyeParamsR.recommendedFieldOfView;

        } else {

          // TODO: This is an older code path and not spec compliant.
          // It should be removed at some point in the near future.
          eyeTranslationL = vrHMD.getEyeTranslation( 'left' );
          eyeTranslationR = vrHMD.getEyeTranslation( 'right' );
          eyeFOVL = vrHMD.getRecommendedEyeFieldOfView( 'left' );
          eyeFOVR = vrHMD.getRecommendedEyeFieldOfView( 'right' );

        }

        break; // We keep the first we encounter

      }

    }

    if ( vrHMD === undefined ) {

      if ( onError ) onError( 'HMD not available' );

    }

  }

  if ( navigator.getVRDevices ) {

    navigator.getVRDevices().then( gotVRDevices );

  }

  //

  this.scale = 1;

  this.setSize = function( width, height ) {

    renderer.setSize( width, height );

  };

  // fullscreen

  var isFullscreen = false;

  var canvas = renderer.domElement;
  var fullscreenchange = canvas.mozRequestFullScreen ? 'mozfullscreenchange' : 'webkitfullscreenchange';

  document.addEventListener( fullscreenchange, function ( event ) {

    isFullscreen = document.mozFullScreenElement || document.webkitFullscreenElement;

  }, false );

  this.setFullScreen = function ( boolean ) {

    if ( vrHMD === undefined ) return;
    if ( isFullscreen === boolean ) return;

    if ( canvas.mozRequestFullScreen ) {

      canvas.mozRequestFullScreen( { vrDisplay: vrHMD } );

    } else if ( canvas.webkitRequestFullscreen ) {

      canvas.webkitRequestFullscreen( { vrDisplay: vrHMD } );

    }

  };

  // render

  var cameraL = new THREE.PerspectiveCamera();
  var cameraR = new THREE.PerspectiveCamera();

  this.render = function ( scene, camera ) {

    if ( vrHMD ) {

      var sceneL, sceneR;

      if ( Array.isArray( scene ) ) {

        sceneL = scene[ 0 ];
        sceneR = scene[ 1 ];

      } else {

        sceneL = scene;
        sceneR = scene;

      }

      var size = renderer.getSize();
      size.width /= 2;

      renderer.enableScissorTest( true );
      renderer.clear();

      if ( camera.parent === undefined ) camera.updateMatrixWorld();

      // Oculus SDK matrix hard coded from gecko
      // var matrix = new THREE.Matrix4();
      // matrix.set(
      //   0.929788947, 0, 0, 0,
      //   0, 0.750974417, 0, 0,
      //   0.0156717598, 0, -1.00000095, -1,
      //   0, 0, -0.01000001, 0
      // );
      // matrix.transpose();

      cameraL.projectionMatrix = fovToProjection( eyeFOVL, true, camera.near, camera.far );
      cameraR.projectionMatrix = fovToProjection( eyeFOVR, true, camera.near, camera.far );

      camera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );
      camera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );

      cameraL.translateX( eyeTranslationL.x * this.scale );
      cameraR.translateX( eyeTranslationR.x * this.scale );

      // render left eye
      renderer.setViewport( 0, 0, size.width, size.height );
      renderer.setScissor( 0, 0, size.width, size.height );
      renderer.render( sceneL, cameraL );

      // render right eye
      renderer.setViewport( size.width, 0, size.width, size.height );
      renderer.setScissor( size.width, 0, size.width, size.height );
      renderer.render( sceneR, cameraR );

      renderer.enableScissorTest( false );

      return;

    }

    // Regular render mode if not HMD

    if ( Array.isArray( scene ) ) scene = scene[ 0 ];

    renderer.render( scene, camera );

  };

  //

  function fovToNDCScaleOffset( fov ) {

    var pxscale = 2.0 / (fov.leftTan + fov.rightTan);
    var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
    var pyscale = 2.0 / (fov.upTan + fov.downTan);
    var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
    return { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };

  }

  function fovPortToProjection( fov, rightHanded, zNear, zFar ) {

    rightHanded = rightHanded === undefined ? true : rightHanded;
    zNear = zNear === undefined ? 0.01 : zNear;
    zFar = zFar === undefined ? 10000.0 : zFar;

    var handednessScale = rightHanded ? -1.0 : 1.0;

    // start with an identity matrix
    var mobj = new THREE.Matrix4();
    var m = mobj.elements;

    // and with scale/offset info for normalized device coords
    var scaleAndOffset = fovToNDCScaleOffset(fov);

    // X result, map clip edges to [-w,+w]
    m[0 * 4 + 0] = scaleAndOffset.scale[0];
    m[0 * 4 + 1] = 0.0;
    m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
    m[0 * 4 + 3] = 0.0;

    // Y result, map clip edges to [-w,+w]
    // Y offset is negated because this proj matrix transforms from world coords with Y=up,
    // but the NDC scaling has Y=down (thanks D3D?)
    m[1 * 4 + 0] = 0.0;
    m[1 * 4 + 1] = scaleAndOffset.scale[1];
    m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
    m[1 * 4 + 3] = 0.0;

    // Z result (up to the app)
    m[2 * 4 + 0] = 0.0;
    m[2 * 4 + 1] = 0.0;
    m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
    m[2 * 4 + 3] = (zFar * zNear) / (zNear - zFar);

    // W result (= Z in)
    m[3 * 4 + 0] = 0.0;
    m[3 * 4 + 1] = 0.0;
    m[3 * 4 + 2] = handednessScale;
    m[3 * 4 + 3] = 0.0;

    mobj.transpose();

    return mobj;
  }

  function fovToProjection( fov, rightHanded, zNear, zFar ) {

    var DEG2RAD = Math.PI / 180.0;

    var fovPort = {
      upTan: Math.tan( fov.upDegrees * DEG2RAD ),
      downTan: Math.tan( fov.downDegrees * DEG2RAD ),
      leftTan: Math.tan( fov.leftDegrees * DEG2RAD ),
      rightTan: Math.tan( fov.rightDegrees * DEG2RAD )
    };

    return fovPortToProjection( fovPort, rightHanded, zNear, zFar );

  }

};

/* globals define */
(function(define){'use strict';define(function(require,exports,module){

	var proto =  Object.create(
    HTMLElement.prototype, {
    createdCallback: {
    	value: function() {
    		var scene = this.scene = document.querySelector('vr-scene');
    		var object = this.object = new THREE.Object3D();
    	}
    },

    attachedCallback: {
    	value: function() {
    		var parent = this.parentNode;
    		parent.add( this );
    		this.update();
    	}
  	},

    detachedCallback: {
    	value: function() {
      	console.log('leaving the DOM :-( )');
    	}
  	},

  	is3Dproperty: {
  		value: function(name) {
  			return name === 'x' ||
  						 name === 'y' ||
  						 name === 'z' ||
  						 name === 'rotx' ||
  						 name === 'roty' ||
  						 name === 'rotz';
  		}
  	},

  	add: {
  		value: function(el) {
  			this.object.add(el.object);
  		}
  	},

  	update: {
  		value: function() {
  			// Position
  			var x = parseFloat(this.getAttribute('x')) || 0;
				var y = parseFloat(this.getAttribute('y')) || 0;
				var z = parseFloat(this.getAttribute('z')) || 0;

				// Orientation
				var orientationX = parseFloat(this.getAttribute('rotX')) || 0;
				var orientationY = parseFloat(this.getAttribute('rotY')) || 0;
				var orientationZ = parseFloat(this.getAttribute('rotZ')) || 0;

				var rotX = THREE.Math.degToRad(orientationX);
				var rotY = THREE.Math.degToRad(orientationY);
				var rotZ = THREE.Math.degToRad(orientationZ);

  			this.object.position.set(x, -y, -z);
  			this.object.rotation.order = 'YXZ';
  			this.object.rotation.set(-rotX, rotY, rotZ);

  			this.scene.render();
  		}
  	},

    attributeChangedCallback: {
    	value: function(name, previousValue, value) {
    		if (this.is3Dproperty(name)) {
    			this.update();
    		}
    }}
  });

	// Registering element and exporting prototype
	module.exports = document.registerElement('vr-object', { prototype: proto });

});})(typeof define=='function'&&define.amd?define
:(function(n,w){'use strict';return typeof module=='object'?function(c){
c(require,exports,module);}:function(c){var m={exports:{}};c(function(n){
return w[n];},m.exports,m);w[n]=m.exports;};})('VRObject',this));
/* globals define */
(function(define){'use strict';define(function(require,exports,module){

	document.registerElement(
	  'vr-camera',
	  {
	    prototype: Object.create(
	      VRObject.prototype, {}
	    )
	  }
	);

});})(typeof define=='function'&&define.amd?define
:(function(n,w){'use strict';return typeof module=='object'?function(c){
c(require,exports,module);}:function(c){var m={exports:{}};c(function(n){
return w[n];},m.exports,m);w[n]=m.exports;};})('VRCamera',this));
/* globals define */
(function(define){'use strict';define(function(require,exports,module){

  var proto = Object.create(
    HTMLElement.prototype, {
      createdCallback: {
        value: function() {
          this.setupScene();
        }
      },

      attachedCallback: {
        value: function() {
          console.log('live on DOM ;-) ');
        }
      },

      detachedCallback: {
        value: function() {
          console.log('leaving the DOM :-( )');
        }
      },

      attributeChangedCallback: {
        value: function(name, previousValue, value)
        {
          if (previousValue == null) {
            console.log(
              'got a new attribute ', name,
              ' with value ', value
            );
          } else if (value == null) {
            console.log(
              'somebody removed ', name,
              ' its value was ', previousValue
            );
          } else {
            console.log(
              name,
              ' changed from ', previousValue,
              ' to ', value
            );
          }
        }
      },

      setupScene: {
        value: function() {
          // The canvas where the WebGL contet will be painted
          this.setupCanvas();
          // three.js camera setup
          this.setupCamera();
          // The three.js renderer setup
          this.setupRenderer();
          this.setupCameraEl();
          this.setupEventHandlers();
        }
      },

      setupCanvas: {
        value: function() {
          var canvas = this.canvas = document.createElement('canvas');
          canvas.classList.add('vr-canvas');
          document.body.appendChild(canvas);
          window.addEventListener('resize', this.resizeCanvas.bind(this), false);
        }
      },

      setupCamera: {
        value: function() {
          var camera = this.camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
          camera.position.z = 400;
        }
      },

      setupCameraEl: {
        value: function() {
          var cameraEl = document.createElement('vr-camera');
          cameraEl.camera = this.camera;
          var els = this.children;
          for (var i = 0; i < els.length; ++i) {
            cameraEl.appendChild(els[i]);
          }
          this.appendChild(cameraEl);
        }
      },

      setupEventHandlers: {
        value: function() {
          var onfullscreenchange = this.onfullscreenchange.bind(this);
          var processDevices = this.processDevices.bind(this);
          var resizeCanvas = this.resizeCanvas.bind(this);
          document.addEventListener("webkitfullscreenchange", onfullscreenchange);
          document.addEventListener("mozfullscreenchange",    onfullscreenchange);
          document.addEventListener("fullscreenchange",       onfullscreenchange);
          this.getVRDevices().then(processDevices)['catch'](function (err) {
            console.warn(err);
          });
        }
      },

      onfullscreenchange: {
        value: function() {
          if ( !document.mozFullScreenElement && !document.webkitFullScreenElement ) {
            this.vrEnabled = false;
            this.renderer = this.monoRenderer;
          } else {
            this.vrEnabled = true;
            this.renderer = this.vrRenderer;
          }
          this.resizeCanvas();
        }
      },

      getVRDevices: {
        value: function() {
          return new Promise(function (resolve, reject) {
            if (navigator.getVRDevices) {
              navigator.getVRDevices().then(function (devices) {
                resolve(devices);
              }, reject);
            } else {
              reject('No VR devices found.');
            }
          });
        }
      },

      enterVR: {
        value: function() {
          if (!this.vr) { return; }
          this.mozRequestFullScreen({
            vrDisplay: this.vr.headset
          });
        }
      },

      resetSensor: {
        value: function() {
          if (this.vr.position) {
            this.vr.position.resetSensor();
          }
        }
      },

      processDevices: {
        value: function(devices) {
          devices = this.filterInvalidDevices(devices);
          var headset = undefined;
          var position = undefined;

          for (var i = 0; i < devices.length; i++) {
            var device = devices[i];
            if (device instanceof HMDVRDevice) {
              headset = device;
            }
            if (device instanceof PositionSensorVRDevice) {
              position = device;
            }
            if (position && headset) {
              this.vr = {
                headset: headset,
                position: position
              };
            }
          }
        }
      },

      filterInvalidDevices: {
        value: function(devices) {
          var oculusDevices = devices.filter(function (device) {
            return device.deviceName.toLowerCase().indexOf('oculus') !== -1;
          });

          if (oculusDevices.length >= 1) {
            return devices.filter(function (device) {
              return device.deviceName.toLowerCase().indexOf('cardboard') === -1;
            });
          } else {
            return devices;
          }
        }
      },

      setupRenderer: {
        value: function() {
          var canvas = this.canvas;
          var renderer = this.renderer = this.monoRenderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true, alpha: true } );
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.sortObjects = false;
          this.vrRenderer = new THREE.VREffect(renderer);
          this.scene = new THREE.Scene();
          this.resizeCanvas();
        }
      },

      resizeCanvas: {
        value: function() {
          var canvas = this.canvas;
          var camera = this.camera;
          // Make it visually fill the positioned parent
          canvas.style.width ='100%';
          canvas.style.height='100%';
          // Set the internal size to match
          canvas.width  = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
          // Updates camera
          camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
          camera.updateProjectionMatrix();
          // Notify the renderer of the size change
          this.renderer.setSize( canvas.width, canvas.height );
          this.render();
        }
      },

      add: {
        value: function(el) {
          this.scene.add(el.object);
        }
      },

      render: {
        value: function() {
          this.renderer.render( this.scene, this.camera );
        }
      }
    }
  );

  // Registering element and exporting prototype
  module.exports = document.registerElement('vr-scene', { prototype: proto });

});})(typeof define=='function'&&define.amd?define
:(function(n,w){'use strict';return typeof module=='object'?function(c){
c(require,exports,module);}:function(c){var m={exports:{}};c(function(n){
return w[n];},m.exports,m);w[n]=m.exports;};})('VRScene',this));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQubWF4LmpzIiwidGhyZWUuanMiLCJWUkVmZmVjdC5qcyIsInZyLW9iamVjdC5qcyIsInZyLWNhbWVyYS5qcyIsInZyLXNjZW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xpa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJ2ci1tYXJrdXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkNvcHlyaWdodCAoQykgMjAxNC0yMDE1IGJ5IFdlYlJlZmxlY3Rpb25cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIE9iamVjdCwgUkVHSVNURVJfRUxFTUVOVCl7J3VzZSBzdHJpY3QnO1xuXG4vLyBpbiBjYXNlIGl0J3MgdGhlcmUgb3IgYWxyZWFkeSBwYXRjaGVkXG5pZiAoUkVHSVNURVJfRUxFTUVOVCBpbiBkb2N1bWVudCkgcmV0dXJuO1xuXG4vLyBETyBOT1QgVVNFIFRISVMgRklMRSBESVJFQ1RMWSwgSVQgV09OJ1QgV09SS1xuLy8gVEhJUyBJUyBBIFBST0pFQ1QgQkFTRUQgT04gQSBCVUlMRCBTWVNURU1cbi8vIFRISVMgRklMRSBJUyBKVVNUIFdSQVBQRUQgVVAgUkVTVUxUSU5HIElOXG4vLyBidWlsZC9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50LmpzXG4vLyBhbmQgaXRzIC5tYXguanMgY291bnRlciBwYXJ0XG5cbnZhclxuICAvLyBJRSA8IDExIG9ubHkgKyBvbGQgV2ViS2l0IGZvciBhdHRyaWJ1dGVzICsgZmVhdHVyZSBkZXRlY3Rpb25cbiAgRVhQQU5ET19VSUQgPSAnX18nICsgUkVHSVNURVJfRUxFTUVOVCArIChNYXRoLnJhbmRvbSgpICogMTBlNCA+PiAwKSxcblxuICAvLyBzaG9ydGN1dHMgYW5kIGNvc3RhbnRzXG4gIEFUVEFDSEVEID0gJ2F0dGFjaGVkJyxcbiAgREVUQUNIRUQgPSAnZGV0YWNoZWQnLFxuICBFWFRFTkRTID0gJ2V4dGVuZHMnLFxuICBBRERJVElPTiA9ICdBRERJVElPTicsXG4gIE1PRElGSUNBVElPTiA9ICdNT0RJRklDQVRJT04nLFxuICBSRU1PVkFMID0gJ1JFTU9WQUwnLFxuICBET01fQVRUUl9NT0RJRklFRCA9ICdET01BdHRyTW9kaWZpZWQnLFxuICBET01fQ09OVEVOVF9MT0FERUQgPSAnRE9NQ29udGVudExvYWRlZCcsXG4gIERPTV9TVUJUUkVFX01PRElGSUVEID0gJ0RPTVN1YnRyZWVNb2RpZmllZCcsXG4gIFBSRUZJWF9UQUcgPSAnPCcsXG4gIFBSRUZJWF9JUyA9ICc9JyxcblxuICAvLyB2YWxpZCBhbmQgaW52YWxpZCBub2RlIG5hbWVzXG4gIHZhbGlkTmFtZSA9IC9eW0EtWl1bQS1aMC05XSooPzotW0EtWjAtOV0rKSskLyxcbiAgaW52YWxpZE5hbWVzID0gW1xuICAgICdBTk5PVEFUSU9OLVhNTCcsXG4gICAgJ0NPTE9SLVBST0ZJTEUnLFxuICAgICdGT05ULUZBQ0UnLFxuICAgICdGT05ULUZBQ0UtU1JDJyxcbiAgICAnRk9OVC1GQUNFLVVSSScsXG4gICAgJ0ZPTlQtRkFDRS1GT1JNQVQnLFxuICAgICdGT05ULUZBQ0UtTkFNRScsXG4gICAgJ01JU1NJTkctR0xZUEgnXG4gIF0sXG5cbiAgLy8gcmVnaXN0ZXJlZCB0eXBlcyBhbmQgdGhlaXIgcHJvdG90eXBlc1xuICB0eXBlcyA9IFtdLFxuICBwcm90b3MgPSBbXSxcblxuICAvLyB0byBxdWVyeSBzdWJub2Rlc1xuICBxdWVyeSA9ICcnLFxuXG4gIC8vIGh0bWwgc2hvcnRjdXQgdXNlZCB0byBmZWF0dXJlIGRldGVjdFxuICBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cbiAgLy8gRVM1IGlubGluZSBoZWxwZXJzIHx8IGJhc2ljIHBhdGNoZXNcbiAgaW5kZXhPZiA9IHR5cGVzLmluZGV4T2YgfHwgZnVuY3Rpb24gKHYpIHtcbiAgICBmb3IodmFyIGkgPSB0aGlzLmxlbmd0aDsgaS0tICYmIHRoaXNbaV0gIT09IHY7KXt9XG4gICAgcmV0dXJuIGk7XG4gIH0sXG5cbiAgLy8gb3RoZXIgaGVscGVycyAvIHNob3J0Y3V0c1xuICBPUCA9IE9iamVjdC5wcm90b3R5cGUsXG4gIGhPUCA9IE9QLmhhc093blByb3BlcnR5LFxuICBpUE8gPSBPUC5pc1Byb3RvdHlwZU9mLFxuXG4gIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgZ09QTiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnUE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIHNQTyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZixcblxuICAvLyBqc2hpbnQgcHJvdG86IHRydWVcbiAgaGFzUHJvdG8gPSAhIU9iamVjdC5fX3Byb3RvX18sXG5cbiAgLy8gdXNlZCB0byBjcmVhdGUgdW5pcXVlIGluc3RhbmNlc1xuICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIEJyaWRnZShwcm90bykge1xuICAgIC8vIHNpbGx5IGJyb2tlbiBwb2x5ZmlsbCBwcm9iYWJseSBldmVyIHVzZWQgYnV0IHNob3J0IGVub3VnaCB0byB3b3JrXG4gICAgcmV0dXJuIHByb3RvID8gKChCcmlkZ2UucHJvdG90eXBlID0gcHJvdG8pLCBuZXcgQnJpZGdlKCkpIDogdGhpcztcbiAgfSxcblxuICAvLyB3aWxsIHNldCB0aGUgcHJvdG90eXBlIGlmIHBvc3NpYmxlXG4gIC8vIG9yIGNvcHkgb3ZlciBhbGwgcHJvcGVydGllc1xuICBzZXRQcm90b3R5cGUgPSBzUE8gfHwgKFxuICAgIGhhc1Byb3RvID9cbiAgICAgIGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9IDogKFxuICAgIChnT1BOICYmIGdPUEQpID9cbiAgICAgIChmdW5jdGlvbigpe1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wZXJ0aWVzKG8sIHApIHtcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbmFtZXMgPSBnT1BOKHApLFxuICAgICAgICAgICAgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAga2V5ID0gbmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoIWhPUC5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkobywga2V5LCBnT1BEKHAsIGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBzZXRQcm9wZXJ0aWVzKG8sIHApO1xuICAgICAgICAgIH0gd2hpbGUgKChwID0gZ1BPKHApKSAmJiAhaVBPLmNhbGwocCwgbykpO1xuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuICAgICAgfSgpKSA6XG4gICAgICBmdW5jdGlvbiAobywgcCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkge1xuICAgICAgICAgIG9ba2V5XSA9IHBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgKSksXG5cbiAgLy8gRE9NIHNob3J0Y3V0cyBhbmQgaGVscGVycywgaWYgYW55XG5cbiAgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixcblxuICBIVE1MRWxlbWVudFByb3RvdHlwZSA9IChcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQgfHxcbiAgICB3aW5kb3cuRWxlbWVudCB8fFxuICAgIHdpbmRvdy5Ob2RlXG4gICkucHJvdG90eXBlLFxuXG4gIElFOCA9ICFpUE8uY2FsbChIVE1MRWxlbWVudFByb3RvdHlwZSwgZG9jdW1lbnRFbGVtZW50KSxcblxuICBpc1ZhbGlkTm9kZSA9IElFOCA/XG4gICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gaVBPLmNhbGwoSFRNTEVsZW1lbnRQcm90b3R5cGUsIG5vZGUpO1xuICAgIH0sXG5cbiAgdGFyZ2V0cyA9IElFOCAmJiBbXSxcblxuICBjbG9uZU5vZGUgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUsXG4gIHNldEF0dHJpYnV0ZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLnNldEF0dHJpYnV0ZSxcbiAgcmVtb3ZlQXR0cmlidXRlID0gSFRNTEVsZW1lbnRQcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlLFxuXG4gIC8vIHJlcGxhY2VkIGxhdGVyIG9uXG4gIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LFxuXG4gIC8vIHNoYXJlZCBvYnNlcnZlciBmb3IgYWxsIGF0dHJpYnV0ZXNcbiAgYXR0cmlidXRlc09ic2VydmVyID0gTXV0YXRpb25PYnNlcnZlciAmJiB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlXG4gIH0sXG5cbiAgLy8gdXNlZnVsIHRvIGRldGVjdCBvbmx5IGlmIHRoZXJlJ3Mgbm8gTXV0YXRpb25PYnNlcnZlclxuICBET01BdHRyTW9kaWZpZWQgPSBNdXRhdGlvbk9ic2VydmVyIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICBkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgRE9NX0FUVFJfTU9ESUZJRUQsXG4gICAgICBET01BdHRyTW9kaWZpZWRcbiAgICApO1xuICB9LFxuXG4gIC8vIHdpbGwgYm90aCBiZSB1c2VkIHRvIG1ha2UgRE9NTm9kZUluc2VydGVkIGFzeW5jaHJvbm91c1xuICBhc2FwUXVldWUsXG4gIHJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBmdW5jdGlvbiAoZm4pIHsgc2V0VGltZW91dChmbiwgMTApOyB9LFxuXG4gIC8vIGludGVybmFsIGZsYWdzXG4gIHNldExpc3RlbmVyID0gZmFsc2UsXG4gIGRvZXNOb3RTdXBwb3J0RE9NQXR0ck1vZGlmaWVkID0gdHJ1ZSxcbiAgZHJvcERvbUNvbnRlbnRMb2FkZWQgPSB0cnVlLFxuXG4gIC8vIG5lZWRlZCBmb3IgdGhlIGlubmVySFRNTCBoZWxwZXJcbiAgbm90RnJvbUlubmVySFRNTEhlbHBlciA9IHRydWUsXG5cbiAgLy8gb3B0aW9uYWxseSBkZWZpbmVkIGxhdGVyIG9uXG4gIG9uU3VidHJlZU1vZGlmaWVkLFxuICBjYWxsRE9NQXR0ck1vZGlmaWVkLFxuICBnZXRBdHRyaWJ1dGVzTWlycm9yLFxuICBvYnNlcnZlcixcblxuICAvLyBiYXNlZCBvbiBzZXR0aW5nIHByb3RvdHlwZSBjYXBhYmlsaXR5XG4gIC8vIHdpbGwgY2hlY2sgcHJvdG8gb3IgdGhlIGV4cGFuZG8gYXR0cmlidXRlXG4gIC8vIGluIG9yZGVyIHRvIHNldHVwIHRoZSBub2RlIG9uY2VcbiAgcGF0Y2hJZk5vdEFscmVhZHksXG4gIHBhdGNoXG47XG5cbmlmIChzUE8gfHwgaGFzUHJvdG8pIHtcbiAgICBwYXRjaElmTm90QWxyZWFkeSA9IGZ1bmN0aW9uIChub2RlLCBwcm90bykge1xuICAgICAgaWYgKCFpUE8uY2FsbChwcm90bywgbm9kZSkpIHtcbiAgICAgICAgc2V0dXBOb2RlKG5vZGUsIHByb3RvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhdGNoID0gc2V0dXBOb2RlO1xufSBlbHNlIHtcbiAgICBwYXRjaElmTm90QWxyZWFkeSA9IGZ1bmN0aW9uIChub2RlLCBwcm90bykge1xuICAgICAgaWYgKCFub2RlW0VYUEFORE9fVUlEXSkge1xuICAgICAgICBub2RlW0VYUEFORE9fVUlEXSA9IE9iamVjdCh0cnVlKTtcbiAgICAgICAgc2V0dXBOb2RlKG5vZGUsIHByb3RvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhdGNoID0gcGF0Y2hJZk5vdEFscmVhZHk7XG59XG5pZiAoSUU4KSB7XG4gIGRvZXNOb3RTdXBwb3J0RE9NQXR0ck1vZGlmaWVkID0gZmFsc2U7XG4gIChmdW5jdGlvbiAoKXtcbiAgICB2YXJcbiAgICAgIGRlc2NyaXB0b3IgPSBnT1BEKEhUTUxFbGVtZW50UHJvdG90eXBlLCAnYWRkRXZlbnRMaXN0ZW5lcicpLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lciA9IGRlc2NyaXB0b3IudmFsdWUsXG4gICAgICBwYXRjaGVkUmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQ3VzdG9tRXZlbnQoRE9NX0FUVFJfTU9ESUZJRUQsIHtidWJibGVzOiB0cnVlfSk7XG4gICAgICAgIGUuYXR0ck5hbWUgPSBuYW1lO1xuICAgICAgICBlLnByZXZWYWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBlLm5ld1ZhbHVlID0gbnVsbDtcbiAgICAgICAgZVtSRU1PVkFMXSA9IGUuYXR0ckNoYW5nZSA9IDI7XG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICB9LFxuICAgICAgcGF0Y2hlZFNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBoYWQgPSB0aGlzLmhhc0F0dHJpYnV0ZShuYW1lKSxcbiAgICAgICAgICBvbGQgPSBoYWQgJiYgdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSksXG4gICAgICAgICAgZSA9IG5ldyBDdXN0b21FdmVudChET01fQVRUUl9NT0RJRklFRCwge2J1YmJsZXM6IHRydWV9KVxuICAgICAgICA7XG4gICAgICAgIHNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgZS5hdHRyTmFtZSA9IG5hbWU7XG4gICAgICAgIGUucHJldlZhbHVlID0gaGFkID8gb2xkIDogbnVsbDtcbiAgICAgICAgZS5uZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoaGFkKSB7XG4gICAgICAgICAgZVtNT0RJRklDQVRJT05dID0gZS5hdHRyQ2hhbmdlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlW0FERElUSU9OXSA9IGUuYXR0ckNoYW5nZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvcGVydHlDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBqc2hpbnQgZXFudWxsOnRydWVcbiAgICAgICAgdmFyXG4gICAgICAgICAgbm9kZSA9IGUuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBzdXBlclNlY3JldCA9IG5vZGVbRVhQQU5ET19VSURdLFxuICAgICAgICAgIHByb3BlcnR5TmFtZSA9IGUucHJvcGVydHlOYW1lLFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHN1cGVyU2VjcmV0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICBzdXBlclNlY3JldCA9IHN1cGVyU2VjcmV0W3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRE9NX0FUVFJfTU9ESUZJRUQsIHtidWJibGVzOiB0cnVlfSk7XG4gICAgICAgICAgZXZlbnQuYXR0ck5hbWUgPSBzdXBlclNlY3JldC5uYW1lO1xuICAgICAgICAgIGV2ZW50LnByZXZWYWx1ZSA9IHN1cGVyU2VjcmV0LnZhbHVlIHx8IG51bGw7XG4gICAgICAgICAgZXZlbnQubmV3VmFsdWUgPSAoc3VwZXJTZWNyZXQudmFsdWUgPSBub2RlW3Byb3BlcnR5TmFtZV0gfHwgbnVsbCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnByZXZWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudFtBRERJVElPTl0gPSBldmVudC5hdHRyQ2hhbmdlID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRbTU9ESUZJQ0FUSU9OXSA9IGV2ZW50LmF0dHJDaGFuZ2UgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlID09PSBET01fQVRUUl9NT0RJRklFRCAmJlxuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAmJlxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSAhPT0gcGF0Y2hlZFNldEF0dHJpYnV0ZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXNbRVhQQU5ET19VSURdID0ge1xuICAgICAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAgICAgbmFtZTogJ2NsYXNzJyxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNsYXNzTmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUgPSBwYXRjaGVkU2V0QXR0cmlidXRlO1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSA9IHBhdGNoZWRSZW1vdmVBdHRyaWJ1dGU7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCAncHJvcGVydHljaGFuZ2UnLCBvblByb3BlcnR5Q2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlLCAnYWRkRXZlbnRMaXN0ZW5lcicsIGRlc2NyaXB0b3IpO1xuICB9KCkpO1xufSBlbHNlIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xuICBkb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihET01fQVRUUl9NT0RJRklFRCwgRE9NQXR0ck1vZGlmaWVkKTtcbiAgZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShFWFBBTkRPX1VJRCwgMSk7XG4gIGRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoRVhQQU5ET19VSUQpO1xuICBpZiAoZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQpIHtcbiAgICBvblN1YnRyZWVNb2RpZmllZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXJcbiAgICAgICAgbm9kZSA9IHRoaXMsXG4gICAgICAgIG9sZEF0dHJpYnV0ZXMsXG4gICAgICAgIG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgIGtleVxuICAgICAgO1xuICAgICAgaWYgKG5vZGUgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXMgPSBub2RlW0VYUEFORE9fVUlEXTtcbiAgICAgICAgbm9kZVtFWFBBTkRPX1VJRF0gPSAobmV3QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNNaXJyb3Iobm9kZSkpO1xuICAgICAgICBmb3IgKGtleSBpbiBuZXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIG9sZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGUgd2FzIGFkZGVkXG4gICAgICAgICAgICByZXR1cm4gY2FsbERPTUF0dHJNb2RpZmllZChcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgQURESVRJT05cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdBdHRyaWJ1dGVzW2tleV0gIT09IG9sZEF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgLy8gYXR0cmlidXRlIHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICByZXR1cm4gY2FsbERPTUF0dHJNb2RpZmllZChcbiAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgTU9ESUZJQ0FUSU9OXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVja2luZyBpZiBpdCBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgIGZvciAoa2V5IGluIG9sZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3QXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gY2FsbERPTUF0dHJNb2RpZmllZChcbiAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgUkVNT1ZBTFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxET01BdHRyTW9kaWZpZWQgPSBmdW5jdGlvbiAoXG4gICAgICBhdHRyQ2hhbmdlLFxuICAgICAgY3VycmVudFRhcmdldCxcbiAgICAgIGF0dHJOYW1lLFxuICAgICAgcHJldlZhbHVlLFxuICAgICAgbmV3VmFsdWUsXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIHZhciBlID0ge1xuICAgICAgICBhdHRyQ2hhbmdlOiBhdHRyQ2hhbmdlLFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0LFxuICAgICAgICBhdHRyTmFtZTogYXR0ck5hbWUsXG4gICAgICAgIHByZXZWYWx1ZTogcHJldlZhbHVlLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH07XG4gICAgICBlW2FjdGlvbl0gPSBhdHRyQ2hhbmdlO1xuICAgICAgb25ET01BdHRyTW9kaWZpZWQoZSk7XG4gICAgfTtcbiAgICBnZXRBdHRyaWJ1dGVzTWlycm9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGZvciAodmFyXG4gICAgICAgIGF0dHIsIG5hbWUsXG4gICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICBpID0gMCwgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIGkgPCBsZW5ndGg7IGkrK1xuICAgICAgKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICBuYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBpZiAobmFtZSAhPT0gJ3NldEF0dHJpYnV0ZScpIHtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vcEFuZFZlcmlmeShsaXN0LCBhY3Rpb24pIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2ZXJpZnlBbmRTZXR1cEFuZEFjdGlvbihsaXN0W2ldLCBhY3Rpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3BBbmRTZXR1cChsaXN0KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxpc3RbaV07XG4gICAgcGF0Y2gobm9kZSwgcHJvdG9zW2dldFR5cGVJbmRleChub2RlKV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc1ZhbGlkTm9kZShub2RlKSkge1xuICAgICAgdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obm9kZSwgYWN0aW9uKTtcbiAgICAgIGxvb3BBbmRWZXJpZnkoXG4gICAgICAgIG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICAgIGFjdGlvblxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0YXJnZXQpIHtcbiAgdmFyXG4gICAgaXMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdpcycpLFxuICAgIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCksXG4gICAgaSA9IGluZGV4T2YuY2FsbChcbiAgICAgIHR5cGVzLFxuICAgICAgaXMgP1xuICAgICAgICAgIFBSRUZJWF9JUyArIGlzLnRvVXBwZXJDYXNlKCkgOlxuICAgICAgICAgIFBSRUZJWF9UQUcgKyBub2RlTmFtZVxuICAgIClcbiAgO1xuICByZXR1cm4gaXMgJiYgLTEgPCBpICYmICFpc0luUVNBKG5vZGVOYW1lLCBpcykgPyAtMSA6IGk7XG59XG5cbmZ1bmN0aW9uIGlzSW5RU0EobmFtZSwgdHlwZSkge1xuICByZXR1cm4gLTEgPCBxdWVyeS5pbmRleE9mKG5hbWUgKyAnW2lzPVwiJyArIHR5cGUgKyAnXCJdJyk7XG59XG5cbmZ1bmN0aW9uIG9uRE9NQXR0ck1vZGlmaWVkKGUpIHtcbiAgdmFyXG4gICAgbm9kZSA9IGUuY3VycmVudFRhcmdldCxcbiAgICBhdHRyQ2hhbmdlID0gZS5hdHRyQ2hhbmdlLFxuICAgIHByZXZWYWx1ZSA9IGUucHJldlZhbHVlLFxuICAgIG5ld1ZhbHVlID0gZS5uZXdWYWx1ZVxuICA7XG4gIGlmIChub3RGcm9tSW5uZXJIVE1MSGVscGVyICYmXG4gICAgICBub2RlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAmJlxuICAgICAgZS5hdHRyTmFtZSAhPT0gJ3N0eWxlJykge1xuICAgIG5vZGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKFxuICAgICAgZS5hdHRyTmFtZSxcbiAgICAgIGF0dHJDaGFuZ2UgPT09IGVbQURESVRJT05dID8gbnVsbCA6IHByZXZWYWx1ZSxcbiAgICAgIGF0dHJDaGFuZ2UgPT09IGVbUkVNT1ZBTF0gPyBudWxsIDogbmV3VmFsdWVcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uRE9NTm9kZShhY3Rpb24pIHtcbiAgdmFyIGV4ZWN1dG9yID0gZXhlY3V0ZUFjdGlvbihhY3Rpb24pO1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICBhc2FwUXVldWUucHVzaChleGVjdXRvciwgZS50YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvblJlYWR5U3RhdGVDaGFuZ2UoZSkge1xuICBpZiAoZHJvcERvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICBkcm9wRG9tQ29udGVudExvYWRlZCA9IGZhbHNlO1xuICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKERPTV9DT05URU5UX0xPQURFRCwgb25SZWFkeVN0YXRlQ2hhbmdlKTtcbiAgfVxuICBsb29wQW5kVmVyaWZ5KFxuICAgIChlLnRhcmdldCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgZS5kZXRhaWwgPT09IERFVEFDSEVEID8gREVUQUNIRUQgOiBBVFRBQ0hFRFxuICApO1xuICBpZiAoSUU4KSBwdXJnZSgpO1xufVxuXG5mdW5jdGlvbiBwYXRjaGVkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIGpzaGludCB2YWxpZHRoaXM6dHJ1ZVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEF0dHJpYnV0ZS5jYWxsKHNlbGYsIG5hbWUsIHZhbHVlKTtcbiAgb25TdWJ0cmVlTW9kaWZpZWQuY2FsbChzZWxmLCB7dGFyZ2V0OiBzZWxmfSk7XG59XG5cbmZ1bmN0aW9uIHNldHVwTm9kZShub2RlLCBwcm90bykge1xuICBzZXRQcm90b3R5cGUobm9kZSwgcHJvdG8pO1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIGF0dHJpYnV0ZXNPYnNlcnZlcik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRvZXNOb3RTdXBwb3J0RE9NQXR0ck1vZGlmaWVkKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSA9IHBhdGNoZWRTZXRBdHRyaWJ1dGU7XG4gICAgICBub2RlW0VYUEFORE9fVUlEXSA9IGdldEF0dHJpYnV0ZXNNaXJyb3Iobm9kZSk7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoRE9NX1NVQlRSRUVfTU9ESUZJRUQsIG9uU3VidHJlZU1vZGlmaWVkKTtcbiAgICB9XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKERPTV9BVFRSX01PRElGSUVELCBvbkRPTUF0dHJNb2RpZmllZCk7XG4gIH1cbiAgaWYgKG5vZGUuY3JlYXRlZENhbGxiYWNrICYmIG5vdEZyb21Jbm5lckhUTUxIZWxwZXIpIHtcbiAgICBub2RlLmNyZWF0ZWQgPSB0cnVlO1xuICAgIG5vZGUuY3JlYXRlZENhbGxiYWNrKCk7XG4gICAgbm9kZS5jcmVhdGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVyZ2UoKSB7XG4gIGZvciAodmFyXG4gICAgbm9kZSxcbiAgICBpID0gMCxcbiAgICBsZW5ndGggPSB0YXJnZXRzLmxlbmd0aDtcbiAgICBpIDwgbGVuZ3RoOyBpKytcbiAgKSB7XG4gICAgbm9kZSA9IHRhcmdldHNbaV07XG4gICAgaWYgKCFkb2N1bWVudEVsZW1lbnQuY29udGFpbnMobm9kZSkpIHtcbiAgICAgIHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICAgICAgdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obm9kZSwgREVUQUNIRUQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlBbmRTZXR1cEFuZEFjdGlvbihub2RlLCBhY3Rpb24pIHtcbiAgdmFyXG4gICAgZm4sXG4gICAgaSA9IGdldFR5cGVJbmRleChub2RlKVxuICA7XG4gIGlmICgtMSA8IGkpIHtcbiAgICBwYXRjaElmTm90QWxyZWFkeShub2RlLCBwcm90b3NbaV0pO1xuICAgIGkgPSAwO1xuICAgIGlmIChhY3Rpb24gPT09IEFUVEFDSEVEICYmICFub2RlW0FUVEFDSEVEXSkge1xuICAgICAgbm9kZVtERVRBQ0hFRF0gPSBmYWxzZTtcbiAgICAgIG5vZGVbQVRUQUNIRURdID0gdHJ1ZTtcbiAgICAgIGkgPSAxO1xuICAgICAgaWYgKElFOCAmJiBpbmRleE9mLmNhbGwodGFyZ2V0cywgbm9kZSkgPCAwKSB7XG4gICAgICAgIHRhcmdldHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gREVUQUNIRUQgJiYgIW5vZGVbREVUQUNIRURdKSB7XG4gICAgICBub2RlW0FUVEFDSEVEXSA9IGZhbHNlO1xuICAgICAgbm9kZVtERVRBQ0hFRF0gPSB0cnVlO1xuICAgICAgaSA9IDE7XG4gICAgfVxuICAgIGlmIChpICYmIChmbiA9IG5vZGVbYWN0aW9uICsgJ0NhbGxiYWNrJ10pKSBmbi5jYWxsKG5vZGUpO1xuICB9XG59XG5cbi8vIHNldCBhcyBlbnVtZXJhYmxlLCB3cml0YWJsZSBhbmQgY29uZmlndXJhYmxlXG5kb2N1bWVudFtSRUdJU1RFUl9FTEVNRU5UXSA9IGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudCh0eXBlLCBvcHRpb25zKSB7XG4gIHVwcGVyVHlwZSA9IHR5cGUudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFzZXRMaXN0ZW5lcikge1xuICAgIC8vIG9ubHkgZmlyc3QgdGltZSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQgaXMgdXNlZFxuICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoaXMgbGlzdGVuZXJcbiAgICAvLyBzZXR0aW5nIGl0IGJ5IGRlZmF1bHQgbWlnaHQgc2xvdyBkb3duIGZvciBubyByZWFzb25cbiAgICBzZXRMaXN0ZW5lciA9IHRydWU7XG4gICAgaWYgKE11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyID0gKGZ1bmN0aW9uKGF0dGFjaGVkLCBkZXRhY2hlZCl7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrRW1BbGwobGlzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGNhbGxiYWNrKGxpc3RbaSsrXSkpe31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKHJlY29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgY3VycmVudCwgbm9kZSxcbiAgICAgICAgICAgIGkgPSAwLCBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgIGNoZWNrRW1BbGwoY3VycmVudC5hZGRlZE5vZGVzLCBhdHRhY2hlZCk7XG4gICAgICAgICAgICAgIGNoZWNrRW1BbGwoY3VycmVudC5yZW1vdmVkTm9kZXMsIGRldGFjaGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgaWYgKG5vdEZyb21Jbm5lckhUTUxIZWxwZXIgJiZcbiAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZU5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQub2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICBub2RlLmdldEF0dHJpYnV0ZShjdXJyZW50LmF0dHJpYnV0ZU5hbWUpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KGV4ZWN1dGVBY3Rpb24oQVRUQUNIRUQpLCBleGVjdXRlQWN0aW9uKERFVEFDSEVEKSkpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc2FwUXVldWUgPSBbXTtcbiAgICAgIHJBRihmdW5jdGlvbiBBU0FQKCkge1xuICAgICAgICB3aGlsZSAoYXNhcFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIGFzYXBRdWV1ZS5zaGlmdCgpLmNhbGwoXG4gICAgICAgICAgICBudWxsLCBhc2FwUXVldWUuc2hpZnQoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgckFGKEFTQVApO1xuICAgICAgfSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBvbkRPTU5vZGUoQVRUQUNIRUQpKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgb25ET01Ob2RlKERFVEFDSEVEKSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihET01fQ09OVEVOVF9MT0FERUQsIG9uUmVhZHlTdGF0ZUNoYW5nZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIG9uUmVhZHlTdGF0ZUNoYW5nZSk7XG5cbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGxvY2FsTmFtZSwgdHlwZUV4dGVuc2lvbikge1xuICAgICAgdmFyXG4gICAgICAgIG5vZGUgPSBjcmVhdGVFbGVtZW50LmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpLFxuICAgICAgICBuYW1lID0gJycgKyBsb2NhbE5hbWUsXG4gICAgICAgIGkgPSBpbmRleE9mLmNhbGwoXG4gICAgICAgICAgdHlwZXMsXG4gICAgICAgICAgKHR5cGVFeHRlbnNpb24gPyBQUkVGSVhfSVMgOiBQUkVGSVhfVEFHKSArXG4gICAgICAgICAgKHR5cGVFeHRlbnNpb24gfHwgbmFtZSkudG9VcHBlckNhc2UoKVxuICAgICAgICApLFxuICAgICAgICBzZXR1cCA9IC0xIDwgaVxuICAgICAgO1xuICAgICAgaWYgKHR5cGVFeHRlbnNpb24pIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2lzJywgdHlwZUV4dGVuc2lvbiA9IHR5cGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmIChzZXR1cCkge1xuICAgICAgICAgIHNldHVwID0gaXNJblFTQShuYW1lLnRvVXBwZXJDYXNlKCksIHR5cGVFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3RGcm9tSW5uZXJIVE1MSGVscGVyID0gIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuaW5uZXJIVE1MSGVscGVyO1xuICAgICAgaWYgKHNldHVwKSBwYXRjaChub2RlLCBwcm90b3NbaV0pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEhUTUxFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChkZWVwKSB7XG4gICAgICB2YXJcbiAgICAgICAgbm9kZSA9IGNsb25lTm9kZS5jYWxsKHRoaXMsICEhZGVlcCksXG4gICAgICAgIGkgPSBnZXRUeXBlSW5kZXgobm9kZSlcbiAgICAgIDtcbiAgICAgIGlmICgtMSA8IGkpIHBhdGNoKG5vZGUsIHByb3Rvc1tpXSk7XG4gICAgICBpZiAoZGVlcCkgbG9vcEFuZFNldHVwKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuXG4gIGlmICgtMiA8IChcbiAgICBpbmRleE9mLmNhbGwodHlwZXMsIFBSRUZJWF9JUyArIHVwcGVyVHlwZSkgK1xuICAgIGluZGV4T2YuY2FsbCh0eXBlcywgUFJFRklYX1RBRyArIHVwcGVyVHlwZSlcbiAgKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSAnICsgdHlwZSArICcgdHlwZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcbiAgfVxuXG4gIGlmICghdmFsaWROYW1lLnRlc3QodXBwZXJUeXBlKSB8fCAtMSA8IGluZGV4T2YuY2FsbChpbnZhbGlkTmFtZXMsIHVwcGVyVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0eXBlICcgKyB0eXBlICsgJyBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXJcbiAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleHRlbmRpbmcgP1xuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lLCB1cHBlclR5cGUpIDpcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgfSxcbiAgICBvcHQgPSBvcHRpb25zIHx8IE9QLFxuICAgIGV4dGVuZGluZyA9IGhPUC5jYWxsKG9wdCwgRVhURU5EUyksXG4gICAgbm9kZU5hbWUgPSBleHRlbmRpbmcgPyBvcHRpb25zW0VYVEVORFNdLnRvVXBwZXJDYXNlKCkgOiB1cHBlclR5cGUsXG4gICAgaSA9IHR5cGVzLnB1c2goKGV4dGVuZGluZyA/IFBSRUZJWF9JUyA6IFBSRUZJWF9UQUcpICsgdXBwZXJUeXBlKSAtIDEsXG4gICAgdXBwZXJUeXBlXG4gIDtcblxuICBxdWVyeSA9IHF1ZXJ5LmNvbmNhdChcbiAgICBxdWVyeS5sZW5ndGggPyAnLCcgOiAnJyxcbiAgICBleHRlbmRpbmcgPyBub2RlTmFtZSArICdbaXM9XCInICsgdHlwZS50b0xvd2VyQ2FzZSgpICsgJ1wiXScgOiBub2RlTmFtZVxuICApO1xuXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IChcbiAgICBwcm90b3NbaV0gPSBoT1AuY2FsbChvcHQsICdwcm90b3R5cGUnKSA/XG4gICAgICBvcHQucHJvdG90eXBlIDpcbiAgICAgIGNyZWF0ZShIVE1MRWxlbWVudFByb3RvdHlwZSlcbiAgKTtcblxuICBsb29wQW5kVmVyaWZ5KFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgIEFUVEFDSEVEXG4gICk7XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yO1xufTtcblxufSh3aW5kb3csIGRvY3VtZW50LCBPYmplY3QsICdyZWdpc3RlckVsZW1lbnQnKSk7IiwiLy8gRmlsZTpzcmMvVGhyZWUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBUSFJFRSA9IHsgUkVWSVNJT046ICc3MmRldicgfTtcblxuLy8gYnJvd3NlcmlmeSBzdXBwb3J0XG5cbmlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgKSB7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcblxufVxuXG4vLyBwb2x5ZmlsbHNcblxuaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cblxuICBNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XG5cbiAgICByZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICt4O1xuXG4gIH07XG5cbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9uXG5cblRIUkVFLk1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XG5cbi8vIEdMIFNUQVRFIENPTlNUQU5UU1xuXG5USFJFRS5DdWxsRmFjZU5vbmUgPSAwO1xuVEhSRUUuQ3VsbEZhY2VCYWNrID0gMTtcblRIUkVFLkN1bGxGYWNlRnJvbnQgPSAyO1xuVEhSRUUuQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSAxO1xuXG4vLyBTSEFET1dJTkcgVFlQRVNcblxuVEhSRUUuQmFzaWNTaGFkb3dNYXAgPSAwO1xuVEhSRUUuUENGU2hhZG93TWFwID0gMTtcblRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgPSAyO1xuXG4vLyBNQVRFUklBTCBDT05TVEFOVFNcblxuLy8gc2lkZVxuXG5USFJFRS5Gcm9udFNpZGUgPSAwO1xuVEhSRUUuQmFja1NpZGUgPSAxO1xuVEhSRUUuRG91YmxlU2lkZSA9IDI7XG5cbi8vIHNoYWRpbmdcblxuVEhSRUUuTm9TaGFkaW5nID0gMDtcblRIUkVFLkZsYXRTaGFkaW5nID0gMTtcblRIUkVFLlNtb290aFNoYWRpbmcgPSAyO1xuXG4vLyBjb2xvcnNcblxuVEhSRUUuTm9Db2xvcnMgPSAwO1xuVEhSRUUuRmFjZUNvbG9ycyA9IDE7XG5USFJFRS5WZXJ0ZXhDb2xvcnMgPSAyO1xuXG4vLyBibGVuZGluZyBtb2Rlc1xuXG5USFJFRS5Ob0JsZW5kaW5nID0gMDtcblRIUkVFLk5vcm1hbEJsZW5kaW5nID0gMTtcblRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XG5USFJFRS5NdWx0aXBseUJsZW5kaW5nID0gNDtcblRIUkVFLkN1c3RvbUJsZW5kaW5nID0gNTtcblxuLy8gY3VzdG9tIGJsZW5kaW5nIGVxdWF0aW9uc1xuLy8gKG51bWJlcnMgc3RhcnQgZnJvbSAxMDAgbm90IHRvIGNsYXNoIHdpdGggb3RoZXJcbi8vICBtYXBwaW5ncyB0byBPcGVuR0wgY29uc3RhbnRzIGRlZmluZWQgaW4gVGV4dHVyZS5qcylcblxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XG5USFJFRS5TdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XG5USFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcblRIUkVFLk1heEVxdWF0aW9uID0gMTA0O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xuXG5USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xuVEhSRUUuU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5USFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgc291cmNlIGZhY3RvcnNcblxuLy9USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuLy9USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xuLy9USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuLy9USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcblRIUkVFLkRzdENvbG9yRmFjdG9yID0gMjA4O1xuVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5cbi8vIGRlcHRoIG1vZGVzXG5cblRIUkVFLk5ldmVyRGVwdGggPSAwO1xuVEhSRUUuQWx3YXlzRGVwdGggPSAxO1xuVEhSRUUuTGVzc0RlcHRoID0gMjtcblRIUkVFLkxlc3NFcXVhbERlcHRoID0gMztcblRIUkVFLkVxdWFsRGVwdGggPSA0O1xuVEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuVEhSRUUuR3JlYXRlckRlcHRoID0gNjtcblRIUkVFLk5vdEVxdWFsRGVwdGggPSA3O1xuXG5cbi8vIFRFWFRVUkUgQ09OU1RBTlRTXG5cblRIUkVFLk11bHRpcGx5T3BlcmF0aW9uID0gMDtcblRIUkVFLk1peE9wZXJhdGlvbiA9IDE7XG5USFJFRS5BZGRPcGVyYXRpb24gPSAyO1xuXG4vLyBNYXBwaW5nIG1vZGVzXG5cblRIUkVFLlVWTWFwcGluZyA9IDMwMDtcblxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuXG5USFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcblxuLy8gV3JhcHBpbmcgbW9kZXNcblxuVEhSRUUuUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcblxuLy8gRmlsdGVyc1xuXG5USFJFRS5OZWFyZXN0RmlsdGVyID0gMTAwMztcblRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuVEhSRUUuTGluZWFyRmlsdGVyID0gMTAwNjtcblRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcblxuLy8gRGF0YSB0eXBlc1xuXG5USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLkJ5dGVUeXBlID0gMTAxMDtcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XG5USFJFRS5VbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5USFJFRS5JbnRUeXBlID0gMTAxMztcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XG5USFJFRS5GbG9hdFR5cGUgPSAxMDE1O1xuVEhSRUUuSGFsZkZsb2F0VHlwZSA9IDEwMjU7XG5cbi8vIFBpeGVsIHR5cGVzXG5cbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE2O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxNztcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcblxuLy8gUGl4ZWwgZm9ybWF0c1xuXG5USFJFRS5BbHBoYUZvcm1hdCA9IDEwMTk7XG5USFJFRS5SR0JGb3JtYXQgPSAxMDIwO1xuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XG5USFJFRS5MdW1pbmFuY2VGb3JtYXQgPSAxMDIyO1xuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDIzO1xuLy8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xuVEhSRUUuUkdCRUZvcm1hdCA9IFRIUkVFLlJHQkFGb3JtYXQ7IC8vMTAyNDtcblxuLy8gRERTIC8gU1QzQyBDb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xuXG5USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XG5USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcblRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XG5cblxuLy8gUFZSVEMgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xuVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xuVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcblRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XG5cblxuLy8gREVQUkVDQVRFRFxuXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgY29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XG5cbiAgdGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG4gICAgdmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xuXG4gIH07XG5cbiAgdGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XG4gICAgdmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XG5cbiAgfTtcblxuICB0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBpcyBub3cgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoKS4nICk7XG5cbiAgfTtcblxufTtcblxuVEhSRUUuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgY29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XG5cbiAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQ29sb3IuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRSR0IoIGFyZ3VtZW50c1sgMCBdLCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKTtcblxuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0KCBjb2xvciApXG5cbn07XG5cblRIUkVFLkNvbG9yLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXG5cbiAgcjogMSwgZzogMSwgYjogMSxcblxuICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cbiAgICAgIHRoaXMuY29weSggdmFsdWUgKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cbiAgICAgIHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuICAgICAgdGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuICAgIGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xuXG4gICAgdGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcbiAgICB0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG4gICAgdGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XG5cbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cbiAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG4gICAgaWYgKCBzID09PSAwICkge1xuXG4gICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGh1ZTJyZ2IgPSBmdW5jdGlvbiAoIHAsIHEsIHQgKSB7XG5cbiAgICAgICAgaWYgKCB0IDwgMCApIHQgKz0gMTtcbiAgICAgICAgaWYgKCB0ID4gMSApIHQgLT0gMTtcbiAgICAgICAgaWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xuICAgICAgICBpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuICAgICAgICBpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XG4gICAgICAgIHJldHVybiBwO1xuXG4gICAgICB9O1xuXG4gICAgICB2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuICAgICAgdmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG4gICAgICB0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcbiAgICAgIHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcbiAgICAgIHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcblxuICAgIC8vIHJnYigyNTUsMCwwKVxuXG4gICAgaWYgKCAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG4gICAgICB2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS5leGVjKCBzdHlsZSApO1xuXG4gICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgLy8gcmdiKDEwMCUsMCUsMCUpXG5cbiAgICBpZiAoIC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLnRlc3QoIHN0eWxlICkgKSB7XG5cbiAgICAgIHZhciBjb2xvciA9IC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLmV4ZWMoIHN0eWxlICk7XG5cbiAgICAgIHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG4gICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICAvLyAjZmYwMDAwXG5cbiAgICBpZiAoIC9eXFwjKFswLTlhLWZdezZ9KSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG4gICAgICB2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXXs2fSkkL2kuZXhlYyggc3R5bGUgKTtcblxuICAgICAgdGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxNiApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgLy8gI2YwMFxuXG4gICAgaWYgKCAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG4gICAgICB2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS5leGVjKCBzdHlsZSApO1xuXG4gICAgICB0aGlzLnNldEhleCggcGFyc2VJbnQoIGNvbG9yWyAxIF0gKyBjb2xvclsgMSBdICsgY29sb3JbIDIgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMyBdICsgY29sb3JbIDMgXSwgMTYgKSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIC8vIHJlZFxuXG4gICAgaWYgKCAvXihcXHcrKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG4gICAgICB0aGlzLnNldEhleCggVEhSRUUuQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIHRoaXMuciA9IGNvbG9yLnI7XG4gICAgdGhpcy5nID0gY29sb3IuZztcbiAgICB0aGlzLmIgPSBjb2xvci5iO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XG5cbiAgICBpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuICAgIHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xuICAgIHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBnYW1tYUZhY3RvciApO1xuICAgIHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBnYW1tYUZhY3RvciApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XG5cbiAgICBpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuICAgIHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XG5cbiAgICB0aGlzLnIgPSBNYXRoLnBvdyggY29sb3Iuciwgc2FmZUludmVyc2UgKTtcbiAgICB0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcbiAgICB0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgc2FmZUludmVyc2UgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29udmVydEdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xuXG4gICAgdGhpcy5yID0gciAqIHI7XG4gICAgdGhpcy5nID0gZyAqIGc7XG4gICAgdGhpcy5iID0gYiAqIGI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbnZlcnRMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xuICAgIHRoaXMuZyA9IE1hdGguc3FydCggdGhpcy5nICk7XG4gICAgdGhpcy5iID0gTWF0aC5zcXJ0KCB0aGlzLmIgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZ2V0SGV4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gKCB0aGlzLnIgKiAyNTUgKSA8PCAxNiBeICggdGhpcy5nICogMjU1ICkgPDwgOCBeICggdGhpcy5iICogMjU1ICkgPDwgMDtcblxuICB9LFxuXG4gIGdldEhleFN0cmluZzogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xuXG4gIH0sXG5cbiAgZ2V0SFNMOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgLy8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblxuICAgIHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcblxuICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XG5cbiAgICB2YXIgaHVlLCBzYXR1cmF0aW9uO1xuICAgIHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xuXG4gICAgaWYgKCBtaW4gPT09IG1heCApIHtcblxuICAgICAgaHVlID0gMDtcbiAgICAgIHNhdHVyYXRpb24gPSAwO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuXG4gICAgICBzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cbiAgICAgIHN3aXRjaCAoIG1heCApIHtcblxuICAgICAgICBjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xuICAgICAgICBjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG4gICAgICAgIGNhc2UgYjogaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0OyBicmVhaztcblxuICAgICAgfVxuXG4gICAgICBodWUgLz0gNjtcblxuICAgIH1cblxuICAgIGhzbC5oID0gaHVlO1xuICAgIGhzbC5zID0gc2F0dXJhdGlvbjtcbiAgICBoc2wubCA9IGxpZ2h0bmVzcztcblxuICAgIHJldHVybiBoc2w7XG5cbiAgfSxcblxuICBnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICdyZ2IoJyArICggKCB0aGlzLnIgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmcgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmIgKiAyNTUgKSB8IDAgKSArICcpJztcblxuICB9LFxuXG4gIG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xuXG4gICAgdmFyIGhzbCA9IHRoaXMuZ2V0SFNMKCk7XG5cbiAgICBoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xuXG4gICAgdGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG4gICAgdGhpcy5yICs9IGNvbG9yLnI7XG4gICAgdGhpcy5nICs9IGNvbG9yLmc7XG4gICAgdGhpcy5iICs9IGNvbG9yLmI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcblxuICAgIHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XG4gICAgdGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcbiAgICB0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMuciArPSBzO1xuICAgIHRoaXMuZyArPSBzO1xuICAgIHRoaXMuYiArPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIHRoaXMuciAqPSBjb2xvci5yO1xuICAgIHRoaXMuZyAqPSBjb2xvci5nO1xuICAgIHRoaXMuYiAqPSBjb2xvci5iO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy5yICo9IHM7XG4gICAgdGhpcy5nICo9IHM7XG4gICAgdGhpcy5iICo9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxlcnA6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG4gICAgdGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XG4gICAgdGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XG4gICAgdGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xuXG4gICAgcmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5yID0gYXJyYXlbIDAgXTtcbiAgICB0aGlzLmcgPSBhcnJheVsgMSBdO1xuICAgIHRoaXMuYiA9IGFycmF5WyAyIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLnI7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Db2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXG4nYmVpZ2UnOiAweEY1RjVEQywgJ2Jpc3F1ZSc6IDB4RkZFNEM0LCAnYmxhY2snOiAweDAwMDAwMCwgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsICdibHVlJzogMHgwMDAwRkYsICdibHVldmlvbGV0JzogMHg4QTJCRTIsXG4nYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXG4nY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4QixcbidkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsICdkYXJrZ3JheSc6IDB4QTlBOUE5LCAnZGFya2dyZWVuJzogMHgwMDY0MDAsICdkYXJrZ3JleSc6IDB4QTlBOUE5LCAnZGFya2toYWtpJzogMHhCREI3NkIsICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxuJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcbidkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG4nZGVlcHBpbmsnOiAweEZGMTQ5MywgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsICdkaW1ncmF5JzogMHg2OTY5NjksICdkaW1ncmV5JzogMHg2OTY5NjksICdkb2RnZXJibHVlJzogMHgxRTkwRkYsICdmaXJlYnJpY2snOiAweEIyMjIyMixcbidmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxuJ2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxuJ2luZGlhbnJlZCc6IDB4Q0Q1QzVDLCAnaW5kaWdvJzogMHg0QjAwODIsICdpdm9yeSc6IDB4RkZGRkYwLCAna2hha2knOiAweEYwRTY4QywgJ2xhdmVuZGVyJzogMHhFNkU2RkEsICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcbidsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXG4nbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcbidsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LCAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSwgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLCAnbGltZSc6IDB4MDBGRjAwLCAnbGltZWdyZWVuJzogMHgzMkNEMzIsXG4nbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXG4nbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG4nbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCwgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLCAnbWlzdHlyb3NlJzogMHhGRkU0RTEsICdtb2NjYXNpbic6IDB4RkZFNEI1LCAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcbiduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXG4ncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcbidwZXJ1JzogMHhDRDg1M0YsICdwaW5rJzogMHhGRkMwQ0IsICdwbHVtJzogMHhEREEwREQsICdwb3dkZXJibHVlJzogMHhCMEUwRTYsICdwdXJwbGUnOiAweDgwMDA4MCwgJ3JlZCc6IDB4RkYwMDAwLCAncm9zeWJyb3duJzogMHhCQzhGOEYsXG4ncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcbidzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxuJ3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsICdzdGVlbGJsdWUnOiAweDQ2ODJCNCwgJ3Rhbic6IDB4RDJCNDhDLCAndGVhbCc6IDB4MDA4MDgwLCAndGhpc3RsZSc6IDB4RDhCRkQ4LCAndG9tYXRvJzogMHhGRjYzNDcsICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcbid2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XG5cbi8vIEZpbGU6c3JjL21hdGgvUXVhdGVybmlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gIHRoaXMuX3ggPSB4IHx8IDA7XG4gIHRoaXMuX3kgPSB5IHx8IDA7XG4gIHRoaXMuX3ogPSB6IHx8IDA7XG4gIHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxuXG4gIF94OiAwLF95OiAwLCBfejogMCwgX3c6IDAsXG5cbiAgZ2V0IHggKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3g7XG5cbiAgfSxcblxuICBzZXQgeCAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgZ2V0IHkgKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3k7XG5cbiAgfSxcblxuICBzZXQgeSAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5feSA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgZ2V0IHogKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3o7XG5cbiAgfSxcblxuICBzZXQgeiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5feiA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgZ2V0IHcgKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3c7XG5cbiAgfSxcblxuICBzZXQgdyAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5fdyA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLl93ID0gdztcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cbiAgICB0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuICAgIHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG4gICAgdGhpcy5feiA9IHF1YXRlcm5pb24uejtcbiAgICB0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciwgdXBkYXRlICkge1xuXG4gICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgIC8vICAyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cbiAgICAvLyAgY29udGVudC9TcGluQ2FsYy5tXG5cbiAgICB2YXIgYzEgPSBNYXRoLmNvcyggZXVsZXIuX3ggLyAyICk7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbiggZXVsZXIuX3ggLyAyICk7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcblxuICAgIGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfVxuXG4gICAgaWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cbiAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG4gICAgdmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuICAgIHRoaXMuX3ggPSBheGlzLnggKiBzO1xuICAgIHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuICAgIHRoaXMuX3ogPSBheGlzLnogKiBzO1xuICAgIHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cbiAgICAgIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG4gICAgICBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuICAgICAgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cbiAgICAgIHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuICAgICAgcztcblxuICAgIGlmICggdHJhY2UgPiAwICkge1xuXG4gICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG4gICAgICB0aGlzLl93ID0gMC4yNSAvIHM7XG4gICAgICB0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG4gICAgICB0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG4gICAgICB0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cbiAgICB9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG4gICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuICAgICAgdGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuICAgICAgdGhpcy5feCA9IDAuMjUgKiBzO1xuICAgICAgdGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgICAgdGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG4gICAgfSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG4gICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuICAgICAgdGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuICAgICAgdGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgICAgdGhpcy5feSA9IDAuMjUgKiBzO1xuICAgICAgdGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cbiAgICAgIHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICAgIHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcbiAgICAgIHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcbiAgICAgIHRoaXMuX3ogPSAwLjI1ICogcztcblxuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuICAgIC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG4gICAgdmFyIHYxLCByO1xuXG4gICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cbiAgICAgIGlmICggciA8IEVQUyApIHtcblxuICAgICAgICByID0gMDtcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG4gICAgICAgICAgdjEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdjEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdjEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5feCA9IHYxLng7XG4gICAgICB0aGlzLl95ID0gdjEueTtcbiAgICAgIHRoaXMuX3ogPSB2MS56O1xuICAgICAgdGhpcy5fdyA9IHI7XG5cbiAgICAgIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0oKSxcblxuICBpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX3ggKj0gLSAxO1xuICAgIHRoaXMuX3kgKj0gLSAxO1xuICAgIHRoaXMuX3ogKj0gLSAxO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG4gIH0sXG5cbiAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgaWYgKCBsID09PSAwICkge1xuXG4gICAgICB0aGlzLl94ID0gMDtcbiAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgdGhpcy5feiA9IDA7XG4gICAgICB0aGlzLl93ID0gMTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGwgPSAxIC8gbDtcblxuICAgICAgdGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuICAgICAgdGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuICAgICAgdGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuICAgICAgdGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cbiAgICBpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cbiAgICB2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcbiAgICB2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuICAgIHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG4gICAgdGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcbiAgICB0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuICAgIHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuXG4gIH0sXG5cbiAgc2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XG5cbiAgICBpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgdmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuICAgIHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cbiAgICBpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cbiAgICAgIHRoaXMuX3cgPSAtIHFiLl93O1xuICAgICAgdGhpcy5feCA9IC0gcWIuX3g7XG4gICAgICB0aGlzLl95ID0gLSBxYi5feTtcbiAgICAgIHRoaXMuX3ogPSAtIHFiLl96O1xuXG4gICAgICBjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMuY29weSggcWIgKTtcblxuICAgIH1cblxuICAgIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5feiA9IHo7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgdmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XG4gICAgdmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cbiAgICBpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG4gICAgICB0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xuICAgICAgdGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcbiAgICAgIHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG4gICAgICB0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG4gICAgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICAgIHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG4gICAgdGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcbiAgICB0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuICAgIHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cbiAgICByZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICB0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICB0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cbiAgcmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuXG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuXG59O1xuXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMixcblxuICBzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCArPSB2Lng7XG4gICAgdGhpcy55ICs9IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggKz0gcztcbiAgICB0aGlzLnkgKz0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgIHRoaXMueSA9IGEueSArIGIueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggLT0gcztcbiAgICB0aGlzLnkgLT0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdGhpcy54ID0gYS54IC0gYi54O1xuICAgIHRoaXMueSA9IGEueSAtIGIueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHRoaXMueCAqPSB2Lng7XG4gICAgdGhpcy55ICo9IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMueCAqPSBzO1xuICAgIHRoaXMueSAqPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHRoaXMueCAvPSB2Lng7XG4gICAgdGhpcy55IC89IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIGlmICggc2NhbGFyICE9PSAwICkge1xuXG4gICAgICB2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuICAgICAgdGhpcy54ICo9IGludlNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBpZiAoIHRoaXMueCA+IHYueCApIHtcblxuICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IHYueTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBpZiAoIHRoaXMueCA8IHYueCApIHtcblxuICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IHYueTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsYW1wU2NhbGFyOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtaW4sIG1heDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIH1cblxuICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwgKTtcbiAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgfTtcblxuICB9ICkoKSxcblxuICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICByb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gLSB0aGlzLng7XG4gICAgdGhpcy55ID0gLSB0aGlzLnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcblxuICB9LFxuXG4gIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICB9LFxuXG4gIHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cbiAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cbiAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cbiAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHRoaXMueCwgdGhpcy55ICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cbiAgdGhpcy54ID0geCB8fCAwO1xuICB0aGlzLnkgPSB5IHx8IDA7XG4gIHRoaXMueiA9IHogfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG4gICAgdGhpcy56ID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMueDtcbiAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMueTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuejtcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB0aGlzLnggPSB2Lng7XG4gICAgdGhpcy55ID0gdi55O1xuICAgIHRoaXMueiA9IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCArPSB2Lng7XG4gICAgdGhpcy55ICs9IHYueTtcbiAgICB0aGlzLnogKz0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMueCArPSBzO1xuICAgIHRoaXMueSArPSBzO1xuICAgIHRoaXMueiArPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgdGhpcy55ID0gYS55ICsgYi55O1xuICAgIHRoaXMueiA9IGEueiArIGIuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcbiAgICB0aGlzLnogLT0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMueCAtPSBzO1xuICAgIHRoaXMueSAtPSBzO1xuICAgIHRoaXMueiAtPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgdGhpcy55ID0gYS55IC0gYi55O1xuICAgIHRoaXMueiA9IGEueiAtIGIuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG4gICAgfVxuXG4gICAgdGhpcy54ICo9IHYueDtcbiAgICB0aGlzLnkgKj0gdi55O1xuICAgIHRoaXMueiAqPSB2Lno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICB0aGlzLnogKj0gc2NhbGFyO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCAqIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgKiBiLnk7XG4gICAgdGhpcy56ID0gYS56ICogYi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcXVhdGVybmlvbjtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBxdWF0ZXJuaW9uO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgIGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcbiAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cbiAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcbiAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcbiAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxuXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cbiAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG4gICAgdmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcblxuICAgIHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF0gKSAqIGQ7XG4gICAgdGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcbiAgICB0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiBkO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIHF4ID0gcS54O1xuICAgIHZhciBxeSA9IHEueTtcbiAgICB2YXIgcXogPSBxLno7XG4gICAgdmFyIHF3ID0gcS53O1xuXG4gICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgdmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgICB2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgIHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcbiAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtYXRyaXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cbiAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHVucHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1hdHJpeDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgIG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG4gICAgLy8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHo7XG4gICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogejtcbiAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG4gICAgdGhpcy5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB0aGlzLnggLz0gdi54O1xuICAgIHRoaXMueSAvPSB2Lnk7XG4gICAgdGhpcy56IC89IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIGlmICggc2NhbGFyICE9PSAwICkge1xuXG4gICAgICB2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuICAgICAgdGhpcy54ICo9IGludlNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLnogKj0gaW52U2NhbGFyO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGlmICggdGhpcy54ID4gdi54ICkge1xuXG4gICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA+IHYueSApIHtcblxuICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnogPiB2LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IHYuejtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBpZiAoIHRoaXMueCA8IHYueCApIHtcblxuICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IHYueTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy56IDwgdi56ICkge1xuXG4gICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueiA8IG1pbi56ICkge1xuXG4gICAgICB0aGlzLnogPSBtaW4uejtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueiA+IG1heC56ICkge1xuXG4gICAgICB0aGlzLnogPSBtYXguejtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1pbiwgbWF4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cbiAgICAgIGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgfVxuXG4gICAgICBtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgfTtcblxuICB9ICkoKSxcblxuICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICByb3VuZDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSAtIHRoaXMueDtcbiAgICB0aGlzLnkgPSAtIHRoaXMueTtcbiAgICB0aGlzLnogPSAtIHRoaXMuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG4gIH0sXG5cbiAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG4gIH0sXG5cbiAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICB9LFxuXG4gIHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggICkge1xuXG4gICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG4gICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cbiAgICB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuICAgIGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xuXG4gICAgfVxuXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cbiAgICB0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcbiAgICB0aGlzLnkgPSB6ICogdi54IC0geCAqIHYuejtcbiAgICB0aGlzLnogPSB4ICogdi55IC0geSAqIHYueDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcbiAgICB2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcblxuICAgIHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSwgZG90O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHYxLmNvcHkoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBkb3QgPSB0aGlzLmRvdCggdjEgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcGxhbmVOb3JtYWwgKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdjEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc3ViKCB2MSApO1xuXG4gICAgfVxuXG4gIH0oKSxcblxuICByZWZsZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcbiAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBub3JtYWwgKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIHRoaXMubGVuZ3RoKCkgKiB2Lmxlbmd0aCgpICk7XG5cbiAgICAvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG4gICAgcmV0dXJuIE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB2YXIgZHggPSB0aGlzLnggLSB2Lng7XG4gICAgdmFyIGR5ID0gdGhpcy55IC0gdi55O1xuICAgIHZhciBkeiA9IHRoaXMueiAtIHYuejtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cbiAgfSxcblxuICBzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgaW5zdGVhZC4nICk7XG5cbiAgfSxcblxuICBzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEsIG9yZGVyICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XG5cbiAgfSxcblxuICBnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcblxuICB9LFxuXG4gIGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcblxuICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xuICB9LFxuXG4gIGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcblxuICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIGluZGV4LCBtYXRyaXggKTtcblxuICB9LFxuXG4gIHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdGhpcy54ID0gbS5lbGVtZW50c1sgMTIgXTtcbiAgICB0aGlzLnkgPSBtLmVsZW1lbnRzWyAxMyBdO1xuICAgIHRoaXMueiA9IG0uZWxlbWVudHNbIDE0IF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdmFyIHN4ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDAgXSwgbS5lbGVtZW50c1sgMSBdLCBtLmVsZW1lbnRzWyAgMiBdICkubGVuZ3RoKCk7XG4gICAgdmFyIHN5ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDQgXSwgbS5lbGVtZW50c1sgNSBdLCBtLmVsZW1lbnRzWyAgNiBdICkubGVuZ3RoKCk7XG4gICAgdmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICB0aGlzLnggPSBzeDtcbiAgICB0aGlzLnkgPSBzeTtcbiAgICB0aGlzLnogPSBzejtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcblxuICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XG5cbiAgICB2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cbiAgICB0aGlzLnggPSBtZVsgb2Zmc2V0IF07XG4gICAgdGhpcy55ID0gbWVbIG9mZnNldCArIDEgXTtcbiAgICB0aGlzLnogPSBtZVsgb2Zmc2V0ICsgMiBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgdGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfSxcblxuICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuICAgIHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3I0ID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuICB0aGlzLnogPSB6IHx8IDA7XG4gIHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufTtcblxuVEhSRUUuVmVjdG9yNC5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLncgPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cbiAgICB0aGlzLnggPSB4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRaOiBmdW5jdGlvbiAoIHogKSB7XG5cbiAgICB0aGlzLnogPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XG5cbiAgICB0aGlzLncgPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG4gICAgc3dpdGNoICggaW5kZXggKSB7XG5cbiAgICAgIGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgICBjYXNlIDI6IHJldHVybiB0aGlzLno7XG4gICAgICBjYXNlIDM6IHJldHVybiB0aGlzLnc7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICB0aGlzLnogPSB2Lno7XG4gICAgdGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCArPSB2Lng7XG4gICAgdGhpcy55ICs9IHYueTtcbiAgICB0aGlzLnogKz0gdi56O1xuICAgIHRoaXMudyArPSB2Lnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54ICs9IHM7XG4gICAgdGhpcy55ICs9IHM7XG4gICAgdGhpcy56ICs9IHM7XG4gICAgdGhpcy53ICs9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgdGhpcy56ID0gYS56ICsgYi56O1xuICAgIHRoaXMudyA9IGEudyArIGIudztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcbiAgICB0aGlzLnogLT0gdi56O1xuICAgIHRoaXMudyAtPSB2Lnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54IC09IHM7XG4gICAgdGhpcy55IC09IHM7XG4gICAgdGhpcy56IC09IHM7XG4gICAgdGhpcy53IC09IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgdGhpcy56ID0gYS56IC0gYi56O1xuICAgIHRoaXMudyA9IGEudyAtIGIudztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgdGhpcy53ICo9IHNjYWxhcjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcbiAgICB2YXIgdyA9IHRoaXMudztcblxuICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xuICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xuICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcbiAgICB0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuICAgICAgdGhpcy56ICo9IGludlNjYWxhcjtcbiAgICAgIHRoaXMudyAqPSBpbnZTY2FsYXI7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMueiA9IDA7XG4gICAgICB0aGlzLncgPSAxO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgLy8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xuXG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcblxuICAgIGlmICggcyA8IDAuMDAwMSApIHtcblxuICAgICAgIHRoaXMueCA9IDE7XG4gICAgICAgdGhpcy55ID0gMDtcbiAgICAgICB0aGlzLnogPSAwO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgIHRoaXMueCA9IHEueCAvIHM7XG4gICAgICAgdGhpcy55ID0gcS55IC8gcztcbiAgICAgICB0aGlzLnogPSBxLnogLyBzO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIHZhciBhbmdsZSwgeCwgeSwgeiwgICAvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuICAgICAgZXBzaWxvbiA9IDAuMDEsICAgLy8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcbiAgICAgIGVwc2lsb24yID0gMC4xLCAgIC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cbiAgICAgIHRlID0gbS5lbGVtZW50cyxcblxuICAgICAgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcbiAgICAgIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG4gICAgICBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuICAgIGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uIClcbiAgICAgICAmJiAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKVxuICAgICAgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xuXG4gICAgICAvLyBzaW5ndWxhcml0eSBmb3VuZFxuICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuICAgICAgLy8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xuXG4gICAgICBpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxuICAgICAgICAgJiYgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApXG4gICAgICAgICAmJiAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yIClcbiAgICAgICAgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XG5cbiAgICAgICAgLy8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cbiAgICAgICAgdGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcblxuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG4gICAgICBhbmdsZSA9IE1hdGguUEk7XG5cbiAgICAgIHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcbiAgICAgIHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcbiAgICAgIHZhciB6eiA9ICggbTMzICsgMSApIC8gMjtcbiAgICAgIHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuICAgICAgdmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XG4gICAgICB2YXIgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcblxuICAgICAgaWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHsgLy8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuICAgICAgICBpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuICAgICAgICAgIHggPSAwO1xuICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICB6ID0gMC43MDcxMDY3ODE7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHggPSBNYXRoLnNxcnQoIHh4ICk7XG4gICAgICAgICAgeSA9IHh5IC8geDtcbiAgICAgICAgICB6ID0geHogLyB4O1xuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICggeXkgPiB6eiApIHsgLy8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuICAgICAgICBpZiAoIHl5IDwgZXBzaWxvbiApIHtcblxuICAgICAgICAgIHggPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB6ID0gMC43MDcxMDY3ODE7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHkgPSBNYXRoLnNxcnQoIHl5ICk7XG4gICAgICAgICAgeCA9IHh5IC8geTtcbiAgICAgICAgICB6ID0geXogLyB5O1xuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHsgLy8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuXG4gICAgICAgIGlmICggenogPCBlcHNpbG9uICkge1xuXG4gICAgICAgICAgeCA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICB6ID0gMDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgeiA9IE1hdGguc3FydCggenogKTtcbiAgICAgICAgICB4ID0geHogLyB6O1xuICAgICAgICAgIHkgPSB5eiAvIHo7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cblxuICAgIH1cblxuICAgIC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuICAgIHZhciBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKVxuICAgICAgICAgICAgICArICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApXG4gICAgICAgICAgICAgICsgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuICAgIGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XG5cbiAgICAvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG4gICAgLy8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXG5cbiAgICB0aGlzLnggPSAoIG0zMiAtIG0yMyApIC8gcztcbiAgICB0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICB0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICB0aGlzLncgPSBNYXRoLmFjb3MoICggbTExICsgbTIyICsgbTMzIC0gMSApIC8gMiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGlmICggdGhpcy54ID4gdi54ICkge1xuXG4gICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA+IHYueSApIHtcblxuICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnogPiB2LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IHYuejtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy53ID4gdi53ICkge1xuXG4gICAgICB0aGlzLncgPSB2Lnc7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueiA8IHYueiApIHtcblxuICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLncgPCB2LncgKSB7XG5cbiAgICAgIHRoaXMudyA9IHYudztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy56IDwgbWluLnogKSB7XG5cbiAgICAgIHRoaXMueiA9IG1pbi56O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IG1heC56O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLncgPCBtaW4udyApIHtcblxuICAgICAgdGhpcy53ID0gbWluLnc7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLncgPiBtYXgudyApIHtcblxuICAgICAgdGhpcy53ID0gbWF4Lnc7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wU2NhbGFyOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtaW4sIG1heDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG4gICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cbiAgICAgIH1cblxuICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICB9O1xuXG4gIH0gKSgpLFxuXG4gIGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcbiAgICB0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2VpbDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgIHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG4gICAgdGhpcy53ID0gTWF0aC5jZWlsKCB0aGlzLncgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgIHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuICAgIHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICByb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgdGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gLSB0aGlzLng7XG4gICAgdGhpcy55ID0gLSB0aGlzLnk7XG4gICAgdGhpcy56ID0gLSB0aGlzLno7XG4gICAgdGhpcy53ID0gLSB0aGlzLnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcblxuICB9LFxuXG4gIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuICB9LFxuXG4gIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgfSxcblxuICBzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcblxuICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgaWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xuXG4gICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cbiAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG4gICAgdGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcbiAgICB0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgdGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICB0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcbiAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuICAgIHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9FdWxlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkV1bGVyID0gZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcblxuICB0aGlzLl94ID0geCB8fCAwO1xuICB0aGlzLl95ID0geSB8fCAwO1xuICB0aGlzLl96ID0geiB8fCAwO1xuICB0aGlzLl9vcmRlciA9IG9yZGVyIHx8IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcjtcblxufTtcblxuVEhSRUUuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuRXVsZXIsXG5cbiAgX3g6IDAsIF95OiAwLCBfejogMCwgX29yZGVyOiBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXIsXG5cbiAgZ2V0IHggKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3g7XG5cbiAgfSxcblxuICBzZXQgeCAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgZ2V0IHkgKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3k7XG5cbiAgfSxcblxuICBzZXQgeSAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5feSA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgZ2V0IHogKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3o7XG5cbiAgfSxcblxuICBzZXQgeiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5feiA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgZ2V0IG9yZGVyICgpIHtcblxuICAgIHJldHVybiB0aGlzLl9vcmRlcjtcblxuICB9LFxuXG4gIHNldCBvcmRlciAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5fb3JkZXIgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcblxuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuX3ogPSB6O1xuICAgIHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIHRoaXMuX3ggPSBldWxlci5feDtcbiAgICB0aGlzLl95ID0gZXVsZXIuX3k7XG4gICAgdGhpcy5feiA9IGV1bGVyLl96O1xuICAgIHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG4gICAgdmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcblxuICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICB2YXIgdGUgPSBtLmVsZW1lbnRzO1xuICAgIHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuICAgIHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuICAgIHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuICAgIG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICBpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuICAgICAgdGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG4gICAgICAgIHRoaXMuX3ogPSAwO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuICAgICAgICB0aGlzLl96ID0gMDtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICB0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgdGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cbiAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICB0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcbiAgICAgICAgdGhpcy5feSA9IDA7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXG5cbiAgICB9XG5cbiAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG4gICAgaWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWF0cml4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICBtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcbiAgICAgIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcblxuICAgIHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuICB9LFxuXG4gIHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuICAgIHZhciBxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xuXG4gICAgICBxLnNldEZyb21FdWxlciggdGhpcyApO1xuICAgICAgdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuICB9LFxuXG4gIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuICAgIHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuICAgIHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuICAgIHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuICAgIGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcblxuICB0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cbiAgICBpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG4gICAgICByZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuICAgIH1cblxuICB9LFxuXG4gIG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkV1bGVyKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9MaW5lMy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkxpbmUzID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXG4gIHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5MaW5lMy5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxuXG4gIHNldDogZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXG4gICAgdGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xuICAgIHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cbiAgICB0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcbiAgICB0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gIH0sXG5cbiAgZGVsdGE6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xuXG4gIH0sXG5cbiAgYXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gIH0sXG5cbiAgY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHN0YXJ0UCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHN0YXJ0RW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcblxuICAgICAgc3RhcnRQLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLnN0YXJ0ICk7XG4gICAgICBzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG4gICAgICB2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xuICAgICAgdmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XG5cbiAgICAgIHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG4gICAgICBpZiAoIGNsYW1wVG9MaW5lICkge1xuXG4gICAgICAgIHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICB0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcblxuICAgIHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkxpbmUzKCkuY29weSggdGhpcyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuQm94MiA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgdGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMiggSW5maW5pdHksIEluZmluaXR5ICk7XG4gIHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxufTtcblxuVEhSRUUuQm94Mi5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkJveDIsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgdGhpcy5taW4uY29weSggbWluICk7XG4gICAgdGhpcy5tYXguY29weSggbWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG4gICAgdGhpcy5tYWtlRW1wdHkoKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGNlbnRlciwgc2l6ZSApIHtcblxuICAgICAgdmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcbiAgICAgIHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcbiAgICAgIHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcbiAgICB0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG4gICAgcmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XG5cbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICB9LFxuXG4gIHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG4gIH0sXG5cbiAgZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHRoaXMubWluLm1pbiggcG9pbnQgKTtcbiAgICB0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICB0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuICAgIHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG4gICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSxcblxuICBjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcbiAgICAgICAgICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIH0sXG5cbiAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG4gICAgLy8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5zZXQoXG4gICAgICAoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG4gICAgICAoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcbiAgICApO1xuXG4gIH0sXG5cbiAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgLy8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cbiAgICBpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ICkge1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgICB2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG4gICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICB0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcbiAgICB0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgdGhpcy5taW4ubWluKCBib3gubWluICk7XG4gICAgdGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICB0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuICAgIHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICByZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Cb3gyKCkuY29weSggdGhpcyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gzLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5Cb3gzID0gZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICB0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XG4gIHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxufTtcblxuVEhSRUUuQm94My5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkJveDMsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgdGhpcy5taW4uY29weSggbWluICk7XG4gICAgdGhpcy5tYXguY29weSggbWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG4gICAgdGhpcy5tYWtlRW1wdHkoKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cbiAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICAgIHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcbiAgICAgIHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxuICAgIC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW5zJywgd29ybGQgdHJhbnNmb3Jtc1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgb2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICAgIG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICAgIHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcblxuICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICBzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdLmFycmF5O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgICAgdjEuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblxuICAgICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgICAgICBzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICB0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG4gICAgdGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG4gICAgcmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xuXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgfSxcblxuICBzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuICB9LFxuXG4gIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICB0aGlzLm1pbi5taW4oIHBvaW50ICk7XG4gICAgdGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICB0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuICAgIHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcbiAgICB0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgaWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcbiAgICAgICAgIHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuICAgICAgICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcbiAgICAgICAoIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICkgJiYgKCBib3gubWF4LnogPD0gdGhpcy5tYXgueiApICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuICAgIC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiByZXN1bHQuc2V0KFxuICAgICAgKCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuICAgICAgKCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuICAgICAgKCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG4gICAgKTtcblxuICB9LFxuXG4gIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG4gICAgaWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuICAgICAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgICB2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG4gICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICAgIHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlcigpO1xuICAgICAgcmVzdWx0LnJhZGl1cyA9IHRoaXMuc2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICB0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcbiAgICB0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgdGhpcy5taW4ubWluKCBib3gubWluICk7XG4gICAgdGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHBvaW50cyA9IFtcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgXTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgICAgLy8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcbiAgICAgIHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuICAgICAgcG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG4gICAgICBwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcbiAgICAgIHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuICAgICAgcG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG4gICAgICBwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcbiAgICAgIHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuICAgICAgcG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxuXG4gICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuICAgICAgdGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG4gICAgdGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcbiAgICB0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQm94MygpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblxuICAgIDEsIDAsIDAsXG4gICAgMCwgMSwgMCxcbiAgICAwLCAwLCAxXG5cbiAgXSApO1xuXG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4MyxcblxuICBzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0ZVsgMCBdID0gbjExOyB0ZVsgMyBdID0gbjEyOyB0ZVsgNiBdID0gbjEzO1xuICAgIHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XG4gICAgdGVbIDIgXSA9IG4zMTsgdGVbIDUgXSA9IG4zMjsgdGVbIDggXSA9IG4zMztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgaWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICAxLCAwLCAwLFxuICAgICAgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgbWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcbiAgICAgIG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sXG4gICAgICBtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cbiAgfSxcblxuICBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuICAgICAgICB2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG4gICAgICAgIHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xuICAgICAgICB2MS50b0FycmF5KCBhcnJheSwgaiApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKyssIGogKysgKSB7XG5cbiAgICAgICAgdjEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XG4gICAgICAgIHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuICAgICAgICB2MS56ID0gYnVmZmVyLmdldFooIGogKTtcblxuICAgICAgICB2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuICAgICAgICBidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcbiAgICB0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xuICAgIHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXG4gICAgICBkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuICAgICAgZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcblxuICAgIHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XG5cbiAgfSxcblxuICBnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cbiAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxuICAgIC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxuXG4gICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0ZVsgMCBdID0gICBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcbiAgICB0ZVsgMSBdID0gLSBtZVsgMTAgXSAqIG1lWyAxIF0gKyBtZVsgMiBdICogbWVbIDkgXTtcbiAgICB0ZVsgMiBdID0gICBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xuICAgIHRlWyAzIF0gPSAtIG1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xuICAgIHRlWyA0IF0gPSAgIG1lWyAxMCBdICogbWVbIDAgXSAtIG1lWyAyIF0gKiBtZVsgOCBdO1xuICAgIHRlWyA1IF0gPSAtIG1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XG4gICAgdGVbIDYgXSA9ICAgbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcbiAgICB0ZVsgNyBdID0gLSBtZVsgOSBdICogbWVbIDAgXSArIG1lWyAxIF0gKiBtZVsgOCBdO1xuICAgIHRlWyA4IF0gPSAgIG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XG5cbiAgICB2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xuXG4gICAgLy8gbm8gaW52ZXJzZVxuXG4gICAgaWYgKCBkZXQgPT09IDAgKSB7XG5cbiAgICAgIHZhciBtc2cgPSBcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cbiAgICAgIGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oIG1zZyApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWRlbnRpdHkoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCAxLjAgLyBkZXQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG4gICAgdG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcbiAgICB0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGFycmF5WyBvZmZzZXQgICAgIF0gPSB0ZVsgMCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cbiAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfSxcblxuICBnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG5cbiAgICB0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cbiAgICB2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICByWyAwIF0gPSBtWyAwIF07XG4gICAgclsgMSBdID0gbVsgMyBdO1xuICAgIHJbIDIgXSA9IG1bIDYgXTtcbiAgICByWyAzIF0gPSBtWyAxIF07XG4gICAgclsgNCBdID0gbVsgNCBdO1xuICAgIHJbIDUgXSA9IG1bIDcgXTtcbiAgICByWyA2IF0gPSBtWyAyIF07XG4gICAgclsgNyBdID0gbVsgNSBdO1xuICAgIHJbIDggXSA9IG1bIDggXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcbiAgICAgIHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXG4gICAgICB0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG4gICAgXTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDMoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5cbiAgXSApO1xuXG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcblxuICBzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuICAgIHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuICAgIHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcbiAgICB0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xuICAgIHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuXG4gIH0sXG5cbiAgY29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuICAgIHRlWyAxMyBdID0gbWVbIDEzIF07XG4gICAgdGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgeEF4aXMuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XG4gICAgeUF4aXMuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG4gICAgekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuICAgIHRoaXMuc2V0KFxuICAgICAgeEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcbiAgICAgIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG4gICAgICB4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuICAgICAgMCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbSApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgICAgdmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcbiAgICAgIHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0KCBtZVsgNCBdLCBtZVsgNSBdLCBtZVsgNiBdICkubGVuZ3RoKCk7XG4gICAgICB2YXIgc2NhbGVaID0gMSAvIHYxLnNldCggbWVbIDggXSwgbWVbIDkgXSwgbWVbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgICAgdGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG4gICAgICB0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcbiAgICAgIHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXG4gICAgICB0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcbiAgICAgIHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuICAgICAgdGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cbiAgICAgIHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuICAgICAgdGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG4gICAgICB0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgfVxuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHZhciB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuICAgIHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XG4gICAgdmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcbiAgICB2YXIgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG4gICAgaWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgIHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG4gICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICB0ZVsgNCBdID0gLSBjICogZjtcbiAgICAgIHRlWyA4IF0gPSBkO1xuXG4gICAgICB0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XG4gICAgICB0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XG4gICAgICB0ZVsgOSBdID0gLSBiICogYztcblxuICAgICAgdGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xuICAgICAgdGVbIDYgXSA9IGJlICsgYWYgKiBkO1xuICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgdmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cbiAgICAgIHRlWyAwIF0gPSBjZSArIGRmICogYjtcbiAgICAgIHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcbiAgICAgIHRlWyA4IF0gPSBhICogZDtcblxuICAgICAgdGVbIDEgXSA9IGEgKiBmO1xuICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgdGVbIDkgXSA9IC0gYjtcblxuICAgICAgdGVbIDIgXSA9IGNmICogYiAtIGRlO1xuICAgICAgdGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgdmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cbiAgICAgIHRlWyAwIF0gPSBjZSAtIGRmICogYjtcbiAgICAgIHRlWyA0IF0gPSAtIGEgKiBmO1xuICAgICAgdGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG4gICAgICB0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG4gICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICB0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cbiAgICAgIHRlWyAyIF0gPSAtIGEgKiBkO1xuICAgICAgdGVbIDYgXSA9IGI7XG4gICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICB2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgdGVbIDQgXSA9IGJlICogZCAtIGFmO1xuICAgICAgdGVbIDggXSA9IGFlICogZCArIGJmO1xuXG4gICAgICB0ZVsgMSBdID0gYyAqIGY7XG4gICAgICB0ZVsgNSBdID0gYmYgKiBkICsgYWU7XG4gICAgICB0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XG5cbiAgICAgIHRlWyAyIF0gPSAtIGQ7XG4gICAgICB0ZVsgNiBdID0gYiAqIGM7XG4gICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICB2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgdGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuICAgICAgdGVbIDggXSA9IGJjICogZiArIGFkO1xuXG4gICAgICB0ZVsgMSBdID0gZjtcbiAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgIHRlWyA5IF0gPSAtIGIgKiBlO1xuXG4gICAgICB0ZVsgMiBdID0gLSBkICogZTtcbiAgICAgIHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcbiAgICAgIHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cbiAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICAgIHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG4gICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICB0ZVsgNCBdID0gLSBmO1xuICAgICAgdGVbIDggXSA9IGQgKiBlO1xuXG4gICAgICB0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG4gICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICB0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cbiAgICAgIHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcbiAgICAgIHRlWyA2IF0gPSBiICogZTtcbiAgICAgIHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cbiAgICB9XG5cbiAgICAvLyBsYXN0IGNvbHVtblxuICAgIHRlWyAzIF0gPSAwO1xuICAgIHRlWyA3IF0gPSAwO1xuICAgIHRlWyAxMSBdID0gMDtcblxuICAgIC8vIGJvdHRvbSByb3dcbiAgICB0ZVsgMTIgXSA9IDA7XG4gICAgdGVbIDEzIF0gPSAwO1xuICAgIHRlWyAxNCBdID0gMDtcbiAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKS4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG4gIH0sXG5cbiAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcbiAgICB2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcbiAgICB2YXIgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6MjtcbiAgICB2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcbiAgICB2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuICAgIHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XG4gICAgdGVbIDQgXSA9IHh5IC0gd3o7XG4gICAgdGVbIDggXSA9IHh6ICsgd3k7XG5cbiAgICB0ZVsgMSBdID0geHkgKyB3ejtcbiAgICB0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xuICAgIHRlWyA5IF0gPSB5eiAtIHd4O1xuXG4gICAgdGVbIDIgXSA9IHh6IC0gd3k7XG4gICAgdGVbIDYgXSA9IHl6ICsgd3g7XG4gICAgdGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XG5cbiAgICAvLyBsYXN0IGNvbHVtblxuICAgIHRlWyAzIF0gPSAwO1xuICAgIHRlWyA3IF0gPSAwO1xuICAgIHRlWyAxMSBdID0gMDtcblxuICAgIC8vIGJvdHRvbSByb3dcbiAgICB0ZVsgMTIgXSA9IDA7XG4gICAgdGVbIDEzIF0gPSAwO1xuICAgIHRlWyAxNCBdID0gMDtcbiAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHgsIHksIHo7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBleWUsIHRhcmdldCwgdXAgKSB7XG5cbiAgICAgIGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIHkgPT09IHVuZGVmaW5lZCApIHkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCB6ID09PSB1bmRlZmluZWQgKSB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBpZiAoIHoubGVuZ3RoKCkgPT09IDAgKSB7XG5cbiAgICAgICAgei56ID0gMTtcblxuICAgICAgfVxuXG4gICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgaWYgKCB4Lmxlbmd0aCgpID09PSAwICkge1xuXG4gICAgICAgIHoueCArPSAwLjAwMDE7XG4gICAgICAgIHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICB9XG5cbiAgICAgIHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XG5cblxuICAgICAgdGVbIDAgXSA9IHgueDsgdGVbIDQgXSA9IHkueDsgdGVbIDggXSA9IHoueDtcbiAgICAgIHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XG4gICAgICB0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtdWx0aXBseTogZnVuY3Rpb24gKCBtLCBuICkge1xuXG4gICAgaWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuICB9LFxuXG4gIG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHZhciBhZSA9IGEuZWxlbWVudHM7XG4gICAgdmFyIGJlID0gYi5lbGVtZW50cztcbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuICAgIHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcbiAgICB2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuICAgIHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cbiAgICB2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XG4gICAgdmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuICAgIHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG4gICAgdmFyIGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcblxuICAgIHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG4gICAgdGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcbiAgICB0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuICAgIHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG4gICAgdGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcbiAgICB0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuICAgIHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG4gICAgdGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cbiAgICB0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuICAgIHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG4gICAgdGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG4gICAgdGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cbiAgICB0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuICAgIHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG4gICAgdGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG4gICAgdGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCBhLCBiLCByICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApO1xuXG4gICAgclsgMCBdID0gdGVbIDAgXTsgclsgMSBdID0gdGVbIDEgXTsgclsgMiBdID0gdGVbIDIgXTsgclsgMyBdID0gdGVbIDMgXTtcbiAgICByWyA0IF0gPSB0ZVsgNCBdOyByWyA1IF0gPSB0ZVsgNSBdOyByWyA2IF0gPSB0ZVsgNiBdOyByWyA3IF0gPSB0ZVsgNyBdO1xuICAgIHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XG4gICAgclsgMTIgXSA9IHRlWyAxMiBdOyByWyAxMyBdID0gdGVbIDEzIF07IHJbIDE0IF0gPSB0ZVsgMTQgXTsgclsgMTUgXSA9IHRlWyAxNSBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG4gICAgdGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcbiAgICB0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcbiAgICB0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcblxuICB9LFxuXG4gIG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cbiAgfSxcblxuICBtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcblxuICB9LFxuXG4gIGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG4gICAgICAgIHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcbiAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG4gICAgICAgIHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcblxuICAgICAgICB2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcbiAgICAgICAgdjEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XG4gICAgICAgIHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xuXG4gICAgICAgIHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gICAgICAgIGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgcm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG4gICAgdi50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcblxuICB9LFxuXG4gIGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gIH0sXG5cbiAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG4gICAgdmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuICAgIHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XG4gICAgdmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuICAgIC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG4gICAgLy8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cbiAgICByZXR1cm4gKFxuICAgICAgbjQxICogKFxuICAgICAgICArIG4xNCAqIG4yMyAqIG4zMlxuICAgICAgICAgLSBuMTMgKiBuMjQgKiBuMzJcbiAgICAgICAgIC0gbjE0ICogbjIyICogbjMzXG4gICAgICAgICArIG4xMiAqIG4yNCAqIG4zM1xuICAgICAgICAgKyBuMTMgKiBuMjIgKiBuMzRcbiAgICAgICAgIC0gbjEyICogbjIzICogbjM0XG4gICAgICApICtcbiAgICAgIG40MiAqIChcbiAgICAgICAgKyBuMTEgKiBuMjMgKiBuMzRcbiAgICAgICAgIC0gbjExICogbjI0ICogbjMzXG4gICAgICAgICArIG4xNCAqIG4yMSAqIG4zM1xuICAgICAgICAgLSBuMTMgKiBuMjEgKiBuMzRcbiAgICAgICAgICsgbjEzICogbjI0ICogbjMxXG4gICAgICAgICAtIG4xNCAqIG4yMyAqIG4zMVxuICAgICAgKSArXG4gICAgICBuNDMgKiAoXG4gICAgICAgICsgbjExICogbjI0ICogbjMyXG4gICAgICAgICAtIG4xMSAqIG4yMiAqIG4zNFxuICAgICAgICAgLSBuMTQgKiBuMjEgKiBuMzJcbiAgICAgICAgICsgbjEyICogbjIxICogbjM0XG4gICAgICAgICArIG4xNCAqIG4yMiAqIG4zMVxuICAgICAgICAgLSBuMTIgKiBuMjQgKiBuMzFcbiAgICAgICkgK1xuICAgICAgbjQ0ICogKFxuICAgICAgICAtIG4xMyAqIG4yMiAqIG4zMVxuICAgICAgICAgLSBuMTEgKiBuMjMgKiBuMzJcbiAgICAgICAgICsgbjExICogbjIyICogbjMzXG4gICAgICAgICArIG4xMyAqIG4yMSAqIG4zMlxuICAgICAgICAgLSBuMTIgKiBuMjEgKiBuMzNcbiAgICAgICAgICsgbjEyICogbjIzICogbjMxXG4gICAgICApXG5cbiAgICApO1xuXG4gIH0sXG5cbiAgdHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciB0bXA7XG5cbiAgICB0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuICAgIHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgYXJyYXlbIG9mZnNldCAgICAgXSA9IHRlWyAwIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cbiAgICBhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblxuICAgIGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgOSBdICA9IHRlWyA5IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgcmV0dXJuIHYxLnNldCggdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0ZVsgMTIgXSA9IHYueDtcbiAgICB0ZVsgMTMgXSA9IHYueTtcbiAgICB0ZVsgMTQgXSA9IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZ2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcblxuICAgIC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgIHZhciBuMTEgPSBtZVsgMCBdLCBuMTIgPSBtZVsgNCBdLCBuMTMgPSBtZVsgOCBdLCBuMTQgPSBtZVsgMTIgXTtcbiAgICB2YXIgbjIxID0gbWVbIDEgXSwgbjIyID0gbWVbIDUgXSwgbjIzID0gbWVbIDkgXSwgbjI0ID0gbWVbIDEzIF07XG4gICAgdmFyIG4zMSA9IG1lWyAyIF0sIG4zMiA9IG1lWyA2IF0sIG4zMyA9IG1lWyAxMCBdLCBuMzQgPSBtZVsgMTQgXTtcbiAgICB2YXIgbjQxID0gbWVbIDMgXSwgbjQyID0gbWVbIDcgXSwgbjQzID0gbWVbIDExIF0sIG40NCA9IG1lWyAxNSBdO1xuXG4gICAgdGVbIDAgXSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NDtcbiAgICB0ZVsgNCBdID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0O1xuICAgIHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XG4gICAgdGVbIDEyIF0gPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG4gICAgdGVbIDEgXSA9IG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NDtcbiAgICB0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xuICAgIHRlWyA5IF0gPSBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQ7XG4gICAgdGVbIDEzIF0gPSBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQ7XG4gICAgdGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcbiAgICB0ZVsgNiBdID0gbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0O1xuICAgIHRlWyAxMCBdID0gbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0O1xuICAgIHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xuICAgIHRlWyAzIF0gPSBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDM7XG4gICAgdGVbIDcgXSA9IG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MztcbiAgICB0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MztcbiAgICB0ZVsgMTUgXSA9IG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMztcblxuICAgIHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcblxuICAgIGlmICggZGV0ID09PSAwICkge1xuXG4gICAgICB2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgICBpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCBtc2cgKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLmlkZW50aXR5KCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfSxcblxuICByb3RhdGVYOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfSxcblxuICByb3RhdGVZOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfSxcblxuICByb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfSxcblxuICByb3RhdGVCeUF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH0sXG5cbiAgc2NhbGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XG5cbiAgICB0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xuICAgIHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XG4gICAgdGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XG4gICAgdGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuICAgIHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcbiAgICB2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgTWF0aC5tYXgoIHNjYWxlWVNxLCBzY2FsZVpTcSApICkgKTtcblxuICB9LFxuXG4gIG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIDEsIDAsIDAsIHgsXG4gICAgICAwLCAxLCAwLCB5LFxuICAgICAgMCwgMCwgMSwgeixcbiAgICAgIDAsIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cbiAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgMSwgMCwgIDAsIDAsXG4gICAgICAwLCBjLCAtIHMsIDAsXG4gICAgICAwLCBzLCAgYywgMCxcbiAgICAgIDAsIDAsICAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgICBjLCAwLCBzLCAwLFxuICAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAtIHMsIDAsIGMsIDAsXG4gICAgICAgMCwgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICBjLCAtIHMsIDAsIDAsXG4gICAgICBzLCAgYywgMCwgMCxcbiAgICAgIDAsICAwLCAxLCAwLFxuICAgICAgMCwgIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcblxuICAgIHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgdmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcbiAgICB2YXIgdCA9IDEgLSBjO1xuICAgIHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuICAgIHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcbiAgICAgIHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcbiAgICAgIHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcbiAgICAgIDAsIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICB4LCAwLCAwLCAwLFxuICAgICAgMCwgeSwgMCwgMCxcbiAgICAgIDAsIDAsIHosIDAsXG4gICAgICAwLCAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuICAgIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcbiAgICB0aGlzLnNjYWxlKCBzY2FsZSApO1xuICAgIHRoaXMuc2V0UG9zaXRpb24oIHBvc2l0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZlY3RvciwgbWF0cml4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG4gICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICB2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG4gICAgICB2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG4gICAgICB2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG4gICAgICAvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuICAgICAgdmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcbiAgICAgIGlmICggZGV0IDwgMCApIHtcblxuICAgICAgICBzeCA9IC0gc3g7XG5cbiAgICAgIH1cblxuICAgICAgcG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuICAgICAgcG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuICAgICAgcG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG4gICAgICAvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXG4gICAgICBtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcblxuICAgICAgdmFyIGludlNYID0gMSAvIHN4O1xuICAgICAgdmFyIGludlNZID0gMSAvIHN5O1xuICAgICAgdmFyIGludlNaID0gMSAvIHN6O1xuXG4gICAgICBtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG4gICAgICBtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuICAgICAgbWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG4gICAgICBtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuICAgICAgcXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgICBzY2FsZS54ID0gc3g7XG4gICAgICBzY2FsZS55ID0gc3k7XG4gICAgICBzY2FsZS56ID0gc3o7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgbWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xuICAgIHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG4gICAgdmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICB2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xuICAgIHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuICAgIHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xuXG4gICAgdGVbIDAgXSA9IHg7ICB0ZVsgNCBdID0gMDsgIHRlWyA4IF0gPSBhOyAgdGVbIDEyIF0gPSAwO1xuICAgIHRlWyAxIF0gPSAwOyAgdGVbIDUgXSA9IHk7ICB0ZVsgOSBdID0gYjsgIHRlWyAxMyBdID0gMDtcbiAgICB0ZVsgMiBdID0gMDsgIHRlWyA2IF0gPSAwOyAgdGVbIDEwIF0gPSBjOyB0ZVsgMTQgXSA9IGQ7XG4gICAgdGVbIDMgXSA9IDA7ICB0ZVsgNyBdID0gMDsgIHRlWyAxMSBdID0gLSAxOyB0ZVsgMTUgXSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG4gICAgdmFyIHltYXggPSBuZWFyICogTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICk7XG4gICAgdmFyIHltaW4gPSAtIHltYXg7XG4gICAgdmFyIHhtaW4gPSB5bWluICogYXNwZWN0O1xuICAgIHZhciB4bWF4ID0geW1heCAqIGFzcGVjdDtcblxuICAgIHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBuZWFyLCBmYXIgKTtcblxuICB9LFxuXG4gIG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciB3ID0gcmlnaHQgLSBsZWZ0O1xuICAgIHZhciBoID0gdG9wIC0gYm90dG9tO1xuICAgIHZhciBwID0gZmFyIC0gbmVhcjtcblxuICAgIHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAvIHc7XG4gICAgdmFyIHkgPSAoIHRvcCArIGJvdHRvbSApIC8gaDtcbiAgICB2YXIgeiA9ICggZmFyICsgbmVhciApIC8gcDtcblxuICAgIHRlWyAwIF0gPSAyIC8gdzsgIHRlWyA0IF0gPSAwOyAgdGVbIDggXSA9IDA7ICB0ZVsgMTIgXSA9IC0geDtcbiAgICB0ZVsgMSBdID0gMDsgIHRlWyA1IF0gPSAyIC8gaDsgIHRlWyA5IF0gPSAwOyAgdGVbIDEzIF0gPSAtIHk7XG4gICAgdGVbIDIgXSA9IDA7ICB0ZVsgNiBdID0gMDsgIHRlWyAxMCBdID0gLSAyIC8gcDsgdGVbIDE0IF0gPSAtIHo7XG4gICAgdGVbIDMgXSA9IDA7ICB0ZVsgNyBdID0gMDsgIHRlWyAxMSBdID0gMDsgdGVbIDE1IF0gPSAxO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cbiAgICB0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHJldHVybiBbXG4gICAgICB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxuICAgICAgdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSwgdGVbIDcgXSxcbiAgICAgIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdLCB0ZVsgMTEgXSxcbiAgICAgIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXG4gICAgXTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUmF5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICB0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuUmF5LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxuXG4gIHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgIHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuICAgIHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcblxuICAgIHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcbiAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgfSxcblxuICByZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgICB0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG4gICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICAgIHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgICAgLy8gcG9pbnQgYmVoaW5kIHRoZSByYXlcblxuICAgICAgaWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cbiAgICAgIH1cblxuICAgICAgdjEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgIHJldHVybiB2MS5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNlZ0NlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHNlZ0RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cbiAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvRGlzdGFuY2UvV201RGlzdFJheTNTZWdtZW50My5jcHBcbiAgICAgIC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XG4gICAgICAvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxuICAgICAgLy8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcbiAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxuICAgICAgLy8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxuXG4gICAgICBzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuICAgICAgc2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xuICAgICAgZGlmZi5jb3B5KCB0aGlzLm9yaWdpbiApLnN1Yiggc2VnQ2VudGVyICk7XG5cbiAgICAgIHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xuICAgICAgdmFyIGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBzZWdEaXIgKTtcbiAgICAgIHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuICAgICAgdmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XG4gICAgICB2YXIgYyA9IGRpZmYubGVuZ3RoU3EoKTtcbiAgICAgIHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xuICAgICAgdmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG4gICAgICBpZiAoIGRldCA+IDAgKSB7XG5cbiAgICAgICAgLy8gVGhlIHJheSBhbmQgc2VnbWVudCBhcmUgbm90IHBhcmFsbGVsLlxuXG4gICAgICAgIHMwID0gYTAxICogYjEgLSBiMDtcbiAgICAgICAgczEgPSBhMDEgKiBiMCAtIGIxO1xuICAgICAgICBleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XG5cbiAgICAgICAgaWYgKCBzMCA+PSAwICkge1xuXG4gICAgICAgICAgaWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuICAgICAgICAgICAgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cbiAgICAgICAgICAgICAgLy8gcmVnaW9uIDBcbiAgICAgICAgICAgICAgLy8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG4gICAgICAgICAgICAgIHZhciBpbnZEZXQgPSAxIC8gZGV0O1xuICAgICAgICAgICAgICBzMCAqPSBpbnZEZXQ7XG4gICAgICAgICAgICAgIHMxICo9IGludkRldDtcbiAgICAgICAgICAgICAgc3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvLyByZWdpb24gMVxuXG4gICAgICAgICAgICAgIHMxID0gc2VnRXh0ZW50O1xuICAgICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG4gICAgICAgICAgICAgIHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHJlZ2lvbiA1XG5cbiAgICAgICAgICAgIHMxID0gLSBzZWdFeHRlbnQ7XG4gICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG4gICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAvLyByZWdpb24gNFxuXG4gICAgICAgICAgICBzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgICAgICAgICBzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAvLyByZWdpb24gM1xuXG4gICAgICAgICAgICBzMCA9IDA7XG4gICAgICAgICAgICBzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgICAgICAgICBzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gcmVnaW9uIDJcblxuICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcbiAgICAgICAgICAgIHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG4gICAgICAgIHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcbiAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xuXG4gICAgICAgIG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cbiAgICAgICAgb3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcXJEaXN0O1xuXG4gICAgfTtcblxuICB9KCksXG5cblxuICBpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xuXG4gIH0sXG5cbiAgaW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1zcGhlcmUtaW50ZXJzZWN0aW9uL1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgIHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XG5cbiAgICAgIHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICAgIHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcblxuICAgICAgdmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcblxuICAgICAgaWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cbiAgICAgIC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXG4gICAgICB2YXIgdDAgPSB0Y2EgLSB0aGM7XG5cbiAgICAgIC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcbiAgICAgIHZhciB0MSA9IHRjYSArIHRoYztcblxuICAgICAgLy8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXG4gICAgICBpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG4gICAgICAvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG4gICAgICAvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG4gICAgICBpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgICAgLy8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcbiAgICAgIHJldHVybiB0aGlzLmF0KCB0MCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIH1cblxuICB9KCksXG5cbiAgaXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuICAgIHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcblxuICAgIGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgdmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgIGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgLy8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgdmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcbiAgICBpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG4gICAgICAvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG4gICAgICBpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgfVxuXG4gICAgICAvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfVxuXG4gICAgdmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuICAgIC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cbiAgICByZXR1cm4gdCA+PSAwID8gdCA6ICBudWxsO1xuXG4gIH0sXG5cbiAgaW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuICAgIGlmICggdCA9PT0gbnVsbCApIHtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgfSxcblxuICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktYm94LWludGVyc2VjdGlvbi9cblxuICAgIHZhciB0bWluLHRtYXgsdHltaW4sdHltYXgsdHptaW4sdHptYXg7XG5cbiAgICB2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxuICAgICAgaW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxuICAgICAgaW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xuXG4gICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG4gICAgaWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cbiAgICAgIHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuICAgICAgdG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICAgIHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuICAgIH1cblxuICAgIGlmICggaW52ZGlyeSA+PSAwICkge1xuXG4gICAgICB0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgICB0eW1heCA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0eW1pbiA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgICB0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XG4gICAgfVxuXG4gICAgaWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cbiAgICAvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXG5cbiAgICBpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xuXG4gICAgaWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuICAgIGlmICggaW52ZGlyeiA+PSAwICkge1xuXG4gICAgICB0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgICB0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgICB0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgfVxuXG4gICAgaWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuICAgIGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XG5cbiAgICBpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xuXG4gICAgLy9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG4gICAgaWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xuXG4gIH0sXG5cbiAgaW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgZWRnZTEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBlZGdlMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0ludGVyc2VjdGlvbi9XbTVJbnRyUmF5M1RyaWFuZ2xlMy5jcHBcblxuICAgICAgZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuICAgICAgZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xuICAgICAgbm9ybWFsLmNyb3NzVmVjdG9ycyggZWRnZTEsIGVkZ2UyICk7XG5cbiAgICAgIC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuICAgICAgLy8gRTEgPSBrRWRnZTEsIEUyID0ga0VkZ2UyLCBOID0gQ3Jvc3MoRTEsRTIpKSBieVxuICAgICAgLy8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXG4gICAgICAvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcbiAgICAgIC8vICAgfERvdChELE4pfCp0ID0gLXNpZ24oRG90KEQsTikpKkRvdChRLE4pXG4gICAgICB2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcbiAgICAgIHZhciBzaWduO1xuXG4gICAgICBpZiAoIERkTiA+IDAgKSB7XG5cbiAgICAgICAgaWYgKCBiYWNrZmFjZUN1bGxpbmcgKSByZXR1cm4gbnVsbDtcbiAgICAgICAgc2lnbiA9IDE7XG5cbiAgICAgIH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XG5cbiAgICAgICAgc2lnbiA9IC0gMTtcbiAgICAgICAgRGROID0gLSBEZE47XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIH1cblxuICAgICAgZGlmZi5zdWJWZWN0b3JzKCB0aGlzLm9yaWdpbiwgYSApO1xuICAgICAgdmFyIERkUXhFMiA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UyLmNyb3NzVmVjdG9ycyggZGlmZiwgZWRnZTIgKSApO1xuXG4gICAgICAvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgICAgaWYgKCBEZFF4RTIgPCAwICkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMS5jcm9zcyggZGlmZiApICk7XG5cbiAgICAgIC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICBpZiAoIERkRTF4USA8IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIH1cblxuICAgICAgLy8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgIGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXG4gICAgICB2YXIgUWROID0gLSBzaWduICogZGlmZi5kb3QoIG5vcm1hbCApO1xuXG4gICAgICAvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICBpZiAoIFFkTiA8IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIH1cblxuICAgICAgLy8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXG4gICAgICByZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XG5cbiAgICB0aGlzLmRpcmVjdGlvbi5hZGQoIHRoaXMub3JpZ2luICkuYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG4gICAgdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG4gICAgdGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xuICAgIHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHJheSApIHtcblxuICAgIHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlJheSgpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvU3BoZXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNwaGVyZSA9IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XG5cbiAgdGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XG5cbn07XG5cblRIUkVFLlNwaGVyZS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlNwaGVyZSxcblxuICBzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XG5cbiAgICB0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG4gICAgICBpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYm94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICB0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XG4gICAgdGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xuXG4gIH0sXG5cbiAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuICB9LFxuXG4gIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgdmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuICAgIHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XG5cbiAgfSxcblxuICBjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXN1bHQuY29weSggcG9pbnQgKTtcblxuICAgIGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG4gICAgICByZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuICAgICAgcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgfSxcblxuICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgYm94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG4gICAgYm94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG4gICAgcmV0dXJuIGJveDtcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICB0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuICAgIHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuU3BoZXJlKCkuY29weSggdGhpcyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5GcnVzdHVtID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG4gIHRoaXMucGxhbmVzID0gW1xuXG4gICAgKCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuICAgICggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgVEhSRUUuUGxhbmUoKSxcbiAgICAoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXG4gICAgKCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuICAgICggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgVEhSRUUuUGxhbmUoKSxcbiAgICAoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcblxuICBdO1xuXG59O1xuXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuRnJ1c3R1bSxcblxuICBzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgIHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XG4gICAgcGxhbmVzWyAxIF0uY29weSggcDEgKTtcbiAgICBwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xuICAgIHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XG4gICAgcGxhbmVzWyA0IF0uY29weSggcDQgKTtcbiAgICBwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XG5cbiAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgICBwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcbiAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuICAgIHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xuICAgIHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuICAgIHZhciBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcbiAgICB2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xuXG4gICAgcGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgaW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgaW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG4gICAgdmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG4gICAgdmFyIG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgIHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XG5cbiAgICAgIGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XG5cbiAgICAgICAgcDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcbiAgICAgICAgcDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcbiAgICAgICAgcDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcbiAgICAgICAgcDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcbiAgICAgICAgcDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcbiAgICAgICAgcDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcblxuICAgICAgICB2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XG4gICAgICAgIHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuICAgICAgICAvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxuXG4gICAgICAgIGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgfSgpLFxuXG5cbiAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgIGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuRnJ1c3R1bSgpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUGxhbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuICB0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG4gIHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxufTtcblxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcblxuICBzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuICAgIHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgIHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG4gICAgdGhpcy5jb25zdGFudCA9IHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XG5cbiAgICB0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICB0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7IC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG4gICAgICB2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcblxuICAgICAgLy8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cblxuICAgICAgdGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cblxuICBjb3B5OiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgdGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XG4gICAgdGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxuXG4gICAgdmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcbiAgICB0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xuICAgIHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbnN0YW50ICo9IC0gMTtcbiAgICB0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcblxuICB9LFxuXG4gIHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XG5cbiAgfSxcblxuICBvcnRob1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcblxuICB9LFxuXG4gIGlzSW50ZXJzZWN0aW9uTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG4gICAgLy8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG5cbiAgICB2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcbiAgICB2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG4gICAgcmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xuXG4gIH0sXG5cbiAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGxpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XG5cbiAgICAgIHZhciBkZW5vbWluYXRvciA9IHRoaXMubm9ybWFsLmRvdCggZGlyZWN0aW9uICk7XG5cbiAgICAgIGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cbiAgICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgICAgICBpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHQgPSAtICggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuICAgICAgaWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG5cbiAgY29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcblxuICAgICAgLy8gY29tcHV0ZSBuZXcgbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxuICAgICAgLy8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXG4gICAgICB2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcbiAgICAgIHZhciBuZXdOb3JtYWwgPSB2MS5jb3B5KCB0aGlzLm5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICk7XG5cbiAgICAgIHZhciBuZXdDb3BsYW5hclBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MiApO1xuICAgICAgbmV3Q29wbGFuYXJQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgICB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG4gICAgdGhpcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQgLSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICByZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5QbGFuZSgpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGggPSB7XG5cbiAgZ2VuZXJhdGVVVUlEOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxuXG4gICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcbiAgICB2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcbiAgICB2YXIgcm5kID0gMCwgcjtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xuXG4gICAgICAgIGlmICggaSA9PT0gOCB8fCBpID09PSAxMyB8fCBpID09PSAxOCB8fCBpID09PSAyMyApIHtcblxuICAgICAgICAgIHV1aWRbIGkgXSA9ICctJztcblxuICAgICAgICB9IGVsc2UgaWYgKCBpID09PSAxNCApIHtcblxuICAgICAgICAgIHV1aWRbIGkgXSA9ICc0JztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcbiAgICAgICAgICByID0gcm5kICYgMHhmO1xuICAgICAgICAgIHJuZCA9IHJuZCA+PiA0O1xuICAgICAgICAgIHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1dWlkLmpvaW4oICcnICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICAvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgYj5cblxuICBjbGFtcDogZnVuY3Rpb24gKCB4LCBhLCBiICkge1xuXG4gICAgcmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XG5cbiAgfSxcblxuICAvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgaW5mKVxuXG4gIGNsYW1wQm90dG9tOiBmdW5jdGlvbiAoIHgsIGEgKSB7XG5cbiAgICByZXR1cm4geCA8IGEgPyBhIDogeDtcblxuICB9LFxuXG4gIC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuICBtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cbiAgICByZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuICB9LFxuXG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG4gIHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cbiAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuICAgIHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cbiAgfSxcblxuICBzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cbiAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuICAgIHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cbiAgfSxcblxuICAvLyBSYW5kb20gZmxvYXQgZnJvbSA8MCwgMT4gd2l0aCAxNiBiaXRzIG9mIHJhbmRvbW5lc3NcbiAgLy8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcblxuICByYW5kb20xNjogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XG5cbiAgfSxcblxuICAvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cbiAgcmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vciggdGhpcy5yYW5kRmxvYXQoIGxvdywgaGlnaCApICk7XG5cbiAgfSxcblxuICAvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG4gIHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cbiAgICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG4gIH0sXG5cbiAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG4gIHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcblxuICAgIHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG4gIH0sXG5cbiAgZGVnVG9SYWQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcblxuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBkZWdyZWVUb1JhZGlhbnNGYWN0b3I7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICByYWRUb0RlZzogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG4gICAgICByZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG4gIH0sXG5cbiAgbmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB2YWx1ZSAtLTtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuICAgIHZhbHVlIHw9IHZhbHVlID4+IDI7XG4gICAgdmFsdWUgfD0gdmFsdWUgPj4gNDtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuICAgIHZhbHVlIHw9IHZhbHVlID4+IDE2O1xuICAgIHZhbHVlICsrO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9TcGxpbmUuanNcblxuLyoqXG4gKiBTcGxpbmUgZnJvbSBUd2Vlbi5qcywgc2xpZ2h0bHkgb3B0aW1pemVkIChhbmQgdHJhc2hlZClcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcbiAqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICB2YXIgYyA9IFtdLCB2MyA9IHsgeDogMCwgeTogMCwgejogMCB9LFxuICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxuICBwYSwgcGIsIHBjLCBwZDtcblxuICB0aGlzLmluaXRGcm9tQXJyYXkgPSBmdW5jdGlvbiAoIGEgKSB7XG5cbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMucG9pbnRzWyBpIF0gPSB7IHg6IGFbIGkgXVsgMCBdLCB5OiBhWyBpIF1bIDEgXSwgejogYVsgaSBdWyAyIF0gfTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIGsgKSB7XG5cbiAgICBwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcbiAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgIGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG4gICAgY1sgMSBdID0gaW50UG9pbnQ7XG4gICAgY1sgMiBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMiA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XG4gICAgY1sgMyBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMyA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDI7XG5cbiAgICBwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcbiAgICBwYiA9IHRoaXMucG9pbnRzWyBjWyAxIF0gXTtcbiAgICBwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcbiAgICBwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcblxuICAgIHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xuICAgIHczID0gd2VpZ2h0ICogdzI7XG5cbiAgICB2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XG4gICAgdjMueSA9IGludGVycG9sYXRlKCBwYS55LCBwYi55LCBwYy55LCBwZC55LCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgIHYzLnogPSBpbnRlcnBvbGF0ZSggcGEueiwgcGIueiwgcGMueiwgcGQueiwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuICAgIHJldHVybiB2MztcblxuICB9O1xuXG4gIHRoaXMuZ2V0Q29udHJvbFBvaW50c0FycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgICBjb29yZHMgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgcCA9IHRoaXMucG9pbnRzWyBpIF07XG4gICAgICBjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvb3JkcztcblxuICB9O1xuXG4gIC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xuXG4gIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBuU3ViRGl2aXNpb25zICkge1xuXG4gICAgdmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXG4gICAgICBwb2ludCA9IDAsIGludFBvaW50ID0gMCwgb2xkSW50UG9pbnQgPSAwLFxuICAgICAgb2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgdG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIGNodW5rTGVuZ3RocyA9IFtdLFxuICAgICAgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgLy8gZmlyc3QgcG9pbnQgaGFzIDAgbGVuZ3RoXG5cbiAgICBjaHVua0xlbmd0aHNbIDAgXSA9IDA7XG5cbiAgICBpZiAoICEgblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XG5cbiAgICBuU2FtcGxlcyA9IHRoaXMucG9pbnRzLmxlbmd0aCAqIG5TdWJEaXZpc2lvbnM7XG5cbiAgICBvbGRQb3NpdGlvbi5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICk7XG5cbiAgICBmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xuXG4gICAgICBpbmRleCA9IGkgLyBuU2FtcGxlcztcblxuICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuICAgICAgdG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XG5cbiAgICAgIHRvdGFsTGVuZ3RoICs9IHRtcFZlYy5kaXN0YW5jZVRvKCBvbGRQb3NpdGlvbiApO1xuXG4gICAgICBvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgICBwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XG4gICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cbiAgICAgIGlmICggaW50UG9pbnQgIT09IG9sZEludFBvaW50ICkge1xuXG4gICAgICAgIGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xuICAgICAgICBvbGRJbnRQb2ludCA9IGludFBvaW50O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcblxuICAgIGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XG5cbiAgICByZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XG5cbiAgfTtcblxuICB0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xuXG4gICAgdmFyIGksIGosXG4gICAgICBpbmRleCwgaW5kZXhDdXJyZW50LCBpbmRleE5leHQsXG4gICAgICByZWFsRGlzdGFuY2UsXG4gICAgICBzYW1wbGluZywgcG9zaXRpb24sXG4gICAgICBuZXdwb2ludHMgPSBbXSxcbiAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cbiAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKS5jbG9uZSgpICk7XG5cbiAgICBmb3IgKCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgLy90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcbiAgICAgIC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xuXG4gICAgICByZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcblxuICAgICAgc2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XG5cbiAgICAgIGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuICAgICAgaW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXG4gICAgICBmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaiArKyApIHtcblxuICAgICAgICBpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG4gICAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XG5cbiAgICAgIH1cblxuICAgICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5wb2ludHMgPSBuZXdwb2ludHM7XG5cbiAgfTtcblxuICAvLyBDYXRtdWxsLVJvbVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xuXG4gICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXG4gICAgICB2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG4gICAgcmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG4gIHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xuICAgIHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcbiAgICByZXN1bHQuY3Jvc3MoIHYwICk7XG5cbiAgICB2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcbiAgICBpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuICB9O1xuXG59KCk7XG5cbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljb29yZGluYXRlc1xuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcbiAgICB2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG4gICAgdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcbiAgICB2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG4gICAgdmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcbiAgICB2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cbiAgICB2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIC8vIGNvbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG4gICAgaWYgKCBkZW5vbSA9PT0gMCApIHtcbiAgICAgIC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xuICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcbiAgICB9XG5cbiAgICB2YXIgaW52RGVub20gPSAxIC8gZGVub207XG4gICAgdmFyIHUgPSAoIGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyICkgKiBpbnZEZW5vbTtcbiAgICB2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG4gICAgLy8gYmFyeWNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG4gICAgcmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG4gIH07XG5cbn0oKTtcblxuVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XG5cbiAgICByZXR1cm4gKCByZXN1bHQueCA+PSAwICkgJiYgKCByZXN1bHQueSA+PSAwICkgJiYgKCAoIHJlc3VsdC54ICsgcmVzdWx0LnkgKSA8PSAxICk7XG5cbiAgfTtcblxufSgpO1xuXG5USFJFRS5UcmlhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlRyaWFuZ2xlLFxuXG4gIHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG4gICAgdGhpcy5hLmNvcHkoIGEgKTtcbiAgICB0aGlzLmIuY29weSggYiApO1xuICAgIHRoaXMuYy5jb3B5KCBjICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcblxuICAgIHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcbiAgICB0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XG4gICAgdGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG4gICAgdGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcbiAgICB0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xuICAgIHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFyZWE6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG4gICAgICB2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xuXG4gICAgICByZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG4gIH0sXG5cbiAgbm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuICB9LFxuXG4gIHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5QbGFuZSgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICB9LFxuXG4gIGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuICB9LFxuXG4gIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcblxuICAgIHJldHVybiB0cmlhbmdsZS5hLmVxdWFscyggdGhpcy5hICkgJiYgdHJpYW5nbGUuYi5lcXVhbHMoIHRoaXMuYiApICYmIHRyaWFuZ2xlLmMuZXF1YWxzKCB0aGlzLmMgKTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlRyaWFuZ2xlKCkuY29weSggdGhpcyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9DbG9jay5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ2xvY2sgPSBmdW5jdGlvbiAoIGF1dG9TdGFydCApIHtcblxuICB0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XG5cbiAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICB0aGlzLm9sZFRpbWUgPSAwO1xuICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ2xvY2sucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcblxuICBzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICA/IHNlbGYucGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICAgOiBEYXRlLm5vdygpO1xuXG4gICAgdGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgfSxcblxuICBnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5nZXREZWx0YSgpO1xuICAgIHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xuXG4gIH0sXG5cbiAgZ2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkaWZmID0gMDtcblxuICAgIGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XG5cbiAgICAgIHRoaXMuc3RhcnQoKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5ydW5uaW5nICkge1xuXG4gICAgICB2YXIgbmV3VGltZSA9IHNlbGYucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiBzZWxmLnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgID8gc2VsZi5wZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICAgICA6IERhdGUubm93KCk7XG5cbiAgICAgIGRpZmYgPSAwLjAwMSAqICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApO1xuICAgICAgdGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblxuICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmY7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qc1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5FdmVudERpc3BhdGNoZXIsXG5cbiAgYXBwbHk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgb2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmhhc0V2ZW50TGlzdGVuZXI7XG4gICAgb2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ7XG5cbiAgfSxcblxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcblxuICAgIH1cblxuICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuXG4gICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcblxuICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XG5cbiAgICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcblxuICAgICAgICBsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG5cbiAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcblxuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICBhcnJheVsgaSBdID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICBhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvUmF5Y2FzdGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbS9cbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xuICovXG5cbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcblxuICBUSFJFRS5SYXljYXN0ZXIgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XG5cbiAgICB0aGlzLnJheSA9IG5ldyBUSFJFRS5SYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG4gICAgLy8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuICAgIHRoaXMubmVhciA9IG5lYXIgfHwgMDtcbiAgICB0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcblxuICAgIHRoaXMucGFyYW1zID0ge1xuICAgICAgU3ByaXRlOiB7fSxcbiAgICAgIE1lc2g6IHt9LFxuICAgICAgUG9pbnRDbG91ZDogeyB0aHJlc2hvbGQ6IDEgfSxcbiAgICAgIExPRDoge30sXG4gICAgICBMaW5lOiB7fVxuICAgIH07XG5cbiAgfTtcblxuICB2YXIgZGVzY1NvcnQgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG5cbiAgfTtcblxuICB2YXIgaW50ZXJzZWN0T2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xuXG4gICAgb2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG4gICAgaWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICAvL1xuXG4gIFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVEhSRUUuUmF5Y2FzdGVyLFxuXG4gICAgbGluZVByZWNpc2lvbjogMSxcblxuICAgIHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuICAgICAgLy8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuICAgICAgdGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXG4gICAgfSxcblxuICAgIHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uICggY29vcmRzLCBjYW1lcmEgKSB7XG5cbiAgICAgIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cbiAgICAgICAgdGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgICAgIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICB9IGVsc2UgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cbiAgICAgICAgdGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAtIDEgKS51bnByb2plY3QoIGNhbWVyYSApO1xuICAgICAgICB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtIDEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcblxuICAgICAgaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG4gICAgICBpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgfSxcblxuICAgIGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xuXG4gICAgICB2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG4gICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdHM7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgICAgfVxuXG4gICAgICBpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgfVxuXG4gIH07XG5cbn0oIFRIUkVFICkgKTtcblxuLy8gRmlsZTpzcmMvY29yZS9PYmplY3QzRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxuICovXG5cblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuT2JqZWN0M0RJZENvdW50ICsrIH0gKTtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuICB0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgdGhpcy51cCA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG4gIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xuICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XG5cbiAgdmFyIG9uUm90YXRpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuICB9O1xuXG4gIHZhciBvblF1YXRlcm5pb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcbiAgfTtcblxuICByb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xuICBxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgIHBvc2l0aW9uOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHBvc2l0aW9uXG4gICAgfSxcbiAgICByb3RhdGlvbjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiByb3RhdGlvblxuICAgIH0sXG4gICAgcXVhdGVybmlvbjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBxdWF0ZXJuaW9uXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBzY2FsZVxuICAgIH1cbiAgfSApO1xuXG4gIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gdHJ1ZTtcblxuICB0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gIHRoaXMubWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG4gIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gIHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG4gIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gIHRoaXMucmVuZGVyT3JkZXIgPSAwO1xuXG4gIHRoaXMudXNlckRhdGEgPSB7fTtcblxufTtcblxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcblxuICBnZXQgZXVsZXJPcmRlciAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLicgKTtcblxuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xuXG4gIH0sXG5cbiAgc2V0IGV1bGVyT3JkZXIgKCB2YWx1ZSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byAucm90YXRpb24ub3JkZXIuJyApO1xuXG4gICAgdGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgZ2V0IHVzZVF1YXRlcm5pb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG4gIH0sXG5cbiAgc2V0IHVzZVF1YXRlcm5pb24gKCB2YWx1ZSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcblxuICAgIHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cbiAgfSxcblxuICBzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cbiAgfSxcblxuICBzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cbiAgfSxcblxuICBzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cbiAgfSxcblxuICBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICAvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuICB9LFxuXG4gIHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICB2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAgIHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cbiAgICAgIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYXhpcywgZGlzdGFuY2UgKSB7XG5cbiAgICAgIHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG4gICAgICB0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xuXG4gIH0sXG5cbiAgdHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNsYXRlWjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgbG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgfSxcblxuICB3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cbiAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgICBtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xuXG4gICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgdGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiwgb2JqZWN0ICk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XG5cbiAgICAgIGlmICggb2JqZWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcblxuICAgICAgfVxuXG4gICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdhZGRlZCcgfSApO1xuXG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICB0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcblxuICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcblxuICAgICAgb2JqZWN0LnBhcmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcblxuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcblxuICB9LFxuXG4gIGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG4gIH0sXG5cbiAgZ2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuICB9LFxuXG4gIGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cbiAgICBpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuICAgICAgdmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cbiAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB9LFxuXG4gIGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgfSxcblxuICBnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICB9KCksXG5cbiAgZ2V0V29ybGRSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuRXVsZXIoKTtcblxuICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcblxuICAgIH1cblxuICB9KCksXG5cbiAgZ2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICB9KCksXG5cbiAgZ2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIH1cblxuICB9KCksXG5cbiAgcmF5Y2FzdDogZnVuY3Rpb24gKCkge30sXG5cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBjYWxsYmFjayggdGhpcyApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICB0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBjYWxsYmFjayggdGhpcyApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBpZiAoIHRoaXMucGFyZW50ICkge1xuXG4gICAgICBjYWxsYmFjayggdGhpcy5wYXJlbnQgKTtcblxuICAgICAgdGhpcy5wYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICB1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG4gICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICB9LFxuXG4gIHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xuXG4gICAgaWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgaWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XG5cbiAgICAgIGlmICggdGhpcy5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgZm9yY2UgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNoaWxkcmVuXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuICAgIH1cblxuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgdmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkICk7XG5cbiAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgLy8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cbiAgICAvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuICAgIC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG4gICAgaWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgbWV0YSBvYmpcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIGdlb21ldHJpZXM6IHt9LFxuICAgICAgICBtYXRlcmlhbHM6IHt9LFxuICAgICAgICB0ZXh0dXJlczoge30sXG4gICAgICAgIGltYWdlczoge31cbiAgICAgIH07XG5cbiAgICAgIGRhdGEubWV0YWRhdGEgPSB7XG4gICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgdHlwZTogJ09iamVjdCcsXG4gICAgICAgIGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICAvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cbiAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuICAgIGlmICggdGhpcy52aXNpYmxlICE9PSB0cnVlICkgZGF0YS52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgZGF0YS5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XG5cbiAgICBpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuICAgICAgZGF0YS5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICBkYXRhLmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgaWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cbiAgICAgIHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XG4gICAgICB2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcbiAgICAgIHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcbiAgICAgIHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXG4gICAgICBpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcbiAgICAgIGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuICAgICAgaWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG4gICAgICBpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcblxuICAgIH1cblxuICAgIG91dHB1dC5vYmplY3QgPSBkYXRhO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcblxuICAgIC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG4gICAgLy8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuICAgIC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICBmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xuICAgICAgICB2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcbiAgICAgICAgZGVsZXRlIGRhdGEubWV0YWRhdGE7XG4gICAgICAgIHZhbHVlcy5wdXNoKCBkYXRhICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG4gICAgaWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgIGlmICggcmVjdXJzaXZlID09PSB1bmRlZmluZWQgKSByZWN1cnNpdmUgPSB0cnVlO1xuXG4gICAgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBvYmplY3QudXAuY29weSggdGhpcy51cCApO1xuXG4gICAgb2JqZWN0LnBvc2l0aW9uLmNvcHkoIHRoaXMucG9zaXRpb24gKTtcbiAgICBvYmplY3QucXVhdGVybmlvbi5jb3B5KCB0aGlzLnF1YXRlcm5pb24gKTtcbiAgICBvYmplY3Quc2NhbGUuY29weSggdGhpcy5zY2FsZSApO1xuXG4gICAgb2JqZWN0LnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRoaXMucm90YXRpb25BdXRvVXBkYXRlO1xuXG4gICAgb2JqZWN0Lm1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuICAgIG9iamVjdC5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRoaXMubWF0cml4QXV0b1VwZGF0ZTtcbiAgICBvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuICAgIG9iamVjdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgb2JqZWN0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG5cbiAgICBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgb2JqZWN0LnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSApO1xuXG4gICAgaWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcbiAgICAgICAgb2JqZWN0LmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLk9iamVjdDNESWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlMyA9IGZ1bmN0aW9uICggYSwgYiwgYywgbm9ybWFsLCBjb2xvciApIHtcblxuICB0aGlzLmEgPSBhO1xuICB0aGlzLmIgPSBiO1xuICB0aGlzLmMgPSBjO1xuXG4gIHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XG5cbiAgdGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xuICB0aGlzLnZlcnRleENvbG9ycyA9IEFycmF5LmlzQXJyYXkoIGNvbG9yICkgPyBjb2xvciA6IFtdO1xuXG4gIHRoaXMudmVydGV4VGFuZ2VudHMgPSBbXTtcblxufTtcblxuVEhSRUUuRmFjZTMucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5GYWNlMyxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuICAgIGZhY2Uubm9ybWFsLmNvcHkoIHRoaXMubm9ybWFsICk7XG4gICAgZmFjZS5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSA9IHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGZhY2UudmVydGV4Q29sb3JzWyBpIF0gPSB0aGlzLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaSBdID0gdGhpcy52ZXJ0ZXhUYW5nZW50c1sgaSBdLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFjZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gIGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2U0IGhhcyBiZWVuIHJlbW92ZWQuIEEgVEhSRUUuRmFjZTMgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQuJyApO1xuICByZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSxcblxuICBnZXQgbGVuZ3RoICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3VudC4nICk7XG4gICAgcmV0dXJuIHRoaXMuY291bnQ7XG5cbiAgfSxcblxuICBnZXQgY291bnQoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplO1xuXG4gIH0sXG5cbiAgY29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cbiAgICBpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcbiAgICBpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cbiAgICB0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGNvbG9yID0gY29sb3JzWyBpIF07XG5cbiAgICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcblxuICAgICAgfVxuXG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuZztcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmI7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmI7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5VmVjdG9yMnNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgfVxuXG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5VmVjdG9yM3NBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgfVxuXG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG4gICAgICBpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG4gICAgICB9XG5cbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZ2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuICB9LFxuXG4gIHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xuXG4gIH0sXG5cbiAgc2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcblxuICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG4gIH0sXG5cbiAgc2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG4gIH0sXG5cbiAgc2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuICAgIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG4gICAgaW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIHRoaXMuYXJyYXkgKSwgdGhpcy5pdGVtU2l6ZSApO1xuXG4gIH1cblxufTtcblxuLy9cblxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuSW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5GbG9hdDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9EeW5hbWljQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgYXJyYXksIGl0ZW1TaXplICk7XG5cbiAgdGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLTEgfTtcblxufTtcblxuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XG5cblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIHRoaXMuYXJyYXkgKSwgdGhpcy5pdGVtU2l6ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUsIGR5bmFtaWMpIHtcblxuICBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG4gIHRoaXMuZHluYW1pYyA9IGR5bmFtaWMgfHwgZmFsc2U7XG4gIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSApLCB0aGlzLml0ZW1TaXplLCB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUsIHRoaXMuZHluYW1pYyApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUsIGR5bmFtaWMgKSB7XG5cbiAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcblxuICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy5keW5hbWljID0gZHluYW1pYyB8fCBmYWxzZTtcbiAgdGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLTEgfTtcblxufTtcblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlcixcblxuICBnZXQgbGVuZ3RoICgpIHtcblxuICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICB9LFxuXG4gIGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgaW5kZXgxICo9IHRoaXMuc3RyaWRlO1xuICAgIGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpKysgKSB7XG5cbiAgICAgIHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5ICksIHRoaXMuc3RyaWRlLCB0aGlzLmR5bmFtaWMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uICggYXJyYXksIHN0cmlkZSwgZHluYW1pYywgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlLCBkeW5hbWljICk7XG5cbiAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKTtcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIHRoaXMuYXJyYXkgKSwgdGhpcy5zdHJpZGUsIHRoaXMuZHluYW1pYywgdGhpcy5tZXNoUGVyQXR0cmlidXRlICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQgKSB7XG5cbiAgdGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XG4gIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcbiAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cbn07XG5cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcblxuICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gcmVuYW1lZCB0byAuY291bnQuJyApO1xuICAgIHJldHVybiB0aGlzLmNvdW50O1xuXG4gIH0sXG5cbiAgZ2V0IGNvdW50KCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheS5sZW5ndGggLyB0aGlzLmRhdGEuc3RyaWRlO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcblxuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xuXG4gIH0sXG5cbiAgZ2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xuXG4gIH0sXG5cbiAgZ2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG4gIH0sXG5cbiAgZ2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xuXG4gIH0sXG5cbiAgc2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XG5cbiAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuICB0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG4gIHRoaXMudmVydGljZXMgPSBbXTtcbiAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgdGhpcy5mYWNlcyA9IFtdO1xuICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG5cbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcbiAgdGhpcy5tb3JwaENvbG9ycyA9IFtdO1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXG4gIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcbiAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICB0aGlzLmhhc1RhbmdlbnRzID0gZmFsc2U7XG5cbiAgLy8gdXBkYXRlIGZsYWdzXG5cbiAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5HZW9tZXRyeSxcblxuICBhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICB2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcbiAgICAgIGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gIH0sXG5cbiAgZnJvbUJ1ZmZlckdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgIHZhciB2ZXJ0aWNlcyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgdmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xuICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xuICAgIHZhciBjb2xvcnMgPSBhdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmNvbG9yLmFycmF5IDogdW5kZWZpbmVkO1xuICAgIHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2LmFycmF5IDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIHRlbXBOb3JtYWxzID0gW107XG4gICAgdmFyIHRlbXBVVnMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMywgaiArPSAyICkge1xuXG4gICAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcblxuICAgICAgaWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGVtcE5vcm1hbHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBzY29wZS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGVtcFVWcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzWyBqIF0sIHV2c1sgaiArIDEgXSApICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBhZGRGYWNlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG4gICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XG4gICAgICB2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuXG4gICAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycyApICk7XG5cbiAgICAgIGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGRyYXdjYWxscyA9IGdlb21ldHJ5LmRyYXdjYWxscztcblxuICAgICAgaWYgKCBkcmF3Y2FsbHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkcmF3Y2FsbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgdmFyIGRyYXdjYWxsID0gZHJhd2NhbGxzWyBpIF07XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBkcmF3Y2FsbC5zdGFydDtcbiAgICAgICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbC5jb3VudDtcbiAgICAgICAgICB2YXIgaW5kZXggPSBkcmF3Y2FsbC5pbmRleDtcblxuICAgICAgICAgIGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cbiAgICAgICAgICAgIGFkZEZhY2UoIGluZGV4ICsgaW5kaWNlc1sgaiBdLCBpbmRleCArIGluZGljZXNbIGogKyAxIF0sIGluZGV4ICsgaW5kaWNlc1sgaiArIDIgXSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG4gICAgICAgICAgYWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XG5cbiAgICAgICAgYWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTtcblxuICAgIHRoaXMuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkuc2V0UG9zaXRpb24oIG9mZnNldCApICk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuXG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgdmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuICAgIHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcblxuICAgIHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcblxuICAgIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIG1hdHJpeC5zZXQoXG4gICAgICBzLCAwLCAwLCAtcyAqIGNlbnRlci54LFxuICAgICAgMCwgcywgMCwgLXMgKiBjZW50ZXIueSxcbiAgICAgIDAsIDAsIHMsIC1zICogY2VudGVyLnosXG4gICAgICAwLCAwLCAwLCAxXG4gICAgKTtcblxuICAgIHRoaXMuYXBwbHlNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgdmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgICB2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgICAgY2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG4gICAgICBhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICBjYi5ub3JtYWxpemUoKTtcblxuICAgICAgZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcblxuICAgIHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xuXG4gICAgdmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XG5cbiAgICBmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG4gICAgICB2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIGlmICggYXJlYVdlaWdodGVkICkge1xuXG4gICAgICAvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xuICAgICAgLy8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxuXG4gICAgICB2YXIgdkEsIHZCLCB2QztcbiAgICAgIHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgICAgIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgICAgIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgICAgY2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG4gICAgICAgIGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xuICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBjYiApO1xuICAgICAgICB2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgICAgdmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcbiAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcbiAgICAgICAgdmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuICAgICAgdmVydGljZXNbIHYgXS5ub3JtYWxpemUoKTtcblxuICAgIH1cblxuICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICBpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgICAgIHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcbiAgICAgICAgdmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xuICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmVydGV4Tm9ybWFsc1sgMCBdID0gdmVydGljZXNbIGZhY2UuYSBdLmNsb25lKCk7XG4gICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xuICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0sXG5cbiAgY29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcblxuICAgIC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xuICAgIC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xuICAgIC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcblxuICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xuXG4gICAgICAgIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgICAgZm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gKSB7XG5cbiAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcblxuICAgIHZhciB0bXBHZW8gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcblxuICAgICAgaWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XG5cbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xuICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xuXG4gICAgICAgIHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XG4gICAgICAgIHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgIHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgICAgICBmYWNlTm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICB2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBjOiBuZXcgVEhSRUUuVmVjdG9yMygpIH07XG5cbiAgICAgICAgICBkc3ROb3JtYWxzRmFjZS5wdXNoKCBmYWNlTm9ybWFsICk7XG4gICAgICAgICAgZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xuXG4gICAgICAvLyBzZXQgdmVydGljZXMgdG8gbW9ycGggdGFyZ2V0XG5cbiAgICAgIHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cbiAgICAgIC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xuXG4gICAgICB0bXBHZW8uY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgICB0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgICAgLy8gc3RvcmUgbW9ycGggbm9ybWFsc1xuXG4gICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgIGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcbiAgICAgICAgdmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFscy52ZXJ0ZXhOb3JtYWxzWyBmIF07XG5cbiAgICAgICAgZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgICAgIHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xuICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcbiAgICAgICAgdmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xuXG4gICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xuICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcbiAgICAvLyB0YW5nZW50cyBnbyB0byB2ZXJ0aWNlc1xuXG4gICAgdmFyIGYsIGZsLCB2LCB2bCwgaSwgdmVydGV4SW5kZXgsXG4gICAgICBmYWNlLCB1diwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2QyxcbiAgICAgIHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXG4gICAgICBzMSwgczIsIHQxLCB0MiwgciwgdCwgdGVzdCxcbiAgICAgIHRhbjEgPSBbXSwgdGFuMiA9IFtdLFxuICAgICAgc2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdG1wMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdztcblxuICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cbiAgICAgIHRhbjFbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICB0YW4yWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGNvbnRleHQsIGEsIGIsIGMsIHVhLCB1YiwgdWMgKSB7XG5cbiAgICAgIHZBID0gY29udGV4dC52ZXJ0aWNlc1sgYSBdO1xuICAgICAgdkIgPSBjb250ZXh0LnZlcnRpY2VzWyBiIF07XG4gICAgICB2QyA9IGNvbnRleHQudmVydGljZXNbIGMgXTtcblxuICAgICAgdXZBID0gdXZbIHVhIF07XG4gICAgICB1dkIgPSB1dlsgdWIgXTtcbiAgICAgIHV2QyA9IHV2WyB1YyBdO1xuXG4gICAgICB4MSA9IHZCLnggLSB2QS54O1xuICAgICAgeDIgPSB2Qy54IC0gdkEueDtcbiAgICAgIHkxID0gdkIueSAtIHZBLnk7XG4gICAgICB5MiA9IHZDLnkgLSB2QS55O1xuICAgICAgejEgPSB2Qi56IC0gdkEuejtcbiAgICAgIHoyID0gdkMueiAtIHZBLno7XG5cbiAgICAgIHMxID0gdXZCLnggLSB1dkEueDtcbiAgICAgIHMyID0gdXZDLnggLSB1dkEueDtcbiAgICAgIHQxID0gdXZCLnkgLSB1dkEueTtcbiAgICAgIHQyID0gdXZDLnkgLSB1dkEueTtcblxuICAgICAgciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcbiAgICAgIHNkaXIuc2V0KCAoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxuICAgICAgICAgICAgKCB0MiAqIHkxIC0gdDEgKiB5MiApICogcixcbiAgICAgICAgICAgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHIgKTtcbiAgICAgIHRkaXIuc2V0KCAoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuICAgICAgICAgICAgKCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcbiAgICAgICAgICAgICggczEgKiB6MiAtIHMyICogejEgKSAqIHIgKTtcblxuICAgICAgdGFuMVsgYSBdLmFkZCggc2RpciApO1xuICAgICAgdGFuMVsgYiBdLmFkZCggc2RpciApO1xuICAgICAgdGFuMVsgYyBdLmFkZCggc2RpciApO1xuXG4gICAgICB0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XG4gICAgICB0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XG4gICAgICB0YW4yWyBjIF0uYWRkKCB0ZGlyICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuICAgICAgdXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdOyAvLyB1c2UgVVYgbGF5ZXIgMCBmb3IgdGFuZ2VudHNcblxuICAgICAgaGFuZGxlVHJpYW5nbGUoIHRoaXMsIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMsIDAsIDEsIDIgKTtcblxuICAgIH1cblxuICAgIHZhciBmYWNlSW5kZXggPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG4gICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBNYXRoLm1pbiggZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCwgMyApOyBpICsrICkge1xuXG4gICAgICAgIG4uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcblxuICAgICAgICB2ZXJ0ZXhJbmRleCA9IGZhY2VbIGZhY2VJbmRleFsgaSBdIF07XG5cbiAgICAgICAgdCA9IHRhbjFbIHZlcnRleEluZGV4IF07XG5cbiAgICAgICAgLy8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuICAgICAgICB0bXAuY29weSggdCApO1xuICAgICAgICB0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG4gICAgICAgIHRtcDIuY3Jvc3NWZWN0b3JzKCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSwgdCApO1xuICAgICAgICB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHZlcnRleEluZGV4IF0gKTtcbiAgICAgICAgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cbiAgICAgICAgZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjQoIHRtcC54LCB0bXAueSwgdG1wLnosIHcgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XG5cbiAgfSxcblxuICBjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGQgPSAwO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGlmICggaSA+IDAgKSB7XG5cbiAgICAgICAgZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cbiAgfSxcblxuICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG4gIH0sXG5cbiAgbWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCApIHtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHZhciBub3JtYWxNYXRyaXgsXG4gICAgdmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgdmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcbiAgICB2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcbiAgICBmYWNlczEgPSB0aGlzLmZhY2VzLFxuICAgIGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxuICAgIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcbiAgICB1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG4gICAgaWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgfVxuXG4gICAgLy8gdmVydGljZXNcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcblxuICAgICAgdmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcblxuICAgICAgaWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHZlcnRleENvcHkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgdmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcblxuICAgIH1cblxuICAgIC8vIGZhY2VzXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxuICAgICAgZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXG4gICAgICBmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgIGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XG4gICAgICBmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgaWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgbm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xuXG4gICAgICAgIGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZmFjZUNvcHkudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgICAgfVxuXG4gICAgICBmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Q29sb3JzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xuICAgICAgICBmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xuXG4gICAgfVxuXG4gICAgLy8gdXZzXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xuXG4gICAgICBpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcblxuICAgICAgfVxuXG4gICAgICB1dnMxLnB1c2goIHV2Q29weSApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgbWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cbiAgICBpZiAoIG1lc2ggaW5zdGFuY2VvZiBUSFJFRS5NZXNoID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgdGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcblxuICB9LFxuXG4gIC8qXG4gICAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cbiAgICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuICAgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuICAgKi9cblxuICBtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuICAgIHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xuXG4gICAgdmFyIHYsIGtleTtcbiAgICB2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcbiAgICB2YXIgaSwgaWwsIGZhY2U7XG4gICAgdmFyIGluZGljZXMsIGosIGpsO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdiA9IHRoaXMudmVydGljZXNbIGkgXTtcbiAgICAgIGtleSA9IE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKTtcblxuICAgICAgaWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2ZXJ0aWNlc01hcFsga2V5IF0gPSBpO1xuICAgICAgICB1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XG4gICAgICAgIGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XG4gICAgICAgIGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcbiAgICAvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxuICAgIHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG4gICAgICBmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcbiAgICAgIGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xuICAgICAgZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XG5cbiAgICAgIGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcblxuICAgICAgdmFyIGR1cEluZGV4ID0gLSAxO1xuXG4gICAgICAvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXG4gICAgICAvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxuICAgICAgZm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcbiAgICAgICAgaWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcblxuICAgICAgICAgIGR1cEluZGV4ID0gbjtcbiAgICAgICAgICBmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XG4gICAgICB2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xuXG4gICAgICB0aGlzLmZhY2VzLnNwbGljZSggaWR4LCAxICk7XG5cbiAgICAgIGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xuXG4gICAgdmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcbiAgICByZXR1cm4gZGlmZjtcblxuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgIHR5cGU6ICdHZW9tZXRyeScsXG4gICAgICAgIGdlbmVyYXRvcjogJ0dlb21ldHJ5LnRvSlNPTidcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG4gICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuICAgICAgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgICAgdmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgfVxuXG4gICAgdmFyIGZhY2VzID0gW107XG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgbm9ybWFsc0hhc2ggPSB7fTtcbiAgICB2YXIgY29sb3JzID0gW107XG4gICAgdmFyIGNvbG9yc0hhc2ggPSB7fTtcbiAgICB2YXIgdXZzID0gW107XG4gICAgdmFyIHV2c0hhc2ggPSB7fTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuICAgICAgdmFyIGhhc01hdGVyaWFsID0gZmFsc2U7IC8vIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGhhc0ZhY2VVdiA9IGZhbHNlOyAvLyBkZXByZWNhdGVkXG4gICAgICB2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XG4gICAgICB2YXIgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGggPiAwO1xuICAgICAgdmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xuICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XG5cbiAgICAgIHZhciBmYWNlVHlwZSA9IDA7XG5cbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMywgaGFzRmFjZVZlcnRleFV2ICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA2LCBoYXNGYWNlQ29sb3IgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XG5cbiAgICAgIGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XG4gICAgICBmYWNlcy5wdXNoKCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jICk7XG5cbiAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgICAgICBmYWNlcy5wdXNoKFxuICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxuICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxuICAgICAgICAgIGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXG4gICAgICAgICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgIGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgIGZhY2VzLnB1c2goXG4gICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxuICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcbiAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcbiAgICAgICAgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgICAgICBmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgICAgICB2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgICAgZmFjZXMucHVzaChcbiAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxuICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXG4gICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxuICAgICAgICApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcblxuICAgICAgcmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4gKCAxIDw8IHBvc2l0aW9uKSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcblxuICAgICAgdmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgICB9XG5cbiAgICAgIG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XG4gICAgICBub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuICAgICAgcmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcblxuICAgICAgdmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuICAgICAgfVxuXG4gICAgICBjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgY29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XG5cbiAgICAgIHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcblxuICAgICAgdmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuICAgICAgfVxuXG4gICAgICB1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcbiAgICAgIHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cbiAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cbiAgICB9XG5cbiAgICBkYXRhLmRhdGEgPSB7fTtcblxuICAgIGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgIGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcbiAgICBpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcbiAgICBpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyBpIF07XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XG5cbiAgICAgICAgICB2YXIgdXYgPSB1dnNbIGsgXTtcblxuICAgICAgICAgIHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbiAgfSxcblxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0RpcmVjdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5EaXJlY3RHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy50eXBlID0gJ0RpcmVjdEdlb21ldHJ5JztcblxuICB0aGlzLmluZGljZXMgPSBbXTtcbiAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICB0aGlzLmNvbG9ycyA9IFtdO1xuICB0aGlzLm5vcm1hbHMgPSBbXTtcbiAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgdGhpcy51dnMgPSBbXTtcbiAgdGhpcy51dnMyID0gW107XG5cbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcbiAgdGhpcy5tb3JwaENvbG9ycyA9IFtdO1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXG4gIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcbiAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gIC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAvLyB1cGRhdGUgZmxhZ3NcblxuICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5EaXJlY3RHZW9tZXRyeSxcblxuICBjb21wdXRlQm91bmRpbmdCb3g6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3gsXG4gIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSxcblxuICBjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBtYXRlcmlhbCA9IG1hdGVyaWFsIHx8IHsgJ3ZlcnRleENvbG9ycyc6IFRIUkVFLk5vQ29sb3JzIH07XG5cbiAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcbiAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICB2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XG4gICAgdmFyIG1hdGVyaWFsVmVydGV4Q29sb3JzID0gbWF0ZXJpYWwudmVydGV4Q29sb3JzO1xuXG4gICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcbiAgICB2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcblxuICAgIC8vIG1vcnBoc1xuXG4gICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcbiAgICB2YXIgbW9ycGhUYXJnZXRzTGVuZ3RoID0gbW9ycGhUYXJnZXRzLmxlbmd0aDtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSArKyApIHtcblxuICAgICAgdGhpcy5tb3JwaFRhcmdldHNbIGkgXSA9IFtdO1xuXG4gICAgfVxuXG4gICAgdmFyIG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcbiAgICB2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcblxuICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IFtdO1xuXG4gICAgfVxuXG4gICAgdmFyIG1vcnBoQ29sb3JzID0gZ2VvbWV0cnkubW9ycGhDb2xvcnM7XG4gICAgdmFyIG1vcnBoQ29sb3JzTGVuZ3RoID0gbW9ycGhDb2xvcnMubGVuZ3RoO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhDb2xvcnNMZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMubW9ycGhDb2xvcnNbIGkgXSA9IFtdO1xuXG4gICAgfVxuXG4gICAgLy8gc2tpbnNcblxuICAgIHZhciBza2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzO1xuICAgIHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xuXG4gICAgdmFyIGhhc1NraW5JbmRpY2VzID0gc2tpbkluZGljZXMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgdmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAvL1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgaWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICB0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuICAgICAgICB0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgICAgaWYgKCBtYXRlcmlhbFZlcnRleENvbG9ycyA9PT0gVEhSRUUuVmVydGV4Q29sb3JzICkge1xuXG4gICAgICAgIHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWxWZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLkZhY2VDb2xvcnMgKSB7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICB0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYnLCBpICk7XG5cbiAgICAgICAgICB0aGlzLnV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcblxuICAgICAgICB2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XG5cbiAgICAgICAgaWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyJywgaSApO1xuXG4gICAgICAgICAgdGhpcy51dnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gbW9ycGhzXG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcblxuICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcblxuICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0c1sgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcblxuICAgICAgfVxuICAgICAgLypcbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcblxuICAgICAgICB2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhDb2xvcnNMZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoQ29sb3IgPSBtb3JwaENvbG9yc1sgaiBdLmNvbG9ycztcblxuICAgICAgICB0aGlzLm1vcnBoQ29sb3JzWyBqIF0ucHVzaCggbW9ycGhDb2xvclsgZmFjZS5hIF0sIG1vcnBoQ29sb3JbIGZhY2UuYiBdLCBtb3JwaENvbG9yWyBmYWNlLmMgXSApO1xuXG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgICAvLyBza2luc1xuXG4gICAgICBpZiAoIGhhc1NraW5JbmRpY2VzICkge1xuXG4gICAgICAgIHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzU2tpbldlaWdodHMgKSB7XG5cbiAgICAgICAgdGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcbiAgICB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuICAgIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcblxuICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICB0aGlzLm1vcnBoQXR0cmlidXRlcyA9IFtdO1xuXG4gIHRoaXMuZHJhd2NhbGxzID0gW107XG4gIHRoaXMub2Zmc2V0cyA9IHRoaXMuZHJhd2NhbGxzOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcblxuICBhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xuXG4gICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICYmIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSB7IGFycmF5OiBhcmd1bWVudHNbIDEgXSwgaXRlbVNpemU6IGFyZ3VtZW50c1sgMiBdIH07XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG4gIH0sXG5cbiAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgfSxcblxuICBhZGREcmF3Q2FsbDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0ICkge1xuXG4gICAgdGhpcy5kcmF3Y2FsbHMucHVzaCgge1xuXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBjb3VudDogY291bnQsXG4gICAgICBpbmRleDogaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCA/IGluZGV4T2Zmc2V0IDogMFxuXG4gICAgfSApO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggcG9zaXRpb24uYXJyYXkgKTtcbiAgICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgaWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgbm9ybWFsTWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIG5vcm1hbC5hcnJheSApO1xuICAgICAgbm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbIGkgXTtcblxuICAgICAgdGhpcy5vZmZzZXRzLnB1c2goIHtcblxuICAgICAgICBzdGFydDogb2Zmc2V0LnN0YXJ0LFxuICAgICAgICBpbmRleDogb2Zmc2V0LmluZGV4LFxuICAgICAgICBjb3VudDogb2Zmc2V0LmNvdW50XG5cbiAgICAgIH0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XG5cbiAgICB0aGlzLmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLnNldFBvc2l0aW9uKCBvZmZzZXQgKSApO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcblxuICB9LFxuXG4gIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzLCAzICk7XG4gICAgICB2YXIgY29sb3JzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XG5cbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xuXG4gICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuICAgICAgdmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XG5cbiAgICAgIGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG4gICAgICBkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcbiAgICAgIGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICAgIGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcblxuICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBnZW9tZXRyeSA9IGRpcmVjdDtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XG5cbiAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgYXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIH1cblxuICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBUSFJFRS5EaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICByZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcblxuICB9LFxuXG4gIGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIGlmICggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApLmNvcHlJbmRpY2VzQXJyYXkoIGdlb21ldHJ5LmluZGljZXMgKSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMyApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xuXG4gICAgfVxuXG4gICAgLy8gbW9ycGhzXG5cbiAgICBpZiAoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG1vcnBoVGFyZ2V0Lmxlbmd0aCAqIDMsIDMgKTtcblxuICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlcy5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPIG5vcm1hbHMsIGNvbG9yc1xuXG4gICAgfVxuXG4gICAgLy8gc2tpbm5pbmdcblxuICAgIGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIHNraW5JbmRpY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIHNraW5XZWlnaHRzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAqIDQsIDQgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICBpZiAoIHBvc2l0aW9ucyApIHtcblxuICAgICAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xuICAgICAgICBiYi5tYWtlRW1wdHkoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICBiYi5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubWluLnNldCggMCwgMCwgMCApO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuICAgICAgfVxuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgIGlmICggcG9zaXRpb25zICkge1xuXG4gICAgICAgIGJveC5tYWtlRW1wdHkoKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgYm94LmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBib3guY2VudGVyKCBjZW50ZXIgKTtcblxuICAgICAgICAvLyBob3BpbmcgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxuICAgICAgICAvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXG5cbiAgICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuICAgICAgICBpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xuXG4gICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICB9LFxuXG4gIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgIGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9ucy5sZW5ndGggKSwgMyApICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cbiAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIG5vcm1hbHNbIGkgXSA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICAgIHZhciB2QSwgdkIsIHZDLFxuXG4gICAgICBwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBwQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBwQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgLy8gaW5kZXhlZCBlbGVtZW50c1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMuaW5kZXggKSB7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuXG4gICAgICAgIHZhciBvZmZzZXRzID0gKCB0aGlzLm9mZnNldHMubGVuZ3RoID4gMCA/IHRoaXMub2Zmc2V0cyA6IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMubGVuZ3RoLCBpbmRleDogMCB9IF0gKTtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2Zmc2V0cy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcblxuICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbIGogXS5zdGFydDtcbiAgICAgICAgICB2YXIgY291bnQgPSBvZmZzZXRzWyBqIF0uY291bnQ7XG4gICAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0c1sgaiBdLmluZGV4O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgdkEgPSAoIGluZGV4ICsgaW5kaWNlc1sgaSAgICAgXSApICogMztcbiAgICAgICAgICAgIHZCID0gKCBpbmRleCArIGluZGljZXNbIGkgKyAxIF0gKSAqIDM7XG4gICAgICAgICAgICB2QyA9ICggaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdICkgKiAzO1xuXG4gICAgICAgICAgICBwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcbiAgICAgICAgICAgIHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xuICAgICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XG5cbiAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG4gICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgICAgbm9ybWFsc1sgdkEgICAgIF0gKz0gY2IueDtcbiAgICAgICAgICAgIG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XG4gICAgICAgICAgICBub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xuXG4gICAgICAgICAgICBub3JtYWxzWyB2QiAgICAgXSArPSBjYi54O1xuICAgICAgICAgICAgbm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcbiAgICAgICAgICAgIG5vcm1hbHNbIHZCICsgMiBdICs9IGNiLno7XG5cbiAgICAgICAgICAgIG5vcm1hbHNbIHZDICAgICBdICs9IGNiLng7XG4gICAgICAgICAgICBub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xuICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xuXG4gICAgICAgICAgcEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICBwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcbiAgICAgICAgICBwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcblxuICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICAgICAgbm9ybWFsc1sgaSAgICAgXSA9IGNiLng7XG4gICAgICAgICAgbm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XG4gICAgICAgICAgbm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XG5cbiAgICAgICAgICBub3JtYWxzWyBpICsgMyBdID0gY2IueDtcbiAgICAgICAgICBub3JtYWxzWyBpICsgNCBdID0gY2IueTtcbiAgICAgICAgICBub3JtYWxzWyBpICsgNSBdID0gY2IuejtcblxuICAgICAgICAgIG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xuICAgICAgICAgIG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xuICAgICAgICAgIG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuICAgICAgYXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuICAgIC8vIChwZXIgdmVydGV4IHRhbmdlbnRzKVxuXG4gICAgaWYgKCB0aGlzLmF0dHJpYnV0ZXMuaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgdGhpcy5hdHRyaWJ1dGVzLnV2ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiBNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KSBpbiBCdWZmZXJHZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKScgKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gdGhpcy5hdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuICAgIHZhciB1dnMgPSB0aGlzLmF0dHJpYnV0ZXMudXYuYXJyYXk7XG5cbiAgICB2YXIgblZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7XG5cbiAgICBpZiAoIHRoaXMuYXR0cmlidXRlcy50YW5nZW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndGFuZ2VudCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDQgKiBuVmVydGljZXMgKSwgNCApICk7XG5cbiAgICB9XG5cbiAgICB2YXIgdGFuZ2VudHMgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudC5hcnJheTtcblxuICAgIHZhciB0YW4xID0gW10sIHRhbjIgPSBbXTtcblxuICAgIGZvciAoIHZhciBrID0gMDsgayA8IG5WZXJ0aWNlczsgayArKyApIHtcblxuICAgICAgdGFuMVsgayBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIHRhbjJbIGsgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB9XG5cbiAgICB2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgdkMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICB1dkEgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgICAgdXZCID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICAgIHV2QyA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cbiAgICAgIHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXG4gICAgICBzMSwgczIsIHQxLCB0MiwgcjtcblxuICAgIHZhciBzZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuICAgICAgdkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgICB2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcbiAgICAgIHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG4gICAgICB1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XG4gICAgICB1dkIuZnJvbUFycmF5KCB1dnMsIGIgKiAyICk7XG4gICAgICB1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG5cbiAgICAgIHgxID0gdkIueCAtIHZBLng7XG4gICAgICB4MiA9IHZDLnggLSB2QS54O1xuXG4gICAgICB5MSA9IHZCLnkgLSB2QS55O1xuICAgICAgeTIgPSB2Qy55IC0gdkEueTtcblxuICAgICAgejEgPSB2Qi56IC0gdkEuejtcbiAgICAgIHoyID0gdkMueiAtIHZBLno7XG5cbiAgICAgIHMxID0gdXZCLnggLSB1dkEueDtcbiAgICAgIHMyID0gdXZDLnggLSB1dkEueDtcblxuICAgICAgdDEgPSB1dkIueSAtIHV2QS55O1xuICAgICAgdDIgPSB1dkMueSAtIHV2QS55O1xuXG4gICAgICByID0gMS4wIC8gKCBzMSAqIHQyIC0gczIgKiB0MSApO1xuXG4gICAgICBzZGlyLnNldChcbiAgICAgICAgKCB0MiAqIHgxIC0gdDEgKiB4MiApICogcixcbiAgICAgICAgKCB0MiAqIHkxIC0gdDEgKiB5MiApICogcixcbiAgICAgICAgKCB0MiAqIHoxIC0gdDEgKiB6MiApICogclxuICAgICAgKTtcblxuICAgICAgdGRpci5zZXQoXG4gICAgICAgICggczEgKiB4MiAtIHMyICogeDEgKSAqIHIsXG4gICAgICAgICggczEgKiB5MiAtIHMyICogeTEgKSAqIHIsXG4gICAgICAgICggczEgKiB6MiAtIHMyICogejEgKSAqIHJcbiAgICAgICk7XG5cbiAgICAgIHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcbiAgICAgIHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcbiAgICAgIHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuICAgICAgdGFuMlsgYSBdLmFkZCggdGRpciApO1xuICAgICAgdGFuMlsgYiBdLmFkZCggdGRpciApO1xuICAgICAgdGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG4gICAgfVxuXG4gICAgdmFyIGksIGlsO1xuICAgIHZhciBqLCBqbDtcbiAgICB2YXIgaUEsIGlCLCBpQztcblxuICAgIGlmICggdGhpcy5kcmF3Y2FsbHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICB0aGlzLmFkZERyYXdDYWxsKCAwLCBpbmRpY2VzLmxlbmd0aCwgMCApO1xuXG4gICAgfVxuXG4gICAgdmFyIGRyYXdjYWxscyA9IHRoaXMuZHJhd2NhbGxzO1xuXG4gICAgZm9yICggaiA9IDAsIGpsID0gZHJhd2NhbGxzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG4gICAgICB2YXIgc3RhcnQgPSBkcmF3Y2FsbHNbIGogXS5zdGFydDtcbiAgICAgIHZhciBjb3VudCA9IGRyYXdjYWxsc1sgaiBdLmNvdW50O1xuICAgICAgdmFyIGluZGV4ID0gZHJhd2NhbGxzWyBqIF0uaW5kZXg7XG5cbiAgICAgIGZvciAoIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICBpQSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xuICAgICAgICBpQiA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDEgXTtcbiAgICAgICAgaUMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XG5cbiAgICAgICAgaGFuZGxlVHJpYW5nbGUoIGlBLCBpQiwgaUMgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRtcDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB3LCB0LCB0ZXN0O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlVmVydGV4KCB2ICkge1xuXG4gICAgICBuLmZyb21BcnJheSggbm9ybWFscywgdiAqIDMgKTtcbiAgICAgIG4yLmNvcHkoIG4gKTtcblxuICAgICAgdCA9IHRhbjFbIHYgXTtcblxuICAgICAgLy8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuICAgICAgdG1wLmNvcHkoIHQgKTtcbiAgICAgIHRtcC5zdWIoIG4ubXVsdGlwbHlTY2FsYXIoIG4uZG90KCB0ICkgKSApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG4gICAgICB0bXAyLmNyb3NzVmVjdG9ycyggbjIsIHQgKTtcbiAgICAgIHRlc3QgPSB0bXAyLmRvdCggdGFuMlsgdiBdICk7XG4gICAgICB3ID0gKCB0ZXN0IDwgMC4wICkgPyAtIDEuMCA6IDEuMDtcblxuICAgICAgdGFuZ2VudHNbIHYgKiA0ICAgICBdID0gdG1wLng7XG4gICAgICB0YW5nZW50c1sgdiAqIDQgKyAxIF0gPSB0bXAueTtcbiAgICAgIHRhbmdlbnRzWyB2ICogNCArIDIgXSA9IHRtcC56O1xuICAgICAgdGFuZ2VudHNbIHYgKiA0ICsgMyBdID0gdztcblxuICAgIH1cblxuICAgIGZvciAoIGogPSAwLCBqbCA9IGRyYXdjYWxscy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcblxuICAgICAgdmFyIHN0YXJ0ID0gZHJhd2NhbGxzWyBqIF0uc3RhcnQ7XG4gICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbHNbIGogXS5jb3VudDtcbiAgICAgIHZhciBpbmRleCA9IGRyYXdjYWxsc1sgaiBdLmluZGV4O1xuXG4gICAgICBmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgaUEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcbiAgICAgICAgaUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG4gICAgICAgIGlDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xuXG4gICAgICAgIGhhbmRsZVZlcnRleCggaUEgKTtcbiAgICAgICAgaGFuZGxlVmVydGV4KCBpQiApO1xuICAgICAgICBoYW5kbGVWZXJ0ZXgoIGlDICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIC8qXG4gIENvbXB1dGUgdGhlIGRyYXcgb2Zmc2V0IGZvciBsYXJnZSBtb2RlbHMgYnkgY2h1bmtpbmcgdGhlIGluZGV4IGJ1ZmZlciBpbnRvIGNodW5rcyBvZiA2NWsgYWRkcmVzc2FibGUgdmVydGljZXMuXG4gIFRoaXMgbWV0aG9kIHdpbGwgZWZmZWN0aXZlbHkgcmV3cml0ZSB0aGUgaW5kZXggYnVmZmVyIGFuZCByZW1hcCBhbGwgYXR0cmlidXRlcyB0byBtYXRjaCB0aGUgbmV3IGluZGljZXMuXG4gIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBleHBhbmQgdGhlIHZlcnRleCBjb3VudCB0byBwcmV2ZW50IHNwcmF3bGVkIHRyaWFuZ2xlcyBhY3Jvc3MgZHJhdyBvZmZzZXRzLlxuICBzaXplIC0gRGVmYXVsdHMgdG8gNjU1MzUgb3IgNDI5NDk2NzI5NiBpZiBleHRlbnNpb24gT0VTX2VsZW1lbnRfaW5kZXhfdWludCBzdXBwb3J0ZWQsIGJ1dCBhbGxvd3MgZm9yIGxhcmdlciBvciBzbWFsbGVyIGNodW5rcy5cbiAgKi9cbiAgY29tcHV0ZU9mZnNldHM6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuICAgIGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IFRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4O1xuXG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgdmFyIGZhY2VzQ291bnQgPSAoIGluZGljZXMubGVuZ3RoIC8gMyApO1xuXG4gICAgdmFyIFVpbnRBcnJheSA9ICggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgPiA2NTUzNSAmJiBUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA+IDY1NTM1ICkgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXG4gICAgLypcbiAgICBjb25zb2xlLmxvZyhcIkNvbXB1dGluZyBidWZmZXJzIGluIG9mZnNldHMgb2YgXCIrc2l6ZStcIiAtPiBpbmRpY2VzOlwiK2luZGljZXMubGVuZ3RoK1wiIHZlcnRpY2VzOlwiK3ZlcnRpY2VzLmxlbmd0aCk7XG4gICAgY29uc29sZS5sb2coXCJGYWNlcyB0byBwcm9jZXNzOiBcIisoaW5kaWNlcy5sZW5ndGgvMykpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVvcmRlcmluZyBcIit2ZXJ0aWNlc0NvdW50K1wiIHZlcnRpY2VzLlwiKTtcbiAgICAqL1xuXG4gICAgdmFyIHNvcnRlZEluZGljZXMgPSBuZXcgVWludEFycmF5KCBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgdmFyIGluZGV4UHRyID0gMDtcbiAgICB2YXIgdmVydGV4UHRyID0gMDtcblxuICAgIHZhciBvZmZzZXRzID0gWyB7IHN0YXJ0OjAsIGNvdW50OjAsIGluZGV4OjAgfSBdO1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXRzWyAwIF07XG5cbiAgICB2YXIgZHVwbGljYXRlZFZlcnRpY2VzID0gMDtcbiAgICB2YXIgbmV3VmVydGljZU1hcHMgPSAwO1xuICAgIHZhciBmYWNlVmVydGljZXMgPSBuZXcgSW50MzJBcnJheSggNiApO1xuICAgIHZhciB2ZXJ0ZXhNYXAgPSBuZXcgSW50MzJBcnJheSggdmVydGljZXMubGVuZ3RoICk7XG4gICAgdmFyIHJldlZlcnRleE1hcCA9IG5ldyBJbnQzMkFycmF5KCB2ZXJ0aWNlcy5sZW5ndGggKTtcbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB2ZXJ0aWNlcy5sZW5ndGg7IGogKysgKSB7IHZlcnRleE1hcFsgaiBdID0gLSAxOyByZXZWZXJ0ZXhNYXBbIGogXSA9IC0gMTsgfVxuXG4gICAgLypcbiAgICAgIFRyYXZlcnNlIGV2ZXJ5IGZhY2UgYW5kIHJlb3JkZXIgdmVydGljZXMgaW4gdGhlIHByb3BlciBvZmZzZXRzIG9mIDY1ay5cbiAgICAgIFdlIGNhbiBoYXZlIG1vcmUgdGhhbiAnc2l6ZScgZW50cmllcyBpbiB0aGUgaW5kZXggYnVmZmVyIHBlciBvZmZzZXQsIGJ1dCBvbmx5IHJlZmVyZW5jZSAnc2l6ZScgdmFsdWVzLlxuICAgICovXG4gICAgZm9yICggdmFyIGZpbmRleCA9IDA7IGZpbmRleCA8IGZhY2VzQ291bnQ7IGZpbmRleCArKyApIHtcbiAgICAgIG5ld1ZlcnRpY2VNYXBzID0gMDtcblxuICAgICAgZm9yICggdmFyIHZvID0gMDsgdm8gPCAzOyB2byArKyApIHtcbiAgICAgICAgdmFyIHZpZCA9IGluZGljZXNbIGZpbmRleCAqIDMgKyB2byBdO1xuICAgICAgICBpZiAoIHZlcnRleE1hcFsgdmlkIF0gPT09IC0gMSApIHtcbiAgICAgICAgICAvL1VubWFwcGVkIHZlcnRpY2VcbiAgICAgICAgICBmYWNlVmVydGljZXNbIHZvICogMiBdID0gdmlkO1xuICAgICAgICAgIGZhY2VWZXJ0aWNlc1sgdm8gKiAyICsgMSBdID0gLSAxO1xuICAgICAgICAgIG5ld1ZlcnRpY2VNYXBzICsrO1xuICAgICAgICB9IGVsc2UgaWYgKCB2ZXJ0ZXhNYXBbIHZpZCBdIDwgb2Zmc2V0LmluZGV4ICkge1xuICAgICAgICAgIC8vUmV1c2VkIHZlcnRpY2VzIGZyb20gcHJldmlvdXMgYmxvY2sgKGR1cGxpY2F0ZSlcbiAgICAgICAgICBmYWNlVmVydGljZXNbIHZvICogMiBdID0gdmlkO1xuICAgICAgICAgIGZhY2VWZXJ0aWNlc1sgdm8gKiAyICsgMSBdID0gLSAxO1xuICAgICAgICAgIGR1cGxpY2F0ZWRWZXJ0aWNlcyArKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL1JldXNlZCB2ZXJ0aWNlIGluIHRoZSBjdXJyZW50IGJsb2NrXG4gICAgICAgICAgZmFjZVZlcnRpY2VzWyB2byAqIDIgXSA9IHZpZDtcbiAgICAgICAgICBmYWNlVmVydGljZXNbIHZvICogMiArIDEgXSA9IHZlcnRleE1hcFsgdmlkIF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZhY2VNYXggPSB2ZXJ0ZXhQdHIgKyBuZXdWZXJ0aWNlTWFwcztcbiAgICAgIGlmICggZmFjZU1heCA+ICggb2Zmc2V0LmluZGV4ICsgc2l6ZSApICkge1xuICAgICAgICB2YXIgbmV3X29mZnNldCA9IHsgc3RhcnQ6aW5kZXhQdHIsIGNvdW50OjAsIGluZGV4OnZlcnRleFB0ciB9O1xuICAgICAgICBvZmZzZXRzLnB1c2goIG5ld19vZmZzZXQgKTtcbiAgICAgICAgb2Zmc2V0ID0gbmV3X29mZnNldDtcblxuICAgICAgICAvL1JlLWV2YWx1YXRlIHJldXNlZCB2ZXJ0aWNlcyBpbiBsaWdodCBvZiBuZXcgb2Zmc2V0LlxuICAgICAgICBmb3IgKCB2YXIgdiA9IDA7IHYgPCA2OyB2ICs9IDIgKSB7XG4gICAgICAgICAgdmFyIG5ld192aWQgPSBmYWNlVmVydGljZXNbIHYgKyAxIF07XG4gICAgICAgICAgaWYgKCBuZXdfdmlkID4gLSAxICYmIG5ld192aWQgPCBvZmZzZXQuaW5kZXggKVxuICAgICAgICAgICAgZmFjZVZlcnRpY2VzWyB2ICsgMSBdID0gLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vUmVpbmRleCB0aGUgZmFjZS5cbiAgICAgIGZvciAoIHZhciB2ID0gMDsgdiA8IDY7IHYgKz0gMiApIHtcbiAgICAgICAgdmFyIHZpZCA9IGZhY2VWZXJ0aWNlc1sgdiBdO1xuICAgICAgICB2YXIgbmV3X3ZpZCA9IGZhY2VWZXJ0aWNlc1sgdiArIDEgXTtcblxuICAgICAgICBpZiAoIG5ld192aWQgPT09IC0gMSApXG4gICAgICAgICAgbmV3X3ZpZCA9IHZlcnRleFB0ciArKztcblxuICAgICAgICB2ZXJ0ZXhNYXBbIHZpZCBdID0gbmV3X3ZpZDtcbiAgICAgICAgcmV2VmVydGV4TWFwWyBuZXdfdmlkIF0gPSB2aWQ7XG4gICAgICAgIHNvcnRlZEluZGljZXNbIGluZGV4UHRyICsrIF0gPSBuZXdfdmlkIC0gb2Zmc2V0LmluZGV4OyAvL1hYWCBvdmVyZmxvd3MgYXQgMTZiaXRcbiAgICAgICAgb2Zmc2V0LmNvdW50ICsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE1vdmUgYWxsIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gbWFwIHRvIHRoZSBuZXcgY29tcHV0ZWQgaW5kaWNlcyAsIGFsc28gZXhwYW5kIHRoZSB2ZXJ0aWNlIHN0YWNrIHRvIG1hdGNoIG91ciBuZXcgdmVydGV4UHRyLiAqL1xuICAgIHRoaXMucmVvcmRlckJ1ZmZlcnMoIHNvcnRlZEluZGljZXMsIHJldlZlcnRleE1hcCwgdmVydGV4UHRyICk7XG4gICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0czsgLy8gVE9ETzogRGVwcmVjYXRlXG4gICAgdGhpcy5kcmF3Y2FsbHMgPSBvZmZzZXRzO1xuXG4gICAgLypcbiAgICB2YXIgb3JkZXJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlb3JkZXIgdGltZTogXCIrKG9yZGVyVGltZS1zKStcIm1zXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRHVwbGljYXRlZCBcIitkdXBsaWNhdGVkVmVydGljZXMrXCIgdmVydGljZXMuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiQ29tcHV0ZSBCdWZmZXJzIHRpbWU6IFwiKyhEYXRlLm5vdygpLXMpK1wibXNcIik7XG4gICAgY29uc29sZS5sb2coXCJEcmF3IG9mZnNldHM6IFwiK29mZnNldHMubGVuZ3RoKTtcbiAgICAqL1xuXG4gICAgcmV0dXJuIG9mZnNldHM7XG5cbiAgfSxcblxuICBtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1sga2V5IF07XG4gICAgICB2YXIgYXR0cmlidXRlQXJyYXkxID0gYXR0cmlidXRlMS5hcnJheTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xuXG4gICAgICB2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgdmFyIHgsIHksIHosIG47XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICB4ID0gbm9ybWFsc1sgaSBdO1xuICAgICAgeSA9IG5vcm1hbHNbIGkgKyAxIF07XG4gICAgICB6ID0gbm9ybWFsc1sgaSArIDIgXTtcblxuICAgICAgbiA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XG5cbiAgICAgIG5vcm1hbHNbIGkgICAgIF0gKj0gbjtcbiAgICAgIG5vcm1hbHNbIGkgKyAxIF0gKj0gbjtcbiAgICAgIG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcblxuICAgIH1cblxuICB9LFxuXG4gIC8qXG4gICAgcmVvZGVyQnVmZmVyczpcbiAgICBSZW9yZGVyIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBuZXcgaW5kZXhCdWZmZXIgYW5kIGluZGV4TWFwLlxuICAgIGluZGV4QnVmZmVyIC0gVWludDE2QXJyYXkgb2YgdGhlIG5ldyBvcmRlcmVkIGluZGljZXMuXG4gICAgaW5kZXhNYXAgLSBJbnQzMkFycmF5IHdoZXJlIHRoZSBwb3NpdGlvbiBpcyB0aGUgbmV3IHZlcnRleCBJRCBhbmQgdGhlIHZhbHVlIHRoZSBvbGQgdmVydGV4IElEIGZvciBlYWNoIHZlcnRleC5cbiAgICB2ZXJ0ZXhDb3VudCAtIEFtb3VudCBvZiB0b3RhbCB2ZXJ0aWNlcyBjb25zaWRlcmVkIGluIHRoaXMgcmVvcmRlcmluZyAoaW4gY2FzZSB5b3Ugd2FudCB0byBncm93IHRoZSB2ZXJ0aWNlIHN0YWNrKS5cbiAgKi9cbiAgcmVvcmRlckJ1ZmZlcnM6IGZ1bmN0aW9uICggaW5kZXhCdWZmZXIsIGluZGV4TWFwLCB2ZXJ0ZXhDb3VudCApIHtcblxuICAgIC8qIENyZWF0ZSBhIGNvcHkgb2YgYWxsIGF0dHJpYnV0ZXMgZm9yIHJlb3JkZXJpbmcuICovXG4gICAgdmFyIHNvcnRlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XG4gICAgICBpZiAoIGF0dHIgPT09ICdpbmRleCcgKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBzb3VyY2VBcnJheSA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLmFycmF5O1xuICAgICAgc29ydGVkQXR0cmlidXRlc1sgYXR0ciBdID0gbmV3IHNvdXJjZUFycmF5LmNvbnN0cnVjdG9yKCB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5pdGVtU2l6ZSAqIHZlcnRleENvdW50ICk7XG4gICAgfVxuXG4gICAgLyogTW92ZSBhdHRyaWJ1dGUgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSBuZXcgaW5kZXggbWFwICovXG4gICAgZm9yICggdmFyIG5ld192aWQgPSAwOyBuZXdfdmlkIDwgdmVydGV4Q291bnQ7IG5ld192aWQgKysgKSB7XG4gICAgICB2YXIgdmlkID0gaW5kZXhNYXBbIG5ld192aWQgXTtcbiAgICAgIGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcbiAgICAgICAgaWYgKCBhdHRyID09PSAnaW5kZXgnIClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIGF0dHJBcnJheSA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLmFycmF5O1xuICAgICAgICB2YXIgYXR0clNpemUgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5pdGVtU2l6ZTtcbiAgICAgICAgdmFyIHNvcnRlZEF0dHIgPSBzb3J0ZWRBdHRyaWJ1dGVzWyBhdHRyIF07XG4gICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGF0dHJTaXplOyBrICsrIClcbiAgICAgICAgICBzb3J0ZWRBdHRyWyBuZXdfdmlkICogYXR0clNpemUgKyBrIF0gPSBhdHRyQXJyYXlbIHZpZCAqIGF0dHJTaXplICsgayBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIENhcnJ5IHRoZSBuZXcgc29ydGVkIGJ1ZmZlcnMgbG9jYWxseSAqL1xuICAgIHRoaXMuYXR0cmlidXRlc1sgJ2luZGV4JyBdLmFycmF5ID0gaW5kZXhCdWZmZXI7XG4gICAgZm9yICggdmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuICAgICAgaWYgKCBhdHRyID09PSAnaW5kZXgnIClcbiAgICAgICAgY29udGludWU7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5hcnJheSA9IHNvcnRlZEF0dHJpYnV0ZXNbIGF0dHIgXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLm51bUl0ZW1zID0gdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uaXRlbVNpemUgKiB2ZXJ0ZXhDb3VudDtcbiAgICB9XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgdHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcbiAgICAgICAgZ2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cbiAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgIGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgICBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcblxuICAgIH1cblxuICAgIGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5vZmZzZXRzO1xuICAgIHZhciBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuICAgICAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgICBkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XG4gICAgICAgIGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBhcnJheTogYXJyYXlcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgICBkYXRhLmRhdGEub2Zmc2V0cyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBvZmZzZXRzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgIGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcbiAgICAgICAgY2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuICAgICAgICByYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBzb3VyY2VBdHRyID0gdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF07XG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGF0dHIsIHNvdXJjZUF0dHIuY2xvbmUoKSApO1xuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMub2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0c1sgaSBdO1xuXG4gICAgICBnZW9tZXRyeS5vZmZzZXRzLnB1c2goIHtcblxuICAgICAgICBzdGFydDogb2Zmc2V0LnN0YXJ0LFxuICAgICAgICBpbmRleDogb2Zmc2V0LmluZGV4LFxuICAgICAgICBjb3VudDogb2Zmc2V0LmNvdW50XG5cbiAgICAgIH0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcbiAgdGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHVuZGVmaW5lZDtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZERyYXdDYWxsID0gZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0LCBpbnN0YW5jZXMgKSB7XG5cbiAgdGhpcy5kcmF3Y2FsbHMucHVzaCgge1xuXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGNvdW50OiBjb3VudCxcbiAgICBpbmRleDogaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCA/IGluZGV4T2Zmc2V0IDogMCxcbiAgICBpbnN0YW5jZXM6IGluc3RhbmNlc1xuXG4gIH0gKTtcblxufSxcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSgpO1xuXG4gIGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcblxuICAgIHZhciBzb3VyY2VBdHRyID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggYXR0ciwgc291cmNlQXR0ci5jbG9uZSgpICk7XG5cbiAgfVxuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLm9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldHNbaV07XG5cbiAgICBnZW9tZXRyeS5vZmZzZXRzLnB1c2goIHtcblxuICAgICAgc3RhcnQ6IG9mZnNldC5zdGFydCxcbiAgICAgIGluZGV4OiBvZmZzZXQuaW5kZXgsXG4gICAgICBjb3VudDogb2Zmc2V0LmNvdW50LFxuICAgICAgaW5zdGFuY2VzOiBvZmZzZXQuaW5zdGFuY2VzXG5cbiAgICB9ICk7XG5cbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0NhbWVyYSc7XG5cbiAgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG59O1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICB9O1xuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgbTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcblxuICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cbiAgfTtcblxufSgpO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cbiAgaWYgKCBjYW1lcmEgPT09IHVuZGVmaW5lZCApIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgY2FtZXJhICk7XG5cbiAgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcblxuICByZXR1cm4gY2FtZXJhO1xufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzXG5cbi8qKlxuICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXG4gKiAgLSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkN1YmVDYW1lcmEgPSBmdW5jdGlvbiAoIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuICB2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XG5cbiAgdmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gIGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XG4gIGNhbWVyYVBYLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSApO1xuICB0aGlzLmFkZCggY2FtZXJhUFggKTtcblxuICB2YXIgY2FtZXJhTlggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgY2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgY2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcbiAgdGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cbiAgdmFyIGNhbWVyYVBZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gIGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xuICBjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcbiAgdGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cbiAgdmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gIGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XG4gIGNhbWVyYU5ZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApICk7XG4gIHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG4gIHZhciBjYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICBjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuICBjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcbiAgdGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cbiAgdmFyIGNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gIGNhbWVyYU5aLnVwLnNldCggMCwgLSAxLCAwICk7XG4gIGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XG4gIHRoaXMuYWRkKCBjYW1lcmFOWiApO1xuXG4gIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCB7IGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIgfSApO1xuXG4gIHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG4gICAgaWYgKCB0aGlzLnBhcmVudCA9PT0gdW5kZWZpbmVkICkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG4gICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXG4gIH07XG5cbn07XG5cblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVDYW1lcmE7XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgPSBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG4gIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cbiAgdGhpcy56b29tID0gMTtcblxuICB0aGlzLmxlZnQgPSBsZWZ0O1xuICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIHRoaXMudG9wID0gdG9wO1xuICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuICB0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcbiAgdGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xuXG4gIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG4gIHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG4gIHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcbiAgdmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG4gIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoKTtcblxuICBUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xuXG4gIGNhbWVyYS56b29tID0gdGhpcy56b29tO1xuXG4gIGNhbWVyYS5sZWZ0ID0gdGhpcy5sZWZ0O1xuICBjYW1lcmEucmlnaHQgPSB0aGlzLnJpZ2h0O1xuICBjYW1lcmEudG9wID0gdGhpcy50b3A7XG4gIGNhbWVyYS5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblxuICBjYW1lcmEubmVhciA9IHRoaXMubmVhcjtcbiAgY2FtZXJhLmZhciA9IHRoaXMuZmFyO1xuXG4gIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gIHJldHVybiBjYW1lcmE7XG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XG4gIGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG4gIGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xuICBkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuICBkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSA9IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuICBUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cbiAgdGhpcy56b29tID0gMTtcblxuICB0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XG4gIHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuICB0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuICB0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcblxuICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XG5cblxuLyoqXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXG4gKiAzNW1tIChmdWxsZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xuXG4gIGlmICggZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCApIGZyYW1lSGVpZ2h0ID0gMjQ7XG5cbiAgdGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xuICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG4vKipcbiAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcbiAqXG4gKiAgICstLS0rLS0tKy0tLStcbiAqICAgfCBBIHwgQiB8IEMgfFxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgRCB8IEUgfCBGIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICpcbiAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcbiAqXG4gKiAgIHZhciB3ID0gMTkyMDtcbiAqICAgdmFyIGggPSAxMDgwO1xuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XG4gKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XG4gKlxuICogICAtLUEtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuICogICAtLUItLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuICogICAtLUMtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuICogICAtLUQtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuICogICAtLUUtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuICogICAtLUYtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuICpcbiAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0Vmlld09mZnNldCA9IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gIHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuICB0aGlzLmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmb3YgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKCAyICogTWF0aC5hdGFuKCBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5mb3YgKSAqIDAuNSApIC8gdGhpcy56b29tICkgKTtcblxuICBpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xuXG4gICAgdmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xuICAgIHZhciB0b3AgPSBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKSAqIHRoaXMubmVhcjtcbiAgICB2YXIgYm90dG9tID0gLSB0b3A7XG4gICAgdmFyIGxlZnQgPSBhc3BlY3QgKiBib3R0b207XG4gICAgdmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xuICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKCByaWdodCAtIGxlZnQgKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcCAtIGJvdHRvbSApO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxuICAgICAgbGVmdCArIHRoaXMueCAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXG4gICAgICBsZWZ0ICsgKCB0aGlzLnggKyB0aGlzLndpZHRoICkgKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuICAgICAgdG9wIC0gKCB0aGlzLnkgKyB0aGlzLmhlaWdodCApICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuICAgICAgdG9wIC0gdGhpcy55ICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuICAgICAgdGhpcy5uZWFyLFxuICAgICAgdGhpcy5mYXJcbiAgICApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBmb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXG4gIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgY2FtZXJhICk7XG5cbiAgY2FtZXJhLnpvb20gPSB0aGlzLnpvb207XG5cbiAgY2FtZXJhLmZvdiA9IHRoaXMuZm92O1xuICBjYW1lcmEuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG4gIGNhbWVyYS5uZWFyID0gdGhpcy5uZWFyO1xuICBjYW1lcmEuZmFyID0gdGhpcy5mYXI7XG5cbiAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgcmV0dXJuIGNhbWVyYTtcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuICBkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcbiAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpZ2h0JztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpZ2h0O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG4gIGlmICggbGlnaHQgPT09IHVuZGVmaW5lZCApIGxpZ2h0ID0gbmV3IFRIUkVFLkxpZ2h0KCk7XG5cbiAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XG5cbiAgbGlnaHQuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG4gIHJldHVybiBsaWdodDtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xuXG59O1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQW1iaWVudExpZ2h0O1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoKTtcblxuICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuICByZXR1cm4gbGlnaHQ7XG5cbn07XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvQXJlYUxpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBNUGFua25pbiAvIGh0dHA6Ly93d3cucmVkcGxhbnQuZGUvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkFyZWFMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdBcmVhTGlnaHQnO1xuXG4gIHRoaXMubm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuICB0aGlzLnJpZ2h0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbiAgdGhpcy53aWR0aCA9IDEuMDtcbiAgdGhpcy5oZWlnaHQgPSAxLjA7XG5cbiAgdGhpcy5jb25zdGFudEF0dGVudWF0aW9uID0gMS41O1xuICB0aGlzLmxpbmVhckF0dGVudWF0aW9uID0gMC41O1xuICB0aGlzLnF1YWRyYXRpY0F0dGVudWF0aW9uID0gMC4xO1xuXG59O1xuXG5USFJFRS5BcmVhTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5BcmVhTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJlYUxpZ2h0O1xuXG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcblxuICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblxuICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgdGhpcy5vbmx5U2hhZG93ID0gZmFsc2U7XG5cbiAgLy9cblxuICB0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSA1MDtcbiAgdGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhTGVmdCA9IC0gNTAwO1xuICB0aGlzLnNoYWRvd0NhbWVyYVJpZ2h0ID0gNTAwO1xuICB0aGlzLnNoYWRvd0NhbWVyYVRvcCA9IDUwMDtcbiAgdGhpcy5zaGFkb3dDYW1lcmFCb3R0b20gPSAtIDUwMDtcblxuICB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcblxuICB0aGlzLnNoYWRvd0JpYXMgPSAwO1xuICB0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuXG4gIHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XG4gIHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xuXG4gIC8vXG5cbiAgdGhpcy5zaGFkb3dDYXNjYWRlID0gZmFsc2U7XG5cbiAgdGhpcy5zaGFkb3dDYXNjYWRlT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMTAwMCApO1xuICB0aGlzLnNoYWRvd0Nhc2NhZGVDb3VudCA9IDI7XG5cbiAgdGhpcy5zaGFkb3dDYXNjYWRlQmlhcyA9IFsgMCwgMCwgMCBdO1xuICB0aGlzLnNoYWRvd0Nhc2NhZGVXaWR0aCA9IFsgNTEyLCA1MTIsIDUxMiBdO1xuICB0aGlzLnNoYWRvd0Nhc2NhZGVIZWlnaHQgPSBbIDUxMiwgNTEyLCA1MTIgXTtcblxuICB0aGlzLnNoYWRvd0Nhc2NhZGVOZWFyWiA9IFsgLSAxLjAwMCwgMC45OTAsIDAuOTk4IF07XG4gIHRoaXMuc2hhZG93Q2FzY2FkZUZhclogPSBbIDAuOTkwLCAwLjk5OCwgMS4wMDAgXTtcblxuICB0aGlzLnNoYWRvd0Nhc2NhZGVBcnJheSA9IFtdO1xuXG4gIC8vXG5cbiAgdGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuICB0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuICB0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG4gIHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoKTtcblxuICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuICBsaWdodC50YXJnZXQgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXG4gIGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG4gIGxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gIGxpZ2h0Lm9ubHlTaGFkb3cgPSB0aGlzLm9ubHlTaGFkb3c7XG5cbiAgLy9cblxuICBsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gdGhpcy5zaGFkb3dDYW1lcmFOZWFyO1xuICBsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSB0aGlzLnNoYWRvd0NhbWVyYUZhcjtcblxuICBsaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gdGhpcy5zaGFkb3dDYW1lcmFMZWZ0O1xuICBsaWdodC5zaGFkb3dDYW1lcmFSaWdodCA9IHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQ7XG4gIGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCA9IHRoaXMuc2hhZG93Q2FtZXJhVG9wO1xuICBsaWdodC5zaGFkb3dDYW1lcmFCb3R0b20gPSB0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbTtcblxuICBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG4gIGxpZ2h0LnNoYWRvd0JpYXMgPSB0aGlzLnNoYWRvd0JpYXM7XG4gIGxpZ2h0LnNoYWRvd0RhcmtuZXNzID0gdGhpcy5zaGFkb3dEYXJrbmVzcztcblxuICBsaWdodC5zaGFkb3dNYXBXaWR0aCA9IHRoaXMuc2hhZG93TWFwV2lkdGg7XG4gIGxpZ2h0LnNoYWRvd01hcEhlaWdodCA9IHRoaXMuc2hhZG93TWFwSGVpZ2h0O1xuXG4gIC8vXG5cbiAgbGlnaHQuc2hhZG93Q2FzY2FkZSA9IHRoaXMuc2hhZG93Q2FzY2FkZTtcblxuICBsaWdodC5zaGFkb3dDYXNjYWRlT2Zmc2V0LmNvcHkoIHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCApO1xuICBsaWdodC5zaGFkb3dDYXNjYWRlQ291bnQgPSB0aGlzLnNoYWRvd0Nhc2NhZGVDb3VudDtcblxuICBsaWdodC5zaGFkb3dDYXNjYWRlQmlhcyA9IHRoaXMuc2hhZG93Q2FzY2FkZUJpYXMuc2xpY2UoIDAgKTtcbiAgbGlnaHQuc2hhZG93Q2FzY2FkZVdpZHRoID0gdGhpcy5zaGFkb3dDYXNjYWRlV2lkdGguc2xpY2UoIDAgKTtcbiAgbGlnaHQuc2hhZG93Q2FzY2FkZUhlaWdodCA9IHRoaXMuc2hhZG93Q2FzY2FkZUhlaWdodC5zbGljZSggMCApO1xuXG4gIGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWiA9IHRoaXMuc2hhZG93Q2FzY2FkZU5lYXJaLnNsaWNlKCAwICk7XG4gIGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaID0gdGhpcy5zaGFkb3dDYXNjYWRlRmFyWi5zbGljZSggMCApO1xuXG4gIHJldHVybiBsaWdodDtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24gKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xuXG4gIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxMDAsIDAgKTtcblxuICB0aGlzLmdyb3VuZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBncm91bmRDb2xvciApO1xuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHQ7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgpO1xuXG4gIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG4gIGxpZ2h0Lmdyb3VuZENvbG9yLmNvcHkoIHRoaXMuZ3JvdW5kQ29sb3IgKTtcbiAgbGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cbiAgcmV0dXJuIGxpZ2h0O1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5ICkge1xuXG4gIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgdGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXG4gIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcbiAgdGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuICB0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxufTtcblxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodDtcblxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoKTtcblxuICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuICBsaWdodC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcbiAgbGlnaHQuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuICBsaWdodC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cbiAgcmV0dXJuIGxpZ2h0O1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL1Nwb3RMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXG4gIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG4gIHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuICB0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG4gIHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG4gIHRoaXMuZXhwb25lbnQgPSAoIGV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGV4cG9uZW50IDogMTA7XG4gIHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG4gIHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICB0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcblxuICAvL1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDUwO1xuICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IDUwMDA7XG4gIHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gNTA7XG5cbiAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5zaGFkb3dCaWFzID0gMDtcbiAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuICB0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuICAvL1xuXG4gIHRoaXMuc2hhZG93TWFwID0gbnVsbDtcbiAgdGhpcy5zaGFkb3dNYXBTaXplID0gbnVsbDtcbiAgdGhpcy5zaGFkb3dDYW1lcmEgPSBudWxsO1xuICB0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHQ7XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCgpO1xuXG4gIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG4gIGxpZ2h0LnRhcmdldCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG5cbiAgbGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG4gIGxpZ2h0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcbiAgbGlnaHQuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICBsaWdodC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG4gIGxpZ2h0LmRlY2F5ID0gdGhpcy5kZWNheTtcblxuICBsaWdodC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICBsaWdodC5vbmx5U2hhZG93ID0gdGhpcy5vbmx5U2hhZG93O1xuXG4gIC8vXG5cbiAgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IHRoaXMuc2hhZG93Q2FtZXJhTmVhcjtcbiAgbGlnaHQuc2hhZG93Q2FtZXJhRmFyID0gdGhpcy5zaGFkb3dDYW1lcmFGYXI7XG4gIGxpZ2h0LnNoYWRvd0NhbWVyYUZvdiA9IHRoaXMuc2hhZG93Q2FtZXJhRm92O1xuXG4gIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGU7XG5cbiAgbGlnaHQuc2hhZG93QmlhcyA9IHRoaXMuc2hhZG93QmlhcztcbiAgbGlnaHQuc2hhZG93RGFya25lc3MgPSB0aGlzLnNoYWRvd0RhcmtuZXNzO1xuXG4gIGxpZ2h0LnNoYWRvd01hcFdpZHRoID0gdGhpcy5zaGFkb3dNYXBXaWR0aDtcbiAgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ID0gdGhpcy5zaGFkb3dNYXBIZWlnaHQ7XG5cbiAgcmV0dXJuIGxpZ2h0O1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG4gIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcbiAgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICBkYXRhLm9iamVjdC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG4gIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9DYWNoZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ2FjaGUgPSB7XG5cbiAgZmlsZXM6IHt9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cbiAgICB0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XG5cbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG4gICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cbiAgICByZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XG5cbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG4gICAgZGVsZXRlIHRoaXMuZmlsZXNbIGtleSBdO1xuXG4gIH0sXG5cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZmlsZXMgPSB7fVxuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uICggc2hvd1N0YXR1cyApIHtcblxuICB0aGlzLnNob3dTdGF0dXMgPSBzaG93U3RhdHVzO1xuICB0aGlzLnN0YXR1c0RvbUVsZW1lbnQgPSBzaG93U3RhdHVzID8gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5hZGRTdGF0dXNFbGVtZW50KCkgOiBudWxsO1xuXG4gIHRoaXMuaW1hZ2VMb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcblxuICB0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XG4gIHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG59O1xuXG5USFJFRS5Mb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Mb2FkZXIsXG5cbiAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuICBhZGRTdGF0dXNFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cbiAgICBlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlLnN0eWxlLnJpZ2h0ID0gJzBweCc7XG4gICAgZS5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlLnN0eWxlLmZvbnRTaXplID0gJzAuOGVtJztcbiAgICBlLnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBlLnN0eWxlLmJhY2tncm91bmQgPSAncmdiYSgwLDAsMCwwLjI1KSc7XG4gICAgZS5zdHlsZS5jb2xvciA9ICcjZmZmJztcbiAgICBlLnN0eWxlLndpZHRoID0gJzEyMHB4JztcbiAgICBlLnN0eWxlLnBhZGRpbmcgPSAnMC41ZW0gMC41ZW0gMC41ZW0gMC41ZW0nO1xuICAgIGUuc3R5bGUuekluZGV4ID0gMTAwMDtcblxuICAgIGUuaW5uZXJIVE1MID0gJ0xvYWRpbmcgLi4uJztcblxuICAgIHJldHVybiBlO1xuXG4gIH0sXG5cbiAgdXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uICggcHJvZ3Jlc3MgKSB7XG5cbiAgICB2YXIgbWVzc2FnZSA9ICdMb2FkZWQgJztcblxuICAgIGlmICggcHJvZ3Jlc3MudG90YWwgKSB7XG5cbiAgICAgIG1lc3NhZ2UgKz0gKCAxMDAgKiBwcm9ncmVzcy5sb2FkZWQgLyBwcm9ncmVzcy50b3RhbCApLnRvRml4ZWQoIDAgKSArICclJztcblxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgbWVzc2FnZSArPSAoIHByb2dyZXNzLmxvYWRlZCAvIDEwMjQgKS50b0ZpeGVkKCAyICkgKyAnIEtCJztcblxuICAgIH1cblxuICAgIHRoaXMuc3RhdHVzRG9tRWxlbWVudC5pbm5lckhUTUwgPSBtZXNzYWdlO1xuXG4gIH0sXG5cbiAgZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xuXG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcblxuICAgIGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XG5cbiAgICBwYXJ0cy5wb3AoKTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcblxuICB9LFxuXG4gIGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCApIHtcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcblxuICAgICAgYXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgbmVlZHNUYW5nZW50czogZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgbSA9IG1hdGVyaWFsc1sgaSBdO1xuXG4gICAgICBpZiAoIG0gaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIH0sXG5cbiAgY3JlYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uICggbSwgdGV4dHVyZVBhdGggKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gbmVhcmVzdF9wb3cyKCBuICkge1xuXG4gICAgICB2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcbiAgICAgIHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5yb3VuZCggIGwgKSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3RleHR1cmUoIHdoZXJlLCBuYW1lLCBzb3VyY2VGaWxlLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcblxuICAgICAgdmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBzb3VyY2VGaWxlO1xuXG4gICAgICB2YXIgdGV4dHVyZTtcblxuICAgICAgdmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XG5cbiAgICAgIGlmICggbG9hZGVyICE9PSBudWxsICkge1xuXG4gICAgICAgIHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcblxuICAgICAgICBsb2FkZXIgPSBzY29wZS5pbWFnZUxvYWRlcjtcbiAgICAgICAgbG9hZGVyLmNyb3NzT3JpZ2luID0gc2NvcGUuY3Jvc3NPcmlnaW47XG4gICAgICAgIGxvYWRlci5sb2FkKCBmdWxsUGF0aCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuICAgICAgICAgIGlmICggVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gbmVhcmVzdF9wb3cyKCBpbWFnZS53aWR0aCApO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IG5lYXJlc3RfcG93MiggaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGNhbnZhcztcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgfVxuXG4gICAgICB0ZXh0dXJlLnNvdXJjZUZpbGUgPSBzb3VyY2VGaWxlO1xuXG4gICAgICBpZiAoIHJlcGVhdCApIHtcblxuICAgICAgICB0ZXh0dXJlLnJlcGVhdC5zZXQoIHJlcGVhdFsgMCBdLCByZXBlYXRbIDEgXSApO1xuXG4gICAgICAgIGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgIGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5vZmZzZXQuc2V0KCBvZmZzZXRbIDAgXSwgb2Zmc2V0WyAxIF0gKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHdyYXAgKSB7XG5cbiAgICAgICAgdmFyIHdyYXBNYXAgPSB7XG4gICAgICAgICAgJ3JlcGVhdCc6IFRIUkVFLlJlcGVhdFdyYXBwaW5nLFxuICAgICAgICAgICdtaXJyb3InOiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCB3cmFwTWFwWyB3cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwUyA9IHdyYXBNYXBbIHdyYXBbIDAgXSBdO1xuICAgICAgICBpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgICAgIHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cbiAgICAgIH1cblxuICAgICAgd2hlcmVbIG5hbWUgXSA9IHRleHR1cmU7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2IyaGV4KCByZ2IgKSB7XG5cbiAgICAgIHJldHVybiAoIHJnYlsgMCBdICogMjU1IDw8IDE2ICkgKyAoIHJnYlsgMSBdICogMjU1IDw8IDggKSArIHJnYlsgMiBdICogMjU1O1xuXG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdHNcblxuICAgIHZhciBtdHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcbiAgICB2YXIgbXBhcnMgPSB7IGNvbG9yOiAweGVlZWVlZSwgb3BhY2l0eTogMS4wLCBtYXA6IG51bGwsIGxpZ2h0TWFwOiBudWxsLCBub3JtYWxNYXA6IG51bGwsIGJ1bXBNYXA6IG51bGwsIHdpcmVmcmFtZTogZmFsc2UgfTtcblxuICAgIC8vIHBhcmFtZXRlcnMgZnJvbSBtb2RlbCBmaWxlXG5cbiAgICBpZiAoIG0uc2hhZGluZyApIHtcblxuICAgICAgdmFyIHNoYWRpbmcgPSBtLnNoYWRpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKCBzaGFkaW5nID09PSAncGhvbmcnICkgbXR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuICAgICAgZWxzZSBpZiAoIHNoYWRpbmcgPT09ICdiYXNpYycgKSBtdHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiBUSFJFRVsgbS5ibGVuZGluZyBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG1wYXJzLmJsZW5kaW5nID0gVEhSRUVbIG0uYmxlbmRpbmcgXTtcblxuICAgIH1cblxuICAgIGlmICggbS50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy50cmFuc3BhcmVudCA9IG0udHJhbnNwYXJlbnQ7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG0ub3BhY2l0eSA8IDEuMCApIHtcblxuICAgICAgbXBhcnMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcblxuICAgIH1cblxuICAgIGlmICggbS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG1wYXJzLmRlcHRoV3JpdGUgPSBtLmRlcHRoV3JpdGU7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy52aXNpYmxlID0gbS52aXNpYmxlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLmZsaXBTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy5zaWRlID0gVEhSRUUuQmFja1NpZGU7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0uZG91YmxlU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbXBhcnMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG1wYXJzLndpcmVmcmFtZSA9IG0ud2lyZWZyYW1lO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpZiAoIG0udmVydGV4Q29sb3JzID09PSAnZmFjZScgKSB7XG5cbiAgICAgICAgbXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcblxuICAgICAgfSBlbHNlIGlmICggbS52ZXJ0ZXhDb2xvcnMgKSB7XG5cbiAgICAgICAgbXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjb2xvcnNcblxuICAgIGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XG5cbiAgICAgIG1wYXJzLmNvbG9yID0gcmdiMmhleCggbS5jb2xvckRpZmZ1c2UgKTtcblxuICAgIH0gZWxzZSBpZiAoIG0uRGJnQ29sb3IgKSB7XG5cbiAgICAgIG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcblxuICAgIH1cblxuICAgIGlmICggbS5jb2xvclNwZWN1bGFyICkge1xuXG4gICAgICBtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLmNvbG9yRW1pc3NpdmUgKSB7XG5cbiAgICAgIG1wYXJzLmVtaXNzaXZlID0gcmdiMmhleCggbS5jb2xvckVtaXNzaXZlICk7XG5cbiAgICB9XG5cbiAgICAvLyBtb2RpZmllcnNcblxuICAgIGlmICggbS50cmFuc3BhcmVuY3kgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xuICAgICAgbS5vcGFjaXR5ID0gbS50cmFuc3BhcmVuY3k7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy5vcGFjaXR5ID0gbS5vcGFjaXR5O1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLnNwZWN1bGFyQ29lZiApIHtcblxuICAgICAgbXBhcnMuc2hpbmluZXNzID0gbS5zcGVjdWxhckNvZWY7XG5cbiAgICB9XG5cbiAgICAvLyB0ZXh0dXJlc1xuXG4gICAgaWYgKCBtLm1hcERpZmZ1c2UgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ21hcCcsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBMaWdodCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbGlnaHRNYXAnLCBtLm1hcExpZ2h0LCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBBTyAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYW9NYXAnLCBtLm1hcEFPLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBCdW1wICYmIHRleHR1cmVQYXRoICkge1xuXG4gICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdidW1wTWFwJywgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLm1hcE5vcm1hbCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbm9ybWFsTWFwJywgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBTcGVjdWxhciAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnc3BlY3VsYXJNYXAnLCBtLm1hcFNwZWN1bGFyLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBBbHBoYSAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYWxwaGFNYXAnLCBtLm1hcEFscGhhLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICBpZiAoIG0ubWFwQnVtcFNjYWxlICkge1xuXG4gICAgICBtcGFycy5idW1wU2NhbGUgPSBtLm1hcEJ1bXBTY2FsZTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XG5cbiAgICAgIG1wYXJzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIG0ubWFwTm9ybWFsRmFjdG9yLCBtLm1hcE5vcm1hbEZhY3RvciApO1xuXG4gICAgfVxuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBtdHlwZSBdKCBtcGFycyApO1xuXG4gICAgaWYgKCBtLkRiZ05hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBtLkRiZ05hbWU7XG5cbiAgICByZXR1cm4gbWF0ZXJpYWw7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XG5cbiAgaGFuZGxlcnM6IFtdLFxuXG4gIGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xuXG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xuXG4gICAgICB2YXIgcmVnZXggPSB0aGlzLmhhbmRsZXJzWyBpIF07XG4gICAgICB2YXIgbG9hZGVyICA9IHRoaXMuaGFuZGxlcnNbIGkgKyAxIF07XG5cbiAgICAgIGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xuXG4gICAgICAgIHJldHVybiBsb2FkZXI7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9YSFJMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlhIUkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XG5cbiAgICBpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuXG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblxuICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICBUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcy5yZXNwb25zZSApO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcy5yZXNwb25zZSApO1xuXG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgfSwgZmFsc2UgKTtcblxuICAgIGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcblxuICAgICAgfSwgZmFsc2UgKTtcblxuICAgIH1cblxuICAgIGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgICAgb25FcnJvciggZXZlbnQgKTtcblxuICAgICAgfSwgZmFsc2UgKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgaWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcblxuICAgIHJlcXVlc3Quc2VuZCggbnVsbCApO1xuXG4gICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG5cbiAgfSxcblxuICBzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuSW1hZ2VMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5JbWFnZUxvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xuXG4gICAgaWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuICAgICAgcmV0dXJuIGNhY2hlZDtcblxuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbWcnICk7XG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgIFRIUkVFLkNhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cbiAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XG5cbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICB9LCBmYWxzZSApO1xuXG4gICAgaWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcblxuICAgICAgfSwgZmFsc2UgKTtcblxuICAgIH1cblxuICAgIGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICAgIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICAgIH0sIGZhbHNlICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIGltYWdlLnNyYyA9IHVybDtcblxuICAgIHJldHVybiBpbWFnZTtcblxuICB9LFxuXG4gIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9KU09OTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uICggc2hvd1N0YXR1cyApIHtcblxuICBUSFJFRS5Mb2FkZXIuY2FsbCggdGhpcywgc2hvd1N0YXR1cyApO1xuXG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTG9hZGVyLnByb3RvdHlwZSApO1xuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5KU09OTG9hZGVyO1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApIHtcblxuICAvLyB0b2RvOiB1bmlmeSBsb2FkIEFQSSB0byBmb3IgZWFzaWVyIFNjZW5lTG9hZGVyIHVzZVxuXG4gIHRleHR1cmVQYXRoID0gdGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGV4dHVyZVBhdGggPT09ICdzdHJpbmcnICkgPyB0ZXh0dXJlUGF0aCA6IHRoaXMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG4gIHRoaXMub25Mb2FkU3RhcnQoKTtcbiAgdGhpcy5sb2FkQWpheEpTT04oIHRoaXMsIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICk7XG5cbn07XG5cblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWRBamF4SlNPTiA9IGZ1bmN0aW9uICggY29udGV4dCwgdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGgsIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XG5cbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIHZhciBsZW5ndGggPSAwO1xuXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIHhoci5yZWFkeVN0YXRlID09PSB4aHIuRE9ORSApIHtcblxuICAgICAgaWYgKCB4aHIuc3RhdHVzID09PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMCApIHtcblxuICAgICAgICBpZiAoIHhoci5yZXNwb25zZVRleHQgKSB7XG5cbiAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UoIHhoci5yZXNwb25zZVRleHQgKTtcbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xuXG4gICAgICAgICAgaWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdvYmplY3QnICkge1xuXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuT2JqZWN0TG9hZGVyIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtZXRhZGF0YS50eXBlID09PSAnc2NlbmUnICkge1xuXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzZWVtcyB0byBiZSBhIFNjZW5lLiBVc2UgVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG4gICAgICAgICAgY2FsbGJhY2soIHJlc3VsdC5nZW9tZXRyeSwgcmVzdWx0Lm1hdGVyaWFscyApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2VlbXMgdG8gYmUgdW5yZWFjaGFibGUgb3IgdGhlIGZpbGUgaXMgZW1wdHkuJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBjb250ZXh0IG9mIG1vcmUgY29tcGxleCBhc3NldCBpbml0aWFsaXphdGlvblxuICAgICAgICAvLyBkbyBub3QgYmxvY2sgb24gc2luZ2xlIGZhaWxlZCBmaWxlXG4gICAgICAgIC8vIG1heWJlIHNob3VsZCBnbyBldmVuIG9uZSBtb3JlIGxldmVsIHVwXG5cbiAgICAgICAgY29udGV4dC5vbkxvYWRDb21wbGV0ZSgpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiBDb3VsZG5cXCd0IGxvYWQgJyArIHVybCArICcgKCcgKyB4aHIuc3RhdHVzICsgJyknICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSB4aHIuTE9BRElORyApIHtcblxuICAgICAgaWYgKCBjYWxsYmFja1Byb2dyZXNzICkge1xuXG4gICAgICAgIGlmICggbGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgbGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCAnQ29udGVudC1MZW5ndGgnICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrUHJvZ3Jlc3MoIHsgdG90YWw6IGxlbmd0aCwgbG9hZGVkOiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCB9ICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSB4aHIuSEVBREVSU19SRUNFSVZFRCApIHtcblxuICAgICAgaWYgKCBjYWxsYmFja1Byb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCAnQ29udGVudC1MZW5ndGgnICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIHhoci5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgeGhyLnNlbmQoIG51bGwgKTtcblxufTtcblxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxuICBzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xuXG4gIHBhcnNlTW9kZWwoIHNjYWxlICk7XG5cbiAgcGFyc2VTa2luKCk7XG4gIHBhcnNlTW9ycGhpbmcoIHNjYWxlICk7XG5cbiAgZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kZWwoIHNjYWxlICkge1xuXG4gICAgZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcblxuICAgICAgcmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XG5cbiAgICB9XG5cbiAgICB2YXIgaSwgaiwgZmksXG5cbiAgICBvZmZzZXQsIHpMZW5ndGgsXG5cbiAgICBjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCxcblxuICAgIHR5cGUsXG4gICAgaXNRdWFkLFxuICAgIGhhc01hdGVyaWFsLFxuICAgIGhhc0ZhY2VWZXJ0ZXhVdixcbiAgICBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxuICAgIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxuXG4gICAgdmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxuXG4gICAgdXZMYXllciwgdXYsIHUsIHYsXG5cbiAgICBmYWNlcyA9IGpzb24uZmFjZXMsXG4gICAgdmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxuICAgIG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXG4gICAgY29sb3JzID0ganNvbi5jb2xvcnMsXG5cbiAgICBuVXZMYXllcnMgPSAwO1xuXG4gICAgaWYgKCBqc29uLnV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIG9mZnNldCA9IDA7XG4gICAgekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgIHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuICAgICAgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcbiAgICAgIHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG4gICAgICB2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuXG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgIH1cblxuICAgIG9mZnNldCA9IDA7XG4gICAgekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuICAgIHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuICAgICAgdHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXG4gICAgICBpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcbiAgICAgIGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xuICAgICAgaGFzRmFjZVZlcnRleFV2ICAgICA9IGlzQml0U2V0KCB0eXBlLCAzICk7XG4gICAgICBoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcbiAgICAgIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xuICAgICAgaGFzRmFjZUNvbG9yICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcbiAgICAgIGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xuXG4gICAgICBpZiAoIGlzUXVhZCApIHtcblxuICAgICAgICBmYWNlQSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICBmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xuICAgICAgICBmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcbiAgICAgICAgZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgZmFjZUIgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG4gICAgICAgIGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuICAgICAgICBmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuICAgICAgICBvZmZzZXQgKz0gNDtcblxuICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgICAgICAgb2Zmc2V0ICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG4gICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcblxuICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgICAgICAgICAgIHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuICAgICAgICAgICAgICB2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XG5cbiAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG4gICAgICAgICAgICAgIGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuICAgICAgICAgICAgICBpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgICAgICAgZmFjZUEubm9ybWFsLnNldChcbiAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgKTtcblxuXG4gICAgICAgICAgICBpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuICAgICAgICAgICAgaWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgICAgICAgaGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cbiAgICAgICAgICBmYWNlQS5jb2xvci5zZXRIZXgoIGhleCApO1xuICAgICAgICAgIGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgICAgICAgICBoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuICAgICAgICAgICAgaWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcbiAgICAgICAgICAgIGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XG4gICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICBmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgICAgIGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICAgICAgZmFjZS5jID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgICAgIGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICBvZmZzZXQgKys7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG4gICAgICAgIGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xuXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblxuICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgICAgICAgICAgIHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cbiAgICAgICAgICAgICAgdSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG4gICAgICAgICAgICAgIHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuICAgICAgICAgICAgICB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XG5cbiAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgICAgICAgZmFjZS5ub3JtYWwuc2V0KFxuICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG4gICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cbiAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgIGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG4gICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG4gICAgdmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xuXG4gICAgaWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgICAgICB2YXIgeCA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbldlaWdodHNbIGkgICAgIF07XG4gICAgICAgIHZhciB5ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDEgXSA6IDA7XG4gICAgICAgIHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XG4gICAgICAgIHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cbiAgICAgICAgZ2VvbWV0cnkuc2tpbldlaWdodHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIHgsIHksIHosIHcgKSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIGpzb24uc2tpbkluZGljZXMgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG4gICAgICAgIHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSAgICAgXTtcbiAgICAgICAgdmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcbiAgICAgICAgdmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcbiAgICAgICAgdmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcblxuICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuICAgIGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFdoZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXG4gICAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICsgJyksIGFuZCBza2luV2VpZ2h0cyAoJyArIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCArICcpIHNob3VsZCBtYXRjaC4nICk7XG5cbiAgICB9XG5cblxuICAgIC8vIGNvdWxkIGNoYW5nZSB0aGlzIHRvIGpzb24uYW5pbWF0aW9uc1swXSBvciByZW1vdmUgY29tcGxldGVseVxuXG4gICAgZ2VvbWV0cnkuYW5pbWF0aW9uID0ganNvbi5hbmltYXRpb247XG4gICAgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IGpzb24uYW5pbWF0aW9ucztcblxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cbiAgICBpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBpLCBsLCB2LCB2bCwgZHN0VmVydGljZXMsIHNyY1ZlcnRpY2VzO1xuXG4gICAgICBmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcbiAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcbiAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuICAgICAgICBkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuICAgICAgICBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzIFsgaSBdLnZlcnRpY2VzO1xuXG4gICAgICAgIGZvciAoIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XG5cbiAgICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICB2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcbiAgICAgICAgICB2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XG4gICAgICAgICAgdmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xuXG4gICAgICAgICAgZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGksIGwsIGMsIGNsLCBkc3RDb2xvcnMsIHNyY0NvbG9ycywgY29sb3I7XG5cbiAgICAgIGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaENvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0gPSB7fTtcbiAgICAgICAgZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5uYW1lID0ganNvbi5tb3JwaENvbG9yc1sgaSBdLm5hbWU7XG4gICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XG5cbiAgICAgICAgZHN0Q29sb3JzID0gZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnM7XG4gICAgICAgIHNyY0NvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnMgWyBpIF0uY29sb3JzO1xuXG4gICAgICAgIGZvciAoIGMgPSAwLCBjbCA9IHNyY0NvbG9ycy5sZW5ndGg7IGMgPCBjbDsgYyArPSAzICkge1xuXG4gICAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICk7XG4gICAgICAgICAgY29sb3Iuc2V0UkdCKCBzcmNDb2xvcnNbIGMgXSwgc3JjQ29sb3JzWyBjICsgMSBdLCBzcmNDb2xvcnNbIGMgKyAyIF0gKTtcbiAgICAgICAgICBkc3RDb2xvcnMucHVzaCggY29sb3IgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgaWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xuXG4gIH0gZWxzZSB7XG5cbiAgICB2YXIgbWF0ZXJpYWxzID0gdGhpcy5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGggKTtcblxuICAgIGlmICggdGhpcy5uZWVkc1RhbmdlbnRzKCBtYXRlcmlhbHMgKSApIHtcblxuICAgICAgZ2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgdmFyIGxvYWRlZCA9IDAsIHRvdGFsID0gMDtcblxuICB0aGlzLm9uTG9hZCA9IG9uTG9hZDtcbiAgdGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcblxuICB0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG4gICAgdG90YWwgKys7XG5cbiAgfTtcblxuICB0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIGxvYWRlZCArKztcblxuICAgIGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBzY29wZS5vblByb2dyZXNzKCB1cmwsIGxvYWRlZCwgdG90YWwgKTtcblxuICAgIH1cblxuICAgIGlmICggbG9hZGVkID09PSB0b3RhbCAmJiBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgc2NvcGUub25Mb2FkKCk7XG5cbiAgICB9XG5cbiAgfTtcblxufTtcblxuVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG4gIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICAgIG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgIHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplICkgKTtcblxuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0ganNvbi5kYXRhLm9mZnNldHM7XG5cbiAgICBpZiAoIG9mZnNldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZ2VvbWV0cnkub2Zmc2V0cyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBvZmZzZXRzICkgKTtcblxuICAgIH1cblxuICAgIHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuICAgIGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY2VudGVyLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cbiAgICAgIH1cblxuICAgICAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9NYXRlcmlhbExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWxMb2FkZXIsXG5cbiAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgICAgb25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICB9LFxuXG4gIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsganNvbi50eXBlIF07XG5cbiAgICBpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xuICAgIGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG4gICAgaWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcbiAgICBpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcbiAgICBpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcbiAgICBpZiAoIGpzb24uYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYXR0cmlidXRlcyA9IGpzb24uYXR0cmlidXRlcztcbiAgICBpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcbiAgICBpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcbiAgICBpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcbiAgICBpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hhZGluZyA9IGpzb24uc2hhZGluZztcbiAgICBpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcbiAgICBpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcbiAgICBpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcbiAgICBpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcbiAgICBpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcbiAgICBpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcblxuICAgIC8vIGZvciBQb2ludENsb3VkTWF0ZXJpYWxcbiAgICBpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcbiAgICBpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcblxuICAgIGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5wYXJzZSgganNvbi5tYXRlcmlhbHNbIGkgXSApICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBtYXRlcmlhbDtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvT2JqZWN0TG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5PYmplY3RMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG4gIHRoaXMudGV4dHVyZVBhdGggPSAnJztcblxufTtcblxuVEhSRUUuT2JqZWN0TG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0TG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xuXG4gICAgICB0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcblxuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgICAgc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSwgb25Mb2FkICk7XG5cbiAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgfSxcblxuICBzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuICB9LFxuXG4gIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzICk7XG5cbiAgICB2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygganNvbi5pbWFnZXMsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cbiAgICB9ICk7XG5cbiAgICB2YXIgdGV4dHVyZXMgID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcbiAgICB2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKTtcblxuICAgIGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgIGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcblxuICB9LFxuXG4gIHBhcnNlR2VvbWV0cmllczogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICAgIGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgZ2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuSlNPTkxvYWRlcigpO1xuICAgICAgdmFyIGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnk7XG4gICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xuXG4gICAgICAgIHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuICAgICAgICAgIGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxuICAgICAgICAgIGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRVsgZGF0YS50eXBlIF0oXG4gICAgICAgICAgICAgIGRhdGEud2lkdGgsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQm94R2VvbWV0cnknOlxuICAgICAgICAgIGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLndpZHRoLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgZGF0YS5kZXB0aCxcbiAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmRlcHRoU2VnbWVudHNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgIGRhdGEuc2VnbWVudHNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzVG9wLFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1c0JvdHRvbSxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEub3BlbkVuZGVkXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1NwaGVyZUdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEucGhpU3RhcnQsXG4gICAgICAgICAgICAgIGRhdGEucGhpTGVuZ3RoLFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLmRldGFpbFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUb3J1c0dlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgIGRhdGEudHViZSxcbiAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS50dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuYXJjXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLnR1YmUsXG4gICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLnAsXG4gICAgICAgICAgICAgIGRhdGEucSxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTY2FsZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSApLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1RleHRHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS50ZXh0LFxuICAgICAgICAgICAgICBkYXRhLmRhdGFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgIGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBnZW9tZXRyaWVzO1xuXG4gIH0sXG5cbiAgcGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWxzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGdldFRleHR1cmUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcblxuICAgICAgfTtcblxuICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XG4gICAgICAgIHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xuXG4gICAgICAgIG1hdGVyaWFsLnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICAgICAgaWYgKCBkYXRhLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0gZGF0YS5kZXB0aFRlc3Q7XG4gICAgICAgIGlmICggZGF0YS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0gZGF0YS5kZXB0aFdyaXRlO1xuXG4gICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgIGlmICggZGF0YS5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGRhdGEubWFwICk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGRhdGEuYWxwaGFNYXAgKTtcbiAgICAgICAgICBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YS5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZSggZGF0YS5idW1wTWFwICk7XG4gICAgICAgIGlmICggZGF0YS5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGRhdGEuYnVtcFNjYWxlO1xuXG4gICAgICAgIGlmICggZGF0YS5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoIGRhdGEubm9ybWFsTWFwICk7XG4gICAgICAgIGlmICggZGF0YS5ub3JtYWxTY2FsZSApIG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEubm9ybWFsU2NhbGUsIGRhdGEubm9ybWFsU2NhbGUgKTtcblxuICAgICAgICBpZiAoIGRhdGEuc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSggZGF0YS5zcGVjdWxhck1hcCApO1xuXG4gICAgICAgIGlmICggZGF0YS5lbnZNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoIGRhdGEuZW52TWFwICk7XG4gICAgICAgICAgbWF0ZXJpYWwuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGRhdGEucmVmbGVjdGl2aXR5ICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gZGF0YS5yZWZsZWN0aXZpdHk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGRhdGEubGlnaHRNYXAgKTtcbiAgICAgICAgaWYgKCBkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGRhdGEubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IGdldFRleHR1cmUoIGRhdGEuYW9NYXAgKTtcbiAgICAgICAgaWYgKCBkYXRhLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGRhdGEuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgbWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IG1hdGVyaWFsO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0ZXJpYWxzO1xuXG4gIH0sXG5cbiAgcGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB2YXIgaW1hZ2VzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcblxuICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggbWFuYWdlciApO1xuICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICAgIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGltYWdlID0ganNvblsgaSBdO1xuICAgICAgICBpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggaW1hZ2UudXJsICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZXM7XG5cbiAgfSxcblxuICBwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlICkge1xuXG4gICAgICBpZiAoIHR5cGVvZiggdmFsdWUgKSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcblxuICAgICAgcmV0dXJuIFRIUkVFWyB2YWx1ZSBdO1xuXG4gICAgfVxuXG4gICAgdmFyIHRleHR1cmVzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xuXG4gICAgICAgIGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcImltYWdlXCIgc3BlZmljaWVkIGZvcicsIGRhdGEudXVpZCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgdGV4dHVyZS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcgKTtcbiAgICAgICAgaWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5yZXBlYXRbIDAgXSwgZGF0YS5yZXBlYXRbIDEgXSApO1xuICAgICAgICBpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyICk7XG4gICAgICAgIGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcbiAgICAgICAgaWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBkYXRhLndyYXAgKSApIHtcblxuICAgICAgICAgIHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSApO1xuICAgICAgICAgIHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZXM7XG5cbiAgfSxcblxuICBwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cbiAgICAgIHZhciBvYmplY3Q7XG5cbiAgICAgIHZhciBnZXRHZW9tZXRyeSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgICAgICBpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XG5cbiAgICAgIH07XG5cbiAgICAgIHZhciBnZXRNYXRlcmlhbCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xuXG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgY2FzZSAnU2NlbmUnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBbWJpZW50TGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BvaW50TGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTcG90TGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTWVzaCc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTGluZSc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSwgZGF0YS5tb2RlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludENsb3VkJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludENsb3VkKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTcHJpdGUnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnR3JvdXAnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICAgIH1cblxuICAgICAgb2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgIGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuICAgICAgICBtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcbiAgICAgICAgaWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG4gICAgICAgIGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcbiAgICAgIGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcblxuICAgICAgaWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuICAgICAgaWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG4gICAgICBpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgY2hpbGQgaW4gZGF0YS5jaGlsZHJlbiApIHtcblxuICAgICAgICAgIG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGRhdGEuY2hpbGRyZW5bIGNoaWxkIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSgpXG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvVGV4dHVyZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmVMb2FkZXIsXG5cbiAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2UgKTtcbiAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICB9XG5cbiAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQmluYXJ5VGV4dHVyZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgTmlrb3MgTS4gLyBodHRwczovL2dpdGh1Yi5jb20vZm9vMTIzL1xuICpcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZUxvYWRlciA9IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcbiAgdGhpcy5fcGFyc2VyID0gbnVsbDtcblxufTtcblxuVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIsXG5cbiAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggKTtcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG4gICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cbiAgICAgIHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XG5cbiAgICAgIGlmICggIXRleERhdGEgKSByZXR1cm47XG5cbiAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmltYWdlICkge1xuXG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXG4gICAgICB9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG4gICAgICB9XG5cbiAgICAgIHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICAgIHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWFnRmlsdGVyID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG4gICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5mb3JtYXQgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcblxuICAgICAgfVxuICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcblxuICAgICAgICB0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcblxuICAgICAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xuXG4gICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICB9XG5cbiAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cbiAgICByZXR1cm4gdGV4dHVyZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxuICovXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG4gIHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn07XG5cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBpbWFnZXMgPSBbXTtcblxuICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XG4gICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlcztcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG4gICAgaWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuICAgICAgdmFyIGxvYWRlZCA9IDA7XG5cbiAgICAgIHZhciBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggaSApIHtcblxuICAgICAgICBsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG4gICAgICAgICAgdmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XG5cbiAgICAgICAgICBpbWFnZXNbIGkgXSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxuICAgICAgICAgICAgZm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG4gICAgICAgICAgICBtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGxvYWRlZCArPSAxO1xuXG4gICAgICAgICAgaWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cbiAgICAgICAgICAgIGlmICh0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSlcbiAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG4gICAgICAgIGxvYWRUZXh0dXJlKCBpICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuXG4gICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuICAgICAgICBpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcblxuICAgICAgICAgIHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuICAgICAgICAgICAgaW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcblxuICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgICAgICAgIGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgICAgIGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG4gICAgICAgICAgdGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgfSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk1hdGVyaWFsSWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy50eXBlID0gJ01hdGVyaWFsJztcblxuICB0aGlzLnNpZGUgPSBUSFJFRS5Gcm9udFNpZGU7XG5cbiAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG4gIHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcblxuICB0aGlzLmJsZW5kU3JjID0gVEhSRUUuU3JjQWxwaGFGYWN0b3I7XG4gIHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xuICB0aGlzLmJsZW5kRXF1YXRpb24gPSBUSFJFRS5BZGRFcXVhdGlvbjtcbiAgdGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcbiAgdGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcbiAgdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXG4gIHRoaXMuZGVwdGhGdW5jID0gVEhSRUUuTGVzc0VxdWFsRGVwdGg7XG4gIHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcbiAgdGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblxuICB0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xuXG4gIHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cbiAgdGhpcy5hbHBoYVRlc3QgPSAwO1xuXG4gIHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cbiAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXG5cbiAgZ2V0IG5lZWRzVXBkYXRlICgpIHtcblxuICAgIHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuICB9LFxuXG4gIHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgc2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcblxuICAgIGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuICAgICAgaWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBrZXkgaW4gdGhpcyApIHtcblxuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XG5cbiAgICAgICAgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XG5cbiAgICAgICAgICBjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XG5cbiAgICAgICAgICAvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGFibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXG4gICAgICAgICAgdGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICB0eXBlOiAnTWF0ZXJpYWwnLFxuICAgICAgICBnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cbiAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgIGlmICggdGhpcy5jb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgaWYgKCB0aGlzLmVtaXNzaXZlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcbiAgICBpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuICAgIGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cbiAgICBpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMuYWxwaGFNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMubGlnaHRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG4gICAgICBkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgIGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG4gICAgfVxuICAgIGlmICggdGhpcy5ub3JtYWxNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuICAgICAgZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGU7IC8vIFJlbW92ZWQgZm9yIG5vdywgY2F1c2VzIGlzc3VlIGluIGVkaXRvciB1aS5qc1xuICAgIH1cbiAgICBpZiAoIHRoaXMuc3BlY3VsYXJNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcbiAgICAgIGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgIGRhdGEucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7IC8vIFNjYWxlIGJlaGluZCBlbnZNYXBcbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuICAgIGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cbiAgICBpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcbiAgICBpZiAoIHRoaXMuc2hhZGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2hhZGluZyAhPT0gVEhSRUUuU21vb3RoU2hhZGluZyApIGRhdGEuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcbiAgICBpZiAoIHRoaXMuYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuICAgIGlmICggdGhpcy5zaWRlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cbiAgICBpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG4gICAgaWYgKCB0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSApIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cbiAgICByZXR1cm4gZGF0YTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG4gICAgaWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWF0ZXJpYWwoKTtcblxuICAgIG1hdGVyaWFsLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBtYXRlcmlhbC5zaWRlID0gdGhpcy5zaWRlO1xuXG4gICAgbWF0ZXJpYWwub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cbiAgICBtYXRlcmlhbC5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cbiAgICBtYXRlcmlhbC5ibGVuZFNyYyA9IHRoaXMuYmxlbmRTcmM7XG4gICAgbWF0ZXJpYWwuYmxlbmREc3QgPSB0aGlzLmJsZW5kRHN0O1xuICAgIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24gPSB0aGlzLmJsZW5kRXF1YXRpb247XG4gICAgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSA9IHRoaXMuYmxlbmRTcmNBbHBoYTtcbiAgICBtYXRlcmlhbC5ibGVuZERzdEFscGhhID0gdGhpcy5ibGVuZERzdEFscGhhO1xuICAgIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSA9IHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhO1xuXG4gICAgbWF0ZXJpYWwuZGVwdGhGdW5jID0gdGhpcy5kZXB0aEZ1bmM7XG4gICAgbWF0ZXJpYWwuZGVwdGhUZXN0ID0gdGhpcy5kZXB0aFRlc3Q7XG4gICAgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblxuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSB0aGlzLnBvbHlnb25PZmZzZXQ7XG4gICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IHRoaXMucG9seWdvbk9mZnNldEZhY3RvcjtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLnBvbHlnb25PZmZzZXRVbml0cztcblxuICAgIG1hdGVyaWFsLmFscGhhVGVzdCA9IHRoaXMuYWxwaGFUZXN0O1xuXG4gICAgbWF0ZXJpYWwub3ZlcmRyYXcgPSB0aGlzLm92ZXJkcmF3O1xuXG4gICAgbWF0ZXJpYWwudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgIHJldHVybiBtYXRlcmlhbDtcblxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICd1cGRhdGUnIH0gKTtcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLk1hdGVyaWFsSWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXG4gKiAgbGluZWpvaW46IFwicm91bmRcIixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gIHRoaXMubGluZXdpZHRoID0gMTtcbiAgdGhpcy5saW5lY2FwID0gJ3JvdW5kJztcbiAgdGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuICBtYXRlcmlhbC5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcbiAgbWF0ZXJpYWwubGluZWNhcCA9IHRoaXMubGluZWNhcDtcbiAgbWF0ZXJpYWwubGluZWpvaW4gPSB0aGlzLmxpbmVqb2luO1xuXG4gIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gIG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVEYXNoZWRNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBzY2FsZTogPGZsb2F0PixcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcbiAqICBnYXBTaXplOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICB0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy5zY2FsZSA9IDE7XG4gIHRoaXMuZGFzaFNpemUgPSAzO1xuICB0aGlzLmdhcFNpemUgPSAxO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuICBtYXRlcmlhbC5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcblxuICBtYXRlcmlhbC5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gIG1hdGVyaWFsLmRhc2hTaXplID0gdGhpcy5kYXNoU2l6ZTtcbiAgbWF0ZXJpYWwuZ2FwU2l6ZSA9IHRoaXMuZ2FwU2l6ZTtcblxuICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgdGhpcy5hb01hcCA9IG51bGw7XG4gIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsO1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCk7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG4gIG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xuXG4gIG1hdGVyaWFsLmFvTWFwID0gdGhpcy5hb01hcDtcbiAgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSB0aGlzLmFvTWFwSW50ZW5zaXR5O1xuXG4gIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcblxuICBtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cbiAgbWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XG4gIG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XG4gIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuICBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICBtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG4gIG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gIG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcbiAgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaExhbWJlcnRNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIGVtaXNzaXZlOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuICB0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXG4gIHRoaXMubWFwID0gbnVsbDtcblxuICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICB0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICB0aGlzLmVudk1hcCA9IG51bGw7XG4gIHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCk7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuICBtYXRlcmlhbC5lbWlzc2l2ZS5jb3B5KCB0aGlzLmVtaXNzaXZlICk7XG5cbiAgbWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cbiAgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwO1xuXG4gIG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcDtcblxuICBtYXRlcmlhbC5lbnZNYXAgPSB0aGlzLmVudk1hcDtcbiAgbWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcbiAgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XG4gIG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG4gIG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG4gIG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cbiAgbWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cbiAgbWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xuICBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcbiAgbWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxuICogIHNoaW5pbmVzczogPGZsb2F0PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICpcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcbiAgdGhpcy5zcGVjdWxhciA9IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKTtcbiAgdGhpcy5zaGluaW5lc3MgPSAzMDtcblxuICB0aGlzLm1ldGFsID0gZmFsc2U7XG5cbiAgdGhpcy5tYXAgPSBudWxsO1xuXG4gIHRoaXMubGlnaHRNYXAgPSBudWxsO1xuICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gIHRoaXMuYW9NYXAgPSBudWxsO1xuICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gIHRoaXMuYnVtcE1hcCA9IG51bGw7XG4gIHRoaXMuYnVtcFNjYWxlID0gMTtcblxuICB0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG4gIHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gIHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gIHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gIHRoaXMuZW52TWFwID0gbnVsbDtcbiAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG4gIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gIHRoaXMuZm9nID0gdHJ1ZTtcblxuICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG4gIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICB0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG4gIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtcblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcbiAgbWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xuICBtYXRlcmlhbC5zcGVjdWxhci5jb3B5KCB0aGlzLnNwZWN1bGFyICk7XG4gIG1hdGVyaWFsLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXG4gIG1hdGVyaWFsLm1ldGFsID0gdGhpcy5tZXRhbDtcblxuICBtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcblxuICBtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMubGlnaHRNYXA7XG4gIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0gdGhpcy5saWdodE1hcEludGVuc2l0eTtcblxuICBtYXRlcmlhbC5hb01hcCA9IHRoaXMuYW9NYXA7XG4gIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0gdGhpcy5hb01hcEludGVuc2l0eTtcblxuICBtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5idW1wTWFwO1xuICBtYXRlcmlhbC5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcblxuICBtYXRlcmlhbC5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcDtcbiAgbWF0ZXJpYWwubm9ybWFsU2NhbGUuY29weSggdGhpcy5ub3JtYWxTY2FsZSApO1xuXG4gIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcblxuICBtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cbiAgbWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XG4gIG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XG4gIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuICBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICBtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG4gIG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gIG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcbiAgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG4gIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hEZXB0aE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblxuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbDtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTm9ybWFsTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICB0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcblxuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwoKTtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuICBtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEZhY2VNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG4gIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NZXNoRmFjZU1hdGVyaWFsIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIHZhciBtYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFscyApID8gbWF0ZXJpYWxzWyAwIF0gOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoKTtcbiAgbWF0ZXJpYWwubWF0ZXJpYWxzID0gW107IC8vIHRlbXBvcmFsIHdvcmthcm91bmRcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9Qb2ludENsb3VkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc2l6ZTogPGZsb2F0PixcbiAqICBzaXplQXR0ZW51YXRpb246IDxib29sPixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZE1hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gIHRoaXMubWFwID0gbnVsbDtcblxuICB0aGlzLnNpemUgPSAxO1xuICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbDtcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsKCk7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG4gIG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xuXG4gIG1hdGVyaWFsLnNpemUgPSB0aGlzLnNpemU7XG4gIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG4gIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gIG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC4nICk7XG4gIHJldHVybiBuZXcgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC4nICk7XG4gIHJldHVybiBuZXcgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TaGFkZXJNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBkZWZpbmVzOiB7IFwibGFiZWxcIiA6IFwidmFsdWVcIiB9LFxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXG4gKlxuICogIGZyYWdtZW50U2hhZGVyOiA8c3RyaW5nPixcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgbGlnaHRzOiA8Ym9vbD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlNoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xuXG4gIHRoaXMuZGVmaW5lcyA9IHt9O1xuICB0aGlzLnVuaWZvcm1zID0ge307XG4gIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXG4gIHRoaXMudmVydGV4U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufSc7XG4gIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xuXG4gIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgdGhpcy5saW5ld2lkdGggPSAxO1xuXG4gIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICB0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xuXG4gIHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9yczsgLy8gc2V0IHRvIHVzZSBcImNvbG9yXCIgYXR0cmlidXRlIHN0cmVhbVxuXG4gIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xuXG4gIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcblxuICB0aGlzLmRlcml2YXRpdmVzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcblxuICAvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcbiAgLy8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxuICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7XG4gICAgJ2NvbG9yJzogWyAxLCAxLCAxIF0sXG4gICAgJ3V2JzogWyAwLCAwIF0sXG4gICAgJ3V2Mic6IFsgMCwgMCBdXG4gIH07XG5cbiAgdGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xuXG4gIGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgaWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzLicgKTtcbiAgICAgIHBhcmFtZXRlcnMuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgKTtcblxuICAgIH1cblxuICAgIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYWRlck1hdGVyaWFsO1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG4gIGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCk7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuICBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblxuICBtYXRlcmlhbC51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHRoaXMudW5pZm9ybXMgKTtcblxuICBtYXRlcmlhbC5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICBtYXRlcmlhbC5kZWZpbmVzID0gdGhpcy5kZWZpbmVzO1xuXG4gIG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cbiAgbWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gIG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG4gIG1hdGVyaWFsLmxpZ2h0cyA9IHRoaXMubGlnaHRzO1xuXG4gIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gIG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcblxuICBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcbiAgbWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gIGRhdGEuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcbiAgZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9SYXdTaGFkZXJNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG4gIHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XG5cbn07XG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWw7XG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwoKTtcblxuICBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICogIHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcbiAgdGhpcy5tYXAgPSBudWxsO1xuXG4gIHRoaXMucm90YXRpb24gPSAwO1xuXG4gIHRoaXMuZm9nID0gZmFsc2U7XG5cbiAgLy8gc2V0IHBhcmFtZXRlcnNcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZU1hdGVyaWFsO1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuICBtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcblxuICBtYXRlcmlhbC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG5cbiAgbWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLlRleHR1cmVJZENvdW50ICsrIH0gKTtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuICB0aGlzLnNvdXJjZUZpbGUgPSAnJztcblxuICB0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xuICB0aGlzLm1pcG1hcHMgPSBbXTtcblxuICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cbiAgdGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gIHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gIHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gIHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgdGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cbiAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XG4gIHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG4gIHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcbiAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcbiAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG4gIHRoaXMuZmxpcFkgPSB0cnVlO1xuICB0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG4gIHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMub25VcGRhdGUgPSBudWxsO1xuXG59O1xuXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFRIUkVFLlVWTWFwcGluZztcblxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXG5cbiAgZ2V0IG5lZWRzVXBkYXRlICgpIHtcblxuICAgIHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuICB9LFxuXG4gIHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuICAgIGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cbiAgICB0ZXh0dXJlLmltYWdlID0gdGhpcy5pbWFnZTtcbiAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0aGlzLm1pcG1hcHMuc2xpY2UoIDAgKTtcblxuICAgIHRleHR1cmUubWFwcGluZyA9IHRoaXMubWFwcGluZztcblxuICAgIHRleHR1cmUud3JhcFMgPSB0aGlzLndyYXBTO1xuICAgIHRleHR1cmUud3JhcFQgPSB0aGlzLndyYXBUO1xuXG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcbiAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xuXG4gICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuXG4gICAgdGV4dHVyZS5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICB0ZXh0dXJlLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICB0ZXh0dXJlLm9mZnNldC5jb3B5KCB0aGlzLm9mZnNldCApO1xuICAgIHRleHR1cmUucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cbiAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuICAgIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRoaXMucHJlbXVsdGlwbHlBbHBoYTtcbiAgICB0ZXh0dXJlLmZsaXBZID0gdGhpcy5mbGlwWTtcbiAgICB0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IHRoaXMudW5wYWNrQWxpZ25tZW50O1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgcmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xuXG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgdHlwZTogJ1RleHR1cmUnLFxuICAgICAgICBnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcbiAgICAgIH0sXG5cbiAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcblxuICAgICAgbWFwcGluZzogdGhpcy5tYXBwaW5nLFxuXG4gICAgICByZXBlYXQ6IFsgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSBdLFxuICAgICAgb2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcbiAgICAgIHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxuXG4gICAgICBtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxuICAgICAgbWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcbiAgICAgIGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weVxuICAgIH07XG5cbiAgICBpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgLy8gVE9ETzogTW92ZSB0byBUSFJFRS5JbWFnZVxuXG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICBpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBpbWFnZS51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtZXRhLmltYWdlc1sgdGhpcy5pbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuICAgICAgICB2YXIgc3JjO1xuXG4gICAgICAgIGlmICggaW1hZ2Uud2lkdGggPiAyMDQ4IHx8IGltYWdlLmhlaWdodCA+IDIwNDggKSB7XG5cbiAgICAgICAgICBzcmMgPSBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBzcmMgPSBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBtZXRhLmltYWdlc1sgdGhpcy5pbWFnZS51dWlkIF0gPSB7IHV1aWQ6IHRoaXMuaW1hZ2UudXVpZCwgdXJsOiBzcmMgfTtcblxuICAgICAgfVxuXG4gICAgICBvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xuXG4gICAgfVxuXG4gICAgbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3VwZGF0ZScgfSApO1xuXG4gIH0sXG5cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG5USFJFRS5UZXh0dXJlSWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DdWJlVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgbWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cbiAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuXG59O1xuXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViZVRleHR1cmU7XG5cblRIUkVFLkN1YmVUZXh0dXJlLmNsb25lID0gZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG4gIGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSgpO1xuXG4gIFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcblxuICB0ZXh0dXJlLmltYWdlcyA9IHRoaXMuaW1hZ2VzO1xuXG4gIHJldHVybiB0ZXh0dXJlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gIHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgdGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuICAvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuICAvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxuXG4gIHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuICAvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG4gIC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xuXG4gIFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcblxuICByZXR1cm4gdGV4dHVyZTtcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkRhdGFUZXh0dXJlID0gZnVuY3Rpb24gKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XG5cbiAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICB0aGlzLmltYWdlID0geyBkYXRhOiBkYXRhLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cbn07XG5cblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EYXRhVGV4dHVyZTtcblxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCk7XG5cbiAgVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgdGV4dHVyZSApO1xuXG4gIHJldHVybiB0ZXh0dXJlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlZpZGVvVGV4dHVyZSA9IGZ1bmN0aW9uICggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlICk7XG5cbiAgICBpZiAoIHZpZGVvLnJlYWR5U3RhdGUgPT09IHZpZGVvLkhBVkVfRU5PVUdIX0RBVEEgKSB7XG5cbiAgICAgIHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICB9O1xuXG4gIHVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WaWRlb1RleHR1cmU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvR3JvdXAuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkdyb3VwID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXG59O1xuXG5USFJFRS5Hcm91cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkdyb3VwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyb3VwO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1BvaW50Q2xvdWQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlBvaW50Q2xvdWQgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BvaW50Q2xvdWQnO1xuXG4gIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cbn07XG5cblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Qb2ludENsb3VkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50Q2xvdWQ7XG5cblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gIHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgdmFyIG9iamVjdCA9IHRoaXM7XG4gICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICAgIHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50Q2xvdWQudGhyZXNob2xkO1xuXG4gICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIHRlc3RQb2ludCA9IGZ1bmN0aW9uICggcG9pbnQsIGluZGV4ICkge1xuXG4gICAgICB2YXIgcmF5UG9pbnREaXN0YW5jZSA9IHJheS5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XG5cbiAgICAgIGlmICggcmF5UG9pbnREaXN0YW5jZSA8IGxvY2FsVGhyZXNob2xkICkge1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xuICAgICAgICBpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICBkaXN0YW5jZVRvUmF5OiByYXlQb2ludERpc3RhbmNlLFxuICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgIG9iamVjdDogb2JqZWN0XG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgaWYgKCBhdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGNvdW50OiBpbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG9mZnNldHMgPSBbIG9mZnNldCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgb2kgPSAwLCBvbCA9IG9mZnNldHMubGVuZ3RoOyBvaSA8IG9sOyArKyBvaSApIHtcblxuICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbIG9pIF0uc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0c1sgb2kgXS5jb3VudDtcbiAgICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXRzWyBvaSBdLmluZGV4O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBhID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXG4gICAgICAgICAgICB0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBwb2ludENvdW50ID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSArKyApIHtcblxuICAgICAgICAgIHBvc2l0aW9uLnNldChcbiAgICAgICAgICAgIHBvc2l0aW9uc1sgMyAqIGkgXSxcbiAgICAgICAgICAgIHBvc2l0aW9uc1sgMyAqIGkgKyAxIF0sXG4gICAgICAgICAgICBwb3NpdGlvbnNbIDMgKiBpICsgMiBdXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICB0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbn0oKSApO1xuXG5USFJFRS5Qb2ludENsb3VkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRDbG91ZCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5USFJFRS5Qb2ludENsb3VkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBnZW9tZXRyaWVzIGNhY2hlXG4gIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTigpO1xuICB9XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgbWF0ZXJpYWxzIGNhY2hlXG4gIGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oKTtcbiAgfVxuXG4gIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGVTeXN0ZW0gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50Q2xvdWQuJyApO1xuICByZXR1cm4gbmV3IFRIUkVFLlBvaW50Q2xvdWQoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxpbmUgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcblxuICBpZiAoIG1vZGUgPT09IDEgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTGluZTogVEhSRUUuTGluZVBpZWNlcyBtb2RlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XG5cbiAgfVxuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTGluZSc7XG5cbiAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG59O1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcbiAgICB2YXIgcHJlY2lzaW9uU3EgPSBwcmVjaXNpb24gKiBwcmVjaXNpb247XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHtcblxuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgIHZhciB2U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2RW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgaW50ZXJTZWdtZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzdGVwID0gdGhpcyBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgIGlmICggYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgb2Zmc2V0cyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMubGVuZ3RoLCBpbmRleDogMCB9IF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBvaSA9IDA7IG9pIDwgb2Zmc2V0cy5sZW5ndGg7IG9pICsrKSB7XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXRzWyBvaSBdLnN0YXJ0O1xuICAgICAgICAgIHZhciBjb3VudCA9IG9mZnNldHNbIG9pIF0uY291bnQ7XG4gICAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0c1sgb2kgXS5pbmRleDtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50IC0gMTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgICAgICB2YXIgYSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xuICAgICAgICAgICAgdmFyIGIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG5cbiAgICAgICAgICAgIHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcbiAgICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cbiAgICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgLy8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG4gICAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICBvZmZzZXRJbmRleDogb2ksXG4gICAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XG4gICAgICAgICAgdkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XG5cbiAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgICAgaWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgIH0gKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgdmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgIHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICB9ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICBpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFWyB0aGlzLnR5cGUgXSggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBnZW9tZXRyaWVzIGNhY2hlXG4gIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTigpO1xuICB9XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgbWF0ZXJpYWxzIGNhY2hlXG4gIGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oKTtcbiAgfVxuXG4gIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gREVQUkVDQVRFRFxuXG5USFJFRS5MaW5lU3RyaXAgPSAwO1xuVEhSRUUuTGluZVBpZWNlcyA9IDE7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZVNlZ21lbnRzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lU2VnbWVudHMgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG59O1xuXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lU2VnbWVudHM7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cbiAqL1xuXG5USFJFRS5NZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdNZXNoJztcblxuICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cbiAgdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaDtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuXG4gIGlmICggdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtIDE7XG4gICAgdGhpcy5tb3JwaFRhcmdldEZvcmNlZE9yZGVyID0gW107XG4gICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG4gICAgZm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIG0gXS5uYW1lIF0gPSBtO1xuXG4gICAgfVxuXG4gIH1cblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICBpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHJldHVybiB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdO1xuXG4gIH1cblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcblxuICByZXR1cm4gMDtcblxufTtcblxuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgc3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgaWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cbiAgICBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcbiAgICByYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgaWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG4gICAgICBpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgICAgdmFyIGEsIGIsIGM7XG5cbiAgICAgIGlmICggYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgb2Zmc2V0cyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMubGVuZ3RoLCBpbmRleDogMCB9IF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBvaSA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG9pIDwgb2w7ICsrIG9pICkge1xuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0c1sgb2kgXS5zdGFydDtcbiAgICAgICAgICB2YXIgY291bnQgPSBvZmZzZXRzWyBvaSBdLmNvdW50O1xuICAgICAgICAgIHZhciBpbmRleCA9IG9mZnNldHNbIG9pIF0uaW5kZXg7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICBhID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XG4gICAgICAgICAgICBiID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xuICAgICAgICAgICAgYyA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXTtcblxuICAgICAgICAgICAgdkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgICAgICAgICB2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcbiAgICAgICAgICAgIHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkMsIHZCLCB2QSwgdHJ1ZSApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkEsIHZCLCB2QywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uUG9pbnQgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XG5cbiAgICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgICBwb2ludDogaW50ZXJzZWN0aW9uUG9pbnQsXG4gICAgICAgICAgICAgIGZhY2U6IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKSxcbiAgICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzLCBqICs9IDkgKSB7XG5cbiAgICAgICAgICBhID0gaTtcbiAgICAgICAgICBiID0gaSArIDE7XG4gICAgICAgICAgYyA9IGkgKyAyO1xuXG4gICAgICAgICAgdkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGogKTtcbiAgICAgICAgICB2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaiArIDMgKTtcbiAgICAgICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaiArIDYgKTtcblxuICAgICAgICAgIGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkMsIHZCLCB2QSwgdHJ1ZSApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QSwgdkIsIHZDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIGludGVyc2VjdGlvblBvaW50ID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XG5cbiAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICAgICAgZmFjZTogbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApLFxuICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgaXNGYWNlTWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcbiAgICAgIHZhciBvYmplY3RNYXRlcmlhbHMgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IHRoaXMubWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcblxuICAgICAgdmFyIGEsIGIsIGM7XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICBmb3IgKCB2YXIgZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBnZW9tZXRyeS5mYWNlc1sgZiBdO1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gb2JqZWN0TWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IHRoaXMubWF0ZXJpYWw7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICAgICAgYSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICAgICAgYiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcbiAgICAgICAgYyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG4gICAgICAgICAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgICAgICAgdkEuc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgdkIuc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgdkMuc2V0KCAwLCAwLCAwICk7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xuXG4gICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XG5cbiAgICAgICAgICAgIGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XG5cbiAgICAgICAgICAgIHZBLnggKz0gKCB0YXJnZXRzWyBmYWNlLmEgXS54IC0gYS54ICkgKiBpbmZsdWVuY2U7XG4gICAgICAgICAgICB2QS55ICs9ICggdGFyZ2V0c1sgZmFjZS5hIF0ueSAtIGEueSApICogaW5mbHVlbmNlO1xuICAgICAgICAgICAgdkEueiArPSAoIHRhcmdldHNbIGZhY2UuYSBdLnogLSBhLnogKSAqIGluZmx1ZW5jZTtcblxuICAgICAgICAgICAgdkIueCArPSAoIHRhcmdldHNbIGZhY2UuYiBdLnggLSBiLnggKSAqIGluZmx1ZW5jZTtcbiAgICAgICAgICAgIHZCLnkgKz0gKCB0YXJnZXRzWyBmYWNlLmIgXS55IC0gYi55ICkgKiBpbmZsdWVuY2U7XG4gICAgICAgICAgICB2Qi56ICs9ICggdGFyZ2V0c1sgZmFjZS5iIF0ueiAtIGIueiApICogaW5mbHVlbmNlO1xuXG4gICAgICAgICAgICB2Qy54ICs9ICggdGFyZ2V0c1sgZmFjZS5jIF0ueCAtIGMueCApICogaW5mbHVlbmNlO1xuICAgICAgICAgICAgdkMueSArPSAoIHRhcmdldHNbIGZhY2UuYyBdLnkgLSBjLnkgKSAqIGluZmx1ZW5jZTtcbiAgICAgICAgICAgIHZDLnogKz0gKCB0YXJnZXRzWyBmYWNlLmMgXS56IC0gYy56ICkgKiBpbmZsdWVuY2U7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2QS5hZGQoIGEgKTtcbiAgICAgICAgICB2Qi5hZGQoIGIgKTtcbiAgICAgICAgICB2Qy5hZGQoIGMgKTtcblxuICAgICAgICAgIGEgPSB2QTtcbiAgICAgICAgICBiID0gdkI7XG4gICAgICAgICAgYyA9IHZDO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBjLCBiLCBhLCB0cnVlICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYSwgYiwgYywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGludGVyc2VjdGlvblBvaW50ID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICAgIGZhY2U6IGZhY2UsXG4gICAgICAgICAgZmFjZUluZGV4OiBmLFxuICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbn0oKSApO1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cbiAgaWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cbiAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCwgcmVjdXJzaXZlICk7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcbiAgfVxuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCBtZXRhICk7XG4gIH1cblxuICBkYXRhLm9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcbiAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uICggc2tpbiApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0JvbmUnO1xuXG4gIHRoaXMuc2tpbiA9IHNraW47XG5cbn07XG5cblRIUkVFLkJvbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Cb25lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJvbmU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbiA9IGZ1bmN0aW9uICggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICB0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcblxuICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAvLyBjb3B5IHRoZSBib25lIGFycmF5XG5cbiAgYm9uZXMgPSBib25lcyB8fCBbXTtcblxuICB0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblxuICAvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXG5cbiAgaWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG4gICAgLy8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuICAgIC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgICg4ICogOCAgLyA0KVxuICAgIC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKDE2ICogMTYgLyA0KVxuICAgIC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKDMyICogMzIgLyA0KVxuICAgIC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKDY0ICogNjQgLyA0KVxuXG4gICAgdmFyIHNpemU7XG5cbiAgICBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID4gMjU2IClcbiAgICAgIHNpemUgPSA2NDtcbiAgICBlbHNlIGlmICggdGhpcy5ib25lcy5sZW5ndGggPiA2NCApXG4gICAgICBzaXplID0gMzI7XG4gICAgZWxzZSBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID4gMTYgKVxuICAgICAgc2l6ZSA9IDE2O1xuICAgIGVsc2VcbiAgICAgIHNpemUgPSA4O1xuXG4gICAgdGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcbiAgICB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcblxuICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lVGV4dHVyZVdpZHRoICogdGhpcy5ib25lVGV4dHVyZUhlaWdodCAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcbiAgICB0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcbiAgICB0aGlzLmJvbmVUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgdGhpcy5ib25lVGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRoaXMuYm9uZVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgdGhpcy5ib25lVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcblxuICB9XG5cbiAgLy8gdXNlIHRoZSBzdXBwbGllZCBib25lIGludmVyc2VzIG9yIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZXNcblxuICBpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgdGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xuXG4gICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcy5zbGljZSggMCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XG5cbiAgICAgIHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBUSFJFRS5NYXRyaXg0KCkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNhbGN1bGF0ZUludmVyc2VzID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICB2YXIgaW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICBpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcblxuICAgICAgaW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcblxuICAgIH1cblxuICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBib25lO1xuXG4gIC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG4gIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuICAgIGlmICggYm9uZSApIHtcblxuICAgICAgYm9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXG5cbiAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICBib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG4gICAgaWYgKCBib25lICkge1xuXG4gICAgICBpZiAoIGJvbmUucGFyZW50ICkge1xuXG4gICAgICAgIGJvbmUubWF0cml4LmdldEludmVyc2UoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYm9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICB9XG5cbiAgICAgIGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG9mZnNldE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICAgIC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG4gICAgICBvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG4gICAgICBvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICB0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICB9O1xuXG59ICkoKTtcblxuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NraW5uZWRNZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgdGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcblxuICB0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xuICB0aGlzLmJpbmRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAvLyBpbml0IGJvbmVzXG5cbiAgLy8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXG4gIC8vIGNvbnZlbmllbmNlKSBmb3IgVEhSRUUuU2tpbm5lZE1lc2ggdG8gZG8gdGhpcy5cblxuICB2YXIgYm9uZXMgPSBbXTtcblxuICBpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgdmFyIGJvbmUsIGdib25lLCBwLCBxLCBzO1xuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cbiAgICAgIGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgICBwID0gZ2JvbmUucG9zO1xuICAgICAgcSA9IGdib25lLnJvdHE7XG4gICAgICBzID0gZ2JvbmUuc2NsO1xuXG4gICAgICBib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcbiAgICAgIGJvbmVzLnB1c2goIGJvbmUgKTtcblxuICAgICAgYm9uZS5uYW1lID0gZ2JvbmUubmFtZTtcbiAgICAgIGJvbmUucG9zaXRpb24uc2V0KCBwWyAwIF0sIHBbIDEgXSwgcFsgMiBdICk7XG4gICAgICBib25lLnF1YXRlcm5pb24uc2V0KCBxWyAwIF0sIHFbIDEgXSwgcVsgMiBdLCBxWyAzIF0gKTtcblxuICAgICAgaWYgKCBzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgYm9uZS5zY2FsZS5zZXQoIHNbIDAgXSwgc1sgMSBdLCBzWyAyIF0gKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBib25lLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcblxuICAgICAgZ2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cbiAgICAgIGlmICggZ2JvbmUucGFyZW50ICE9PSAtIDEgKSB7XG5cbiAgICAgICAgYm9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGIgXSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuYWRkKCBib25lc1sgYiBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG4gIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcbiAgdGhpcy5iaW5kKCBuZXcgVEhSRUUuU2tlbGV0b24oIGJvbmVzLCB1bmRlZmluZWQsIHVzZVZlcnRleFRleHR1cmUgKSApO1xuXG59O1xuXG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2lubmVkTWVzaDtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cbiAgdGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG4gIGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgYmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cbiAgfVxuXG4gIHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG4gIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG4gIGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuICAgICAgdmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XG5cbiAgICAgIGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG4gICAgICAgIHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIHNraW5uaW5nIHdlaWdodHMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIGZvciBUSFJFRS5CdWZmZXJHZW9tZXRyeVxuXG4gIH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24oIGZvcmNlICkge1xuXG4gIFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcblxuICBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcblxuICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gIH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcblxuICAgIHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVja29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gIGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG4gIH1cblxuICBUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTW9ycGhBbmltTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgdGhpcy50eXBlID0gJ01vcnBoQW5pbU1lc2gnO1xuXG4gIC8vIEFQSVxuXG4gIHRoaXMuZHVyYXRpb24gPSAxMDAwOyAvLyBtaWxsaXNlY29uZHNcbiAgdGhpcy5taXJyb3JlZExvb3AgPSBmYWxzZTtcbiAgdGhpcy50aW1lID0gMDtcblxuICAvLyBpbnRlcm5hbHNcblxuICB0aGlzLmxhc3RLZXlmcmFtZSA9IDA7XG4gIHRoaXMuY3VycmVudEtleWZyYW1lID0gMDtcblxuICB0aGlzLmRpcmVjdGlvbiA9IDE7XG4gIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgdGhpcy5zZXRGcmFtZVJhbmdlKCAwLCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggLSAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhBbmltTWVzaDtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RnJhbWVSYW5nZSA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuICB0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcbiAgdGhpcy5lbmRLZXlmcmFtZSA9IGVuZDtcblxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gMTtcbiAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5kaXJlY3Rpb24gPSAtIDE7XG4gIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgaWYgKCAhIGdlb21ldHJ5LmFuaW1hdGlvbnMgKSBnZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cbiAgdmFyIGZpcnN0QW5pbWF0aW9uLCBhbmltYXRpb25zID0gZ2VvbWV0cnkuYW5pbWF0aW9ucztcblxuICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG4gICAgdmFyIHBhcnRzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG4gICAgaWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG4gICAgICB2YXIgbGFiZWwgPSBwYXJ0c1sgMSBdO1xuXG4gICAgICBpZiAoICEgYW5pbWF0aW9uc1sgbGFiZWwgXSApIGFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cbiAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zWyBsYWJlbCBdO1xuXG4gICAgICBpZiAoIGkgPCBhbmltYXRpb24uc3RhcnQgKSBhbmltYXRpb24uc3RhcnQgPSBpO1xuICAgICAgaWYgKCBpID4gYW5pbWF0aW9uLmVuZCApIGFuaW1hdGlvbi5lbmQgPSBpO1xuXG4gICAgICBpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IGxhYmVsO1xuXG4gICAgfVxuXG4gIH1cblxuICBnZW9tZXRyeS5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25MYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwsIHN0YXJ0LCBlbmQgKSB7XG5cbiAgaWYgKCAhIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyApIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xuXG4gIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBsYWJlbCwgZnBzICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbIGxhYmVsIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICB0aGlzLnNldEZyYW1lUmFuZ2UoIGFuaW1hdGlvbi5zdGFydCwgYW5pbWF0aW9uLmVuZCApO1xuICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwICogKCAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGZwcyApO1xuICAgIHRoaXMudGltZSA9IDA7XG5cbiAgfSBlbHNlIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1vcnBoQW5pbU1lc2g6IGFuaW1hdGlvblsnICsgbGFiZWwgKyAnXSB1bmRlZmluZWQgaW4gLnBsYXlBbmltYXRpb24oKScgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgdmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmxlbmd0aDtcblxuICB0aGlzLnRpbWUgKz0gdGhpcy5kaXJlY3Rpb24gKiBkZWx0YTtcblxuICBpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xuXG4gICAgaWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMudGltZSA8IDAgKSB7XG5cbiAgICAgIHRoaXMuZGlyZWN0aW9uICo9IC0gMTtcblxuICAgICAgaWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMudGltZSA8IDAgKSB7XG5cbiAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLnRpbWUgPSB0aGlzLnRpbWUgJSB0aGlzLmR1cmF0aW9uO1xuXG4gICAgaWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XG5cbiAgfVxuXG4gIHZhciBrZXlmcmFtZSA9IHRoaXMuc3RhcnRLZXlmcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIHRoaXMudGltZSAvIGZyYW1lVGltZSApLCAwLCB0aGlzLmxlbmd0aCAtIDEgKTtcblxuICBpZiAoIGtleWZyYW1lICE9PSB0aGlzLmN1cnJlbnRLZXlmcmFtZSApIHtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMDtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cbiAgICB0aGlzLmxhc3RLZXlmcmFtZSA9IHRoaXMuY3VycmVudEtleWZyYW1lO1xuICAgIHRoaXMuY3VycmVudEtleWZyYW1lID0ga2V5ZnJhbWU7XG5cbiAgfVxuXG4gIHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG4gIGlmICggdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgKSB7XG5cbiAgICBtaXggPSAxIC0gbWl4O1xuXG4gIH1cblxuICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IG1peDtcbiAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAxIC0gbWl4O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAoIGEsIGIsIHQgKSB7XG5cbiAgdmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBpbmZsdWVuY2VzWyBpIF0gPSAwO1xuXG4gIH1cblxuICBpZiAoIGEgPiAtMSApIGluZmx1ZW5jZXNbIGEgXSA9IDEgLSB0O1xuICBpZiAoIGIgPiAtMSApIGluZmx1ZW5jZXNbIGIgXSA9IHQ7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgaWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cbiAgb2JqZWN0LmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgb2JqZWN0Lm1pcnJvcmVkTG9vcCA9IHRoaXMubWlycm9yZWRMb29wO1xuICBvYmplY3QudGltZSA9IHRoaXMudGltZTtcblxuICBvYmplY3QubGFzdEtleWZyYW1lID0gdGhpcy5sYXN0S2V5ZnJhbWU7XG4gIG9iamVjdC5jdXJyZW50S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcblxuICBvYmplY3QuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG4gIG9iamVjdC5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcztcblxuICBUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMub2JqZWN0cyA9IFtdO1xuXG59O1xuXG5cblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XG5cbiAgaWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuXG4gIGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cbiAgZm9yICggdmFyIGwgPSAwOyBsIDwgdGhpcy5vYmplY3RzLmxlbmd0aDsgbCArKyApIHtcblxuICAgIGlmICggZGlzdGFuY2UgPCB0aGlzLm9iamVjdHNbIGwgXS5kaXN0YW5jZSApIHtcblxuICAgICAgYnJlYWs7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMub2JqZWN0cy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XG4gIHRoaXMuYWRkKCBvYmplY3QgKTtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5nZXRPYmplY3RGb3JEaXN0YW5jZSA9IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cbiAgZm9yICggdmFyIGkgPSAxLCBsID0gdGhpcy5vYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBpZiAoIGRpc3RhbmNlIDwgdGhpcy5vYmplY3RzWyBpIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gdGhpcy5vYmplY3RzWyBpIC0gMSBdLm9iamVjdDtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICBtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XG5cbiAgICB0aGlzLmdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApLnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG4gIH07XG5cbn0oKSApO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuICAgIGlmICggdGhpcy5vYmplY3RzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgIHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgICB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgICAgdmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcblxuICAgICAgdGhpcy5vYmplY3RzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBpZiAoIGRpc3RhbmNlID49IHRoaXMub2JqZWN0c1sgaSBdLmRpc3RhbmNlICkge1xuXG4gICAgICAgICAgdGhpcy5vYmplY3RzWyBpIC0gMSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5vYmplY3RzWyBpICAgICBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdGhpcy5vYmplY3RzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbn0oKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTE9EKCk7XG5cbiAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMub2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgIHZhciB4ID0gdGhpcy5vYmplY3RzWyBpIF0ub2JqZWN0LmNsb25lKCk7XG4gICAgeC52aXNpYmxlID0gaSA9PT0gMDtcbiAgICBvYmplY3QuYWRkTGV2ZWwoIHgsIHRoaXMub2JqZWN0c1sgaSBdLmRpc3RhbmNlICk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1Nwcml0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDIsICAwLCAyLCAzIF0gKTtcbiAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtIDAuNSwgLSAwLjUsIDAsICAgMC41LCAtIDAuNSwgMCwgICAwLjUsIDAuNSwgMCwgICAtIDAuNSwgMC41LCAwIF0gKTtcbiAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgMCwgMCwgICAxLCAwLCAgIDEsIDEsICAgMCwgMSBdICk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU3ByaXRlJztcblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xuXG4gIH07XG5cbn0gKSgpO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVRvUG9pbnQoIG1hdHJpeFBvc2l0aW9uICk7XG5cbiAgICBpZiAoIGRpc3RhbmNlID4gdGhpcy5zY2FsZS54ICkge1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgcG9pbnQ6IHRoaXMucG9zaXRpb24sXG4gICAgICBmYWNlOiBudWxsLFxuICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICB9ICk7XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICBpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlNwcml0ZSggdGhpcy5tYXRlcmlhbCApO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG4gIH1cblxuICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGVuc0ZsYXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLmxlbnNGbGFyZXMgPSBbXTtcblxuICB0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuICBpZiAoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGVuc0ZsYXJlO1xuXG5cbi8qXG4gKiBBZGQ6IGFkZHMgYW5vdGhlciBmbGFyZVxuICovXG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xuXG4gIGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcbiAgaWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuICBpZiAoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xuICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcbiAgaWYgKCBibGVuZGluZyA9PT0gdW5kZWZpbmVkICkgYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcblxuICBkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcblxuICB0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xuICAgIHRleHR1cmU6IHRleHR1cmUsICAgICAgIC8vIFRIUkVFLlRleHR1cmVcbiAgICBzaXplOiBzaXplLCAgICAgICAgIC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZSwgICAgIC8vIGRpc3RhbmNlICgwLTEpIGZyb20gbGlnaHQgc291cmNlICgwPWF0IGxpZ2h0IHNvdXJjZSlcbiAgICB4OiAwLCB5OiAwLCB6OiAwLCAgICAgLy8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBvbnRvcCB6ID0gMSBpcyBiYWNrXG4gICAgc2NhbGU6IDEsICAgICAgICAgICAvLyBzY2FsZVxuICAgIHJvdGF0aW9uOiAxLCAgICAgICAgLy8gcm90YXRpb25cbiAgICBvcGFjaXR5OiBvcGFjaXR5LCAgICAgLy8gb3BhY2l0eVxuICAgIGNvbG9yOiBjb2xvciwgICAgICAgLy8gY29sb3JcbiAgICBibGVuZGluZzogYmxlbmRpbmcgICAgICAvLyBibGVuZGluZ1xuICB9ICk7XG5cbn07XG5cbi8qXG4gKiBVcGRhdGUgbGVucyBmbGFyZXMgdXBkYXRlIHBvc2l0aW9ucyBvbiBhbGwgZmxhcmVzIGJhc2VkIG9uIHRoZSBzY3JlZW4gcG9zaXRpb25cbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmLCBmbCA9IHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7XG4gIHZhciBmbGFyZTtcbiAgdmFyIHZlY1ggPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueCAqIDI7XG4gIHZhciB2ZWNZID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xuXG4gIGZvciAoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xuXG4gICAgZmxhcmUueCA9IHRoaXMucG9zaXRpb25TY3JlZW4ueCArIHZlY1ggKiBmbGFyZS5kaXN0YW5jZTtcbiAgICBmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xuXG4gICAgZmxhcmUud2FudGVkUm90YXRpb24gPSBmbGFyZS54ICogTWF0aC5QSSAqIDAuMjU7XG4gICAgZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xuXG4gIH1cblxufTtcblxuXG4vLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNjZW5lID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXG4gIHRoaXMuZm9nID0gbnVsbDtcbiAgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG59O1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNjZW5lO1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICBpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xuXG4gIGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBvYmplY3QuZm9nID0gdGhpcy5mb2cuY2xvbmUoKTtcbiAgaWYgKCB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSBvYmplY3Qub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuXG4gIG9iamVjdC5hdXRvVXBkYXRlID0gdGhpcy5hdXRvVXBkYXRlO1xuICBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRoaXMubWF0cml4QXV0b1VwZGF0ZTtcblxuICByZXR1cm4gb2JqZWN0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRm9nID0gZnVuY3Rpb24gKCBjb2xvciwgbmVhciwgZmFyICkge1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cbiAgdGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xuICB0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XG5cbn07XG5cblRIUkVFLkZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZ0V4cDIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2dFeHAyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVuc2l0eSApIHtcblxuICB0aGlzLm5hbWUgPSAnJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuICB0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XG5cbn07XG5cblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rLmpzXG5cblRIUkVFLlNoYWRlckNodW5rID0ge307XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuICBkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhdGVzdF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGF0ZXN0X2ZyYWdtZW50J10gPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cXG4gIGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcbiAgdG90YWxBbWJpZW50TGlnaHQgKj0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXG4gIHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2J1bXBtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYnVtcG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcbiAgdW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuICAvLyBEZXJpdmF0aXZlIG1hcHMgLSBidW1wIG1hcHBpbmcgdW5wYXJhbWV0cml6ZWQgc3VyZmFjZXMgYnkgTW9ydGVuIE1pa2tlbHNlblxcbiAvLyBodHRwOi8vbW1pa2tlbHNlbjNkLmJsb2dzcG90LnNrLzIwMTEvMDcvZGVyaXZhdGl2ZS1tYXBzLmh0bWxcXG5cXG4gLy8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXFxuXFxuIHZlYzIgZEhkeHlfZndkKCkge1xcblxcbiAgICB2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuICAgdmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcbiAgIGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG4gICAgZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuICAgIGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcbiAgICByZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG4gIH1cXG5cXG4gdmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXG4gICAgdmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG4gICAgdmVjMyB2U2lnbWFZID0gZEZkeSggc3VyZl9wb3MgKTtcXG4gICAgdmVjMyB2TiA9IHN1cmZfbm9ybTsgICAgLy8gbm9ybWFsaXplZFxcblxcbiAgIHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG4gICB2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuICAgZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXG4gICAgdmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxuICAgIHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXG4gIH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gIGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcbiAgdkNvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIGNvbG9yLnh5eiApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbW1vbiddID0gXCIjZGVmaW5lIFBJIDMuMTQxNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG5cXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5cXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcbiAgcmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBub3JtYWwsIDAuMCApICkueHl6ICk7XFxuXFxufVxcblxcbi8vIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvR0xTTF9Qcm9ncmFtbWluZy9BcHBseWluZ19NYXRyaXhfVHJhbnNmb3JtYXRpb25zXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuICByZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIG5vcm1hbCwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG5cXG59XFxuXFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG4gIGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXG5cXG4gIHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXG5cXG59XFxuXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcbiAgcmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG5cXG59XFxuXFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuIHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG5cXG59XFxuXFxuZmxvYXQgY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcbiBpZiAoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXFxuICAgIHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cXG4gfVxcblxcbiByZXR1cm4gMS4wO1xcblxcbn1cXG5cXG52ZWMzIEZfU2NobGljayggaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBpbiBmbG9hdCBkb3RMSCApIHtcXG5cXG4gcmV0dXJuICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogcG93KCAxLjAgLSBkb3RMSCwgNS4wICkgKyBzcGVjdWxhckNvbG9yO1xcblxcbn1cXG5cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGluIGZsb2F0IGRvdE5MLCBpbiBmbG9hdCBkb3ROViAqLyApIHtcXG5cXG4gLy8gZ2VvbWV0cnkgdGVybSBpcyAobuKLhWwpKG7ii4V2KSAvIDQobuKLhWwpKG7ii4V2KVxcblxcbiAgcmV0dXJuIDAuMjU7XFxuXFxufVxcblxcbmZsb2F0IERfQmxpbm5QaG9uZyggaW4gZmxvYXQgc2hpbmluZXNzLCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXG4gLy8gZmFjdG9yIG9mIDEvUEkgaW4gZGlzdHJpYnV0aW9uIHRlcm0gb21pdHRlZFxcblxcbiAgcmV0dXJuICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG5cXG59XFxuXFxudmVjMyBCUkRGX0JsaW5uUGhvbmcoIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgc2hpbmluZXNzLCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBsaWdodERpciwgaW4gdmVjMyB2aWV3RGlyICkge1xcblxcbiAgdmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXG4gLy9mbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcbiAgLy9mbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuIGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG4gZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBsaWdodERpciwgaGFsZkRpciApICk7XFxuXFxuIHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXG4gZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogZG90TkwsIGRvdE5WICovICk7XFxuXFxuICBmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFxuIHJldHVybiBGICogRyAqIEQ7XFxuXFxufVxcblxcbnZlYzMgaW5wdXRUb0xpbmVhciggaW4gdmVjMyBhICkge1xcblxcbiAjaWZkZWYgR0FNTUFfSU5QVVRcXG5cXG4gICAgcmV0dXJuIHBvdyggYSwgdmVjMyggZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cXG4gI2Vsc2VcXG5cXG4gICByZXR1cm4gYTtcXG5cXG4gI2VuZGlmXFxuXFxufVxcblxcbnZlYzMgbGluZWFyVG9PdXRwdXQoIGluIHZlYzMgYSApIHtcXG5cXG4gI2lmZGVmIEdBTU1BX09VVFBVVFxcblxcbiAgIHJldHVybiBwb3coIGEsIHZlYzMoIDEuMCAvIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuICNlbHNlXFxuXFxuICAgcmV0dXJuIGE7XFxuXFxuICNlbmRpZlxcblxcbn1cXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcXG5cXG4gdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XFxuXFxuI2Vsc2VcXG5cXG4gIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXG4jZW5kaWZcXG5cXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0bm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZGVmYXVsdG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiB2ZWMzIG9iamVjdE5vcm1hbCA9IHNraW5uZWROb3JtYWwueHl6O1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9NT1JQSE5PUk1BTFMgKVxcblxcbiB2ZWMzIG9iamVjdE5vcm1hbCA9IG1vcnBoZWROb3JtYWw7XFxuXFxuI2Vsc2VcXG5cXG4gdmVjMyBvYmplY3ROb3JtYWwgPSBub3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIEZMSVBfU0lERURcXG5cXG4gIG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG4gICNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuICAgIHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG4gICAvLyBUcmFuc2Zvcm1pbmcgTm9ybWFsIFZlY3RvcnMgd2l0aCB0aGUgSW52ZXJzZSBUcmFuc2Zvcm1hdGlvblxcbiAgICB2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuICAgI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG4gICAgIHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcbiAgICNlbHNlXFxuXFxuICAgICB2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcbiAgICAjZW5kaWZcXG5cXG4gICNlbHNlXFxuXFxuICAgdmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFxuICNlbmRpZlxcblxcbiAgI2lmZGVmIERPVUJMRV9TSURFRFxcbiAgIGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuICNlbHNlXFxuICAgZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG4gI2VuZGlmXFxuXFxuICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcbiAgIHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuICNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcbiAgICB2ZWMyIHNhbXBsZVVWO1xcbiAgICBzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG4gICBzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuICAgdmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcbiAgI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG4gICB2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSgodmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApKS54eXogKyB2ZWMzKDAuMCwwLjAsMS4wKSk7XFxuICAgIHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG4gICNlbmRpZlxcblxcbiAgZW52Q29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggZW52Q29sb3IueHl6ICk7XFxuXFxuICNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXG4gICBvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuICAjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXG4gICAgb3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuICAjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXG4gICAgb3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcbiAgI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcbiB1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG4gI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG4gICB1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG4gI2Vsc2VcXG4gICB1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuICNlbmRpZlxcbiAgdW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcbiAjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcbiAgICB1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4gICNlbHNlXFxuXFxuICAgdmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcbiAgI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcbiB2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuICB1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG4gIHZlYzMgd29ybGROb3JtYWwgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIG9iamVjdE5vcm1hbCwgbW9kZWxNYXRyaXggKTtcXG5cXG4gdmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcbiAgI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG4gICB2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcbiAgI2Vsc2VcXG5cXG4gICB2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcbiAgI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG4gICAgZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG4gI2Vsc2VcXG5cXG4gICBmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuICAjZW5kaWZcXG5cXG4gICNpZmRlZiBGT0dfRVhQMlxcblxcbiAgIGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICkgKTtcXG5cXG4gICNlbHNlXFxuXFxuICAgZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcblxcbiAjZW5kaWZcXG4gIFxcbiAgb3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG4gdW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcbiAgI2lmZGVmIEZPR19FWFAyXFxuXFxuICAgdW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcbiAjZWxzZVxcblxcbiAgIHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG4gICAgdW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuICNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcbiAgdG90YWxBbWJpZW50TGlnaHQgKz0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuIHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleCddID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcbiAgdW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF92ZXJ0ZXgnXSA9IFwidkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICB2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcbiAgIHZlYzMgbGlnaHRDb2xvciA9IHBvaW50TGlnaHRDb2xvclsgaSBdO1xcblxcbiAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG4gICB2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XFxuICAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG4gICAvLyBhdHRlbnVhdGlvblxcblxcbiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuICAgLy8gZGlmZnVzZVxcblxcbiAgICBmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuICAgdkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICAgICB2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAgI2VuZGlmXFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gIGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICAgdmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICAgdmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG4gICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggbGlnaHRQb3NpdGlvbiwgMS4wICk7XFxuICAgdmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1xcbiAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuICAgZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIG5vcm1hbGl6ZSggbGlnaHRQb3NpdGlvbiAtIHdvcmxkUG9zaXRpb24ueHl6ICkgKTtcXG5cXG4gICAgaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG4gICAgICBzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApICk7XFxuXFxuICAgICAvLyBhdHRlbnVhdGlvblxcblxcbiAgICAgIGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuICAgICBhdHRlbnVhdGlvbiAqPSBzcG90RWZmZWN0O1xcblxcbiAgICAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgICBmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuICAgICB2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcbiAgICAgI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgICAgICB2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAgICAjZW5kaWZcXG5cXG4gICAgfVxcblxcbiB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbiBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICB2ZWMzIGxpZ2h0RGlyID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIHZpZXdNYXRyaXggKTtcXG5cXG4gICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG4gICB2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICAgICB2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuICAgICNlbmRpZlxcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgIHZlYzMgbGlnaHREaXIgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCB2aWV3TWF0cml4ICk7XFxuXFxuICAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcbiAgIGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG4gICB2TGlnaHRGcm9udCArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuICAgI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgICAgZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcbiAgICAgdkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcbiAgICAjZW5kaWZcXG5cXG4gIH1cXG5cXG4jZW5kaWZcXG5cXG52TGlnaHRGcm9udCArPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuIHZMaWdodEJhY2sgKz0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50J10gPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG4gIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFxuICNpZmRlZiBET1VCTEVfU0lERURcXG5cXG4gICBub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcbiAjZW5kaWZcXG5cXG4jZWxzZVxcblxcbiB2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcXG4gdmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7XFxuIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuIG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcbiBub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcbnZlYzMgdG90YWxEaWZmdXNlTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHRvdGFsU3BlY3VsYXJMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICB2ZWMzIGxpZ2h0UG9zaXRpb24gPSBwb2ludExpZ2h0UG9zaXRpb25bIGkgXTtcXG4gICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBsaWdodFBvc2l0aW9uLCAxLjAgKTtcXG4gICB2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcbiAgIC8vIGF0dGVudWF0aW9uXFxuXFxuICAgIGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG4gICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG4gICB0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcbiAgIC8vIHNwZWN1bGFyXFxuXFxuICAgdmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuICAgIHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gIGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICAgdmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICAgdmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG4gICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggbGlnaHRQb3NpdGlvbiwgMS4wICk7XFxuICAgdmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1xcbiAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG4gICBmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBsaWdodFBvc2l0aW9uIC0gdldvcmxkUG9zaXRpb24gKSApO1xcblxcbiAgIGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuICAgICAgc3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcbiAgICAgLy8gYXR0ZW51YXRpb25cXG5cXG4gICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcbiAgICAgYXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG4gICAgICAvLyBkaWZmdXNlXFxuXFxuICAgICAgZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcbiAgICAgdG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG4gICAgIC8vIHNwZWN1bGFyXFxuXFxuICAgICB2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG4gICAgICB0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcbiAgICB9XFxuXFxuIH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuIGZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgIHZlYzMgbGlnaHRDb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdO1xcblxcbiAgIHZlYzMgbGlnaHREaXIgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcbiAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcbiAgIHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcbiAgIC8vIHNwZWN1bGFyXFxuXFxuICAgdmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuICAgIHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuICBmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0RGlyID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcbiAgICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG4gICBmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuICAgdmVjMyBsaWdodENvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcbiAgICB0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yO1xcblxcbiAgICAvLyBzcGVjdWxhciAoc2t5IHRlcm0gb25seSlcXG5cXG4gICB2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG4gICAgdG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1FVEFMXFxuXFxuIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICogc3BlY3VsYXIgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyBlbWlzc2l2ZTtcXG5cXG4jZWxzZVxcblxcbiAgb3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIHRvdGFsQW1iaWVudExpZ2h0ICkgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyBlbWlzc2l2ZTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuIHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuICB1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcbiAgdW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG4gdW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuIHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4gdW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbiAgdW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGVjYXlbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiAgdW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcbiAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG4gdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQnXSA9IFwiXFxuICBvdXRnb2luZ0xpZ2h0ID0gbGluZWFyVG9PdXRwdXQoIG91dGdvaW5nTGlnaHQgKTtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRikgJiYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUZfRVhUKVxcblxcbiAgZ2xfRnJhZ0RlcHRoRVhUID0gbG9nMih2RnJhZ0RlcHRoKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcbiB1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuICAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcbiAgICAjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXFxuICAgdmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcbiAjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG4gI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG4gICAgdmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcbiAjZW5kaWZcXG5cXG4gIHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcbiAgZ2xfUG9zaXRpb24ueiA9IGxvZzIobWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkpICogbG9nRGVwdGhCdWZGQztcXG5cXG4gICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuICAgIHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcbiNlbHNlXFxuXFxuICAgIGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcbiAgI2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuICB2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFxuICB0ZXhlbENvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIHRleGVsQ29sb3IueHl6ICk7XFxuXFxuIGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcbiBkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKCBtYXAsIHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICkgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHkgKTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuICB1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaG5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBobm9ybWFsX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcbiB2ZWMzIG1vcnBoZWROb3JtYWwgPSB2ZWMzKCAwLjAgKTtcXG5cXG4gbW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuICBtb3JwaGVkTm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG4gIG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcbiAgbW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuICBtb3JwaGVkTm9ybWFsICs9IG5vcm1hbDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuICAjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG4gIHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFxuICNlbHNlXFxuXFxuIHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFxuICNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcbiB2ZWMzIG1vcnBoZWQgPSB2ZWMzKCAwLjAgKTtcXG4gbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuICBtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXG4gICNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuICBtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXG4gICNlbmRpZlxcblxcbiAgbW9ycGhlZCArPSBwb3NpdGlvbjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG4gIHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXG5cXG4gLy8gUGVyLVBpeGVsIFRhbmdlbnQgU3BhY2UgTm9ybWFsIE1hcHBpbmdcXG4gLy8gaHR0cDovL2hhY2tzb2ZsaWZlLmJsb2dzcG90LmNoLzIwMDkvMTEvcGVyLXBpeGVsLXRhbmdlbnQtc3BhY2Utbm9ybWFsLW1hcHBpbmcuaHRtbFxcblxcbiB2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcbiAgICB2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG4gICAgdmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuICAgIHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuICAgIHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuICAgIHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG4gICAgdmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG4gICB2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcblxcbiAgICB2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcbiAgICBtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcbiAgICBtYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXG4gICByZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxuXFxuIH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gICNpZmRlZiBTSEFET1dNQVBfREVCVUdcXG5cXG4gICAgdmVjMyBmcnVzdHVtQ29sb3JzWzNdO1xcbiAgICBmcnVzdHVtQ29sb3JzWzBdID0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1xcbiAgIGZydXN0dW1Db2xvcnNbMV0gPSB2ZWMzKCAwLjAsIDEuMCwgMC44ICk7XFxuICAgZnJ1c3R1bUNvbG9yc1syXSA9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcXG5cXG4gI2VuZGlmXFxuXFxuICAjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcXG5cXG4gICAgaW50IGluRnJ1c3R1bUNvdW50ID0gMDtcXG5cXG4gI2VuZGlmXFxuXFxuICBmbG9hdCBmRGVwdGg7XFxuIHZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG5cXG4gZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcXG5cXG4gICAgICAgLy8gaWYgKCBzb21ldGhpbmcgJiYgc29tZXRoaW5nICkgYnJlYWtzIEFUSSBPcGVuR0wgc2hhZGVyIGNvbXBpbGVyXFxuICAgICAgICAvLyBpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApIHVzaW5nIHRoaXMgaW5zdGVhZFxcblxcbiAgICBidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuICAgIGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG4gICAgICAgLy8gZG9uJ3Qgc2hhZG93IHBpeGVscyBvdXRzaWRlIG9mIGxpZ2h0IGZydXN0dW1cXG4gICAgICAgLy8gdXNlIGp1c3QgZmlyc3QgZnJ1c3R1bSAoZm9yIGNhc2NhZGVzKVxcbiAgICAgICAgLy8gZG9uJ3Qgc2hhZG93IHBpeGVscyBiZWhpbmQgZmFyIHBsYW5lIG9mIGxpZ2h0IGZydXN0dW1cXG5cXG4gICAgI2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuICAgICAgaW5GcnVzdHVtQ291bnQgKz0gaW50KCBpbkZydXN0dW0gKTtcXG4gICAgIGJ2ZWMzIGZydXN0dW1UZXN0VmVjID0gYnZlYzMoIGluRnJ1c3R1bSwgaW5GcnVzdHVtQ291bnQgPT0gMSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXG4gICAjZWxzZVxcblxcbiAgICAgYnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcbiAgICAjZW5kaWZcXG5cXG4gICAgYm9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXG4gICBpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcbiAgICAgIHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcbiAgICAgI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFxuICAgICAgICAgICAvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcbiAgICAgICAgICAgLy8gKDkgcGl4ZWwga2VybmVsKVxcbiAgICAgICAgICAgLy8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcbiAgICAgICAgZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcbiAgIC8qXFxuICAgICAgICAgICAgLy8gbmVzdGVkIGxvb3BzIGJyZWFrcyBzaGFkZXIgY29tcGlsZXIgLyB2YWxpZGF0b3Igb24gc29tZSBBVEkgY2FyZHMgd2hlbiB1c2luZyBPcGVuR0xcXG4gICAgICAgICAgICAvLyBtdXN0IGVucm9sbCBsb29wIG1hbnVhbGx5XFxuXFxuICAgICAgICBmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcXG4gICAgICAgICBmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblxcbiAgICAgICAgICAgdmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IHNlZW0gdG8gcHJvZHVjZSBhbnkgbm90aWNlYWJsZSB2aXN1YWwgZGlmZmVyZW5jZSBjb21wYXJlZCB0byBzaW1wbGUgdGV4dHVyZTJEIGxvb2t1cFxcbiAgICAgICAgICAgICAgIC8vdmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkRQcm9qKCBzaGFkb3dNYXBbIGkgXSwgdmVjNCggdlNoYWRvd0Nvb3JkWyBpIF0udyAqICggdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKSwgMC4wNSwgdlNoYWRvd0Nvb3JkWyBpIF0udyApICk7XFxuXFxuICAgICAgICAgICBmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuICAgICAgICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG4gICAgICAgICAgICAgc2hhZG93ICs9IDEuMDtcXG5cXG4gICAgICAgIH1cXG5cXG4gICAgICAgc2hhZG93IC89IDkuMDtcXG5cXG4gICAgKi9cXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IHNoYWRvd0RlbHRhID0gMS4wIC8gOS4wO1xcblxcbiAgICAgICAgZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuICAgICAgICBmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG4gICAgICAgIGZsb2F0IGR4MCA9IC0xLjI1ICogeFBpeGVsT2Zmc2V0O1xcbiAgICAgICBmbG9hdCBkeTAgPSAtMS4yNSAqIHlQaXhlbE9mZnNldDtcXG4gICAgICAgZmxvYXQgZHgxID0gMS4yNSAqIHhQaXhlbE9mZnNldDtcXG4gICAgICAgIGZsb2F0IGR5MSA9IDEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG4gICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG4gICAgICNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXG4gICAgICAgICAgICAvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcbiAgICAgICAgICAgLy8gKDkgcGl4ZWwga2VybmVsKVxcbiAgICAgICAgICAgLy8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcbiAgICAgICAgZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcbiAgICAgICBmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG4gICAgICAgIGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcbiAgICAgICAgZmxvYXQgZHgwID0gLTEuMCAqIHhQaXhlbE9mZnNldDtcXG4gICAgICAgIGZsb2F0IGR5MCA9IC0xLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuICAgICAgICBmbG9hdCBkeDEgPSAxLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuICAgICAgIGZsb2F0IGR5MSA9IDEuMCAqIHlQaXhlbE9mZnNldDtcXG5cXG4gICAgICAgbWF0MyBzaGFkb3dLZXJuZWw7XFxuICAgICAgICBtYXQzIGRlcHRoS2VybmVsO1xcblxcbiAgICAgICBkZXB0aEtlcm5lbFswXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMF1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzBdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFsxXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMV1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcbiAgICAgICBkZXB0aEtlcm5lbFsxXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMl1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzJdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFsyXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblxcbiAgICAgICAgdmVjMyBzaGFkb3daID0gdmVjMyggc2hhZG93Q29vcmQueiApO1xcbiAgICAgICBzaGFkb3dLZXJuZWxbMF0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzBdLCBzaGFkb3daICkpO1xcbiAgICAgICBzaGFkb3dLZXJuZWxbMF0gKj0gdmVjMygwLjI1KTtcXG5cXG4gICAgICAgIHNoYWRvd0tlcm5lbFsxXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMV0sIHNoYWRvd1ogKSk7XFxuICAgICAgIHNoYWRvd0tlcm5lbFsxXSAqPSB2ZWMzKDAuMjUpO1xcblxcbiAgICAgICAgc2hhZG93S2VybmVsWzJdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFsyXSwgc2hhZG93WiApKTtcXG4gICAgICAgc2hhZG93S2VybmVsWzJdICo9IHZlYzMoMC4yNSk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbaV0ueHkgKTtcXG5cXG4gICAgICAgc2hhZG93S2VybmVsWzBdID0gbWl4KCBzaGFkb3dLZXJuZWxbMV0sIHNoYWRvd0tlcm5lbFswXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG4gICAgICAgc2hhZG93S2VybmVsWzFdID0gbWl4KCBzaGFkb3dLZXJuZWxbMl0sIHNoYWRvd0tlcm5lbFsxXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cXG4gICAgICAgdmVjNCBzaGFkb3dWYWx1ZXM7XFxuICAgICAgICBzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuICAgICAgICBzaGFkb3dWYWx1ZXMueSA9IG1peCggc2hhZG93S2VybmVsWzBdWzJdLCBzaGFkb3dLZXJuZWxbMF1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuICAgICAgICBzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWzFdWzFdLCBzaGFkb3dLZXJuZWxbMV1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuICAgICAgICBzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFxuICAgICAgICBzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKTtcXG5cXG4gICAgICAgIHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1xcblxcbiAgICAgI2Vsc2VcXG5cXG4gICAgICAgdmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApO1xcbiAgICAgICBmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuICAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblxcbiAgIC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGlzIGRhcmtlclxcblxcbiAgICAgICAgIHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICk7XFxuXFxuICAgIC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGhhcyB0aGUgc2FtZSBjb2xvciBhcyBzaW5nbGUgc2hhZG93IHNwb3RcXG5cXG4gICAgLy8gICAgICAgICAgc2hhZG93Q29sb3IgPSBtaW4oIHNoYWRvd0NvbG9yLCB2ZWMzKCBzaGFkb3dEYXJrbmVzc1sgaSBdICkgKTtcXG5cXG4gICAgICAjZW5kaWZcXG5cXG4gICAgfVxcblxcblxcbiAgICNpZmRlZiBTSEFET1dNQVBfREVCVUdcXG5cXG4gICAgICAjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcXG5cXG4gICAgICAgIGlmICggaW5GcnVzdHVtICYmIGluRnJ1c3R1bUNvdW50ID09IDEgKSBvdXRnb2luZ0xpZ2h0ICo9IGZydXN0dW1Db2xvcnNbIGkgXTtcXG5cXG4gICAgICAjZWxzZVxcblxcbiAgICAgICBpZiAoIGluRnJ1c3R1bSApIG91dGdvaW5nTGlnaHQgKj0gZnJ1c3R1bUNvbG9yc1sgaSBdO1xcblxcbiAgICAgI2VuZGlmXFxuXFxuICAgICNlbmRpZlxcblxcbiAgfVxcblxcbiAvLyBOT1RFOiBJIGFtIHVuc3VyZSBpZiB0aGlzIGlzIGNvcnJlY3QgaW4gbGluZWFyIHNwYWNlLiAgLWJob3VzdG9uLCBEZWMgMjksIDIwMTRcXG4gc2hhZG93Q29sb3IgPSBpbnB1dFRvTGluZWFyKCBzaGFkb3dDb2xvciApO1xcblxcbiBvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqIHNoYWRvd0NvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1xcbiB1bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTUFYX1NIQURPV1MgXTtcXG5cXG4gIHVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XFxuICB1bmlmb3JtIGZsb2F0IHNoYWRvd0JpYXNbIE1BWF9TSEFET1dTIF07XFxuXFxuICB2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblxcbiBmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1xcblxcbiAgIGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG4gICAgZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1xcbiAgIHJldHVybiBkZXB0aDtcXG5cXG4gfVxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcbiB2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcbiB1bmlmb3JtIG1hdDQgc2hhZG93TWF0cml4WyBNQVhfU0hBRE9XUyBdO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuICBmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcbiAgIHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcbiAgfVxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2luYmFzZV92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5iYXNlX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuICBtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG4gbWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuIG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcbiBtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gdW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxuICB1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFxuICNpZmRlZiBCT05FX1RFWFRVUkVcXG5cXG4gICB1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG4gICAgdW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG4gICB1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXG4gICAgbWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcbiAgICAgIGZsb2F0IGogPSBpICogNC4wO1xcbiAgICAgIGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG4gICAgICBmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFxuICAgICBmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuICAgICBmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcblxcbiAgICAgIHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcbiAgICAgdmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG4gICAgICB2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuICAgICAgdmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcbiAgICAgIG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFxuICAgICByZXR1cm4gYm9uZTtcXG5cXG4gICAgfVxcblxcbiAjZWxzZVxcblxcbiAgIHVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcblxcbiAgIG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG4gICAgICBtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcbiAgICAgcmV0dXJuIGJvbmU7XFxuXFxuICAgIH1cXG5cXG4gI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gICNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuIHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcXG5cXG4gICNlbHNlXFxuXFxuIHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuICNlbmRpZlxcblxcbiAgdmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuIHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcbiAgc2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuICBza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG4gIHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcbiAgc2tpbm5lZCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5ub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubm9ybWFsX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuICBtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG4gIHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuICBza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcbiAgc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG4gIHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuICBza2luTWF0cml4ICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxuXFxuICAjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcbiB2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbW9ycGhlZE5vcm1hbCwgMC4wICk7XFxuXFxuICNlbHNlXFxuXFxuIHZlYzQgc2tpbm5lZE5vcm1hbCA9IHNraW5NYXRyaXggKiB2ZWM0KCBub3JtYWwsIDAuMCApO1xcblxcbiAgI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9mcmFnbWVudCddID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcblxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG4gdmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuIHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxuXFxuI2Vsc2VcXG5cXG4gIHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcbiAgdmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcbiAgYXR0cmlidXRlIHZlYzIgdXYyO1xcbiB2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG4gdlV2MiA9IHV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc19mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFxuIHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFxuIHZhcnlpbmcgdmVjMiB2VXY7XFxuIHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXG4gIHZVdiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay93b3JsZHBvc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3dvcmxkcG9zX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXG5cXG4gI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXG4gI2VsaWYgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApXFxuXFxuICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcXG5cXG4gICNlbHNlXFxuXFxuICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzXG5cbi8qKlxuICogVW5pZm9ybSBVdGlsaXRpZXNcbiAqL1xuXG5USFJFRS5Vbmlmb3Jtc1V0aWxzID0ge1xuXG4gIG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xuXG4gICAgdmFyIG1lcmdlZCA9IHt9O1xuXG4gICAgZm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xuXG4gICAgICB2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xuXG4gICAgICBmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XG5cbiAgICAgICAgbWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcblxuICAgIHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcblxuICAgIGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcblxuICAgICAgdW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcblxuICAgICAgZm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XG5cbiAgICAgICAgdmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yIHx8XG4gICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyIHx8XG4gICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzIHx8XG4gICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0IHx8XG4gICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXgzIHx8XG4gICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0IHx8XG4gICAgICAgICAgIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XG5cbiAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3Jtc19kc3Q7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qc1xuXG4vKipcbiAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNMaWIgPSB7XG5cbiAgY29tbW9uOiB7XG5cbiAgICBcImRpZmZ1c2VcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcbiAgICBcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblxuICAgIFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcblxuICAgIFwic3BlY3VsYXJNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJhbHBoYU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuICAgIFwiZW52TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwiZmxpcEVudk1hcFwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9LFxuICAgIFwicmVmbGVjdGl2aXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG4gICAgXCJyZWZyYWN0aW9uUmF0aW9cIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH1cblxuICB9LFxuXG4gIGFvbWFwOiB7XG5cbiAgICBcImFvTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwiYW9NYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cbiAgfSxcblxuICBsaWdodG1hcDoge1xuXG4gICAgXCJsaWdodE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcImxpZ2h0TWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG4gIH0sXG5cbiAgYnVtcDoge1xuXG4gICAgXCJidW1wTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwiYnVtcFNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9XG5cbiAgfSxcblxuICBub3JtYWxtYXA6IHtcblxuICAgIFwibm9ybWFsTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwibm9ybWFsU2NhbGVcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9XG4gIH0sXG5cbiAgZm9nIDoge1xuXG4gICAgXCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxuICAgIFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcbiAgICBcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcbiAgICBcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cblxuICB9LFxuXG4gIGxpZ2h0czoge1xuXG4gICAgXCJhbWJpZW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG4gICAgXCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJkaXJlY3Rpb25hbExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblxuICAgIFwiaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwiaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblxuICAgIFwicG9pbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJwb2ludExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcbiAgICBcInBvaW50TGlnaHREaXN0YW5jZVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcbiAgICBcInBvaW50TGlnaHREZWNheVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcblxuICAgIFwic3BvdExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNwb3RMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNwb3RMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuICAgIFwic3BvdExpZ2h0QW5nbGVDb3NcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHRFeHBvbmVudFwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNwb3RMaWdodERlY2F5XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9XG5cbiAgfSxcblxuICBwYXJ0aWNsZToge1xuXG4gICAgXCJwc0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG4gICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG4gICAgXCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG4gICAgXCJzY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuICAgIFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcblxuICAgIFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcbiAgICBcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgXCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXG4gICAgXCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XG5cbiAgfSxcblxuICBzaGFkb3dtYXA6IHtcblxuICAgIFwic2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYydlwiLCB2YWx1ZTogW10gfSxcblxuICAgIFwic2hhZG93Qmlhc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNoYWRvd0RhcmtuZXNzXCI6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInNoYWRvd01hdHJpeFwiIDogeyB0eXBlOiBcIm00dlwiLCB2YWx1ZTogW10gfVxuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliLmpzXG5cbi8qKlxuICogV2ViZ2wgU2hhZGVyIExpYnJhcnkgZm9yIHRocmVlLmpzXG4gKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblxuVEhSRUUuU2hhZGVyTGliID0ge1xuXG4gICdiYXNpYyc6IHtcblxuICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxuXG4gICAgXSApLFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiAjaWZkZWYgVVNFX0VOVk1BUFwiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiAjZW5kaWZcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG4gICAgICBcIiB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcbiAgICAgIFwiIHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSB2ZWMzKCAxLjAgKTtcIiwgLy8gaGFyZHdpcmVkXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogdG90YWxBbWJpZW50TGlnaHQ7XCIsIC8vIHNpbXBsZSBzaGFkZXJcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLCAgICAvLyBUT0RPOiBTaGFkb3dzIG9uIGFuIG90aGVyd2lzZSB1bmxpdCBzdXJmYWNlIGRvZXNuJ3QgbWFrZSBzZW5zZS5cblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsIC8vIFRPRE8sIHRoaXMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIHRvIGFsbG93IGZvciBicmlnaHQgaGlnaGxpZ2h0cyBvbiB2ZXJ5IHRyYW5zcGFyZW50IG9iamVjdHNcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgJ2xhbWJlcnQnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG4gICAgICB7XG4gICAgICAgIFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfVxuICAgICAgfVxuXG4gICAgXSApLFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwiI2RlZmluZSBMQU1CRVJUXCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG4gICAgICBcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgXCIgdmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXG5cbiAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgXCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgXCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXG5cbiAgICAgIFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG4gICAgICBcIiB2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcblxuICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiB2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIiwgLy8gb3V0Z29pbmcgbGlnaHQgZG9lcyBub3QgaGF2ZSBhbiBhbHBoYSwgdGhlIHN1cmZhY2UgZG9lc1xuICAgICAgXCIgdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiAjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cbiAgICAgICAgICAvL1wiZmxvYXQgaXNGcm9udCA9IGZsb2F0KCBnbF9Gcm9udEZhY2luZyApO1wiLFxuICAgICAgICAgIC8vXCJnbF9GcmFnQ29sb3IueHl6ICo9IGlzRnJvbnQgKiB2TGlnaHRGcm9udCArICggMS4wIC0gaXNGcm9udCApICogdkxpZ2h0QmFjaztcIixcblxuICAgICAgXCIgICBpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcbiAgICAgIFwiICAgICBvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiB2TGlnaHRGcm9udCArIGVtaXNzaXZlO1wiLFxuICAgICAgXCIgICBlbHNlXCIsXG4gICAgICBcIiAgICAgb3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0QmFjayArIGVtaXNzaXZlO1wiLFxuXG4gICAgICBcIiAjZWxzZVwiLFxuXG4gICAgICBcIiAgIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqIHZMaWdodEZyb250ICsgZW1pc3NpdmU7XCIsXG5cbiAgICAgIFwiICNlbmRpZlwiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLCAvLyBUT0RPLCB0aGlzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCB0byBhbGxvdyBmb3IgYnJpZ2h0IGhpZ2hsaWdodHMgb24gdmVyeSB0cmFuc3BhcmVudCBvYmplY3RzXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIilcblxuICB9LFxuXG4gICdwaG9uZyc6IHtcblxuICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodG1hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cbiAgICAgIHtcbiAgICAgICAgXCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9LFxuICAgICAgICBcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXG4gICAgICAgIFwic2hpbmluZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAzMCB9XG4gICAgICB9XG5cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXG5cbiAgICAgIFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxuXG4gICAgICBcIiB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiNpZm5kZWYgRkxBVF9TSEFERURcIiwgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxuXG4gICAgICBcIiB2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxuXG4gICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCIgdlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXG5cbiAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcbiAgICAgIFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsIC8vIG91dGdvaW5nIGxpZ2h0IGRvZXMgbm90IGhhdmUgYW4gYWxwaGEsIHRoZSBzdXJmYWNlIGRvZXNcbiAgICAgIFwiIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuICAgICAgXCIgdmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodENvbG9yO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIiwgLy8gVE9ETywgdGhpcyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgdG8gYWxsb3cgZm9yIGJyaWdodCBoaWdobGlnaHRzIG9uIHZlcnkgdHJhbnNwYXJlbnQgb2JqZWN0c1xuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbiAgfSxcblxuICAncGFydGljbGVfYmFzaWMnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwYXJ0aWNsZVwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXG5cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNpemU7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgIFwiICNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXG4gICAgICBcIiAgIGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXG4gICAgICBcIiAjZWxzZVwiLFxuICAgICAgXCIgICBnbF9Qb2ludFNpemUgPSBzaXplO1wiLFxuICAgICAgXCIgI2VuZGlmXCIsXG5cbiAgICAgIFwiIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gdmVjMyBwc0NvbG9yO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsIC8vIG91dGdvaW5nIGxpZ2h0IGRvZXMgbm90IGhhdmUgYW4gYWxwaGEsIHRoZSBzdXJmYWNlIGRvZXNcbiAgICAgIFwiIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggcHNDb2xvciwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIiwgLy8gc2ltcGxlIHNoYWRlclxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsIC8vIFRPRE8sIHRoaXMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIHRvIGFsbG93IGZvciBicmlnaHQgaGlnaGxpZ2h0cyBvbiB2ZXJ5IHRyYW5zcGFyZW50IG9iamVjdHNcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgJ2Rhc2hlZCc6IHtcblxuICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXG4gICAgICB7XG4gICAgICAgIFwic2NhbGVcIiAgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgIFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgIFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cbiAgICAgIH1cblxuICAgIF0gKSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG4gICAgICBcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiB2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgIFwiIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcbiAgICAgIFwiIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IGRhc2hTaXplO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcIixcblxuICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgaWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XCIsXG5cbiAgICAgIFwiICAgZGlzY2FyZDtcIixcblxuICAgICAgXCIgfVwiLFxuXG4gICAgICBcIiB2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIiwgLy8gb3V0Z29pbmcgbGlnaHQgZG9lcyBub3QgaGF2ZSBhbiBhbHBoYSwgdGhlIHN1cmZhY2UgZG9lc1xuICAgICAgXCIgdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIiwgLy8gVE9ETywgdGhpcyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgdG8gYWxsb3cgZm9yIGJyaWdodCBoaWdobGlnaHRzIG9uIHZlcnkgdHJhbnNwYXJlbnQgb2JqZWN0c1xuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbiAgfSxcblxuICAnZGVwdGgnOiB7XG5cbiAgICB1bmlmb3Jtczoge1xuXG4gICAgICBcIm1OZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcbiAgICAgIFwibUZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAuMCB9LFxuICAgICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuICAgIH0sXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cbiAgICAgIFwiICAgZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcIixcblxuICAgICAgXCIgI2Vsc2VcIixcblxuICAgICAgXCIgICBmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cbiAgICAgIFwiICNlbmRpZlwiLFxuXG4gICAgICBcIiBmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLCAgIC8vIFRPRE8sIHRoaXMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIHRvIGFsbG93IGZvciBicmlnaHQgaGlnaGxpZ2h0cyBvbiB2ZXJ5IHRyYW5zcGFyZW50IG9iamVjdHNcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgJ25vcm1hbCc6IHtcblxuICAgIHVuaWZvcm1zOiB7XG5cbiAgICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cbiAgICB9LFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiB2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcbiAgICAgIFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuNSAqIG5vcm1hbGl6ZSggdk5vcm1hbCApICsgMC41LCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbiAgfSxcblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vICBDdWJlIG1hcCBzaGFkZXJcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAnY3ViZSc6IHtcblxuICAgIHVuaWZvcm1zOiB7IFwidEN1YmVcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICBcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSB9LFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxuXG4gICAgICBcIiBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbiAgfSxcblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vICBDdWJlIG1hcCBzaGFkZXJcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAnZXF1aXJlY3QnOiB7XG5cbiAgICB1bmlmb3JtczogeyBcInRFcXVpcmVjdFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgIFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9IH0sXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiB2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXG5cbiAgICAgIFwiIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIC8vIFwiICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxuICAgICAgICBcInZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1wiLFxuICAgICAgICBcInZlYzIgc2FtcGxlVVY7XCIsXG4gICAgICAgIFwic2FtcGxlVVYueSA9IHNhdHVyYXRlKCB0RmxpcCAqIGRpcmVjdGlvbi55ICogLTAuNSArIDAuNSApO1wiLFxuICAgICAgICBcInNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1wiLFxuICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgLyogRGVwdGggZW5jb2RpbmcgaW50byBSR0JBIHRleHR1cmVcbiAgICpcbiAgICogYmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXG4gICAqIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxuICAgKlxuICAgKiBvcmlnaW5hbGx5IGZyb21cbiAgICogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcbiAgICpcbiAgICogc2VlIGFsc29cbiAgICogaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXG4gICAqL1xuXG4gICdkZXB0aFJHQkEnOiB7XG5cbiAgICB1bmlmb3Jtczoge30sXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG5cbiAgICAgIFwiIGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXG4gICAgICBcIiBjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXG4gICAgICBcIiB2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLCAvLyBcIiAgdmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcbiAgICAgIFwiIHJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxuICAgICAgXCIgcmV0dXJuIHJlcztcIixcblxuICAgICAgXCJ9XCIsXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuICAgICAgXCIgICBnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXG5cbiAgICAgIFwiICNlbHNlXCIsXG5cbiAgICAgIFwiICAgZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXG5cbiAgICAgIFwiICNlbmRpZlwiLFxuXG4gICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApO1wiLFxuICAgICAgICAvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXG4gICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggeiApO1wiLFxuICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHZlYzQoIHosIHosIHosIDEuMCApO1wiLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJlci5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcicsIFRIUkVFLlJFVklTSU9OICk7XG5cbiAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgdmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxuICBfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcblxuICBfd2lkdGggPSBfY2FudmFzLndpZHRoLFxuICBfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXG5cbiAgcGl4ZWxSYXRpbyA9IDEsXG5cbiAgX3ByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXG5cbiAgX2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxuICBfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcbiAgX3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG4gIF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcbiAgX3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG4gIF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcbiAgX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlLFxuXG4gIF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxuICBfY2xlYXJBbHBoYSA9IDA7XG5cbiAgdmFyIGxpZ2h0cyA9IFtdO1xuXG4gIHZhciBvcGFxdWVPYmplY3RzID0gW107XG4gIHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcblxuICB2YXIgc3ByaXRlcyA9IFtdO1xuICB2YXIgbGVuc0ZsYXJlcyA9IFtdO1xuXG4gIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cbiAgdGhpcy5kb21FbGVtZW50ID0gX2NhbnZhcztcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAvLyBjbGVhcmluZ1xuXG4gIHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgdGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG4gIHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xuICB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xuXG4gIC8vIHNjZW5lIGdyYXBoXG5cbiAgdGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cbiAgLy8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXG5cbiAgdGhpcy5nYW1tYUZhY3RvciA9IDIuMDsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xuICB0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cbiAgLy8gbW9ycGhzXG5cbiAgdGhpcy5tYXhNb3JwaFRhcmdldHMgPSA4O1xuICB0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XG5cbiAgLy8gZmxhZ3NcblxuICB0aGlzLmF1dG9TY2FsZUN1YmVtYXBzID0gdHJ1ZTtcblxuICAvLyBpbmZvXG5cbiAgdGhpcy5pbmZvID0ge1xuXG4gICAgbWVtb3J5OiB7XG5cbiAgICAgIHByb2dyYW1zOiAwLFxuICAgICAgZ2VvbWV0cmllczogMCxcbiAgICAgIHRleHR1cmVzOiAwXG5cbiAgICB9LFxuXG4gICAgcmVuZGVyOiB7XG5cbiAgICAgIGNhbGxzOiAwLFxuICAgICAgdmVydGljZXM6IDAsXG4gICAgICBmYWNlczogMCxcbiAgICAgIHBvaW50czogMFxuXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG4gIHZhciBfdGhpcyA9IHRoaXMsXG5cbiAgX3Byb2dyYW1zID0gW10sXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcblxuICBfY3VycmVudFByb2dyYW0gPSBudWxsLFxuICBfY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbCxcbiAgX2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxuICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxuICBfY3VycmVudENhbWVyYSA9IG51bGwsXG5cbiAgX3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxuXG4gIF92aWV3cG9ydFggPSAwLFxuICBfdmlld3BvcnRZID0gMCxcbiAgX3ZpZXdwb3J0V2lkdGggPSBfY2FudmFzLndpZHRoLFxuICBfdmlld3BvcnRIZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcbiAgX2N1cnJlbnRXaWR0aCA9IDAsXG4gIF9jdXJyZW50SGVpZ2h0ID0gMCxcblxuICAvLyBmcnVzdHVtXG5cbiAgX2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxuXG4gICAvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcblxuICBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cbiAgX3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gIC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG4gIF9kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcblxuICBfbGlnaHRzID0ge1xuXG4gICAgYW1iaWVudDogWyAwLCAwLCAwIF0sXG4gICAgZGlyZWN0aW9uYWw6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6W10sIHBvc2l0aW9uczogW10gfSxcbiAgICBwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10sIGRlY2F5czogW10gfSxcbiAgICBzcG90OiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSwgZGlzdGFuY2VzOiBbXSwgZGlyZWN0aW9uczogW10sIGFuZ2xlc0NvczogW10sIGV4cG9uZW50czogW10sIGRlY2F5czogW10gfSxcbiAgICBoZW1pOiB7IGxlbmd0aDogMCwgc2t5Q29sb3JzOiBbXSwgZ3JvdW5kQ29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9XG5cbiAgfTtcblxuICAvLyBpbml0aWFsaXplXG5cbiAgdmFyIF9nbDtcblxuICB0cnkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICBhbHBoYTogX2FscGhhLFxuICAgICAgZGVwdGg6IF9kZXB0aCxcbiAgICAgIHN0ZW5jaWw6IF9zdGVuY2lsLFxuICAgICAgYW50aWFsaWFzOiBfYW50aWFsaWFzLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgfTtcblxuICAgIF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcblxuICAgIGlmICggX2dsID09PSBudWxsICkge1xuXG4gICAgICBpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJykgIT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgcmVzZXRHTFN0YXRlKCk7XG4gICAgICBzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG4gICAgICBvYmplY3RzLm9iamVjdHMgPSB7fTtcblxuICAgIH0sIGZhbHNlKTtcblxuICB9IGNhdGNoICggZXJyb3IgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yICk7XG5cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBUSFJFRS5XZWJHTFN0YXRlKCBfZ2wsIHBhcmFtVGhyZWVUb0dMICk7XG5cbiAgaWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAncmFuZ2VNaW4nOiAxLFxuICAgICAgICAncmFuZ2VNYXgnOiAxLFxuICAgICAgICAncHJlY2lzaW9uJzogMVxuICAgICAgfTtcblxuICAgIH1cblxuICB9XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSBuZXcgVEhSRUUuV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcbiAgdmFyIG9iamVjdHMgPSBuZXcgVEhSRUUuV2ViR0xPYmplY3RzKCBfZ2wsIHRoaXMuaW5mbyApO1xuXG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuICBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgaWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDQyOTQ5NjcyOTY7XG5cbiAgfVxuXG4gIGlmICggX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cbiAgICBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xuXG4gIH1cblxuICAvL1xuXG4gIHZhciBnbENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIHIsIGcsIGIsIGEgKSB7XG5cbiAgICBpZiAoIF9wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XG5cbiAgICAgIHIgKj0gYTsgZyAqPSBhOyBiICo9IGE7XG5cbiAgICB9XG5cbiAgICBfZ2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuXG4gIH07XG5cbiAgdmFyIHNldERlZmF1bHRHTFN0YXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2dsLmNsZWFyQ29sb3IoIDAsIDAsIDAsIDEgKTtcbiAgICBfZ2wuY2xlYXJEZXB0aCggMSApO1xuICAgIF9nbC5jbGVhclN0ZW5jaWwoIDAgKTtcblxuICAgIF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XG4gICAgX2dsLmRlcHRoRnVuYyggX2dsLkxFUVVBTCApO1xuXG4gICAgX2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcbiAgICBfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICBfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcbiAgICBfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XG4gICAgX2dsLmJsZW5kRnVuYyggX2dsLlNSQ19BTFBIQSwgX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgIF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG4gICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gIH07XG5cbiAgdmFyIHJlc2V0R0xTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG4gICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcbiAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cbiAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBzdGF0ZS5yZXNldCgpO1xuXG4gIH07XG5cbiAgc2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuICB0aGlzLmNvbnRleHQgPSBfZ2w7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAvLyBzaGFkb3cgbWFwXG5cbiAgdmFyIHNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFNoYWRvd01hcCggdGhpcywgbGlnaHRzLCBvYmplY3RzICk7XG5cbiAgdGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG5cbiAgLy8gR1BVIGNhcGFiaWxpdGllc1xuXG4gIHZhciBfbWF4VGV4dHVyZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcbiAgdmFyIF9tYXhWZXJ0ZXhUZXh0dXJlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcbiAgdmFyIF9tYXhUZXh0dXJlU2l6ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVEVYVFVSRV9TSVpFICk7XG4gIHZhciBfbWF4Q3ViZW1hcFNpemUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xuXG4gIHZhciBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IF9tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG4gIHZhciBfc3VwcG9ydHNCb25lVGV4dHVyZXMgPSBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuICB2YXIgX3N1cHBvcnRzSW5zdGFuY2VkQXJyYXlzID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gIC8vXG5cbiAgdmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5ISUdIX0ZMT0FUICk7XG4gIHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcblxuICB2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5ISUdIX0ZMT0FUICk7XG4gIHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25NZWRpdW1wRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuTUVESVVNX0ZMT0FUICk7XG5cbiAgdmFyIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9ICggZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFycmF5O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCBhcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcblxuICAgICAgfVxuXG4gICAgICBhcnJheSA9IFtdO1xuXG4gICAgICBpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgKSB7XG5cbiAgICAgICAgdmFyIGZvcm1hdHMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgIGFycmF5LnB1c2goIGZvcm1hdHNbIGkgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9O1xuXG4gIH0gKSgpO1xuXG4gIC8vIGNsYW1wIHByZWNpc2lvbiB0byBtYXhpbXVtIGF2YWlsYWJsZVxuXG4gIHZhciBoaWdocEF2YWlsYWJsZSA9IF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdC5wcmVjaXNpb24gPiAwO1xuICB2YXIgbWVkaXVtcEF2YWlsYWJsZSA9IF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25NZWRpdW1wRmxvYXQucHJlY2lzaW9uID4gMCAmJiBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25NZWRpdW1wRmxvYXQucHJlY2lzaW9uID4gMDtcblxuICBpZiAoIF9wcmVjaXNpb24gPT09ICdoaWdocCcgJiYgISBoaWdocEF2YWlsYWJsZSApIHtcblxuICAgIGlmICggbWVkaXVtcEF2YWlsYWJsZSApIHtcblxuICAgICAgX3ByZWNpc2lvbiA9ICdtZWRpdW1wJztcbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGhpZ2hwIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIG1lZGl1bXAuJyApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgX3ByZWNpc2lvbiA9ICdsb3dwJztcbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGhpZ2hwIGFuZCBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3AuJyApO1xuXG4gICAgfVxuXG4gIH1cblxuICBpZiAoIF9wcmVjaXNpb24gPT09ICdtZWRpdW1wJyAmJiAhIG1lZGl1bXBBdmFpbGFibGUgKSB7XG5cbiAgICBfcHJlY2lzaW9uID0gJ2xvd3AnO1xuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IG1lZGl1bXAgbm90IHN1cHBvcnRlZCwgdXNpbmcgbG93cC4nICk7XG5cbiAgfVxuXG4gIC8vIFBsdWdpbnNcblxuICB2YXIgc3ByaXRlUGx1Z2luID0gbmV3IFRIUkVFLlNwcml0ZVBsdWdpbiggdGhpcywgc3ByaXRlcyApO1xuICB2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xuXG4gIC8vIEFQSVxuXG4gIHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfZ2w7XG5cbiAgfTtcblxuICB0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKS5sb3NlQ29udGV4dCgpO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0luc3RhbmNlZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfc3VwcG9ydHNJbnN0YW5jZWRBcnJheXM7XG5cbiAgfTtcblxuICB0aGlzLnN1cHBvcnRzRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cbiAgfTtcblxuICB0aGlzLnN1cHBvcnRzQmxlbmRNaW5NYXggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdmFsdWU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuICAgICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgdmFsdWUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH1cblxuICB9ICkoKTtcblxuICB0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfcHJlY2lzaW9uO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHBpeGVsUmF0aW87XG5cbiAgfTtcblxuICB0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcGl4ZWxSYXRpbyA9IHZhbHVlO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICB9O1xuXG4gIH07XG5cbiAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcblxuICAgIF93aWR0aCA9IHdpZHRoO1xuICAgIF9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBfY2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgIF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblxuICAgIGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xuXG4gICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gIH07XG5cbiAgdGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgIF92aWV3cG9ydFggPSB4ICogcGl4ZWxSYXRpbztcbiAgICBfdmlld3BvcnRZID0geSAqIHBpeGVsUmF0aW87XG5cbiAgICBfdmlld3BvcnRXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICBfdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXG4gICAgX2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cbiAgfTtcblxuICB0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBfZ2wuc2Npc3NvcihcbiAgICAgIHggKiBwaXhlbFJhdGlvLFxuICAgICAgeSAqIHBpeGVsUmF0aW8sXG4gICAgICB3aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICBoZWlnaHQgKiBwaXhlbFJhdGlvXG4gICAgKTtcblxuICB9O1xuXG4gIHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGVuYWJsZSApIHtcblxuICAgIGVuYWJsZSA/IF9nbC5lbmFibGUoIF9nbC5TQ0lTU09SX1RFU1QgKSA6IF9nbC5kaXNhYmxlKCBfZ2wuU0NJU1NPUl9URVNUICk7XG5cbiAgfTtcblxuICAvLyBDbGVhcmluZ1xuXG4gIHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfY2xlYXJDb2xvcjtcblxuICB9O1xuXG4gIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG4gICAgX2NsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xuXG4gICAgX2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xuXG4gICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIF9jbGVhckFscGhhO1xuXG4gIH07XG5cbiAgdGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCBhbHBoYSApIHtcblxuICAgIF9jbGVhckFscGhhID0gYWxwaGE7XG5cbiAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgfTtcblxuICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cbiAgICB2YXIgYml0cyA9IDA7XG5cbiAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuICAgIGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG4gICAgaWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcblxuICAgIF9nbC5jbGVhciggYml0cyApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2dsLmNsZWFyKCBfZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2dsLmNsZWFyKCBfZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBfZ2wuY2xlYXIoIF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKTtcblxuICB9O1xuXG4gIHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuICAgIHRoaXMuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xuXG4gIH07XG5cbiAgLy8gUmVzZXRcblxuICB0aGlzLnJlc2V0R0xTdGF0ZSA9IHJlc2V0R0xTdGF0ZTtcblxuICAvLyBFdmVudHNcblxuICB2YXIgb25UZXh0dXJlRGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICB2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuICAgIHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xuXG4gICAgX3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgLS07XG5cblxuICB9O1xuXG4gIHZhciBvblJlbmRlclRhcmdldERpc3Bvc2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgIHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcblxuICB9O1xuXG4gIHZhciBvbk1hdGVyaWFsRGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XG5cbiAgICBtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgfTtcblxuICAvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXG5cbiAgdmFyIGRlYWxsb2NhdGVUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG4gICAgaWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgICAvLyBjdWJlIHRleHR1cmVcblxuICAgICAgX2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICAgIGRlbGV0ZSB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIDJEIHRleHR1cmVcblxuICAgICAgaWYgKCB0ZXh0dXJlLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgIGRlbGV0ZSB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlO1xuICAgICAgZGVsZXRlIHRleHR1cmUuX193ZWJnbEluaXQ7XG5cbiAgICB9XG5cbiAgfTtcblxuICB2YXIgZGVhbGxvY2F0ZVJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgaWYgKCAhIHJlbmRlclRhcmdldCB8fCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIF9nbC5kZWxldGVUZXh0dXJlKCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIGRlbGV0ZSByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmU7XG5cbiAgICBpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgICAgICBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuICAgICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuICAgICAgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgIH1cblxuICAgIGRlbGV0ZSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyO1xuICAgIGRlbGV0ZSByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlcjtcblxuICB9O1xuXG4gIHZhciBkZWFsbG9jYXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG4gICAgdmFyIHByb2dyYW0gPSBtYXRlcmlhbC5wcm9ncmFtLnByb2dyYW07XG5cbiAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBvbmx5IGRlYWxsb2NhdGUgR0wgcHJvZ3JhbSBpZiB0aGlzIHdhcyB0aGUgbGFzdCB1c2Ugb2Ygc2hhcmVkIHByb2dyYW1cbiAgICAvLyBhc3N1bWVkIHRoZXJlIGlzIG9ubHkgc2luZ2xlIGNvcHkgb2YgYW55IHByb2dyYW0gaW4gdGhlIF9wcm9ncmFtcyBsaXN0XG4gICAgLy8gKHRoYXQncyBob3cgaXQncyBjb25zdHJ1Y3RlZClcblxuICAgIHZhciBpLCBpbCwgcHJvZ3JhbUluZm87XG4gICAgdmFyIGRlbGV0ZVByb2dyYW0gPSBmYWxzZTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IF9wcm9ncmFtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgcHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIGkgXTtcblxuICAgICAgaWYgKCBwcm9ncmFtSW5mby5wcm9ncmFtID09PSBwcm9ncmFtICkge1xuXG4gICAgICAgIHByb2dyYW1JbmZvLnVzZWRUaW1lcyAtLTtcblxuICAgICAgICBpZiAoIHByb2dyYW1JbmZvLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuICAgICAgICAgIGRlbGV0ZVByb2dyYW0gPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBkZWxldGVQcm9ncmFtID09PSB0cnVlICkge1xuXG4gICAgICAvLyBhdm9pZCB1c2luZyBhcnJheS5zcGxpY2UsIHRoaXMgaXMgY29zdGxpZXIgdGhhbiBjcmVhdGluZyBuZXcgYXJyYXkgZnJvbSBzY3JhdGNoXG5cbiAgICAgIHZhciBuZXdQcm9ncmFtcyA9IFtdO1xuXG4gICAgICBmb3IgKCBpID0gMCwgaWwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgcHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIGkgXTtcblxuICAgICAgICBpZiAoIHByb2dyYW1JbmZvLnByb2dyYW0gIT09IHByb2dyYW0gKSB7XG5cbiAgICAgICAgICBuZXdQcm9ncmFtcy5wdXNoKCBwcm9ncmFtSW5mbyApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBfcHJvZ3JhbXMgPSBuZXdQcm9ncmFtcztcblxuICAgICAgX2dsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgX3RoaXMuaW5mby5tZW1vcnkucHJvZ3JhbXMgLS07XG5cbiAgICB9XG5cbiAgfTtcblxuICAvLyBCdWZmZXIgcmVuZGVyaW5nXG5cbiAgdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgaWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgKSBvYmplY3QuX193ZWJnbE5vcm1hbEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBvYmplY3QuX193ZWJnbFV2QnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBvYmplY3QuX193ZWJnbENvbG9yQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cbiAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIH1cblxuICAgIGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XG5cbiAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPT09IGZhbHNlICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xuXG4gICAgICAgIHZhciBueCwgbnksIG56LFxuICAgICAgICAgIG5heCwgbmJ4LCBuY3gsIG5heSwgbmJ5LCBuY3ksIG5heiwgbmJ6LCBuY3osXG4gICAgICAgICAgbm9ybWFsQXJyYXksXG4gICAgICAgICAgaSwgaWwgPSBvYmplY3QuY291bnQgKiAzO1xuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuICAgICAgICAgIG5vcm1hbEFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xuXG4gICAgICAgICAgbmF4ID0gbm9ybWFsQXJyYXlbIGkgXTtcbiAgICAgICAgICBuYXkgPSBub3JtYWxBcnJheVsgaSArIDEgXTtcbiAgICAgICAgICBuYXogPSBub3JtYWxBcnJheVsgaSArIDIgXTtcblxuICAgICAgICAgIG5ieCA9IG5vcm1hbEFycmF5WyBpICsgMyBdO1xuICAgICAgICAgIG5ieSA9IG5vcm1hbEFycmF5WyBpICsgNCBdO1xuICAgICAgICAgIG5ieiA9IG5vcm1hbEFycmF5WyBpICsgNSBdO1xuXG4gICAgICAgICAgbmN4ID0gbm9ybWFsQXJyYXlbIGkgKyA2IF07XG4gICAgICAgICAgbmN5ID0gbm9ybWFsQXJyYXlbIGkgKyA3IF07XG4gICAgICAgICAgbmN6ID0gbm9ybWFsQXJyYXlbIGkgKyA4IF07XG5cbiAgICAgICAgICBueCA9ICggbmF4ICsgbmJ4ICsgbmN4ICkgLyAzO1xuICAgICAgICAgIG55ID0gKCBuYXkgKyBuYnkgKyBuY3kgKSAvIDM7XG4gICAgICAgICAgbnogPSAoIG5heiArIG5ieiArIG5jeiApIC8gMztcblxuICAgICAgICAgIG5vcm1hbEFycmF5WyBpICAgICBdID0gbng7XG4gICAgICAgICAgbm9ybWFsQXJyYXlbIGkgKyAxIF0gPSBueTtcbiAgICAgICAgICBub3JtYWxBcnJheVsgaSArIDIgXSA9IG56O1xuXG4gICAgICAgICAgbm9ybWFsQXJyYXlbIGkgKyAzIF0gPSBueDtcbiAgICAgICAgICBub3JtYWxBcnJheVsgaSArIDQgXSA9IG55O1xuICAgICAgICAgIG5vcm1hbEFycmF5WyBpICsgNSBdID0gbno7XG5cbiAgICAgICAgICBub3JtYWxBcnJheVsgaSArIDYgXSA9IG54O1xuICAgICAgICAgIG5vcm1hbEFycmF5WyBpICsgNyBdID0gbnk7XG4gICAgICAgICAgbm9ybWFsQXJyYXlbIGkgKyA4IF0gPSBuejtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XG5cbiAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcblxuICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgKTtcbiAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcblxuICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIH1cblxuICAgIGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xuXG4gICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuICAgICAgX2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cbiAgICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xuXG4gICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgfVxuXG4gICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgIF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuICAgIG9iamVjdC5jb3VudCA9IDA7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcblxuICAgIHZhciBleHRlbnNpb247XG5cbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgaWYgKCBwcm9ncmFtQXR0cmlidXRlID49IDAgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgdmFyIHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5QXR0cmlidXRlLmRhdGEuYnVmZmVyICk7XG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XG5cbiAgICAgICAgICAgIGlmICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xuXG4gICAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlICk7XG5cbiAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiAoIGRhdGEuYXJyYXkubGVuZ3RoIC8gZGF0YS5zdHJpZGUgKTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUF0dHJpYnV0ZS5idWZmZXIgKTtcbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggcHJvZ3JhbUF0dHJpYnV0ZSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqICggZ2VvbWV0cnlBdHRyaWJ1dGUuYXJyYXkubGVuZ3RoIC8gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemUgKTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xuICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgc3dpdGNoICggdmFsdWUubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliMmZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliNGZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjFmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICB9XG5cbiAgdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0cy5nZW9tZXRyaWVzLmdldCggb2JqZWN0ICk7XG4gICAgdmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICB2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlLFxuICAgICAgd2lyZWZyYW1lQml0ID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gMSA6IDAsXG4gICAgICBnZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeS5pZCArICdfJyArIHByb2dyYW0uaWQgKyAnXycgKyB3aXJlZnJhbWVCaXQ7XG5cbiAgICBpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XG5cbiAgICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xuICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgIHJlbmRlck1lc2goIG1hdGVyaWFsLCBnZW9tZXRyeSwgb2JqZWN0LCBwcm9ncmFtLCB1cGRhdGVCdWZmZXJzICk7XG5cbiAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG4gICAgICByZW5kZXJMaW5lKCBtYXRlcmlhbCwgZ2VvbWV0cnksIG9iamVjdCwgcHJvZ3JhbSwgdXBkYXRlQnVmZmVycyApO1xuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCApIHtcblxuICAgICAgcmVuZGVyUG9pbnRDbG91ZCggbWF0ZXJpYWwsIGdlb21ldHJ5LCBvYmplY3QsIHByb2dyYW0sIHVwZGF0ZUJ1ZmZlcnMgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbmRlck1lc2goIG1hdGVyaWFsLCBnZW9tZXRyeSwgb2JqZWN0LCBwcm9ncmFtLCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgdmFyIG1vZGUgPSBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgPyBfZ2wuTElORVMgOiBfZ2wuVFJJQU5HTEVTO1xuXG4gICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleDtcblxuICAgIGlmICggaW5kZXggKSB7XG5cbiAgICAgIC8vIGluZGV4ZWQgdHJpYW5nbGVzXG5cbiAgICAgIHZhciB0eXBlLCBzaXplO1xuXG4gICAgICBpZiAoIGluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG4gICAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuICAgICAgICBzaXplID0gNDtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICBzaXplID0gMjtcblxuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcbiAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcblxuICAgICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyTWVzaDogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXh0ZW5zaW9uLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBpbmRleC5hcnJheS5sZW5ndGgsIHR5cGUsIDAsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7IC8vIERyYXcgdGhlIGluc3RhbmNlZCBtZXNoZXNcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwICk7XG5cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gaW5kZXguYXJyYXkubGVuZ3RoOyAvLyBub3QgcmVhbGx5IHRydWUsIGhlcmUgdmVydGljZXMgY2FuIGJlIHNoYXJlZFxuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyArPSBpbmRleC5hcnJheS5sZW5ndGggLyAzO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxIGNodW5rXG4gICAgICAgIC8vIG11c3Qgc2V0IGF0dHJpYnV0ZSBwb2ludGVycyB0byB1c2UgbmV3IG9mZnNldHMgZm9yIGVhY2ggY2h1bmtcbiAgICAgICAgLy8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcblxuICAgICAgICB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gb2Zmc2V0c1sgaSBdLmluZGV4O1xuXG4gICAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApO1xuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZW5kZXIgaW5kZXhlZCB0cmlhbmdsZXNcblxuICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBvZmZzZXRzW2ldLmluc3RhbmNlcyA+IDAgKSB7XG5cbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlck1lc2g6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgb2Zmc2V0c1tpXS5jb3VudCwgdHlwZSwgb2Zmc2V0c1tpXS5zdGFydCAqIHNpemUsIG9mZnNldHNbaV0uY291bnQsIHR5cGUsIG9mZnNldHNbaV0uaW5zdGFuY2VzICk7IC8vIERyYXcgdGhlIGluc3RhbmNlZCBtZXNoZXNcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIG9mZnNldHNbIGkgXS5jb3VudCwgdHlwZSwgb2Zmc2V0c1sgaSBdLnN0YXJ0ICogc2l6ZSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50OyAvLyBub3QgcmVhbGx5IHRydWUsIGhlcmUgdmVydGljZXMgY2FuIGJlIHNoYXJlZFxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudCAvIDM7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBub24taW5kZXhlZCB0cmlhbmdsZXNcblxuICAgICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xuXG4gICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgLy8gcmVuZGVyIG5vbi1pbmRleGVkIHRyaWFuZ2xlc1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XG5cbiAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlck1lc2g6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggcG9zaXRpb24gaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uZGF0YS5hcnJheS5sZW5ndGggLyBwb3NpdGlvbi5kYXRhLnN0cmlkZSwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTsgLy8gRHJhdyB0aGUgaW5zdGFuY2VkIG1lc2hlc1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gcG9zaXRpb24uaXRlbVNpemUsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7IC8vIERyYXcgdGhlIGluc3RhbmNlZCBtZXNoZXNcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgMCwgcG9zaXRpb24uZGF0YS5hcnJheS5sZW5ndGggLyBwb3NpdGlvbi5kYXRhLnN0cmlkZSApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgX2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIHBvc2l0aW9uLml0ZW1TaXplICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzKys7XG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIHBvc2l0aW9uLml0ZW1TaXplO1xuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyArPSBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAoIDMgKiBwb3NpdGlvbi5pdGVtU2l6ZSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxIGNodW5rXG4gICAgICAgIC8vIG11c3Qgc2V0IGF0dHJpYnV0ZSBwb2ludGVycyB0byB1c2UgbmV3IG9mZnNldHMgZm9yIGVhY2ggY2h1bmtcbiAgICAgICAgLy8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcblxuICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG4gICAgICAgICAgLy8gcmVuZGVyIG5vbi1pbmRleGVkIHRyaWFuZ2xlc1xuXG4gICAgICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXJNZXNoOiBjYW5ub3QgdXNlIGRyYXdDYWxscyB3aXRoIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCBvZmZzZXRzWyBpIF0uc3RhcnQsIG9mZnNldHNbIGkgXS5jb3VudCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMrKztcbiAgICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBvZmZzZXRzWyBpIF0uY291bnQ7XG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gKCBvZmZzZXRzWyBpIF0uY291bnQgICkgLyAzO1xuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckxpbmUoIG1hdGVyaWFsLCBnZW9tZXRyeSwgb2JqZWN0LCBwcm9ncmFtLCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgdmFyIG1vZGUgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyBfZ2wuTElORVMgOiBfZ2wuTElORV9TVFJJUDtcblxuICAgIC8vIEluIGNhc2UgdXNlciBpcyBub3QgdXNpbmcgTGluZSpNYXRlcmlhbCBieSBtaXN0YWtlXG4gICAgdmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwubGluZXdpZHRoIDogMTtcblxuICAgIHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogcGl4ZWxSYXRpbyApO1xuXG4gICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleDtcblxuICAgIGlmICggaW5kZXggKSB7XG5cbiAgICAgIC8vIGluZGV4ZWQgbGluZXNcblxuICAgICAgdmFyIHR5cGUsIHNpemU7XG5cbiAgICAgIGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XG4gICAgICAgIHNpemUgPSA0O1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgIHNpemUgPSAyO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgMCApO1xuICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBpbmRleC5hcnJheS5sZW5ndGgsIHR5cGUsIDAgKTsgLy8gMiBieXRlcyBwZXIgVWludDE2QXJyYXlcblxuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gaW5kZXguYXJyYXkubGVuZ3RoOyAvLyBub3QgcmVhbGx5IHRydWUsIGhlcmUgdmVydGljZXMgY2FuIGJlIHNoYXJlZFxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxIGNodW5rXG4gICAgICAgIC8vIG11c3Qgc2V0IGF0dHJpYnV0ZSBwb2ludGVycyB0byB1c2UgbmV3IG9mZnNldHMgZm9yIGVhY2ggY2h1bmtcbiAgICAgICAgLy8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID4gMSApIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBvZmZzZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBvZmZzZXRzWyBpIF0uaW5kZXg7XG5cbiAgICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICk7XG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlbmRlciBpbmRleGVkIGxpbmVzXG5cbiAgICAgICAgICBfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBvZmZzZXRzWyBpIF0uY291bnQsIHR5cGUsIG9mZnNldHNbIGkgXS5zdGFydCAqIHNpemUgKTsgLy8gMiBieXRlcyBwZXIgVWludDE2QXJyYXlcblxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIG5vbi1pbmRleGVkIGxpbmVzXG5cbiAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgMCApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgX2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDMgKTtcblxuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCBvZmZzZXRzWyBpIF0uaW5kZXgsIG9mZnNldHNbIGkgXS5jb3VudCApO1xuXG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50O1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJQb2ludENsb3VkKCBtYXRlcmlhbCwgZ2VvbWV0cnksIG9iamVjdCwgcHJvZ3JhbSwgdXBkYXRlQnVmZmVycyApIHtcblxuICAgIHZhciBtb2RlID0gX2dsLlBPSU5UUztcblxuICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXg7XG5cbiAgICBpZiAoIGluZGV4ICkge1xuXG4gICAgICAvLyBpbmRleGVkIHBvaW50c1xuXG4gICAgICB2YXIgdHlwZSwgc2l6ZTtcblxuICAgICAgaWYgKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgc2l6ZSA9IDQ7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgc2l6ZSA9IDI7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xuXG4gICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG4gICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIGluZGV4LmFycmF5Lmxlbmd0aCwgdHlwZSwgMCk7XG5cbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyArPSBpbmRleC5hcnJheS5sZW5ndGg7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIDEgY2h1bmtcbiAgICAgICAgLy8gbXVzdCBzZXQgYXR0cmlidXRlIHBvaW50ZXJzIHRvIHVzZSBuZXcgb2Zmc2V0cyBmb3IgZWFjaCBjaHVua1xuICAgICAgICAvLyBldmVuIGlmIGdlb21ldHJ5IGFuZCBtYXRlcmlhbHMgZGlkbid0IGNoYW5nZVxuXG4gICAgICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPiAxICkgdXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IG9mZnNldHNbIGkgXS5pbmRleDtcblxuICAgICAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKTtcbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVuZGVyIGluZGV4ZWQgcG9pbnRzXG5cbiAgICAgICAgICBfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBvZmZzZXRzWyBpIF0uY291bnQsIHR5cGUsIG9mZnNldHNbIGkgXS5zdGFydCAqIHNpemUgKTtcblxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyArPSBvZmZzZXRzWyBpIF0uY291bnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBub24taW5kZXhlZCBwb2ludHNcblxuICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgMCwgcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMyApO1xuXG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCBvZmZzZXRzWyBpIF0uaW5kZXgsIG9mZnNldHNbIGkgXS5jb3VudCApO1xuXG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IG9mZnNldHNbIGkgXS5jb3VudDtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgLy8gU29ydGluZ1xuXG4gIGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuICAgIGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgIH0gZWxzZSBpZiAoIGEub2JqZWN0Lm1hdGVyaWFsLmlkICE9PSBiLm9iamVjdC5tYXRlcmlhbC5pZCApIHtcblxuICAgICAgcmV0dXJuIGEub2JqZWN0Lm1hdGVyaWFsLmlkIC0gYi5vYmplY3QubWF0ZXJpYWwuaWQ7XG5cbiAgICB9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgcmV0dXJuIGEueiAtIGIuejtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuICAgIGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgIH0gaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgcmV0dXJuIGIueiAtIGEuejtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gUmVuZGVyaW5nXG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuICAgIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG4gICAgLy8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxuXG4gICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcbiAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG4gICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuICAgIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG4gICAgaWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuICAgIGlmICggY2FtZXJhLnBhcmVudCA9PT0gdW5kZWZpbmVkICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgbGlnaHRzLmxlbmd0aCA9IDA7XG4gICAgb3BhcXVlT2JqZWN0cy5sZW5ndGggPSAwO1xuICAgIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPSAwO1xuXG4gICAgc3ByaXRlcy5sZW5ndGggPSAwO1xuICAgIGxlbnNGbGFyZXMubGVuZ3RoID0gMDtcblxuICAgIHByb2plY3RPYmplY3QoIHNjZW5lICk7XG5cbiAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG4gICAgICBvcGFxdWVPYmplY3RzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG4gICAgICB0cmFuc3BhcmVudE9iamVjdHMuc29ydCggcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XG5cbiAgICB9XG5cbiAgICBvYmplY3RzLnVwZGF0ZSggb3BhcXVlT2JqZWN0cyApO1xuICAgIG9iamVjdHMudXBkYXRlKCB0cmFuc3BhcmVudE9iamVjdHMgKTtcblxuICAgIC8vXG5cbiAgICBzaGFkb3dNYXAucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cbiAgICAvL1xuXG4gICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgPSAwO1xuICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcbiAgICBfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyA9IDA7XG4gICAgX3RoaXMuaW5mby5yZW5kZXIucG9pbnRzID0gMDtcblxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuICAgICAgdGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cbiAgICB9XG5cbiAgICAvLyBzZXQgbWF0cmljZXMgZm9yIGltbWVkaWF0ZSBvYmplY3RzXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2JqZWN0cy5vYmplY3RzSW1tZWRpYXRlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgd2ViZ2xPYmplY3QgPSBvYmplY3RzLm9iamVjdHNJbW1lZGlhdGVbIGkgXTtcbiAgICAgIHZhciBvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cbiAgICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgc2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEgKTtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuICAgICAgICAgIHdlYmdsT2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XG4gICAgICAgICAgd2ViZ2xPYmplY3Qub3BhcXVlID0gbnVsbDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgd2ViZ2xPYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XG4gICAgICAgICAgd2ViZ2xPYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICB2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cbiAgICAgIHNldE1hdGVyaWFsKCBvdmVycmlkZU1hdGVyaWFsICk7XG5cbiAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcbiAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggb2JqZWN0cy5vYmplY3RzSW1tZWRpYXRlLCAnJywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXG5cbiAgICAgIHN0YXRlLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XG5cbiAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG51bGwgKTtcbiAgICAgIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIG9iamVjdHMub2JqZWN0c0ltbWVkaWF0ZSwgJ29wYXF1ZScsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG51bGwgKTtcblxuICAgICAgLy8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuICAgICAgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBudWxsICk7XG4gICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBvYmplY3RzLm9iamVjdHNJbW1lZGlhdGUsICd0cmFuc3BhcmVudCcsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG51bGwgKTtcblxuICAgIH1cblxuICAgIC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxuXG4gICAgc3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuICAgIGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XG5cbiAgICAvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuICAgICAgdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuICAgIH1cblxuICAgIC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cbiAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcbiAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG4gICAgc3RhdGUuc2V0Q29sb3JXcml0ZSggdHJ1ZSApO1xuXG4gICAgLy8gX2dsLmZpbmlzaCgpO1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0ICkge1xuXG4gICAgaWYgKCBvYmplY3QudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Hcm91cCApIHtcblxuICAgICAgICAvLyBza2lwXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdXBkYXRlIFNrZWxldG9uIG9iamVjdHNcbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuICAgICAgICAgIG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0cy5pbml0KCBvYmplY3QgKTtcblxuICAgICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xuXG4gICAgICAgICAgbGlnaHRzLnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSApIHtcblxuICAgICAgICAgIHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGVuc0ZsYXJlICkge1xuXG4gICAgICAgICAgbGVuc0ZsYXJlcy5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdmFyIHdlYmdsT2JqZWN0ID0gb2JqZWN0cy5vYmplY3RzWyBvYmplY3QuaWQgXTtcblxuICAgICAgICAgIGlmICggd2ViZ2xPYmplY3QgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcblxuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG4gICAgICAgICAgICAgIHRyYW5zcGFyZW50T2JqZWN0cy5wdXNoKCB3ZWJnbE9iamVjdCApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIG9wYXF1ZU9iamVjdHMucHVzaCggd2ViZ2xPYmplY3QgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgICAgICAgIF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgICAgICAgICAgICB3ZWJnbE9iamVjdC56ID0gX3ZlY3RvcjMuejtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBwcm9qZWN0T2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWw7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcblxuICAgICAgdmFyIG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuICAgICAgc2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEgKTtcblxuICAgICAgaWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICAgIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICBpZiAoICEgbWF0ZXJpYWwgKSBjb250aW51ZTtcblxuICAgICAgICBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xuICAgICAgX3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck9iamVjdHNJbW1lZGlhdGUgKCByZW5kZXJMaXN0LCBtYXRlcmlhbFR5cGUsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWw7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcbiAgICAgIHZhciBvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cbiAgICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgaWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBtYXRlcmlhbCA9IHdlYmdsT2JqZWN0WyBtYXRlcmlhbFR5cGUgXTtcblxuICAgICAgICAgIGlmICggISBtYXRlcmlhbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnJlbmRlckltbWVkaWF0ZU9iamVjdCggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMucmVuZGVySW1tZWRpYXRlT2JqZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG4gICAgdmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXG4gICAgX3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcblxuICAgIGlmICggb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xuXG4gICAgICBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2soIHByb2dyYW0sIF9nbCwgX2ZydXN0dW0gKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkgeyBfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTsgfSApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gTWF0ZXJpYWxzXG5cbiAgdmFyIHNoYWRlcklEcyA9IHtcbiAgICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICAgIE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcbiAgICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgICBMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICAgIFBvaW50Q2xvdWRNYXRlcmlhbDogJ3BhcnRpY2xlX2Jhc2ljJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKSB7XG5cbiAgICB2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcblxuICAgIC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG4gICAgLy8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuICAgIHZhciBtYXhMaWdodENvdW50ID0gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApO1xuICAgIHZhciBtYXhTaGFkb3dzID0gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKTtcbiAgICB2YXIgbWF4Qm9uZXMgPSBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKTtcblxuICAgIHZhciBwYXJhbWV0ZXJzID0ge1xuXG4gICAgICBwcmVjaXNpb246IF9wcmVjaXNpb24sXG4gICAgICBzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyxcblxuICAgICAgbWFwOiAhISBtYXRlcmlhbC5tYXAsXG4gICAgICBlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcbiAgICAgIGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcbiAgICAgIGxpZ2h0TWFwOiAhISBtYXRlcmlhbC5saWdodE1hcCxcbiAgICAgIGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcbiAgICAgIGJ1bXBNYXA6ICEhIG1hdGVyaWFsLmJ1bXBNYXAsXG4gICAgICBub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcbiAgICAgIHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcbiAgICAgIGFscGhhTWFwOiAhISBtYXRlcmlhbC5hbHBoYU1hcCxcblxuICAgICAgY29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcblxuICAgICAgdmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cbiAgICAgIGZvZzogZm9nLFxuICAgICAgdXNlRm9nOiBtYXRlcmlhbC5mb2csXG4gICAgICBmb2dFeHA6IGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIsXG5cbiAgICAgIGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyxcblxuICAgICAgc2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG4gICAgICBsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBfbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuICAgICAgc2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxuICAgICAgbWF4Qm9uZXM6IG1heEJvbmVzLFxuICAgICAgdXNlVmVydGV4VGV4dHVyZTogX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUsXG5cbiAgICAgIG1vcnBoVGFyZ2V0czogbWF0ZXJpYWwubW9ycGhUYXJnZXRzLFxuICAgICAgbW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXG4gICAgICBtYXhNb3JwaFRhcmdldHM6IF90aGlzLm1heE1vcnBoVGFyZ2V0cyxcbiAgICAgIG1heE1vcnBoTm9ybWFsczogX3RoaXMubWF4TW9ycGhOb3JtYWxzLFxuXG4gICAgICBtYXhEaXJMaWdodHM6IG1heExpZ2h0Q291bnQuZGlyZWN0aW9uYWwsXG4gICAgICBtYXhQb2ludExpZ2h0czogbWF4TGlnaHRDb3VudC5wb2ludCxcbiAgICAgIG1heFNwb3RMaWdodHM6IG1heExpZ2h0Q291bnQuc3BvdCxcbiAgICAgIG1heEhlbWlMaWdodHM6IG1heExpZ2h0Q291bnQuaGVtaSxcblxuICAgICAgbWF4U2hhZG93czogbWF4U2hhZG93cyxcbiAgICAgIHNoYWRvd01hcEVuYWJsZWQ6IHNoYWRvd01hcC5lbmFibGVkICYmIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIG1heFNoYWRvd3MgPiAwLFxuICAgICAgc2hhZG93TWFwVHlwZTogc2hhZG93TWFwLnR5cGUsXG4gICAgICBzaGFkb3dNYXBEZWJ1Zzogc2hhZG93TWFwLmRlYnVnLFxuICAgICAgc2hhZG93TWFwQ2FzY2FkZTogc2hhZG93TWFwLmNhc2NhZGUsXG5cbiAgICAgIGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxuICAgICAgbWV0YWw6IG1hdGVyaWFsLm1ldGFsLFxuICAgICAgZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUsXG4gICAgICBmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlXG5cbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgY29kZVxuXG4gICAgdmFyIGNodW5rcyA9IFtdO1xuXG4gICAgaWYgKCBzaGFkZXJJRCApIHtcblxuICAgICAgY2h1bmtzLnB1c2goIHNoYWRlcklEICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcbiAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIH1cblxuICAgIGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5kZWZpbmVzICkge1xuXG4gICAgICAgIGNodW5rcy5wdXNoKCBuYW1lICk7XG4gICAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gcGFyYW1ldGVycyApIHtcblxuICAgICAgY2h1bmtzLnB1c2goIG5hbWUgKTtcbiAgICAgIGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzWyBuYW1lIF0gKTtcblxuICAgIH1cblxuICAgIHZhciBjb2RlID0gY2h1bmtzLmpvaW4oKTtcblxuICAgIGlmICggIW1hdGVyaWFsLnByb2dyYW0gKSB7XG5cbiAgICAgIC8vIG5ldyBtYXRlcmlhbFxuICAgICAgbWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG4gICAgfSBlbHNlIGlmICggbWF0ZXJpYWwucHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xuXG4gICAgICAvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xuICAgICAgZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgfSBlbHNlIGlmICggc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgLy8gc2FtZSBnbHNsXG4gICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zID09PSBtYXRlcmlhbC51bmlmb3JtcyApIHtcblxuICAgICAgLy8gc2FtZSB1bmlmb3JtcyAoY29udGFpbmVyIG9iamVjdClcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIGlmICggc2hhZGVySUQgKSB7XG5cbiAgICAgIHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIHNoYWRlcklEIF07XG5cbiAgICAgIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSB7XG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKSxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0ge1xuICAgICAgICB1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXG4gICAgICAgIHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBwcm9ncmFtO1xuXG4gICAgLy8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG5cbiAgICBmb3IgKCB2YXIgcCA9IDAsIHBsID0gX3Byb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG4gICAgICB2YXIgcHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIHAgXTtcblxuICAgICAgaWYgKCBwcm9ncmFtSW5mby5jb2RlID09PSBjb2RlICkge1xuXG4gICAgICAgIHByb2dyYW0gPSBwcm9ncmFtSW5mbztcbiAgICAgICAgcHJvZ3JhbS51c2VkVGltZXMgKys7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBwcm9ncmFtID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbSggX3RoaXMsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XG4gICAgICBfcHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xuXG4gICAgICBfdGhpcy5pbmZvLm1lbW9yeS5wcm9ncmFtcyA9IF9wcm9ncmFtcy5sZW5ndGg7XG5cbiAgICB9XG5cbiAgICBtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XG5cbiAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhOb3JtYWxzOyBpICsrICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIGkgXSA+PSAwICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgbWF0ZXJpYWwudW5pZm9ybXNMaXN0ID0gW107XG5cbiAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsLnByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcbiAgICBmb3IgKCB2YXIgdSBpbiBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zICkge1xuXG4gICAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XG5cbiAgICAgIGlmICggbG9jYXRpb24gKSB7XG4gICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zTGlzdC5wdXNoKCBbIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cbiAgICBpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xuXG4gICAgICBzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG4gICAgfVxuXG4gICAgc3RhdGUuc2V0RGVwdGhGdW5jKCBtYXRlcmlhbC5kZXB0aEZ1bmMgKTtcbiAgICBzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcbiAgICBzdGF0ZS5zZXRDb2xvcldyaXRlKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XG4gICAgc3RhdGUuc2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XG5cbiAgICBfdXNlZFRleHR1cmVVbml0cyA9IDA7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlICkge1xuXG4gICAgICBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XG4gICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgdmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG4gICAgdmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuICAgIHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW0sXG4gICAgICBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuICAgICAgbV91bmlmb3JtcyA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XG5cbiAgICBpZiAoIHByb2dyYW0uaWQgIT09IF9jdXJyZW50UHJvZ3JhbSApIHtcblxuICAgICAgX2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xuICAgICAgX2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbS5pZDtcblxuICAgICAgcmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcbiAgICAgIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xuXG4gICAgICBpZiAoIF9jdXJyZW50TWF0ZXJpYWxJZCA9PT0gLTEgKSByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcbiAgICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXG4gICAgICByZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgaWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG4gICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgaWYgKCBfbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuICAgICAgICBfZ2wudW5pZm9ybTFmKCBwX3VuaWZvcm1zLmxvZ0RlcHRoQnVmRkMsIDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcblxuICAgICAgfVxuXG5cbiAgICAgIGlmICggY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIF9jdXJyZW50Q2FtZXJhID0gY2FtZXJhO1xuXG4gICAgICAvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG4gICAgICAvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsLmVudk1hcCApIHtcblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgIF9nbC51bmlmb3JtM2YoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24sIF92ZWN0b3IzLngsIF92ZWN0b3IzLnksIF92ZWN0b3IzLnogKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy52aWV3TWF0cml4ICE9PSBudWxsICkge1xuXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuICAgIC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xuICAgIC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXG5cbiAgICBpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG4gICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4ICYmIHBfdW5pZm9ybXMuYmluZE1hdHJpeCAhPT0gbnVsbCApIHtcblxuICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4LCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSBudWxsICkge1xuXG4gICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlLCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlLmVsZW1lbnRzICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBfc3VwcG9ydHNCb25lVGV4dHVyZXMgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGggIT09IG51bGwgKSB7XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGgsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZVdpZHRoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZUhlaWdodCApO1xuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICggb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKSB7XG5cbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gbnVsbCApIHtcblxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG4gICAgICAvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG4gICAgICBpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwubGlnaHRzICkge1xuXG4gICAgICAgIGlmICggX2xpZ2h0c05lZWRVcGRhdGUgKSB7XG5cbiAgICAgICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcbiAgICAgICAgICBzZXR1cExpZ2h0cyggbGlnaHRzICk7XG4gICAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmVmcmVzaExpZ2h0cyApIHtcbiAgICAgICAgICByZWZyZXNoVW5pZm9ybXNMaWdodHMoIG1fdW5pZm9ybXMsIF9saWdodHMgKTtcbiAgICAgICAgICBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgdHJ1ZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCBtX3VuaWZvcm1zLCBmYWxzZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIHJlZnJlc2ggc2luZ2xlIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cbiAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuICAgICAgICByZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zQmFzaWMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgbV91bmlmb3Jtcy5tTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xuICAgICAgICBtX3VuaWZvcm1zLm1GYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xuICAgICAgICBtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuICAgICAgICBtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgISBtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNTaGFkb3coIG1fdW5pZm9ybXMsIGxpZ2h0cyApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXG5cbiAgICAgIGxvYWRVbmlmb3Jtc0dlbmVyaWMoIG1hdGVyaWFsLnVuaWZvcm1zTGlzdCApO1xuXG4gICAgfVxuXG4gICAgbG9hZFVuaWZvcm1zTWF0cmljZXMoIHBfdW5pZm9ybXMsIG9iamVjdCApO1xuXG4gICAgaWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSBudWxsICkge1xuXG4gICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG5cbiAgfVxuXG4gIC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICB1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cbiAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG4gICAgdW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcbiAgICB1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG4gICAgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgICB1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcbiAgICAgIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuICAgIH1cblxuICAgIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG4gICAgICB1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG4gICAgICB1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG4gICAgfVxuXG4gICAgLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG4gICAgLy8gMS4gY29sb3IgbWFwXG4gICAgLy8gMi4gc3BlY3VsYXIgbWFwXG4gICAgLy8gMy4gbm9ybWFsIG1hcFxuICAgIC8vIDQuIGJ1bXAgbWFwXG4gICAgLy8gNS4gYWxwaGEgbWFwXG5cbiAgICB2YXIgdXZTY2FsZU1hcDtcblxuICAgIGlmICggbWF0ZXJpYWwubWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuXG4gICAgfSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xuXG4gICAgfSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuICAgIH1cblxuICAgIGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XG4gICAgICB2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XG5cbiAgICAgIHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cbiAgICB9XG5cbiAgICB1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XG4gICAgdW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggbWF0ZXJpYWwuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkgPyAxIDogLSAxO1xuXG4gICAgdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuICAgIHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcbiAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XG4gICAgdW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xuICAgIHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BhcnRpY2xlICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMucHNDb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuICAgIHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplO1xuICAgIHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2NhbnZhcy5oZWlnaHQgLyAyLjA7IC8vIFRPRE86IENhY2hlIHRoaXMuXG5cbiAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuICAgICAgdmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XG4gICAgICB2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcblxuICAgICAgdW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRm9nICggdW5pZm9ybXMsIGZvZyApIHtcblxuICAgIHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xuXG4gICAgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XG5cbiAgICAgIHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcbiAgICAgIHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XG5cbiAgICB9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xuXG4gICAgICB1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gbWF0ZXJpYWwuc2hpbmluZXNzO1xuXG4gICAgdW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcbiAgICB1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuXG4gICAgdW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcbiAgICB1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgdW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcbiAgICB1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMYW1iZXJ0ICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQmFzaWMgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICB1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuICAgIHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyAoIHVuaWZvcm1zLCBsaWdodHMgKSB7XG5cbiAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xuXG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycztcbiAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztcblxuICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5wb2ludC5jb2xvcnM7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcbiAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMucG9pbnQuZGlzdGFuY2VzO1xuICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kZWNheXM7XG5cbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LnBvc2l0aW9ucztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpc3RhbmNlcztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodEFuZ2xlQ29zLnZhbHVlID0gbGlnaHRzLnNwb3QuYW5nbGVzQ29zO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50LnZhbHVlID0gbGlnaHRzLnNwb3QuZXhwb25lbnRzO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5LnZhbHVlID0gbGlnaHRzLnNwb3QuZGVjYXlzO1xuXG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5za3lDb2xvcnM7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5ncm91bmRDb2xvcnM7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmhlbWkucG9zaXRpb25zO1xuXG4gIH1cblxuICAvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cbiAgZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUgKCB1bmlmb3JtcywgdmFsdWUgKSB7XG5cbiAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgdW5pZm9ybXMucG9pbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU2hhZG93ICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcblxuICAgIGlmICggdW5pZm9ybXMuc2hhZG93TWF0cml4ICkge1xuXG4gICAgICB2YXIgaiA9IDA7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8ICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICYmICEgbGlnaHQuc2hhZG93Q2FzY2FkZSApICkge1xuXG4gICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWFwLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXA7XG4gICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwU2l6ZTtcblxuICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hdHJpeC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWF0cml4O1xuXG4gICAgICAgICAgdW5pZm9ybXMuc2hhZG93RGFya25lc3MudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xuICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0JpYXMudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd0JpYXM7XG5cbiAgICAgICAgICBqICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICAvLyBVbmlmb3JtcyAobG9hZCB0byBHUFUpXG5cbiAgZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xuXG4gICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICBpZiAoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCApIHtcblxuICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5fbm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRleHR1cmVVbml0KCkge1xuXG4gICAgdmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cbiAgICBpZiAoIHRleHR1cmVVbml0ID49IF9tYXhUZXh0dXJlcyApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgX21heFRleHR1cmVzICk7XG5cbiAgICB9XG5cbiAgICBfdXNlZFRleHR1cmVVbml0cyArPSAxO1xuXG4gICAgcmV0dXJuIHRleHR1cmVVbml0O1xuXG4gIH1cblxuICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljICggdW5pZm9ybXMgKSB7XG5cbiAgICB2YXIgdGV4dHVyZSwgdGV4dHVyZVVuaXQsIG9mZnNldDtcblxuICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XG5cbiAgICAgIC8vIG5lZWRzVXBkYXRlIHByb3BlcnR5IGlzIG5vdCBhZGRlZCB0byBhbGwgdW5pZm9ybXMuXG4gICAgICBpZiAoIHVuaWZvcm0ubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgIHZhciB0eXBlID0gdW5pZm9ybS50eXBlO1xuICAgICAgdmFyIHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IHVuaWZvcm1zWyBqIF1bIDEgXTtcblxuICAgICAgc3dpdGNoICggdHlwZSApIHtcblxuICAgICAgICBjYXNlICcxaSc6XG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnMWYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzJmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzNmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzRmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSwgdmFsdWVbIDMgXSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzFpdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzNpdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzFmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzJmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzNmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzRmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ01hdHJpeDNmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdNYXRyaXg0ZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBjYXNlICdpJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBpbnRlZ2VyXG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBmbG9hdFxuICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjInOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcbiAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjMnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjQnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcbiAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYyc6XG5cbiAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuQ29sb3JcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaXYxJzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2l2JzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICBfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdjEnOlxuXG4gICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Z2JzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjJ2JzpcblxuICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIG9mZnNldCA9IGkgKiAyO1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Yzdic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBpICogMztcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjR2JzpcblxuICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjRcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIG9mZnNldCA9IGkgKiA0O1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMyBdID0gdmFsdWVbIGkgXS53O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbTMnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLk1hdHJpeDNcbiAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbTN2JzpcblxuICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDNcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogOSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ200JzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ200dic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXG5cbiAgICAgICAgICB0ZXh0dXJlID0gdmFsdWU7XG4gICAgICAgICAgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICBpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcbiAgICAgICAgICAgICAoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkgeyAvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xuXG4gICAgICAgICAgICBzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgICAgICAgIHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0dic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5UZXh0dXJlICgyZClcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBbXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICB0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZVsgaSBdO1xuICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xuXG4gICAgICAgICAgICBpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwTWF0cmljZXMgKCBvYmplY3QsIGNhbWVyYSApIHtcblxuICAgIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgIG9iamVjdC5fbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXggKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29sb3JMaW5lYXIoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICBhcnJheVsgb2Zmc2V0ICsgMCBdID0gY29sb3IuciAqIGludGVuc2l0eTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZyAqIGludGVuc2l0eTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGludGVuc2l0eTtcblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBMaWdodHMgKCBsaWdodHMgKSB7XG5cbiAgICB2YXIgbCwgbGwsIGxpZ2h0LFxuICAgIHIgPSAwLCBnID0gMCwgYiA9IDAsXG4gICAgY29sb3IsIHNreUNvbG9yLCBncm91bmRDb2xvcixcbiAgICBpbnRlbnNpdHksXG4gICAgZGlzdGFuY2UsXG5cbiAgICB6bGlnaHRzID0gX2xpZ2h0cyxcblxuICAgIGRpckNvbG9ycyA9IHpsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzLFxuICAgIGRpclBvc2l0aW9ucyA9IHpsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zLFxuXG4gICAgcG9pbnRDb2xvcnMgPSB6bGlnaHRzLnBvaW50LmNvbG9ycyxcbiAgICBwb2ludFBvc2l0aW9ucyA9IHpsaWdodHMucG9pbnQucG9zaXRpb25zLFxuICAgIHBvaW50RGlzdGFuY2VzID0gemxpZ2h0cy5wb2ludC5kaXN0YW5jZXMsXG4gICAgcG9pbnREZWNheXMgPSB6bGlnaHRzLnBvaW50LmRlY2F5cyxcblxuICAgIHNwb3RDb2xvcnMgPSB6bGlnaHRzLnNwb3QuY29sb3JzLFxuICAgIHNwb3RQb3NpdGlvbnMgPSB6bGlnaHRzLnNwb3QucG9zaXRpb25zLFxuICAgIHNwb3REaXN0YW5jZXMgPSB6bGlnaHRzLnNwb3QuZGlzdGFuY2VzLFxuICAgIHNwb3REaXJlY3Rpb25zID0gemxpZ2h0cy5zcG90LmRpcmVjdGlvbnMsXG4gICAgc3BvdEFuZ2xlc0NvcyA9IHpsaWdodHMuc3BvdC5hbmdsZXNDb3MsXG4gICAgc3BvdEV4cG9uZW50cyA9IHpsaWdodHMuc3BvdC5leHBvbmVudHMsXG4gICAgc3BvdERlY2F5cyA9IHpsaWdodHMuc3BvdC5kZWNheXMsXG5cbiAgICBoZW1pU2t5Q29sb3JzID0gemxpZ2h0cy5oZW1pLnNreUNvbG9ycyxcbiAgICBoZW1pR3JvdW5kQ29sb3JzID0gemxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycyxcbiAgICBoZW1pUG9zaXRpb25zID0gemxpZ2h0cy5oZW1pLnBvc2l0aW9ucyxcblxuICAgIGRpckxlbmd0aCA9IDAsXG4gICAgcG9pbnRMZW5ndGggPSAwLFxuICAgIHNwb3RMZW5ndGggPSAwLFxuICAgIGhlbWlMZW5ndGggPSAwLFxuXG4gICAgZGlyQ291bnQgPSAwLFxuICAgIHBvaW50Q291bnQgPSAwLFxuICAgIHNwb3RDb3VudCA9IDAsXG4gICAgaGVtaUNvdW50ID0gMCxcblxuICAgIGRpck9mZnNldCA9IDAsXG4gICAgcG9pbnRPZmZzZXQgPSAwLFxuICAgIHNwb3RPZmZzZXQgPSAwLFxuICAgIGhlbWlPZmZzZXQgPSAwO1xuXG4gICAgZm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG4gICAgICBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgICBpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgY29sb3IgPSBsaWdodC5jb2xvcjtcbiAgICAgIGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcbiAgICAgIGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQgKSB7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICByICs9IGNvbG9yLnI7XG4gICAgICAgIGcgKz0gY29sb3IuZztcbiAgICAgICAgYiArPSBjb2xvci5iO1xuXG4gICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cbiAgICAgICAgZGlyQ291bnQgKz0gMTtcblxuICAgICAgICBpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgICAgICBfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcbiAgICAgICAgX2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgICAgICBkaXJPZmZzZXQgPSBkaXJMZW5ndGggKiAzO1xuXG4gICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgc2V0Q29sb3JMaW5lYXIoIGRpckNvbG9ycywgZGlyT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgZGlyTGVuZ3RoICs9IDE7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuICAgICAgICBwb2ludENvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICBwb2ludE9mZnNldCA9IHBvaW50TGVuZ3RoICogMztcblxuICAgICAgICBzZXRDb2xvckxpbmVhciggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XG4gICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XG4gICAgICAgIHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XG5cbiAgICAgICAgLy8gZGlzdGFuY2UgaXMgMCBpZiBkZWNheSBpcyAwLCBiZWNhdXNlIHRoZXJlIGlzIG5vIGF0dGVudWF0aW9uIGF0IGFsbC5cbiAgICAgICAgcG9pbnREaXN0YW5jZXNbIHBvaW50TGVuZ3RoIF0gPSBkaXN0YW5jZTtcbiAgICAgICAgcG9pbnREZWNheXNbIHBvaW50TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgICAgICBwb2ludExlbmd0aCArPSAxO1xuXG4gICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuICAgICAgICBzcG90Q291bnQgKz0gMTtcblxuICAgICAgICBpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG4gICAgICAgIHNwb3RPZmZzZXQgPSBzcG90TGVuZ3RoICogMztcblxuICAgICAgICBzZXRDb2xvckxpbmVhciggc3BvdENvbG9ycywgc3BvdE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgIHNwb3RQb3NpdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgc3BvdERpc3RhbmNlc1sgc3BvdExlbmd0aCBdID0gZGlzdGFuY2U7XG5cbiAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgX2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG4gICAgICAgIF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuICAgICAgICBzcG90QW5nbGVzQ29zWyBzcG90TGVuZ3RoIF0gPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcbiAgICAgICAgc3BvdEV4cG9uZW50c1sgc3BvdExlbmd0aCBdID0gbGlnaHQuZXhwb25lbnQ7XG4gICAgICAgIHNwb3REZWNheXNbIHNwb3RMZW5ndGggXSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xuXG4gICAgICAgIHNwb3RMZW5ndGggKz0gMTtcblxuICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSB7XG5cbiAgICAgICAgaGVtaUNvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgX2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgICAgICBoZW1pT2Zmc2V0ID0gaGVtaUxlbmd0aCAqIDM7XG5cbiAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcbiAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgaGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuICAgICAgICBza3lDb2xvciA9IGxpZ2h0LmNvbG9yO1xuICAgICAgICBncm91bmRDb2xvciA9IGxpZ2h0Lmdyb3VuZENvbG9yO1xuXG4gICAgICAgIHNldENvbG9yTGluZWFyKCBoZW1pU2t5Q29sb3JzLCBoZW1pT2Zmc2V0LCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XG4gICAgICAgIHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgaGVtaUxlbmd0aCArPSAxO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xuICAgIC8vICh0aGlzIGlzIHRvIGF2b2lkIGlmIGluIHNoYWRlcilcblxuICAgIGZvciAoIGwgPSBkaXJMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBkaXJDb2xvcnMubGVuZ3RoLCBkaXJDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgZGlyQ29sb3JzWyBsIF0gPSAwLjA7XG4gICAgZm9yICggbCA9IHBvaW50TGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggcG9pbnRDb2xvcnMubGVuZ3RoLCBwb2ludENvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBwb2ludENvbG9yc1sgbCBdID0gMC4wO1xuICAgIGZvciAoIGwgPSBzcG90TGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggc3BvdENvbG9ycy5sZW5ndGgsIHNwb3RDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgc3BvdENvbG9yc1sgbCBdID0gMC4wO1xuICAgIGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaVNreUNvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgaGVtaVNreUNvbG9yc1sgbCBdID0gMC4wO1xuICAgIGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaUdyb3VuZENvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgaGVtaUdyb3VuZENvbG9yc1sgbCBdID0gMC4wO1xuXG4gICAgemxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJMZW5ndGg7XG4gICAgemxpZ2h0cy5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcbiAgICB6bGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcbiAgICB6bGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuICAgIHpsaWdodHMuYW1iaWVudFsgMCBdID0gcjtcbiAgICB6bGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XG4gICAgemxpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xuXG4gIH1cblxuICAvLyBHTCBzdGF0ZSBzZXR0aW5nXG5cbiAgdGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcblxuICAgIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlTm9uZSApIHtcblxuICAgICAgX2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyApIHtcblxuICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xuXG4gICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuICAgICAgfSBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xuXG4gICAgICB9XG5cbiAgICAgIF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0TWF0ZXJpYWxGYWNlcyA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cbiAgICBzdGF0ZS5zZXREb3VibGVTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSApO1xuICAgIHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKTtcblxuICB9O1xuXG4gIC8vIFRleHR1cmVzXG5cbiAgZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMgKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgaWYgKCBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBTICkgKTtcbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwVCApICk7XG5cbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWFnRmlsdGVyICkgKTtcbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XG5cbiAgICAgIGlmICggdGV4dHVyZS53cmFwUyAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuICggJyArIHRleHR1cmUuc291cmNlRmlsZSArICcgKScgKTtcblxuICAgICAgfVxuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cbiAgICAgIGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuICggJyArIHRleHR1cmUuc291cmNlRmlsZSArICcgKScgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cbiAgICBpZiAoIGV4dGVuc2lvbiAmJiB0ZXh0dXJlLnR5cGUgIT09IFRIUkVFLkZsb2F0VHlwZSAmJiB0ZXh0dXJlLnR5cGUgIT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgKSB7XG5cbiAgICAgIGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCB0ZXh0dXJlLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XG5cbiAgICAgICAgX2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF90aGlzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG4gICAgICAgIHRleHR1cmUuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLnVwbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBpZiAoIHRleHR1cmUuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdGV4dHVyZS5fX3dlYmdsSW5pdCA9IHRydWU7XG5cbiAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICAgIHRleHR1cmUuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICBfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuICAgIH1cblxuICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcbiAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cbiAgICB0ZXh0dXJlLmltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIF9tYXhUZXh0dXJlU2l6ZSApO1xuXG4gICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZSxcbiAgICBpc0ltYWdlUG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcbiAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcblxuICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cbiAgICBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZSApIHtcblxuICAgICAgLy8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgICAgLy8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cbiAgICAgIGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuICAgICAgICBpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XG5cbiAgICAgICAgICBpZiAoIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtMSApIHtcblxuICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKClcIiApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG5cbiAgICAgIC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICAgIC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG4gICAgICBpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcbiAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG4gIH07XG5cbiAgdGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgaWYgKCB0ZXh0dXJlLm5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG4gICAgICBpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwbG9hZFRleHR1cmUoIHRleHR1cmUsIHNsb3QgKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplICggaW1hZ2UsIG1heFNpemUgKSB7XG5cbiAgICBpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG4gICAgICAvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxuICAgICAgLy8gcHJlbXVsdGlwbGllZCBhbHBoYS5cblxuICAgICAgdmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xuICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG4gICAgICByZXR1cm4gY2FudmFzO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG4gICAgICBpZiAoIHRleHR1cmUubmVlZHNVcGRhdGUgKSB7XG5cbiAgICAgICAgaWYgKCAhIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgICAgICAgdGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAgIF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgICAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cbiAgICAgICAgdmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcbiAgICAgICAgdmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcblxuICAgICAgICB2YXIgY3ViZUltYWdlID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgICAgICAgIGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG4gICAgICAgICAgICBjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIF9tYXhDdWJlbWFwU2l6ZSApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcbiAgICAgICAgaXNJbWFnZVBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXG4gICAgICAgIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG4gICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgICAgICAgIGlmICggISBpc0NvbXByZXNzZWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBqIF07XG5cbiAgICAgICAgICAgICAgaWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0Q3ViZVRleHR1cmUoKVwiICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyAoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgfVxuXG4gIC8vIFJlbmRlciB0YXJnZXRzXG5cbiAgZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlciAoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIHRleHR1cmVUYXJnZXQgKSB7XG5cbiAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG4gICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVRhcmdldCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlLCAwICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcbiAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICAvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cbiAgICB9IGVsc2UgaWYgKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLlNURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG4gICAgKi9cbiAgICB9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcbiAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcblxuICAgICAgcmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cbiAgICAgIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgIF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG4gICAgICAvLyBTZXR1cCB0ZXh0dXJlLCBjcmVhdGUgcmVuZGVyIGFuZCBmcmFtZSBidWZmZXJzXG5cbiAgICAgIHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKSxcbiAgICAgICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLFxuICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnR5cGUgKTtcblxuICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuICAgICAgICByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xuXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgICAgICByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuICAgICAgICAgIHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xuICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XG5cbiAgICAgICAgICByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbS5fX3dlYmdsUmVuZGVyYnVmZmVyO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcbiAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXG4gICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cbiAgICAgICAgc2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG4gICAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBSZWxlYXNlIGV2ZXJ5dGhpbmdcblxuICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICAgIH1cblxuICAgICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcbiAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG4gICAgfVxuXG4gICAgdmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XG5cbiAgICBpZiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXI7XG5cbiAgICAgIH1cblxuICAgICAgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXG4gICAgICB2eCA9IDA7XG4gICAgICB2eSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cbiAgICAgIHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XG4gICAgICBoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgIHZ4ID0gX3ZpZXdwb3J0WDtcbiAgICAgIHZ5ID0gX3ZpZXdwb3J0WTtcblxuICAgIH1cblxuICAgIGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cbiAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcbiAgICAgIF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgIF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcblxuICAgIH1cblxuICAgIF9jdXJyZW50V2lkdGggPSB3aWR0aDtcbiAgICBfY3VycmVudEhlaWdodCA9IGhlaWdodDtcblxuICB9O1xuXG4gIHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciApIHtcblxuICAgIGlmICggISAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyICkge1xuXG4gICAgICBpZiAoIHJlbmRlclRhcmdldC5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIGZvcm1hdC4gcmVhZFBpeGVscyBjYW4gcmVhZCBvbmx5IFJHQkEgZm9ybWF0LicgKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciByZXN0b3JlID0gZmFsc2U7XG5cbiAgICAgIGlmICggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblxuICAgICAgICByZXN0b3JlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIF9nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBfZ2wuRlJBTUVCVUZGRVIgKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFICkge1xuXG4gICAgICAgIF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZ2wuUkdCQSwgX2dsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlciApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggcmVzdG9yZSApIHtcblxuICAgICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9jdXJyZW50RnJhbWVidWZmZXIgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwICggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG4gICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG4gICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuICBmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayAoIGYgKSB7XG5cbiAgICBpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcblxuICAgICAgcmV0dXJuIF9nbC5ORUFSRVNUO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIF9nbC5MSU5FQVI7XG5cbiAgfVxuXG4gIC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXG5cbiAgZnVuY3Rpb24gcGFyYW1UaHJlZVRvR0wgKCBwICkge1xuXG4gICAgdmFyIGV4dGVuc2lvbjtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLlJFUEVBVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gX2dsLkNMQU1QX1RPX0VER0U7XG4gICAgaWYgKCBwID09PSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5NSVJST1JFRF9SRVBFQVQ7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XG4gICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XG4gICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG4gICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9CWVRFO1xuICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xuICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xuICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5CeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlNob3J0VHlwZSApIHJldHVybiBfZ2wuU0hPUlQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5JbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEludFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0lOVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XG5cbiAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cbiAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgaWYgKCBwID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcblxuICAgIH1cblxuICAgIGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xuICAgIGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG4gICAgaWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XG4gICAgaWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5TdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1NVQlRSQUNUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcbiAgICBpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xuICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XG4gICAgaWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xuICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkRzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XG4gICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xuICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcblxuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cbiAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuICAgIH1cblxuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG4gICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG4gICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcCA9PT0gVEhSRUUuTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG5cbiAgfVxuXG4gIC8vIEFsbG9jYXRpb25zXG5cbiAgZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcblxuICAgIGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgIHJldHVybiAxMDI0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuICAgICAgLy8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXG4gICAgICAvL1xuICAgICAgLy8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcbiAgICAgIC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuICAgICAgLy8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxuXG4gICAgICB2YXIgblZlcnRleFVuaWZvcm1zID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XG4gICAgICB2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG4gICAgICB2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cbiAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgICAgbWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuICAgICAgICBpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXhCb25lcztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApIHtcblxuICAgIHZhciBkaXJMaWdodHMgPSAwO1xuICAgIHZhciBwb2ludExpZ2h0cyA9IDA7XG4gICAgdmFyIHNwb3RMaWdodHMgPSAwO1xuICAgIHZhciBoZW1pTGlnaHRzID0gMDtcblxuICAgIGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cbiAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgICBpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgfHwgbGlnaHQudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMgKys7XG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzICsrO1xuICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHNwb3RMaWdodHMgKys7XG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cyArKztcblxuICAgIH1cblxuICAgIHJldHVybiB7ICdkaXJlY3Rpb25hbCc6IGRpckxpZ2h0cywgJ3BvaW50JzogcG9pbnRMaWdodHMsICdzcG90Jzogc3BvdExpZ2h0cywgJ2hlbWknOiBoZW1pTGlnaHRzIH07XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICkge1xuXG4gICAgdmFyIG1heFNoYWRvd3MgPSAwO1xuXG4gICAgZm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cbiAgICAgIGlmICggISBsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBtYXhTaGFkb3dzICsrO1xuICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgbWF4U2hhZG93cyArKztcblxuICAgIH1cblxuICAgIHJldHVybiBtYXhTaGFkb3dzO1xuXG4gIH1cblxuICAvLyBERVBSRUNBVEVEXG5cbiAgdGhpcy5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfTtcblxuICB0aGlzLmFkZFByZVBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9O1xuXG4gIHRoaXMuYWRkUG9zdFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfTtcblxuICB0aGlzLnVwZGF0ZVNoYWRvd01hcCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgc2hhZG93TWFwRW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xuICAgICAgICBzaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93TWFwVHlwZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzaGFkb3dNYXAudHlwZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBUeXBlIGlzIG5vdyAuc2hhZG93TWFwLnR5cGUuJyApO1xuICAgICAgICBzaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93TWFwQ3VsbEZhY2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hhZG93TWFwLmN1bGxGYWNlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGlzIG5vdyAuc2hhZG93TWFwLmN1bGxGYWNlLicgKTtcbiAgICAgICAgc2hhZG93TWFwLmN1bGxGYWNlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3dNYXBEZWJ1Zzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzaGFkb3dNYXAuZGVidWc7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRGVidWcgaXMgbm93IC5zaGFkb3dNYXAuZGVidWcuJyApO1xuICAgICAgICBzaGFkb3dNYXAuZGVidWcgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvd01hcENhc2NhZGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hhZG93TWFwLmNhc2NhZGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ2FzY2FkZSBpcyBub3cgLnNoYWRvd01hcC5jYXNjYWRlLicgKTtcbiAgICAgICAgc2hhZG93TWFwLmNhc2NhZGUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gKTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0LmpzXG5cbi8qKlxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMud3JhcFMgPSBvcHRpb25zLndyYXBTICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgdGhpcy53cmFwVCA9IG9wdGlvbnMud3JhcFQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gIHRoaXMubWFnRmlsdGVyID0gb3B0aW9ucy5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuICB0aGlzLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICB0aGlzLmFuaXNvdHJvcHkgPSBvcHRpb25zLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pc290cm9weSA6IDE7XG5cbiAgdGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xuICB0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cbiAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xuICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XG5cbiAgdGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xuICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XG5cbiAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXG4gIHRoaXMuc2hhcmVEZXB0aEZyb20gPSBvcHRpb25zLnNoYXJlRGVwdGhGcm9tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNoYXJlRGVwdGhGcm9tIDogbnVsbDtcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxcblxuICBzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBpZiAoIHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgKSB7XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgIH1cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRtcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQgKTtcblxuICAgIHRtcC53cmFwUyA9IHRoaXMud3JhcFM7XG4gICAgdG1wLndyYXBUID0gdGhpcy53cmFwVDtcblxuICAgIHRtcC5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcbiAgICB0bXAubWluRmlsdGVyID0gdGhpcy5taW5GaWx0ZXI7XG5cbiAgICB0bXAuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcblxuICAgIHRtcC5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcbiAgICB0bXAucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cbiAgICB0bXAuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgdG1wLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICB0bXAuZGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoQnVmZmVyO1xuICAgIHRtcC5zdGVuY2lsQnVmZmVyID0gdGhpcy5zdGVuY2lsQnVmZmVyO1xuXG4gICAgdG1wLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgdG1wLnNoYXJlRGVwdGhGcm9tID0gdGhpcy5zaGFyZURlcHRoRnJvbTtcblxuICAgIHJldHVybiB0bXA7XG5cbiAgfSxcblxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXRDdWJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuICBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cbiAgdGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XG5cbiAgICB9XG5cbiAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgc3dpdGNoICggbmFtZSApIHtcblxuICAgICAgY2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuICAgIH1cblxuICAgIGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcblxuICAgIHJldHVybiBleHRlbnNpb247XG5cbiAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMR2VvbWV0cmllcyA9IGZ1bmN0aW9uICggZ2wsIGluZm8gKSB7XG5cbiAgdmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgaWYgKCBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgfVxuXG4gICAgZ2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gZ2VvbWV0cnk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICB9XG5cbiAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG4gICAgcmV0dXJuIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgfTtcblxuICBmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG5cbiAgICBnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cbiAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZS5idWZmZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBnbC5kZWxldGVCdWZmZXIoIGF0dHJpYnV0ZS5idWZmZXIgKTtcblxuICAgICAgICBkZWxldGUgYXR0cmlidXRlLmJ1ZmZlcjtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTE9iamVjdHMuanNcblxuLyoqXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4qL1xuXG5USFJFRS5XZWJHTE9iamVjdHMgPSBmdW5jdGlvbiAoIGdsLCBpbmZvICkge1xuXG4gIHZhciBvYmplY3RzID0ge307XG4gIHZhciBvYmplY3RzSW1tZWRpYXRlID0gW107XG5cbiAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKTtcblxuICB2YXIgZ2VvbWV0cmllcyA9IG5ldyBUSFJFRS5XZWJHTEdlb21ldHJpZXMoIGdsLCBpbmZvICk7XG5cbiAgLy9cblxuICBmdW5jdGlvbiBvbk9iamVjdFJlbW92ZWQoIGV2ZW50ICkge1xuXG4gICAgdmFyIG9iamVjdCA9IGV2ZW50LnRhcmdldDtcblxuICAgIG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuICAgICAgY2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3JlbW92ZScsIG9uT2JqZWN0UmVtb3ZlZCApO1xuICAgICAgcmVtb3ZlT2JqZWN0KCBjaGlsZCApO1xuXG4gICAgfSApO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVPYmplY3QoIG9iamVjdCApIHtcblxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fFxuICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgfHxcbiAgICAgICBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG4gICAgICBkZWxldGUgb2JqZWN0c1sgb2JqZWN0LmlkIF07XG5cbiAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgfHwgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xuXG4gICAgICByZW1vdmVJbnN0YW5jZXMoIG9iamVjdHNJbW1lZGlhdGUsIG9iamVjdCApO1xuXG4gICAgfVxuXG4gICAgZGVsZXRlIG9iamVjdC5fX3dlYmdsSW5pdDtcbiAgICBkZWxldGUgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXg7XG4gICAgZGVsZXRlIG9iamVjdC5fbm9ybWFsTWF0cml4O1xuXG4gICAgZGVsZXRlIG9iamVjdC5fX3dlYmdsQWN0aXZlO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXMoIG9iamxpc3QsIG9iamVjdCApIHtcblxuICAgIGZvciAoIHZhciBvID0gb2JqbGlzdC5sZW5ndGggLSAxOyBvID49IDA7IG8gLS0gKSB7XG5cbiAgICAgIGlmICggb2JqbGlzdFsgbyBdLm9iamVjdCA9PT0gb2JqZWN0ICkge1xuXG4gICAgICAgIG9iamxpc3Quc3BsaWNlKCBvLCAxICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgLy9cblxuICB0aGlzLm9iamVjdHMgPSBvYmplY3RzO1xuICB0aGlzLm9iamVjdHNJbW1lZGlhdGUgPSBvYmplY3RzSW1tZWRpYXRlO1xuXG4gIHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIG9iamVjdC5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBvYmplY3QuX193ZWJnbEluaXQgPSB0cnVlO1xuICAgICAgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgb2JqZWN0Ll9ub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciggJ3JlbW92ZWQnLCBvbk9iamVjdFJlbW92ZWQgKTtcblxuICAgIH1cblxuICAgIGlmICggb2JqZWN0Ll9fd2ViZ2xBY3RpdmUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgb2JqZWN0Ll9fd2ViZ2xBY3RpdmUgPSB0cnVlO1xuXG4gICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkICkge1xuXG4gICAgICAgIG9iamVjdHNbIG9iamVjdC5pZCBdID0ge1xuICAgICAgICAgIGlkOiBvYmplY3QuaWQsXG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgejogMFxuICAgICAgICB9O1xuXG4gICAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgfHwgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xuXG4gICAgICAgIG9iamVjdHNJbW1lZGlhdGUucHVzaCgge1xuICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIG9wYXF1ZTogbnVsbCxcbiAgICAgICAgICB0cmFuc3BhcmVudDogbnVsbCxcbiAgICAgICAgICB6OiAwXG4gICAgICAgIH0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gbnVtZXJpY2FsU29ydCAoIGEsIGIgKSB7XG5cbiAgICByZXR1cm4gYlsgMCBdIC0gYVsgMCBdO1xuXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVPYmplY3QoIG9iamVjdCApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QgKTtcblxuICAgIGlmICggb2JqZWN0Lmdlb21ldHJ5LmR5bmFtaWMgPT09IHRydWUgKSB7XG5cbiAgICAgIGdlb21ldHJ5LnVwZGF0ZUZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgfVxuXG4gICAgLy8gbW9ycGggdGFyZ2V0c1xuXG4gICAgaWYgKCBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBhY3RpdmVJbmZsdWVuY2VzID0gW107XG4gICAgICB2YXIgbW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGluZmx1ZW5jZSA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xuICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLnB1c2goIFsgaW5mbHVlbmNlLCBpIF0gKTtcblxuICAgICAgfVxuXG4gICAgICBhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcblxuICAgICAgaWYgKCBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA+IDggKSB7XG5cbiAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPSA4O1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IGFjdGl2ZUluZmx1ZW5jZXNbIGkgXVsgMCBdO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbIGFjdGl2ZUluZmx1ZW5jZXNbIGkgXVsgMSBdIF07XG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIGF0dHJpYnV0ZSApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgaWYgKCBtYXRlcmlhbC5wcm9ncmFtICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gbnVsbCApIHtcblxuICAgICAgICAgIGdsLnVuaWZvcm0xZnYoIG1hdGVyaWFsLnByb2dyYW0udW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBtb3JwaEluZmx1ZW5jZXMgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVE9GSVg6IG1hdGVyaWFsLnByb2dyYW0gaXMgdW5kZWZpbmVkJyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgdmFyIGJ1ZmZlclR5cGUgPSAoIG5hbWUgPT09ICdpbmRleCcgKSA/IGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogZ2wuQVJSQVlfQlVGRkVSO1xuXG4gICAgICB2YXIgZGF0YSA9ICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXG4gICAgICBpZiAoIGRhdGEuYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZGF0YS5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgZGF0YS5idWZmZXIgKTtcblxuICAgICAgICB2YXIgdXNhZ2UgPSBnbC5TVEFUSUNfRFJBVztcblxuICAgICAgICBpZiAoIGRhdGEgaW5zdGFuY2VvZiBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlXG4gICAgICAgICAgICAgfHwgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICYmIGRhdGEuZHluYW1pYyA9PT0gdHJ1ZSApXG4gICAgICAgICAgICAgfHwgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIgJiYgZGF0YS5keW5hbWljID09PSB0cnVlICkgKSB7XG5cbiAgICAgICAgICB1c2FnZSA9IGdsLkRZTkFNSUNfRFJBVztcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgZGF0YS5hcnJheSwgdXNhZ2UgKTtcblxuICAgICAgICBkYXRhLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGRhdGEubmVlZHNVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgZGF0YS5idWZmZXIgKTtcblxuICAgICAgICBpZiAoIGRhdGEudXBkYXRlUmFuZ2UgPT09IHVuZGVmaW5lZCB8fCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAtMSApIHsgLy8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcblxuICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGRhdGEuYXJyYXkgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xuXG4gICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIudXBkYXRlT2JqZWN0OiB1c2luZyB1cGRhdGVSYW5nZSBmb3IgVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBhbmQgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCBjb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgICAgICAgICAgICBkYXRhLmFycmF5LnN1YmFycmF5KCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKyBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcblxuICAgICAgICAgIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPSAwOyAvLyByZXNldCByYW5nZVxuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCByZW5kZXJMaXN0ICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCB1bCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgdWw7IGkrKyApIHtcblxuICAgICAgdmFyIG9iamVjdCA9IHJlbmRlckxpc3RbaV0ub2JqZWN0O1xuXG4gICAgICBpZiAoIG9iamVjdC5tYXRlcmlhbC52aXNpYmxlICE9PSBmYWxzZSApIHtcblxuICAgICAgICB1cGRhdGVPYmplY3QoIG9iamVjdCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbS5qc1xuXG5USFJFRS5XZWJHTFByb2dyYW0gPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcblxuICAgIHZhciBjaHVua3MgPSBbXTtcblxuICAgIGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcblxuICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgICAgY2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cblxuICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuXG4gICAgdmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cbiAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSAsIGkgKTtcbiAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cbiAgICAgIC8vY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBVTklGT1JNOlwiLCBuYW1lKTtcblxuICAgICAgdmFyIHN1ZmZpeFBvcyA9IG5hbWUubGFzdEluZGV4T2YoICdbMF0nICk7XG4gICAgICBpZiAoIHN1ZmZpeFBvcyAhPT0gLTEgJiYgc3VmZml4UG9zID09PSBuYW1lLmxlbmd0aCAtIDMgKSB7XG5cbiAgICAgICAgdW5pZm9ybXNbIG5hbWUuc3Vic3RyKCAwLCBzdWZmaXhQb3MgKSBdID0gbG9jYXRpb247XG5cbiAgICAgIH1cblxuICAgICAgdW5pZm9ybXNbIG5hbWUgXSA9IGxvY2F0aW9uO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xuXG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cbiAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtICwgaSApO1xuICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWU7XG5cbiAgICAgIC8vY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lKTtcblxuICAgICAgYXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuXG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcblxuICAgIHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG4gICAgdmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xuICAgIHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzO1xuXG4gICAgdmFyIHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudmVydGV4U2hhZGVyO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIuZnJhZ21lbnRTaGFkZXI7XG5cbiAgICB2YXIgaW5kZXgwQXR0cmlidXRlTmFtZSA9IG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWU7XG5cbiAgICAvKlxuICAgIGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSA9PT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG4gICAgICAvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblxuICAgICAgaW5kZXgwQXR0cmlidXRlTmFtZSA9ICdwb3NpdGlvbic7XG5cbiAgICB9XG4gICAgKi9cblxuICAgIHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcblxuICAgIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XG5cbiAgICAgIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblxuICAgIH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcblxuICAgICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCc7XG5cbiAgICB9XG5cbiAgICB2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcbiAgICB2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcbiAgICB2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblxuICAgIGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XG5cbiAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG4gICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9FUVVJUkVDJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxuICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfU1BIRVJFJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRlJBQ1RJT04nO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjpcbiAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVEhSRUUuTWl4T3BlcmF0aW9uOlxuICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVEhSRUUuQWRkT3BlcmF0aW9uOlxuICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ2J1aWxkaW5nIG5ldyBwcm9ncmFtICcgKTtcblxuICAgIC8vXG5cbiAgICB2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG4gICAgLy9cblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cbiAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cbiAgICAgIHByZWZpeFZlcnRleCA9ICcnO1xuICAgICAgcHJlZml4RnJhZ21lbnQgPSAnJztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHByZWZpeFZlcnRleCA9IFtcblxuICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG4gICAgICAgIGN1c3RvbURlZmluZXMsXG5cbiAgICAgICAgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTJyA6ICcnLFxuXG4gICAgICAgIHJlbmRlcmVyLmdhbW1hSW5wdXQgPyAnI2RlZmluZSBHQU1NQV9JTlBVVCcgOiAnJyxcbiAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXG4gICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICAgICAgJyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxuICAgICAgICAnI2RlZmluZSBNQVhfUE9JTlRfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuICAgICAgICAnI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXG5cbiAgICAgICAgJyNkZWZpbmUgTUFYX1NIQURPV1MgJyArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuICAgICAgICAnI2RlZmluZSBNQVhfQk9ORVMgJyArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXG5cbiAgICAgICAgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJzogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBDYXNjYWRlID8gJyNkZWZpbmUgU0hBRE9XTUFQX0NBU0NBREUnIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyAnI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCdFWFRfZnJhZ19kZXB0aCcpID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXG4gICAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cbiAgICAgICAgJyNpZmRlZiBVU0VfQ09MT1InLFxuXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgY29sb3I7JyxcblxuICAgICAgICAnI2VuZGlmJyxcblxuICAgICAgICAnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxuXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXG5cbiAgICAgICAgJyAjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXG5cbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JyxcbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxuXG4gICAgICAgICcgI2Vsc2UnLFxuXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcblxuICAgICAgICAnICNlbmRpZicsXG5cbiAgICAgICAgJyNlbmRpZicsXG5cbiAgICAgICAgJyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxuXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxuXG4gICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICdcXG4nXG5cbiAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgICBwcmVmaXhGcmFnbWVudCA9IFtcblxuICAgICAgICAoIHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nIHx8IG1hdGVyaWFsLmRlcml2YXRpdmVzICkgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXG5cbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG4gICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcblxuICAgICAgICBjdXN0b21EZWZpbmVzLFxuXG4gICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG4gICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cbiAgICAgICAgcGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogJycsXG5cbiAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxuICAgICAgICByZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcbiAgICAgICAgJyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuICAgICAgICAoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxuICAgICAgICAoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCc6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMubWV0YWwgPyAnI2RlZmluZSBNRVRBTCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/ICcjZGVmaW5lIFNIQURPV01BUF9DQVNDQURFJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCdFWFRfZnJhZ19kZXB0aCcpID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgICAgICdcXG4nXG5cbiAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgfVxuXG4gICAgdmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG4gICAgdmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cbiAgICB2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBuZXcgVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG4gICAgdmFyIGdsRnJhZ21lbnRTaGFkZXIgPSBuZXcgVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgaWYgKCBpbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cbiAgICAgIC8vIGJlY2F1c2UgcG90ZW50aWFsbHkgZXhwZW5zaXZlIGVtdWxhdGlvbiBpcyBkb25lIGJ5IGJyb3dzZXIgaWYgYXR0cmlidXRlIDAgaXMgZGlzYWJsZWQuXG4gICAgICAvLyBBbmQsIGNvbG9yLCBmb3IgZXhhbXBsZSBpcyBvZnRlbiBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIGluZGV4IDAgc28gZGlzYWJsaW5nIGl0XG5cbiAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgaW5kZXgwQXR0cmlidXRlTmFtZSApO1xuXG4gICAgfVxuXG4gICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIHZhciBwcm9ncmFtTG9nSW5mbyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XG4gICAgdmFyIHZlcnRleEVycm9yTG9nSW5mbyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsVmVydGV4U2hhZGVyICk7XG4gICAgdmFyIGZyYWdtZW50RXJyb3JMb2dJbmZvID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgaWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2dJbmZvLCB2ZXJ0ZXhFcnJvckxvZ0luZm8sIGZyYWdtZW50RXJyb3JMb2dJbmZvICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHByb2dyYW1Mb2dJbmZvICE9PSAnJyApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZ0luZm8gKTtcblxuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwXG5cbiAgICBnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICAvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcblxuICAgIHZhciBnZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fY2FjaGVkVW5pZm9ybXM7IH07XG5cbiAgICB0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIC8vIGZldGNoLCBjYWNoZSwgYW5kIG5leHQgdGltZSBqdXN0IHVzZSBhIGR1bWIgYWNjZXNzb3JcbiAgICAgIHZhciB1bmlmb3JtcyA9IGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcbiAgICAgIHRoaXMuX2NhY2hlZFVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgICB0aGlzLmdldFVuaWZvcm1zID0gZ2V0VW5pZm9ybXM7XG4gICAgICByZXR1cm4gdW5pZm9ybXM7XG5cbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcblxuICAgIHZhciBnZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jYWNoZWRBdHRyaWJ1dGVzOyB9O1xuXG4gICAgdGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG4gICAgICB0aGlzLl9jYWNoZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXM7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICAgIH07XG5cbiAgICAvLyBERVBSRUNBVEVEXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcblxuXG4gICAgLy9cblxuICAgIHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMudXNlZFRpbWVzID0gMTtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZGVyLmpzXG5cblRIUkVFLldlYkdMU2hhZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGFkZExpbmVOdW1iZXJzID0gZnVuY3Rpb24gKCBzdHJpbmcgKSB7XG5cbiAgICB2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggZ2wsIHR5cGUsIHN0cmluZyApIHtcblxuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTtcblxuICAgIGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcblxuICAgIGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cbiAgICB9XG5cbiAgICAvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuICAgIC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuXG4gIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkb3dNYXAuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XZWJHTFNoYWRvd01hcCA9IGZ1bmN0aW9uICggX3JlbmRlcmVyLCBfbGlnaHRzLCBfb2JqZWN0cyApIHtcblxuICB2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXG4gIF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcbiAgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gIF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICBfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICBfd2ViZ2xPYmplY3RzID0gX29iamVjdHMub2JqZWN0cyxcbiAgX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSA9IF9vYmplY3RzLm9iamVjdHNJbW1lZGlhdGUsXG5cbiAgX21hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICBfcmVuZGVyTGlzdCA9IFtdO1xuXG4gIC8vIGluaXRcblxuICB2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcbiAgdmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xuXG4gIHZhciBfZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlclxuICAgfSApO1xuXG4gIHZhciBfZGVwdGhNYXRlcmlhbE1vcnBoID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgIG1vcnBoVGFyZ2V0czogdHJ1ZVxuICB9ICk7XG5cbiAgdmFyIF9kZXB0aE1hdGVyaWFsU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICBza2lubmluZzogdHJ1ZVxuICB9ICk7XG5cbiAgdmFyIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgIG1vcnBoVGFyZ2V0czogdHJ1ZSxcbiAgICBza2lubmluZzogdHJ1ZVxuICB9ICk7XG5cbiAgX2RlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuICBfZGVwdGhNYXRlcmlhbE1vcnBoLl9zaGFkb3dQYXNzID0gdHJ1ZTtcbiAgX2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcbiAgX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG4gIC8vXG5cbiAgdmFyIHNjb3BlID0gdGhpcztcblxuICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgdGhpcy50eXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xuICB0aGlzLmN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICB0aGlzLmNhc2NhZGUgPSBmYWxzZTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcblxuICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICB2YXIgaSwgaWwsIGosIGpsLCBuLFxuXG4gICAgc2hhZG93TWFwLCBzaGFkb3dNYXRyaXgsIHNoYWRvd0NhbWVyYSxcbiAgICB3ZWJnbE9iamVjdCwgb2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsXG5cbiAgICBsaWdodHMgPSBbXSxcbiAgICBrID0gMCxcblxuICAgIGZvZyA9IG51bGw7XG5cbiAgICAvLyBzZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcFxuXG4gICAgX2dsLmNsZWFyQ29sb3IoIDEsIDEsIDEsIDEgKTtcbiAgICBfZ2wuZGlzYWJsZSggX2dsLkJMRU5EICk7XG5cbiAgICBfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG4gICAgX2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG4gICAgaWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuICAgIH1cblxuICAgIF9yZW5kZXJlci5zdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcblxuICAgIC8vIHByZXByb2Nlc3MgbGlnaHRzXG4gICAgLy8gIC0gc2tpcCBsaWdodHMgdGhhdCBhcmUgbm90IGNhc3Rpbmcgc2hhZG93c1xuICAgIC8vICAtIGNyZWF0ZSB2aXJ0dWFsIGxpZ2h0cyBmb3IgY2FzY2FkZWQgc2hhZG93IG1hcHNcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGxpZ2h0ID0gX2xpZ2h0c1sgaSBdO1xuXG4gICAgICBpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgJiYgbGlnaHQuc2hhZG93Q2FzY2FkZSApIHtcblxuICAgICAgICBmb3IgKCBuID0gMDsgbiA8IGxpZ2h0LnNoYWRvd0Nhc2NhZGVDb3VudDsgbiArKyApIHtcblxuICAgICAgICAgIHZhciB2aXJ0dWFsTGlnaHQ7XG5cbiAgICAgICAgICBpZiAoICEgbGlnaHQuc2hhZG93Q2FzY2FkZUFycmF5WyBuIF0gKSB7XG5cbiAgICAgICAgICAgIHZpcnR1YWxMaWdodCA9IGNyZWF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcbiAgICAgICAgICAgIHZpcnR1YWxMaWdodC5vcmlnaW5hbENhbWVyYSA9IGNhbWVyYTtcblxuICAgICAgICAgICAgdmFyIGd5cm8gPSBuZXcgVEhSRUUuR3lyb3Njb3BlKCk7XG4gICAgICAgICAgICBneXJvLnBvc2l0aW9uLmNvcHkoIGxpZ2h0LnNoYWRvd0Nhc2NhZGVPZmZzZXQgKTtcblxuICAgICAgICAgICAgZ3lyby5hZGQoIHZpcnR1YWxMaWdodCApO1xuICAgICAgICAgICAgZ3lyby5hZGQoIHZpcnR1YWxMaWdodC50YXJnZXQgKTtcblxuICAgICAgICAgICAgY2FtZXJhLmFkZCggZ3lybyApO1xuXG4gICAgICAgICAgICBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXSA9IHZpcnR1YWxMaWdodDtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggXCJDcmVhdGVkIHZpcnR1YWxMaWdodFwiLCB2aXJ0dWFsTGlnaHQgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZpcnR1YWxMaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgbiBdO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgbiApO1xuXG4gICAgICAgICAgbGlnaHRzWyBrIF0gPSB2aXJ0dWFsTGlnaHQ7XG4gICAgICAgICAgayArKztcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbGlnaHRzWyBrIF0gPSBsaWdodDtcbiAgICAgICAgayArKztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIGRlcHRoIG1hcFxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG4gICAgICBpZiAoICEgbGlnaHQuc2hhZG93TWFwICkge1xuXG4gICAgICAgIHZhciBzaGFkb3dGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgaWYgKCBzY29wZS50eXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG4gICAgICAgICAgc2hhZG93RmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogc2hhZG93RmlsdGVyLCBtYWdGaWx0ZXI6IHNoYWRvd0ZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0IH07XG5cbiAgICAgICAgbGlnaHQuc2hhZG93TWFwID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0LCBwYXJzICk7XG4gICAgICAgIGxpZ2h0LnNoYWRvd01hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCApO1xuXG4gICAgICAgIGxpZ2h0LnNoYWRvd01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCAhIGxpZ2h0LnNoYWRvd0NhbWVyYSApIHtcblxuICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xuXG4gICAgICAgICAgbGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBsaWdodC5zaGFkb3dDYW1lcmFGb3YsIGxpZ2h0LnNoYWRvd01hcFdpZHRoIC8gbGlnaHQuc2hhZG93TWFwSGVpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cbiAgICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBsaWdodC5zaGFkb3dDYW1lcmFMZWZ0LCBsaWdodC5zaGFkb3dDYW1lcmFSaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhVG9wLCBsaWdodC5zaGFkb3dDYW1lcmFCb3R0b20sIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLlNoYWRvd01hcFBsdWdpbjogVW5zdXBwb3J0ZWQgbGlnaHQgdHlwZSBmb3Igc2hhZG93XCIsIGxpZ2h0ICk7XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHNjZW5lLmFkZCggbGlnaHQuc2hhZG93Q2FtZXJhICk7XG5cbiAgICAgICAgaWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgJiYgISBsaWdodC5jYW1lcmFIZWxwZXIgKSB7XG5cbiAgICAgICAgbGlnaHQuY2FtZXJhSGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggbGlnaHQuc2hhZG93Q2FtZXJhICk7XG4gICAgICAgIHNjZW5lLmFkZCggbGlnaHQuY2FtZXJhSGVscGVyICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBsaWdodC5pc1ZpcnR1YWwgJiYgdmlydHVhbExpZ2h0Lm9yaWdpbmFsQ2FtZXJhID09IGNhbWVyYSApIHtcblxuICAgICAgICB1cGRhdGVTaGFkb3dDYW1lcmEoIGNhbWVyYSwgbGlnaHQgKTtcblxuICAgICAgfVxuXG4gICAgICBzaGFkb3dNYXAgPSBsaWdodC5zaGFkb3dNYXA7XG4gICAgICBzaGFkb3dNYXRyaXggPSBsaWdodC5zaGFkb3dNYXRyaXg7XG4gICAgICBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmE7XG5cbiAgICAgIC8vXG5cbiAgICAgIHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICBfbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgIHNoYWRvd0NhbWVyYS5sb29rQXQoIF9tYXRyaXhQb3NpdGlvbiApO1xuICAgICAgc2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGlmICggbGlnaHQuY2FtZXJhSGVscGVyICkgbGlnaHQuY2FtZXJhSGVscGVyLnZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuICAgICAgaWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICkgbGlnaHQuY2FtZXJhSGVscGVyLnVwZGF0ZSgpO1xuXG4gICAgICAvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcblxuICAgICAgc2hhZG93TWF0cml4LnNldChcbiAgICAgICAgMC41LCAwLjAsIDAuMCwgMC41LFxuICAgICAgICAwLjAsIDAuNSwgMC4wLCAwLjUsXG4gICAgICAgIDAuMCwgMC4wLCAwLjUsIDAuNSxcbiAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wXG4gICAgICApO1xuXG4gICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG4gICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgICAgLy8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG4gICAgICBfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgICAgX2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgICAgLy8gcmVuZGVyIHNoYWRvdyBtYXBcblxuICAgICAgX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG4gICAgICBfcmVuZGVyZXIuY2xlYXIoKTtcblxuICAgICAgLy8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xuXG4gICAgICBfcmVuZGVyTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgICBwcm9qZWN0T2JqZWN0KCBzY2VuZSwgc2hhZG93Q2FtZXJhICk7XG5cblxuICAgICAgLy8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xuXG4gICAgICB2YXIgb2JqZWN0TWF0ZXJpYWwsIHVzZU1vcnBoaW5nLCB1c2VTa2lubmluZztcblxuICAgICAgZm9yICggaiA9IDAsIGpsID0gX3JlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgd2ViZ2xPYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xuXG4gICAgICAgIG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuICAgICAgICAvLyBjdWxsaW5nIGlzIG92ZXJyaWRlbiBnbG9iYWxseSBmb3IgYWxsIG9iamVjdHNcbiAgICAgICAgLy8gd2hpbGUgcmVuZGVyaW5nIGRlcHRoIG1hcFxuXG4gICAgICAgIC8vIG5lZWQgdG8gZGVhbCB3aXRoIE1lc2hGYWNlTWF0ZXJpYWwgc29tZWhvd1xuICAgICAgICAvLyBpbiB0aGF0IGNhc2UganVzdCB1c2UgdGhlIGZpcnN0IG9mIG1hdGVyaWFsLm1hdGVyaWFscyBmb3Igbm93XG4gICAgICAgIC8vIChwcm9wZXIgc29sdXRpb24gd291bGQgcmVxdWlyZSB0byBicmVhayBvYmplY3RzIGJ5IG1hdGVyaWFsc1xuICAgICAgICAvLyAgc2ltaWxhcmx5IHRvIHJlZ3VsYXIgcmVuZGVyaW5nIGFuZCB0aGVuIHNldCBjb3JyZXNwb25kaW5nXG4gICAgICAgIC8vICBkZXB0aCBtYXRlcmlhbHMgcGVyIGVhY2ggY2h1bmsgaW5zdGVhZCBvZiBqdXN0IG9uY2UgcGVyIG9iamVjdClcblxuICAgICAgICBvYmplY3RNYXRlcmlhbCA9IGdldE9iamVjdE1hdGVyaWFsKCBvYmplY3QgKTtcblxuICAgICAgICB1c2VNb3JwaGluZyA9IG9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgJiYgb2JqZWN0TWF0ZXJpYWwubW9ycGhUYXJnZXRzO1xuICAgICAgICB1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG9iamVjdE1hdGVyaWFsLnNraW5uaW5nO1xuXG4gICAgICAgIGlmICggb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICBtYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIHVzZVNraW5uaW5nICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwgPSB1c2VNb3JwaGluZyA/IF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luIDogX2RlcHRoTWF0ZXJpYWxTa2luO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIHVzZU1vcnBoaW5nICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbE1vcnBoO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfcmVuZGVyZXIuc2V0TWF0ZXJpYWxGYWNlcyggb2JqZWN0TWF0ZXJpYWwgKTtcbiAgICAgICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBzZXQgbWF0cmljZXMgYW5kIHJlbmRlciBpbW1lZGlhdGUgb2JqZWN0c1xuXG4gICAgICBmb3IgKCBqID0gMCwgamwgPSBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHdlYmdsT2JqZWN0ID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZVsgaiBdO1xuICAgICAgICBvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cbiAgICAgICAgaWYgKCBvYmplY3QudmlzaWJsZSAmJiBvYmplY3QuY2FzdFNoYWRvdyApIHtcblxuICAgICAgICAgIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgX3JlbmRlcmVyLnJlbmRlckltbWVkaWF0ZU9iamVjdCggc2hhZG93Q2FtZXJhLCBfbGlnaHRzLCBmb2csIF9kZXB0aE1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgR0wgc3RhdGVcblxuICAgIHZhciBjbGVhckNvbG9yID0gX3JlbmRlcmVyLmdldENsZWFyQ29sb3IoKSxcbiAgICBjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcblxuICAgIF9nbC5jbGVhckNvbG9yKCBjbGVhckNvbG9yLnIsIGNsZWFyQ29sb3IuZywgY2xlYXJDb2xvci5iLCBjbGVhckFscGhhICk7XG4gICAgX2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XG5cbiAgICBpZiAoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG4gICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cbiAgICB9XG5cbiAgICBfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIHNoYWRvd0NhbWVyYSApIHtcblxuICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgIHZhciB3ZWJnbE9iamVjdCA9IF9vYmplY3RzLm9iamVjdHNbIG9iamVjdC5pZCBdO1xuXG4gICAgICBpZiAoIHdlYmdsT2JqZWN0ICYmIG9iamVjdC5jYXN0U2hhZG93ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XG5cbiAgICAgICAgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIF9yZW5kZXJMaXN0LnB1c2goIHdlYmdsT2JqZWN0ICk7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgcHJvamVjdE9iamVjdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0sIHNoYWRvd0NhbWVyYSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIGNhc2NhZGUgKSB7XG5cbiAgICB2YXIgdmlydHVhbExpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoKTtcblxuICAgIHZpcnR1YWxMaWdodC5pc1ZpcnR1YWwgPSB0cnVlO1xuXG4gICAgdmlydHVhbExpZ2h0Lm9ubHlTaGFkb3cgPSB0cnVlO1xuICAgIHZpcnR1YWxMaWdodC5jYXN0U2hhZG93ID0gdHJ1ZTtcblxuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gbGlnaHQuc2hhZG93Q2FtZXJhTmVhcjtcbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhRmFyID0gbGlnaHQuc2hhZG93Q2FtZXJhRmFyO1xuXG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUxlZnQgPSBsaWdodC5zaGFkb3dDYW1lcmFMZWZ0O1xuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFSaWdodCA9IGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0O1xuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFCb3R0b20gPSBsaWdodC5zaGFkb3dDYW1lcmFCb3R0b207XG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVRvcCA9IGxpZ2h0LnNoYWRvd0NhbWVyYVRvcDtcblxuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dEYXJrbmVzcyA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xuXG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3dDYXNjYWRlQmlhc1sgY2FzY2FkZSBdO1xuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dNYXBXaWR0aCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVXaWR0aFsgY2FzY2FkZSBdO1xuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dNYXBIZWlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlSGVpZ2h0WyBjYXNjYWRlIF07XG5cbiAgICB2aXJ0dWFsTGlnaHQucG9pbnRzV29ybGQgPSBbXTtcbiAgICB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bSA9IFtdO1xuXG4gICAgdmFyIHBvaW50c1dvcmxkID0gdmlydHVhbExpZ2h0LnBvaW50c1dvcmxkLFxuICAgICAgcG9pbnRzRnJ1c3R1bSA9IHZpcnR1YWxMaWdodC5wb2ludHNGcnVzdHVtO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgODsgaSArKyApIHtcblxuICAgICAgcG9pbnRzV29ybGRbIGkgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBwb2ludHNGcnVzdHVtWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgfVxuXG4gICAgdmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XG4gICAgdmFyIGZhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlRmFyWlsgY2FzY2FkZSBdO1xuXG4gICAgcG9pbnRzRnJ1c3R1bVsgMCBdLnNldCggLSAxLCAtIDEsIG5lYXJaICk7XG4gICAgcG9pbnRzRnJ1c3R1bVsgMSBdLnNldCggIDEsIC0gMSwgbmVhclogKTtcbiAgICBwb2ludHNGcnVzdHVtWyAyIF0uc2V0KCAtIDEsICAxLCBuZWFyWiApO1xuICAgIHBvaW50c0ZydXN0dW1bIDMgXS5zZXQoICAxLCAgMSwgbmVhclogKTtcblxuICAgIHBvaW50c0ZydXN0dW1bIDQgXS5zZXQoIC0gMSwgLSAxLCBmYXJaICk7XG4gICAgcG9pbnRzRnJ1c3R1bVsgNSBdLnNldCggIDEsIC0gMSwgZmFyWiApO1xuICAgIHBvaW50c0ZydXN0dW1bIDYgXS5zZXQoIC0gMSwgIDEsIGZhclogKTtcbiAgICBwb2ludHNGcnVzdHVtWyA3IF0uc2V0KCAgMSwgIDEsIGZhclogKTtcblxuICAgIHJldHVybiB2aXJ0dWFsTGlnaHQ7XG5cbiAgfVxuXG4gIC8vIFN5bmNocm9uaXplIHZpcnR1YWwgbGlnaHQgd2l0aCB0aGUgb3JpZ2luYWwgbGlnaHRcblxuICBmdW5jdGlvbiB1cGRhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xuXG4gICAgdmFyIHZpcnR1YWxMaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgY2FzY2FkZSBdO1xuXG4gICAgdmlydHVhbExpZ2h0LnBvc2l0aW9uLmNvcHkoIGxpZ2h0LnBvc2l0aW9uICk7XG4gICAgdmlydHVhbExpZ2h0LnRhcmdldC5wb3NpdGlvbi5jb3B5KCBsaWdodC50YXJnZXQucG9zaXRpb24gKTtcbiAgICB2aXJ0dWFsTGlnaHQubG9va0F0KCB2aXJ0dWFsTGlnaHQudGFyZ2V0ICk7XG5cbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0RhcmtuZXNzID0gbGlnaHQuc2hhZG93RGFya25lc3M7XG5cbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93QmlhcyA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVCaWFzWyBjYXNjYWRlIF07XG5cbiAgICB2YXIgbmVhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlTmVhclpbIGNhc2NhZGUgXTtcbiAgICB2YXIgZmFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaWyBjYXNjYWRlIF07XG5cbiAgICB2YXIgcG9pbnRzRnJ1c3R1bSA9IHZpcnR1YWxMaWdodC5wb2ludHNGcnVzdHVtO1xuXG4gICAgcG9pbnRzRnJ1c3R1bVsgMCBdLnogPSBuZWFyWjtcbiAgICBwb2ludHNGcnVzdHVtWyAxIF0ueiA9IG5lYXJaO1xuICAgIHBvaW50c0ZydXN0dW1bIDIgXS56ID0gbmVhclo7XG4gICAgcG9pbnRzRnJ1c3R1bVsgMyBdLnogPSBuZWFyWjtcblxuICAgIHBvaW50c0ZydXN0dW1bIDQgXS56ID0gZmFyWjtcbiAgICBwb2ludHNGcnVzdHVtWyA1IF0ueiA9IGZhclo7XG4gICAgcG9pbnRzRnJ1c3R1bVsgNiBdLnogPSBmYXJaO1xuICAgIHBvaW50c0ZydXN0dW1bIDcgXS56ID0gZmFyWjtcblxuICB9XG5cbiAgLy8gRml0IHNoYWRvdyBjYW1lcmEncyBvcnRobyBmcnVzdHVtIHRvIGNhbWVyYSBmcnVzdHVtXG5cbiAgZnVuY3Rpb24gdXBkYXRlU2hhZG93Q2FtZXJhKCBjYW1lcmEsIGxpZ2h0ICkge1xuXG4gICAgdmFyIHNoYWRvd0NhbWVyYSA9IGxpZ2h0LnNoYWRvd0NhbWVyYSxcbiAgICAgIHBvaW50c0ZydXN0dW0gPSBsaWdodC5wb2ludHNGcnVzdHVtLFxuICAgICAgcG9pbnRzV29ybGQgPSBsaWdodC5wb2ludHNXb3JsZDtcblxuICAgIF9taW4uc2V0KCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XG4gICAgX21heC5zZXQoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cbiAgICAgIHZhciBwID0gcG9pbnRzV29ybGRbIGkgXTtcblxuICAgICAgcC5jb3B5KCBwb2ludHNGcnVzdHVtWyBpIF0gKTtcbiAgICAgIHAudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgICAgcC5hcHBseU1hdHJpeDQoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgICAgaWYgKCBwLnggPCBfbWluLnggKSBfbWluLnggPSBwLng7XG4gICAgICBpZiAoIHAueCA+IF9tYXgueCApIF9tYXgueCA9IHAueDtcblxuICAgICAgaWYgKCBwLnkgPCBfbWluLnkgKSBfbWluLnkgPSBwLnk7XG4gICAgICBpZiAoIHAueSA+IF9tYXgueSApIF9tYXgueSA9IHAueTtcblxuICAgICAgaWYgKCBwLnogPCBfbWluLnogKSBfbWluLnogPSBwLno7XG4gICAgICBpZiAoIHAueiA+IF9tYXgueiApIF9tYXgueiA9IHAuejtcblxuICAgIH1cblxuICAgIHNoYWRvd0NhbWVyYS5sZWZ0ID0gX21pbi54O1xuICAgIHNoYWRvd0NhbWVyYS5yaWdodCA9IF9tYXgueDtcbiAgICBzaGFkb3dDYW1lcmEudG9wID0gX21heC55O1xuICAgIHNoYWRvd0NhbWVyYS5ib3R0b20gPSBfbWluLnk7XG5cbiAgICAvLyBjYW4ndCByZWFsbHkgZml0IG5lYXIvZmFyXG4gICAgLy9zaGFkb3dDYW1lcmEubmVhciA9IF9taW4uejtcbiAgICAvL3NoYWRvd0NhbWVyYS5mYXIgPSBfbWF4Lno7XG5cbiAgICBzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gIH1cblxuICAvLyBGb3IgdGhlIG1vbWVudCBqdXN0IGlnbm9yZSBvYmplY3RzIHRoYXQgaGF2ZSBtdWx0aXBsZSBtYXRlcmlhbHMgd2l0aCBkaWZmZXJlbnQgYW5pbWF0aW9uIG1ldGhvZHNcbiAgLy8gT25seSB0aGUgZmlyc3QgbWF0ZXJpYWwgd2lsbCBiZSB0YWtlbiBpbnRvIGFjY291bnQgZm9yIGRlY2lkaW5nIHdoaWNoIGRlcHRoIG1hdGVyaWFsIHRvIHVzZSBmb3Igc2hhZG93IG1hcHNcblxuICBmdW5jdGlvbiBnZXRPYmplY3RNYXRlcmlhbCggb2JqZWN0ICkge1xuXG4gICAgcmV0dXJuIG9iamVjdC5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWxcbiAgICAgID8gb2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFsc1sgMCBdXG4gICAgICA6IG9iamVjdC5tYXRlcmlhbDtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFN0YXRlLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xTdGF0ZSA9IGZ1bmN0aW9uICggZ2wsIHBhcmFtVGhyZWVUb0dMICkge1xuXG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcbiAgdmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG5cbiAgdmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG4gIHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcbiAgdmFyIGN1cnJlbnREZXB0aFRlc3QgPSBudWxsO1xuICB2YXIgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xuXG4gIHZhciBjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XG5cbiAgdmFyIGN1cnJlbnREb3VibGVTaWRlZCA9IG51bGw7XG4gIHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuICB2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cbiAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xuXG4gIHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuICB2YXIgY3VycmVudFRleHR1cmVTbG90ID0gdW5kZWZpbmVkO1xuICB2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuICB0aGlzLmluaXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBuZXdBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5lbmFibGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGF0dHJpYnV0ZSApIHtcblxuICAgIG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG4gICAgICBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRCbGVuZGluZyA9IGZ1bmN0aW9uICggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhICkge1xuXG4gICAgaWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nICkge1xuXG4gICAgICBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5Ob0JsZW5kaW5nICkge1xuXG4gICAgICAgIGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xuXG4gICAgICAgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcblxuICAgICAgICAvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cbiAgICAgICAgZ2wuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuICAgICAgfSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XG5cbiAgICAgICAgLy8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG4gICAgICAgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcblxuICAgICAgfSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG4gICAgICAgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXG4gICAgfVxuXG4gICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cbiAgICAgIGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuICAgICAgYmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG4gICAgICBibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcblxuICAgICAgaWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcblxuICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG4gICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XG5cbiAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xuXG4gICAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuICAgICAgICBjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcbiAgICAgICAgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuICAgICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcbiAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldERlcHRoRnVuYyA9IGZ1bmN0aW9uICggZGVwdGhGdW5jICkge1xuXG4gICAgICBpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgIGlmICggZGVwdGhGdW5jICkge1xuXG4gICAgICAgICAgICAgIHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5OZXZlckRlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkFsd2F5c0RlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5MZXNzRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5MZXNzRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuR3JlYXRlckRlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTm90RXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcblxuICAgICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcblxuICAgIGlmICggY3VycmVudERlcHRoVGVzdCAhPT0gZGVwdGhUZXN0ICkge1xuXG4gICAgICBpZiAoIGRlcHRoVGVzdCApIHtcblxuICAgICAgICBnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBnbC5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgIH1cblxuICAgICAgY3VycmVudERlcHRoVGVzdCA9IGRlcHRoVGVzdDtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcblxuICAgIGlmICggY3VycmVudERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XG5cbiAgICAgIGdsLmRlcHRoTWFzayggZGVwdGhXcml0ZSApO1xuICAgICAgY3VycmVudERlcHRoV3JpdGUgPSBkZXB0aFdyaXRlO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRDb2xvcldyaXRlID0gZnVuY3Rpb24gKCBjb2xvcldyaXRlICkge1xuXG4gICAgaWYgKCBjdXJyZW50Q29sb3JXcml0ZSAhPT0gY29sb3JXcml0ZSApIHtcblxuICAgICAgZ2wuY29sb3JNYXNrKCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlICk7XG4gICAgICBjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldERvdWJsZVNpZGVkID0gZnVuY3Rpb24gKCBkb3VibGVTaWRlZCApIHtcblxuICAgIGlmICggY3VycmVudERvdWJsZVNpZGVkICE9PSBkb3VibGVTaWRlZCApIHtcblxuICAgICAgaWYgKCBkb3VibGVTaWRlZCApIHtcblxuICAgICAgICBnbC5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBnbC5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREb3VibGVTaWRlZCA9IGRvdWJsZVNpZGVkO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRGbGlwU2lkZWQgPSBmdW5jdGlvbiAoIGZsaXBTaWRlZCApIHtcblxuICAgIGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xuXG4gICAgICBpZiAoIGZsaXBTaWRlZCApIHtcblxuICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNXICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcblxuICAgICAgfVxuXG4gICAgICBjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRMaW5lV2lkdGggPSBmdW5jdGlvbiAoIHdpZHRoICkge1xuXG4gICAgaWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcblxuICAgICAgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xuXG4gICAgICBjdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldFBvbHlnb25PZmZzZXQgPSBmdW5jdGlvbiAoIHBvbHlnb25vZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XG5cbiAgICBpZiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0ICE9PSBwb2x5Z29ub2Zmc2V0ICkge1xuXG4gICAgICBpZiAoIHBvbHlnb25vZmZzZXQgKSB7XG5cbiAgICAgICAgZ2wuZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wuZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0ID0gcG9seWdvbm9mZnNldDtcblxuICAgIH1cblxuICAgIGlmICggcG9seWdvbm9mZnNldCAmJiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSApIHtcblxuICAgICAgZ2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG4gICAgICBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcbiAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcblxuICAgIH1cblxuICB9O1xuXG4gIC8vIHRleHR1cmVcblxuICB0aGlzLmFjdGl2ZVRleHR1cmUgPSBmdW5jdGlvbiAoIHdlYmdsU2xvdCApIHtcblxuICAgIGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcblxuICAgIGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XG5cbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xuICAgICAgY3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmJpbmRUZXh0dXJlID0gZnVuY3Rpb24gKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSApIHtcblxuICAgIGlmICggY3VycmVudFRleHR1cmVTbG90ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIF90aGlzLmFjdGl2ZVRleHR1cmUoKTtcblxuICAgIH1cblxuICAgIHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1tjdXJyZW50VGV4dHVyZVNsb3RdO1xuXG4gICAgaWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgYm91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xuICAgICAgY3VycmVudEJvdW5kVGV4dHVyZXNbY3VycmVudFRleHR1cmVTbG90XSA9IGJvdW5kVGV4dHVyZTtcblxuICAgIH1cblxuICAgIGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xuXG4gICAgICBnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKTtcblxuICAgICAgYm91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG4gICAgICBib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuY29tcHJlc3NlZFRleEltYWdlMkQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0cnkge1xuXG4gICAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgfSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy50ZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdHJ5IHtcblxuICAgICAgZ2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgfSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy9cblxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XG5cbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG4gICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuICAgIGN1cnJlbnREZXB0aFRlc3QgPSBudWxsO1xuICAgIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcbiAgICBjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XG4gICAgY3VycmVudERvdWJsZVNpZGVkID0gbnVsbDtcbiAgICBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuICB9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmVQbHVnaW4gPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBmbGFyZXMgKSB7XG5cbiAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuICB2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICB2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG4gIHZhciBoYXNWZXJ0ZXhUZXh0dXJlO1xuXG4gIHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAgIC0xLCAtMSwgIDAsIDAsXG4gICAgICAgMSwgLTEsICAxLCAwLFxuICAgICAgIDEsICAxLCAgMSwgMSxcbiAgICAgIC0xLCAgMSwgIDAsIDFcbiAgICBdICk7XG5cbiAgICB2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcbiAgICAgIDAsIDEsIDIsXG4gICAgICAwLCAyLCAzXG4gICAgXSApO1xuXG4gICAgLy8gYnVmZmVyc1xuXG4gICAgdmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGVsZW1lbnRCdWZmZXIgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgLy8gdGV4dHVyZXNcblxuICAgIHRlbXBUZXh0dXJlICAgICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgb2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIHJlbmRlcmVyLnN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cbiAgICByZW5kZXJlci5zdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDE2LCAxNiwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuICAgIGhhc1ZlcnRleFRleHR1cmUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApID4gMDtcblxuICAgIHZhciBzaGFkZXI7XG5cbiAgICBpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAgIHNoYWRlciA9IHtcblxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxuXG4gICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG5cbiAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cbiAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG4gICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG4gICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIFwidlVWID0gdXY7XCIsXG5cbiAgICAgICAgICAgIFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG4gICAgICAgICAgICAgIFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1wiLFxuXG4gICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxuICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcIixcbiAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXG4gICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxuXG4gICAgICAgICAgICAgIFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcbiAgICAgICAgICAgICAgXCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG4gICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgICAgXCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cbiAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG4gICAgICAgICAgXCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG4gICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgICAgIC8vIHBpbmsgc3F1YXJlXG5cbiAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG4gICAgICAgICAgICAvLyByZXN0b3JlXG5cbiAgICAgICAgICAgIFwifSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cbiAgICAgICAgICAgIC8vIGZsYXJlXG5cbiAgICAgICAgICAgIFwifSBlbHNlIHtcIixcblxuICAgICAgICAgICAgICBcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcbiAgICAgICAgICAgICAgXCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBzaGFkZXIgPSB7XG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG4gICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcInZVViA9IHV2O1wiLFxuXG4gICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuICAgICAgICAgICAgICBcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG4gICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cbiAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxuXG4gICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcbiAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcbiAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcbiAgICAgICAgICBcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuICAgICAgICAgIFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAvLyBwaW5rIHNxdWFyZVxuXG4gICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcblxuICAgICAgICAgICAgLy8gcmVzdG9yZVxuXG4gICAgICAgICAgICBcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG4gICAgICAgICAgICAvLyBmbGFyZVxuXG4gICAgICAgICAgICBcIn0gZWxzZSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKS5hO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKS5hO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgPSAoIDEuMCAtIHZpc2liaWxpdHkgLyA0LjAgKTtcIixcblxuICAgICAgICAgICAgICBcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcbiAgICAgICAgICAgICAgXCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XCIsXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxuXG4gICAgICAgICAgICBcIn1cIixcblxuICAgICAgICAgIFwifVwiXG5cbiAgICAgICAgXS5qb2luKCBcIlxcblwiIClcblxuICAgICAgfTtcblxuICAgIH1cblxuICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcblxuICAgIGF0dHJpYnV0ZXMgPSB7XG4gICAgICB2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXG4gICAgICB1djogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJ1dlwiIClcbiAgICB9O1xuXG4gICAgdW5pZm9ybXMgPSB7XG4gICAgICByZW5kZXJUeXBlOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJlbmRlclR5cGVcIiApLFxuICAgICAgbWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxuICAgICAgb2NjbHVzaW9uTWFwOiAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvY2NsdXNpb25NYXBcIiApLFxuICAgICAgb3BhY2l0eTogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvcGFjaXR5XCIgKSxcbiAgICAgIGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxuICAgICAgc2NhbGU6ICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY2FsZVwiICksXG4gICAgICByb3RhdGlvbjogICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJvdGF0aW9uXCIgKSxcbiAgICAgIHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXG4gICAgfTtcblxuICB9O1xuXG4gIC8qXG4gICAqIFJlbmRlciBsZW5zIGZsYXJlc1xuICAgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxuICAgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxuICAgKi9cblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQgKSB7XG5cbiAgICBpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICB2YXIgdGVtcFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydEhlaWdodCAvIHZpZXdwb3J0V2lkdGgsXG4gICAgICBoYWxmVmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0V2lkdGggKiAwLjUsXG4gICAgICBoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodCAqIDAuNTtcblxuICAgIHZhciBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodCxcbiAgICAgIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuICAgIHZhciBzY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAwICksXG4gICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cbiAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaW5pdCgpO1xuXG4gICAgfVxuXG4gICAgZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgcmVuZGVyZXIuc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcbiAgICByZW5kZXJlci5zdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XG4gICAgcmVuZGVyZXIuc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG4gICAgcmVuZGVyZXIuc3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXG4gICAgLy8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5mb3Jtc1xuXG4gICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5vY2NsdXNpb25NYXAsIDAgKTtcbiAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnZlcnRleCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cbiAgICBnbC5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICBnbC5kZXB0aE1hc2soIGZhbHNlICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQ7XG4gICAgICBzY2FsZS5zZXQoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuICAgICAgLy8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXG5cbiAgICAgIHZhciBmbGFyZSA9IGZsYXJlc1sgaSBdO1xuXG4gICAgICB0ZW1wUG9zaXRpb24uc2V0KCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEzXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTRdICk7XG5cbiAgICAgIHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICAgIHRlbXBQb3NpdGlvbi5hcHBseVByb2plY3Rpb24oIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICAgIC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcblxuICAgICAgc2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XG5cbiAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPSBzY3JlZW5Qb3NpdGlvbi54ICogaGFsZlZpZXdwb3J0V2lkdGggKyBoYWxmVmlld3BvcnRXaWR0aDtcbiAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPSBzY3JlZW5Qb3NpdGlvbi55ICogaGFsZlZpZXdwb3J0SGVpZ2h0ICsgaGFsZlZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICAvLyBzY3JlZW4gY3VsbFxuXG4gICAgICBpZiAoIGhhc1ZlcnRleFRleHR1cmUgfHwgKFxuICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54ID4gMCAmJlxuICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54IDwgdmlld3BvcnRXaWR0aCAmJlxuICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55ID4gMCAmJlxuICAgICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55IDwgdmlld3BvcnRIZWlnaHQgKSApIHtcblxuICAgICAgICAvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxuXG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgICAgICBnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSAtIDgsIDE2LCAxNiwgMCApO1xuXG5cbiAgICAgICAgLy8gcmVuZGVyIHBpbmsgcXVhZFxuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XG4gICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblxuICAgICAgICBnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xuICAgICAgICBnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG4gICAgICAgIC8vIGNvcHkgcmVzdWx0IHRvIG9jY2x1c2lvbk1hcFxuXG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XG4gICAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSAtIDgsIDE2LCAxNiwgMCApO1xuXG5cbiAgICAgICAgLy8gcmVzdG9yZSBncmFwaGljc1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xuICAgICAgICBnbC5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcblxuICAgICAgICBmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xuXG4gICAgICAgIGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5kZXIgZmxhcmVzXG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XG4gICAgICAgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICAgIHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XG5cbiAgICAgICAgICBpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XG5cbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcbiAgICAgICAgICAgIHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcblxuICAgICAgICAgICAgc2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xuICAgICAgICAgICAgc2NhbGUueSA9IHNpemU7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XG4gICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLnN0YXRlLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIGdsXG5cbiAgICBnbC5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuICAgIGdsLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuICAgIGdsLmRlcHRoTWFzayggdHJ1ZSApO1xuXG4gICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyICkge1xuXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuICAgIHZhciBwcmVmaXggPSBcInByZWNpc2lvbiBcIiArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgXCIgZmxvYXQ7XFxuXCI7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xuXG4gICAgZ2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuXG4gICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIHJldHVybiBwcm9ncmFtO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU3ByaXRlUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc3ByaXRlcyApIHtcblxuICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG4gIHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG4gIHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuICB2YXIgdGV4dHVyZTtcblxuICAvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcblxuICB2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuICAgICAgLSAwLjUsIC0gMC41LCAgMCwgMCxcbiAgICAgICAgMC41LCAtIDAuNSwgIDEsIDAsXG4gICAgICAgIDAuNSwgICAwLjUsICAxLCAxLFxuICAgICAgLSAwLjUsICAgMC41LCAgMCwgMVxuICAgIF0gKTtcblxuICAgIHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuICAgICAgMCwgMSwgMixcbiAgICAgIDAsIDIsIDNcbiAgICBdICk7XG5cbiAgICB2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcbiAgICBnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgYXR0cmlidXRlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXG4gICAgICB1djogICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxuICAgIH07XG5cbiAgICB1bmlmb3JtcyA9IHtcbiAgICAgIHV2T2Zmc2V0OiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXG4gICAgICB1dlNjYWxlOiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cbiAgICAgIHJvdGF0aW9uOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG4gICAgICBzY2FsZTogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxuXG4gICAgICBjb2xvcjogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxuICAgICAgbWFwOiAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxuICAgICAgb3BhY2l0eTogICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxuXG4gICAgICBtb2RlbFZpZXdNYXRyaXg6ICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxuXG4gICAgICBmb2dUeXBlOiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXG4gICAgICBmb2dEZW5zaXR5OiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcbiAgICAgIGZvZ05lYXI6ICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcbiAgICAgIGZvZ0ZhcjogICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxuICAgICAgZm9nQ29sb3I6ICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuICAgICAgYWxwaGFUZXN0OiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxuICAgIH07XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICBjYW52YXMud2lkdGggPSA4O1xuICAgIGNhbnZhcy5oZWlnaHQgPSA4O1xuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cbiAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICBpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG4gICAgLy8gc2V0dXAgZ2xcblxuICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpbml0KCk7XG5cbiAgICB9XG5cbiAgICBnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICByZW5kZXJlci5zdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuICAgIHJlbmRlcmVyLnN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgIHJlbmRlcmVyLnN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgIHJlbmRlcmVyLnN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBnbC5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICByZW5kZXJlci5zdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XG5cbiAgICB2YXIgb2xkRm9nVHlwZSA9IDA7XG4gICAgdmFyIHNjZW5lRm9nVHlwZSA9IDA7XG4gICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcblxuICAgIGlmICggZm9nICkge1xuXG4gICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cbiAgICAgIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcbiAgICAgICAgb2xkRm9nVHlwZSA9IDE7XG4gICAgICAgIHNjZW5lRm9nVHlwZSA9IDE7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuICAgICAgICBvbGRGb2dUeXBlID0gMjtcbiAgICAgICAgc2NlbmVGb2dUeXBlID0gMjtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG4gICAgICBvbGRGb2dUeXBlID0gMDtcbiAgICAgIHNjZW5lRm9nVHlwZSA9IDA7XG5cbiAgICB9XG5cblxuICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuICAgICAgc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XG4gICAgICBzcHJpdGUueiA9IC0gc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XG5cbiAgICB9XG5cbiAgICBzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG5cbiAgICAvLyByZW5kZXIgYWxsIHNwcml0ZXNcblxuICAgIHZhciBzY2FsZSA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuICAgICAgdmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xuXG4gICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUuX21vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICBzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XG5cbiAgICAgIHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xuICAgICAgc2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XG5cbiAgICAgIHZhciBmb2dUeXBlID0gMDtcblxuICAgICAgaWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgICAgIGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xuICAgICAgICBvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcblxuICAgICAgfVxuXG4gICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcbiAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcblxuICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcbiAgICAgIGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG4gICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICAgIHJlbmRlcmVyLnN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblxuICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcblxuICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCBtYXRlcmlhbC5tYXAsIDAgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XG5cbiAgICAgIH1cblxuICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIGdsXG5cbiAgICBnbC5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICgpIHtcblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xuXG4gICAgICAncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICAgICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuICAgICAgJ3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcbiAgICAgICd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcbiAgICAgICd1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7JyxcbiAgICAgICd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxuXG4gICAgICAnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JyxcbiAgICAgICdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG4gICAgICAndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgJ3ZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlOycsXG5cbiAgICAgICAgJ3ZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxuXG4gICAgICAgICd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgICAgICAncm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG4gICAgICAgICdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcblxuICAgICAgICAndmVjNCBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxuICAgICAgICAnZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247JyxcbiAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICdnbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgJ30nXG5cbiAgICBdLmpvaW4oICdcXG4nICkgKTtcblxuICAgIGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIFtcblxuICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cbiAgICAgICd1bmlmb3JtIHZlYzMgY29sb3I7JyxcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcblxuICAgICAgJ3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcbiAgICAgICd1bmlmb3JtIHZlYzMgZm9nQ29sb3I7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsnLFxuICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXG5cbiAgICAgICd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cbiAgICAgICd2b2lkIG1haW4oKSB7JyxcblxuICAgICAgICAndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXG5cbiAgICAgICAgJ2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcblxuICAgICAgICAnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxuXG4gICAgICAgICAgJ2Zsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudzsnLFxuICAgICAgICAgICdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcblxuICAgICAgICAgICdpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxuXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXG5cbiAgICAgICAgICAnfSBlbHNlIHsnLFxuXG4gICAgICAgICAgICAnY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcbiAgICAgICAgICAgICdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXG5cbiAgICAgICAgICAnfScsXG5cbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG4gICAgICAgICd9JyxcblxuICAgICAgJ30nXG5cbiAgICBdLmpvaW4oICdcXG4nICkgKTtcblxuICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG4gICAgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgcmV0dXJuIGIueiAtIGEuejtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcblxuICAgIH1cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9HZW9tZXRyeVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5HZW9tZXRyeVV0aWxzID0ge1xuXG4gIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcblxuICAgIHZhciBtYXRyaXg7XG5cbiAgICBpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgIGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgbWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcbiAgICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5Mi5nZW9tZXRyeTtcblxuICAgIH1cblxuICAgIGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcblxuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xuICAgIHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9JbWFnZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIERhb3NoZW5nIE11IC8gaHR0cHM6Ly9naXRodWIuY29tL0Rhb3NoZW5nTXUvXG4gKi9cblxuVEhSRUUuSW1hZ2VVdGlscyA9IHtcblxuICBjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxuXG4gIGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuICAgIGxvYWRlci5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCB1bmRlZmluZWQsIG1hcHBpbmcgKTtcblxuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cbiAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG4gICAgfSApO1xuXG4gICAgdGV4dHVyZS5zb3VyY2VGaWxlID0gdXJsO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfSxcblxuICBsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggYXJyYXksIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgIHZhciBpbWFnZXMgPSBbXTtcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcbiAgICBsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIGltYWdlcywgbWFwcGluZyApO1xuXG4gICAgLy8gbm8gZmxpcHBpbmcgbmVlZGVkIGZvciBjdWJlIHRleHR1cmVzXG5cbiAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG5cbiAgICB2YXIgbG9hZGVkID0gMDtcblxuICAgIHZhciBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggaSApIHtcblxuICAgICAgbG9hZGVyLmxvYWQoIGFycmF5WyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xuXG4gICAgICAgIGxvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cbiAgICB9O1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG4gICAgICBsb2FkVGV4dHVyZSggaSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfSxcblxuICBsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cbiAgfSxcblxuICBsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nIClcblxuICB9LFxuXG4gIGdldE5vcm1hbE1hcDogZnVuY3Rpb24gKCBpbWFnZSwgZGVwdGggKSB7XG5cbiAgICAvLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvbGFiL2hlaWdodG5vcm1hbC9cblxuICAgIHZhciBjcm9zcyA9IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgICAgcmV0dXJuIFsgYVsgMSBdICogYlsgMiBdIC0gYVsgMiBdICogYlsgMSBdLCBhWyAyIF0gKiBiWyAwIF0gLSBhWyAwIF0gKiBiWyAyIF0sIGFbIDAgXSAqIGJbIDEgXSAtIGFbIDEgXSAqIGJbIDAgXSBdO1xuXG4gICAgfTtcblxuICAgIHZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgICAgcmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xuXG4gICAgfTtcblxuICAgIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoIGEgKSB7XG5cbiAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBhWyAwIF0gKiBhWyAwIF0gKyBhWyAxIF0gKiBhWyAxIF0gKyBhWyAyIF0gKiBhWyAyIF0gKTtcbiAgICAgIHJldHVybiBbIGFbIDAgXSAvIGwsIGFbIDEgXSAvIGwsIGFbIDIgXSAvIGwgXTtcblxuICAgIH07XG5cbiAgICBkZXB0aCA9IGRlcHRoIHwgMTtcblxuICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCApO1xuXG4gICAgdmFyIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgd2lkdGgsIGhlaWdodCApLmRhdGE7XG4gICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgdmFyIG91dHB1dCA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgZm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGg7IHggKysgKSB7XG5cbiAgICAgIGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSArKyApIHtcblxuICAgICAgICB2YXIgbHkgPSB5IC0gMSA8IDAgPyAwIDogeSAtIDE7XG4gICAgICAgIHZhciB1eSA9IHkgKyAxID4gaGVpZ2h0IC0gMSA/IGhlaWdodCAtIDEgOiB5ICsgMTtcbiAgICAgICAgdmFyIGx4ID0geCAtIDEgPCAwID8gMCA6IHggLSAxO1xuICAgICAgICB2YXIgdXggPSB4ICsgMSA+IHdpZHRoIC0gMSA/IHdpZHRoIC0gMSA6IHggKyAxO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG9yaWdpbiA9IFsgMCwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdO1xuICAgICAgICBwb2ludHMucHVzaCggWyAtIDEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgLSAxLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIDAsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICBwb2ludHMucHVzaCggWyAxLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIDEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgMCwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICBwb2ludHMucHVzaCggWyAtIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICAgICAgdmFyIG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51bV9wb2ludHM7IGkgKysgKSB7XG5cbiAgICAgICAgICB2YXIgdjEgPSBwb2ludHNbIGkgXTtcbiAgICAgICAgICB2YXIgdjIgPSBwb2ludHNbICggaSArIDEgKSAlIG51bV9wb2ludHMgXTtcbiAgICAgICAgICB2MSA9IHN1YnRyYWN0KCB2MSwgb3JpZ2luICk7XG4gICAgICAgICAgdjIgPSBzdWJ0cmFjdCggdjIsIG9yaWdpbiApO1xuICAgICAgICAgIG5vcm1hbHMucHVzaCggbm9ybWFsaXplKCBjcm9zcyggdjEsIHYyICkgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsID0gWyAwLCAwLCAwIF07XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICBub3JtYWxbIDAgXSArPSBub3JtYWxzWyBpIF1bIDAgXTtcbiAgICAgICAgICBub3JtYWxbIDEgXSArPSBub3JtYWxzWyBpIF1bIDEgXTtcbiAgICAgICAgICBub3JtYWxbIDIgXSArPSBub3JtYWxzWyBpIF1bIDIgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsWyAwIF0gLz0gbm9ybWFscy5sZW5ndGg7XG4gICAgICAgIG5vcm1hbFsgMSBdIC89IG5vcm1hbHMubGVuZ3RoO1xuICAgICAgICBub3JtYWxbIDIgXSAvPSBub3JtYWxzLmxlbmd0aDtcblxuICAgICAgICB2YXIgaWR4ID0gKCB5ICogd2lkdGggKyB4ICkgKiA0O1xuXG4gICAgICAgIG91dHB1dFsgaWR4IF0gPSAoICggbm9ybWFsWyAwIF0gKyAxLjAgKSAvIDIuMCAqIDI1NSApIHwgMDtcbiAgICAgICAgb3V0cHV0WyBpZHggKyAxIF0gPSAoICggbm9ybWFsWyAxIF0gKyAxLjAgKSAvIDIuMCAqIDI1NSApIHwgMDtcbiAgICAgICAgb3V0cHV0WyBpZHggKyAyIF0gPSAoIG5vcm1hbFsgMiBdICogMjU1ICkgfCAwO1xuICAgICAgICBvdXRwdXRbIGlkeCArIDMgXSA9IDI1NTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlRGF0YSwgMCwgMCApO1xuXG4gICAgcmV0dXJuIGNhbnZhcztcblxuICB9LFxuXG4gIGdlbmVyYXRlRGF0YVRleHR1cmU6IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgY29sb3IgKSB7XG5cbiAgICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDMgKiBzaXplICk7XG5cbiAgICB2YXIgciA9IE1hdGguZmxvb3IoIGNvbG9yLnIgKiAyNTUgKTtcbiAgICB2YXIgZyA9IE1hdGguZmxvb3IoIGNvbG9yLmcgKiAyNTUgKTtcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoIGNvbG9yLmIgKiAyNTUgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cbiAgICAgIGRhdGFbIGkgKiAzIF0gICAgICA9IHI7XG4gICAgICBkYXRhWyBpICogMyArIDEgXSA9IGc7XG4gICAgICBkYXRhWyBpICogMyArIDIgXSA9IGI7XG5cbiAgICB9XG5cbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggZGF0YSwgd2lkdGgsIGhlaWdodCwgVEhSRUUuUkdCRm9ybWF0ICk7XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9TY2VuZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZVV0aWxzID0ge1xuXG4gIGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcblxuICAgIHZhciBncm91cCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIGdyb3VwLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG5cbiAgfSxcblxuICBkZXRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XG5cbiAgICBjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgcGFyZW50LnJlbW92ZSggY2hpbGQgKTtcbiAgICBzY2VuZS5hZGQoIGNoaWxkICk7XG5cbiAgfSxcblxuICBhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XG5cbiAgICB2YXIgbWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICBtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgY2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG4gICAgc2NlbmUucmVtb3ZlKCBjaGlsZCApO1xuICAgIHBhcmVudC5hZGQoIGNoaWxkICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvRm9udFV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBGb3IgVGV4dCBvcGVyYXRpb25zIGluIHRocmVlLmpzIChTZWUgVGV4dEdlb21ldHJ5KVxuICpcbiAqIEl0IHVzZXMgdGVjaG5pcXVlcyB1c2VkIGluOlxuICpcbiAqICBUcmlhbmd1bGF0aW9uIHBvcnRlZCBmcm9tIEFTM1xuICogICAgU2ltcGxlIFBvbHlnb24gVHJpYW5ndWxhdGlvblxuICogICAgaHR0cDovL2FjdGlvbnNuaXBwZXQuY29tLz9wPTE0NjJcbiAqXG4gKiAgQSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcbiAqICAgIGh0dHA6Ly93d3cuc2FrcmkubmV0L2Jsb2cvMjAwOS8wNi8xMi9hbi1hcHByb2FjaC10by10cmlhbmd1bGF0aW5nLXBvbHlnb25zLXdpdGgtaG9sZXMvXG4gKlxuICovXG5cblRIUkVFLkZvbnRVdGlscyA9IHtcblxuICBmYWNlczoge30sXG5cbiAgLy8gSnVzdCBmb3Igbm93LiBmYWNlW3dlaWdodF1bc3R5bGVdXG5cbiAgZmFjZTogJ2hlbHZldGlrZXInLFxuICB3ZWlnaHQ6ICdub3JtYWwnLFxuICBzdHlsZTogJ25vcm1hbCcsXG4gIHNpemU6IDE1MCxcbiAgZGl2aXNpb25zOiAxMCxcblxuICBnZXRGYWNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0cnkge1xuXG4gICAgICByZXR1cm4gdGhpcy5mYWNlc1sgdGhpcy5mYWNlIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgdGhyb3cgXCJUaGUgZm9udCBcIiArIHRoaXMuZmFjZSArIFwiIHdpdGggXCIgKyB0aGlzLndlaWdodCArIFwiIHdlaWdodCBhbmQgXCIgKyB0aGlzLnN0eWxlICsgXCIgc3R5bGUgaXMgbWlzc2luZy5cIlxuXG4gICAgfVxuXG4gIH0sXG5cbiAgbG9hZEZhY2U6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuICAgIHZhciBmYW1pbHkgPSBkYXRhLmZhbWlseU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIHZhciBUaHJlZUZvbnQgPSB0aGlzO1xuXG4gICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gfHwge307XG5cbiAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdIHx8IHt9O1xuICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgZHJhd1RleHQ6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgIC8vIFJlbmRlclRleHRcblxuICAgIHZhciBpLFxuICAgICAgZmFjZSA9IHRoaXMuZ2V0RmFjZSgpLFxuICAgICAgc2NhbGUgPSB0aGlzLnNpemUgLyBmYWNlLnJlc29sdXRpb24sXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgY2hhcnMgPSBTdHJpbmcoIHRleHQgKS5zcGxpdCggJycgKSxcbiAgICAgIGxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcblxuICAgIHZhciBmb250UGF0aHMgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgcGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cbiAgICAgIHZhciByZXQgPSB0aGlzLmV4dHJhY3RHbHlwaFBvaW50cyggY2hhcnNbIGkgXSwgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApO1xuICAgICAgb2Zmc2V0ICs9IHJldC5vZmZzZXQ7XG5cbiAgICAgIGZvbnRQYXRocy5wdXNoKCByZXQucGF0aCApO1xuXG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB3aWR0aFxuXG4gICAgdmFyIHdpZHRoID0gb2Zmc2V0IC8gMjtcbiAgICAvL1xuICAgIC8vIGZvciAoIHAgPSAwOyBwIDwgYWxsUHRzLmxlbmd0aDsgcCsrICkge1xuICAgIC8vXG4gICAgLy8gIGFsbFB0c1sgcCBdLnggLT0gd2lkdGg7XG4gICAgLy9cbiAgICAvLyB9XG5cbiAgICAvL3ZhciBleHRyYWN0ID0gdGhpcy5leHRyYWN0UG9pbnRzKCBhbGxQdHMsIGNoYXJhY3RlclB0cyApO1xuICAgIC8vZXh0cmFjdC5jb250b3VyID0gYWxsUHRzO1xuXG4gICAgLy9leHRyYWN0LnBhdGhzID0gZm9udFBhdGhzO1xuICAgIC8vZXh0cmFjdC5vZmZzZXQgPSB3aWR0aDtcblxuICAgIHJldHVybiB7IHBhdGhzOiBmb250UGF0aHMsIG9mZnNldDogd2lkdGggfTtcblxuICB9LFxuXG5cblxuXG4gIGV4dHJhY3RHbHlwaFBvaW50czogZnVuY3Rpb24gKCBjLCBmYWNlLCBzY2FsZSwgb2Zmc2V0LCBwYXRoICkge1xuXG4gICAgdmFyIHB0cyA9IFtdO1xuXG4gICAgdmFyIGksIGkyLCBkaXZpc2lvbnMsXG4gICAgICBvdXRsaW5lLCBhY3Rpb24sIGxlbmd0aCxcbiAgICAgIHNjYWxlWCwgc2NhbGVZLFxuICAgICAgeCwgeSwgY3B4LCBjcHksIGNweDAsIGNweTAsIGNweDEsIGNweTEsIGNweDIsIGNweTIsXG4gICAgICBsYXN0ZSxcbiAgICAgIGdseXBoID0gZmFjZS5nbHlwaHNbIGMgXSB8fCBmYWNlLmdseXBoc1sgJz8nIF07XG5cbiAgICBpZiAoICEgZ2x5cGggKSByZXR1cm47XG5cbiAgICBpZiAoIGdseXBoLm8gKSB7XG5cbiAgICAgIG91dGxpbmUgPSBnbHlwaC5fY2FjaGVkT3V0bGluZSB8fCAoIGdseXBoLl9jYWNoZWRPdXRsaW5lID0gZ2x5cGguby5zcGxpdCggJyAnICkgKTtcbiAgICAgIGxlbmd0aCA9IG91dGxpbmUubGVuZ3RoO1xuXG4gICAgICBzY2FsZVggPSBzY2FsZTtcbiAgICAgIHNjYWxlWSA9IHNjYWxlO1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgKSB7XG5cbiAgICAgICAgYWN0aW9uID0gb3V0bGluZVsgaSArKyBdO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coIGFjdGlvbiApO1xuXG4gICAgICAgIHN3aXRjaCAoIGFjdGlvbiApIHtcblxuICAgICAgICBjYXNlICdtJzpcblxuICAgICAgICAgIC8vIE1vdmUgVG9cblxuICAgICAgICAgIHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgeSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcblxuICAgICAgICAgIHBhdGgubW92ZVRvKCB4LCB5ICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbCc6XG5cbiAgICAgICAgICAvLyBMaW5lIFRvXG5cbiAgICAgICAgICB4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XG4gICAgICAgICAgcGF0aC5saW5lVG8oIHgsIHkgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdxJzpcblxuICAgICAgICAgIC8vIFF1YWRyYXRpY0N1cnZlVG9cblxuICAgICAgICAgIGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgY3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcbiAgICAgICAgICBjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XG5cbiAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XG5cbiAgICAgICAgICBsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgIGlmICggbGFzdGUgKSB7XG5cbiAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XG5cbiAgICAgICAgICAgIGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XG5cbiAgICAgICAgICAgICAgdmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcbiAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xuICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdiJzpcblxuICAgICAgICAgIC8vIEN1YmljIEJlemllciBDdXJ2ZVxuXG4gICAgICAgICAgY3B4ICA9IG91dGxpbmVbIGkgKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgY3B5ICA9IG91dGxpbmVbIGkgKysgXSAqICBzY2FsZVk7XG4gICAgICAgICAgY3B4MSA9IG91dGxpbmVbIGkgKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgY3B5MSA9IG91dGxpbmVbIGkgKysgXSAqICBzY2FsZVk7XG4gICAgICAgICAgY3B4MiA9IG91dGxpbmVbIGkgKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgY3B5MiA9IG91dGxpbmVbIGkgKysgXSAqICBzY2FsZVk7XG5cbiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGNweCwgY3B5ICk7XG5cbiAgICAgICAgICBsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcblxuICAgICAgICAgIGlmICggbGFzdGUgKSB7XG5cbiAgICAgICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICAgICAgY3B5MCA9IGxhc3RlLnk7XG5cbiAgICAgICAgICAgIGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XG5cbiAgICAgICAgICAgICAgdmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcbiAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuXG5cbiAgICByZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6cGF0aCB9O1xuICB9XG5cbn07XG5cblxuVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG4gIC8vIFBhcmFtZXRlcnNcblxuICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICB2YXIgc2l6ZSA9IHBhcmFtZXRlcnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplIDogMTAwO1xuICB2YXIgY3VydmVTZWdtZW50cyA9IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzIDogNDtcblxuICB2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb250IDogJ2hlbHZldGlrZXInO1xuICB2YXIgd2VpZ2h0ID0gcGFyYW1ldGVycy53ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2VpZ2h0IDogJ25vcm1hbCc7XG4gIHZhciBzdHlsZSA9IHBhcmFtZXRlcnMuc3R5bGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3R5bGUgOiAnbm9ybWFsJztcblxuICBUSFJFRS5Gb250VXRpbHMuc2l6ZSA9IHNpemU7XG4gIFRIUkVFLkZvbnRVdGlscy5kaXZpc2lvbnMgPSBjdXJ2ZVNlZ21lbnRzO1xuXG4gIFRIUkVFLkZvbnRVdGlscy5mYWNlID0gZm9udDtcbiAgVEhSRUUuRm9udFV0aWxzLndlaWdodCA9IHdlaWdodDtcbiAgVEhSRUUuRm9udFV0aWxzLnN0eWxlID0gc3R5bGU7XG5cbiAgLy8gR2V0IGEgRm9udCBkYXRhIGpzb24gb2JqZWN0XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5Gb250VXRpbHMuZHJhd1RleHQoIHRleHQgKTtcblxuICB2YXIgcGF0aHMgPSBkYXRhLnBhdGhzO1xuICB2YXIgc2hhcGVzID0gW107XG5cbiAgZm9yICggdmFyIHAgPSAwLCBwbCA9IHBhdGhzLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XG5cbiAgfVxuXG4gIHJldHVybiBzaGFwZXM7XG5cbn07XG5cblxuLyoqXG4gKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xuICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcbiAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XG4gKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXG4gKlxuICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcbiAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxuICpcbiAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cbiAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKi9cblxuXG4oIGZ1bmN0aW9uICggbmFtZXNwYWNlICkge1xuXG4gIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gIC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcblxuICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uICggY29udG91ciwgaW5kaWNlcyApIHtcblxuICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cbiAgICBpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgdmVydEluZGljZXMgPSBbXTtcblxuICAgIC8qIHdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIHZlcnRzICovXG5cbiAgICB2YXIgdSwgdiwgdztcblxuICAgIGlmICggYXJlYSggY29udG91ciApID4gMC4wICkge1xuXG4gICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xuXG4gICAgfVxuXG4gICAgdmFyIG52ID0gbjtcblxuICAgIC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cblxuICAgIHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cblxuICAgIGZvciAoIHYgPSBudiAtIDE7IG52ID4gMjsgKSB7XG5cbiAgICAgIC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXG5cbiAgICAgIGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XG5cbiAgICAgICAgLy8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcblxuICAgICAgICAvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xuICAgICAgICAvL3JldHVybiBudWxsO1xuICAgICAgICAvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRm9udFV0aWxzOiBXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gVHJpYW5ndWxhdGUucHJvY2VzcygpJyApO1xuXG4gICAgICAgIGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgfVxuXG4gICAgICAvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cblxuICAgICAgdSA9IHY7ICAgIGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cbiAgICAgIHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cbiAgICAgIHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuICAgICAgaWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuICAgICAgICB2YXIgYSwgYiwgYywgcywgdDtcblxuICAgICAgICAvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG4gICAgICAgIGEgPSB2ZXJ0c1sgdSBdO1xuICAgICAgICBiID0gdmVydHNbIHYgXTtcbiAgICAgICAgYyA9IHZlcnRzWyB3IF07XG5cbiAgICAgICAgLyogb3V0cHV0IFRyaWFuZ2xlICovXG5cbiAgICAgICAgcmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuICAgICAgICAgIGNvbnRvdXJbIGIgXSxcbiAgICAgICAgICBjb250b3VyWyBjIF0gXSApO1xuXG5cbiAgICAgICAgdmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuICAgICAgICAvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG4gICAgICAgIGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcyArKywgdCArKyApIHtcblxuICAgICAgICAgIHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBudiAtLTtcblxuICAgICAgICAvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xuXG4gICAgICAgIGNvdW50ID0gMiAqIG52O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cblxuICB2YXIgYXJlYSA9IGZ1bmN0aW9uICggY29udG91ciApIHtcblxuICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XG4gICAgdmFyIGEgPSAwLjA7XG5cbiAgICBmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG4gICAgICBhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiAwLjU7XG5cbiAgfTtcblxuICB2YXIgc25pcCA9IGZ1bmN0aW9uICggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XG5cbiAgICB2YXIgcDtcbiAgICB2YXIgYXgsIGF5LCBieCwgYnk7XG4gICAgdmFyIGN4LCBjeSwgcHgsIHB5O1xuXG4gICAgYXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcbiAgICBheSA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS55O1xuXG4gICAgYnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcbiAgICBieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xuXG4gICAgY3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcbiAgICBjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xuXG4gICAgaWYgKCBFUFNJTE9OID4gKCAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgKSAtICggKCBieSAtIGF5ICkgKiAoIGN4IC0gYXggKSApICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgYVgsIGFZLCBiWCwgYlksIGNYLCBjWTtcbiAgICB2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcbiAgICB2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcblxuICAgIGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcbiAgICBiWCA9IGF4IC0gY3g7ICBiWSA9IGF5IC0gY3k7XG4gICAgY1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xuXG4gICAgZm9yICggcCA9IDA7IHAgPCBuOyBwICsrICkge1xuXG4gICAgICBweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xuICAgICAgcHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcblxuICAgICAgaWYgKCAoICggcHggPT09IGF4ICkgJiYgKCBweSA9PT0gYXkgKSApIHx8XG4gICAgICAgICAoICggcHggPT09IGJ4ICkgJiYgKCBweSA9PT0gYnkgKSApIHx8XG4gICAgICAgICAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApICkgY29udGludWU7XG5cbiAgICAgIGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuICAgICAgYnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XG4gICAgICBjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcblxuICAgICAgLy8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG4gICAgICBhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XG4gICAgICBjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XG4gICAgICBiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cbiAgICAgIGlmICggKCBhQ1JPU1NicCA+PSAtIEVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBFUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9O1xuXG5cbiAgbmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2VzcztcbiAgbmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xuXG4gIHJldHVybiBuYW1lc3BhY2U7XG5cbn0gKSggVEhSRUUuRm9udFV0aWxzICk7XG5cbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXG5cblRIUkVFLnR5cGVmYWNlX2pzID0geyBmYWNlczogVEhSRUUuRm9udFV0aWxzLmZhY2VzLCBsb2FkRmFjZTogVEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlIH07XG5pZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIHNlbGYuX3R5cGVmYWNlX2pzID0gVEhSRUUudHlwZWZhY2VfanM7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpby5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW8gPSBmdW5jdGlvbiAoIGxpc3RlbmVyICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXG4gIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG4gIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICB0aGlzLnNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQodGhpcyk7XG5cbiAgdGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG4gIHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuICB0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxuICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG5cbiAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvO1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggZmlsZSApIHtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcXVlc3Qub3BlbiggJ0dFVCcsIGZpbGUsIHRydWUgKTtcbiAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICggZSApIHtcblxuICAgIHNjb3BlLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCB0aGlzLnJlc3BvbnNlLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgICAgc2NvcGUuc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuICAgICAgaWYoIHNjb3BlLmF1dG9wbGF5ICkgc2NvcGUucGxheSgpO1xuXG4gICAgfSApO1xuXG4gIH07XG4gIHJlcXVlc3Quc2VuZCgpO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XG4gICAgcmV0dXJuO1xuXG4gIH1cblxuICB2YXIgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXG4gIHNvdXJjZS5idWZmZXIgPSB0aGlzLnNvdXJjZS5idWZmZXI7XG4gIHNvdXJjZS5sb29wID0gdGhpcy5zb3VyY2UubG9vcDtcbiAgc291cmNlLm9uZW5kZWQgPSB0aGlzLnNvdXJjZS5vbmVuZGVkO1xuICBzb3VyY2UuY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcbiAgc291cmNlLnN0YXJ0KCAwLCB0aGlzLnN0YXJ0VGltZSApO1xuXG4gIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgdGhpcy5zdGFydFRpbWUgPSAwO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUub25FbmRlZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICB0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgdGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG4gICAgcG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICB0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXG4gIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW9MaXN0ZW5lci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW9MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG4gIHRoaXMuY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvTGlzdGVuZXI7XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHZhciBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcbiAgICB2YXIgdXAgPSB0aGlzLnVwO1xuXG4gICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG4gICAgb3JpZW50YXRpb24uc2V0KCAwLCAwLCAtMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgbGlzdGVuZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcbiAgICBsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xuXG4gIH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG4gKlxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG4gKiAuZ2V0TGVuZ3RoKClcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcbiAqXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XG4gKlxuICogLS0gMmQgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuU3BsaW5lQ3VydmVcbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqXG4gKiAtLSAzZCBjbGFzc2VzIC0tXG4gKiBUSFJFRS5MaW5lQ3VydmUzXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xuICpcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuLy8gIC0gdCBbMCAuLiAxXVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgY29uc29sZS53YXJuKCBcIlRIUkVFLkN1cnZlOiBXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIiApO1xuICByZXR1cm4gbnVsbDtcblxufTtcblxuLy8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG4vLyAtIHUgWzAgLi4gMV1cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG4gIHJldHVybiB0aGlzLmdldFBvaW50KCB0ICk7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgaWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cbiAgdmFyIGQsIHB0cyA9IFtdO1xuXG4gIGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuICAgIHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcblxuICB9XG5cbiAgcmV0dXJuIHB0cztcblxufTtcblxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG4gIHZhciBkLCBwdHMgPSBbXTtcblxuICBmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cbiAgICBwdHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcblxuICB9XG5cbiAgcmV0dXJuIHB0cztcblxufTtcblxuLy8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuICByZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGhzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgaWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9ICh0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zKSA/ICh0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zKSA6IDIwMDtcblxuICBpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXG4gICAgJiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxuICAgICYmICEgdGhpcy5uZWVkc1VwZGF0ZSkge1xuXG4gICAgLy9jb25zb2xlLmxvZyggXCJjYWNoZWRcIiwgdGhpcy5jYWNoZUFyY0xlbmd0aHMgKTtcbiAgICByZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XG5cbiAgfVxuXG4gIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICB2YXIgY2FjaGUgPSBbXTtcbiAgdmFyIGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XG4gIHZhciBwLCBzdW0gPSAwO1xuXG4gIGNhY2hlLnB1c2goIDAgKTtcblxuICBmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XG5cbiAgICBjdXJyZW50ID0gdGhpcy5nZXRQb2ludCAoIHAgLyBkaXZpc2lvbnMgKTtcbiAgICBzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XG4gICAgY2FjaGUucHVzaCggc3VtICk7XG4gICAgbGFzdCA9IGN1cnJlbnQ7XG5cbiAgfVxuXG4gIHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XG5cbiAgcmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06c3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG59O1xuXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS51cGRhdGVBcmNMZW5ndGhzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB0aGlzLmdldExlbmd0aHMoKTtcbn07XG5cbi8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aSBkaXN0YW5jZVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VXRvVG1hcHBpbmcgPSBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xuXG4gIHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cbiAgdmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXG4gIHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG4gIGlmICggZGlzdGFuY2UgKSB7XG5cbiAgICB0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG4gIH1cblxuICAvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuICAvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG4gIHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xuXG4gIHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cbiAgICBpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuICAgIGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XG5cbiAgICBpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG4gICAgICBsb3cgPSBpICsgMTtcblxuICAgIH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xuXG4gICAgICBoaWdoID0gaSAtIDE7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBoaWdoID0gaTtcbiAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBET05FXG5cbiAgICB9XG5cbiAgfVxuXG4gIGkgPSBoaWdoO1xuXG4gIC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcblxuICBpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG4gICAgdmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcbiAgICByZXR1cm4gdDtcblxuICB9XG5cbiAgLy8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuXG4gIHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG4gIHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XG5cbiAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcblxuICAgIC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cbiAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG4gIHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG4gIHJldHVybiB0O1xuXG59O1xuXG4vLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuLy8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciBkZWx0YSA9IDAuMDAwMTtcbiAgdmFyIHQxID0gdCAtIGRlbHRhO1xuICB2YXIgdDIgPSB0ICsgZGVsdGE7XG5cbiAgLy8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG4gIGlmICggdDEgPCAwICkgdDEgPSAwO1xuICBpZiAoIHQyID4gMSApIHQyID0gMTtcblxuICB2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcbiAgdmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cbiAgdmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YihwdDEpO1xuICByZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG4gIHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcblxufTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZS5VdGlscyA9IHtcblxuICB0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICByZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcblxuICB9LFxuXG4gIC8vIFB1YXkgQmluZywgdGhhbmtzIGZvciBoZWxwaW5nIHdpdGggdGhpcyBkZXJpdmF0aXZlIVxuXG4gIHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgcmV0dXJuIC0gMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgICtcbiAgICAgIDMgKiBwMSAqICgxIC0gdCkgKiAoMSAtIHQpIC0gNiAqIHQgKiBwMSAqICgxIC0gdCkgK1xuICAgICAgNiAqIHQgKiAgcDIgKiAoMSAtIHQpIC0gMyAqIHQgKiB0ICogcDIgK1xuICAgICAgMyAqIHQgKiB0ICogcDM7XG5cbiAgfSxcblxuICB0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgLy8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcblxuICAgIHZhciBoMDAgPSA2ICogdCAqIHQgLSA2ICogdDsgIC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxuICAgIHZhciBoMTAgPSAzICogdCAqIHQgLSA0ICogdCArIDE7IC8vIHReMyDiiJIgMnReMiArIHRcbiAgICB2YXIgaDAxID0gLSA2ICogdCAqIHQgKyA2ICogdDsgIC8vIOKIkiAydDMgKyAzdDJcbiAgICB2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7ICAvLyB0MyDiiJIgdDJcblxuICAgIHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XG5cbiAgfSxcblxuICAvLyBDYXRtdWxsLVJvbVxuXG4gIGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cbiAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcbiAgICB2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcbiAgICB2YXIgdDIgPSB0ICogdDtcbiAgICB2YXIgdDMgPSB0ICogdDI7XG4gICAgcmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgfVxuXG59O1xuXG5cbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIDNEIEN1cnZlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XG5cbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZVBhdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZVBhdGggPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5jdXJ2ZXMgPSBbXTtcbiAgdGhpcy5iZW5kcyA9IFtdO1xuXG4gIHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3VydmVQYXRoO1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggY3VydmUgKSB7XG5cbiAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ET1xuICAvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXG4gIC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETyBUZXN0XG4gIC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXG4gIC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApO1xuICB2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGggLSAxXS5nZXRQb2ludCgxKTtcblxuICBpZiAoISBzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKGVuZFBvaW50LCBzdGFydFBvaW50KSApO1xuICB9XG5cbn07XG5cbi8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuLy8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuLy8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxuXG4vLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG4vLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcbi8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcbi8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgdmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcbiAgdmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG4gIHZhciBpID0gMCwgZGlmZiwgY3VydmU7XG5cbiAgLy8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXG5cbiAgd2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuICAgIGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcblxuICAgICAgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcbiAgICAgIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuICAgICAgdmFyIHUgPSAxIC0gZGlmZiAvIGN1cnZlLmdldExlbmd0aCgpO1xuXG4gICAgICByZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xuXG4gICAgfVxuXG4gICAgaSArKztcblxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG5cbiAgLy8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cbn07XG5cbi8qXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcbn07Ki9cblxuXG4vLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcbi8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblxuICB2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG4gIHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcblxufTtcblxuLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXG4vLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuICBpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xuXG4gIH1cblxuICAvLyBHZXQgbGVuZ3RoIG9mIHN1YnN1cnZlXG4gIC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxuXG4gIHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xuICB2YXIgaSwgaWwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7XG5cbiAgZm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcbiAgICBsZW5ndGhzLnB1c2goIHN1bXMgKTtcblxuICB9XG5cbiAgdGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG4gIHJldHVybiBsZW5ndGhzO1xuXG59O1xuXG5cblxuLy8gUmV0dXJucyBtaW4gYW5kIG1heCBjb29yZGluYXRlc1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuXG4gIHZhciBtYXhYLCBtYXhZLCBtYXhaO1xuICB2YXIgbWluWCwgbWluWSwgbWluWjtcblxuICBtYXhYID0gbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgbWluWCA9IG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgdmFyIHAsIGksIGlsLCBzdW07XG5cbiAgdmFyIHYzID0gcG9pbnRzWzBdIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMztcblxuICBzdW0gPSB2MyA/IG5ldyBUSFJFRS5WZWN0b3IzKCkgOiBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gIGZvciAoIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIHAgPSBwb2ludHNbIGkgXTtcblxuICAgIGlmICggcC54ID4gbWF4WCApIG1heFggPSBwLng7XG4gICAgZWxzZSBpZiAoIHAueCA8IG1pblggKSBtaW5YID0gcC54O1xuXG4gICAgaWYgKCBwLnkgPiBtYXhZICkgbWF4WSA9IHAueTtcbiAgICBlbHNlIGlmICggcC55IDwgbWluWSApIG1pblkgPSBwLnk7XG5cbiAgICBpZiAoIHYzICkge1xuXG4gICAgICBpZiAoIHAueiA+IG1heFogKSBtYXhaID0gcC56O1xuICAgICAgZWxzZSBpZiAoIHAueiA8IG1pblogKSBtaW5aID0gcC56O1xuXG4gICAgfVxuXG4gICAgc3VtLmFkZCggcCApO1xuXG4gIH1cblxuICB2YXIgcmV0ID0ge1xuXG4gICAgbWluWDogbWluWCxcbiAgICBtaW5ZOiBtaW5ZLFxuICAgIG1heFg6IG1heFgsXG4gICAgbWF4WTogbWF4WVxuXG4gIH07XG5cbiAgaWYgKCB2MyApIHtcblxuICAgIHJldC5tYXhaID0gbWF4WjtcbiAgICByZXQubWluWiA9IG1pblo7XG5cbiAgfVxuXG4gIHJldHVybiByZXQ7XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENyZWF0ZSBHZW9tZXRyaWVzIEhlbHBlcnNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBvaW50cyBvYmplY3RzKVxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICB2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cbi8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbmNlIHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gIHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XG4gIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55LCBwb2ludHNbIGkgXS56IHx8IDApICk7XG5cbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBCZW5kIC8gV3JhcCBIZWxwZXIgTWV0aG9kc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBXcmFwIHBhdGggLyBCZW5kIG1vZGlmaWVycz9cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGRXcmFwUGF0aCA9IGZ1bmN0aW9uICggYmVuZHBhdGggKSB7XG5cbiAgdGhpcy5iZW5kcy5wdXNoKCBiZW5kcGF0aCApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcblxuICB2YXIgb2xkUHRzID0gdGhpcy5nZXRQb2ludHMoIHNlZ21lbnRzICk7IC8vIGdldFBvaW50cyBnZXRTcGFjZWRQb2ludHNcbiAgdmFyIGksIGlsO1xuXG4gIGlmICggISBiZW5kcyApIHtcblxuICAgIGJlbmRzID0gdGhpcy5iZW5kcztcblxuICB9XG5cbiAgZm9yICggaSA9IDAsIGlsID0gYmVuZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBvbGRQdHMgPSB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgYmVuZHNbIGkgXSApO1xuXG4gIH1cblxuICByZXR1cm4gb2xkUHRzO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcblxuICB2YXIgb2xkUHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIHNlZ21lbnRzICk7XG5cbiAgdmFyIGksIGlsO1xuXG4gIGlmICggISBiZW5kcyApIHtcblxuICAgIGJlbmRzID0gdGhpcy5iZW5kcztcblxuICB9XG5cbiAgZm9yICggaSA9IDAsIGlsID0gYmVuZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBvbGRQdHMgPSB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgYmVuZHNbIGkgXSApO1xuXG4gIH1cblxuICByZXR1cm4gb2xkUHRzO1xuXG59O1xuXG4vLyBUaGlzIHJldHVybnMgZ2V0UG9pbnRzKCkgYmVuZC93cmFwcGVkIGFyb3VuZCB0aGUgY29udG91ciBvZiBhIHBhdGguXG4vLyBSZWFkIGh0dHA6Ly93d3cucGxhbmV0Y2xlZ2cuY29tL3Byb2plY3RzL1dhcnBpbmdUZXh0VG9TcGxpbmVzLmh0bWxcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRXcmFwUG9pbnRzID0gZnVuY3Rpb24gKCBvbGRQdHMsIHBhdGggKSB7XG5cbiAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcblxuICB2YXIgaSwgaWwsIHAsIG9sZFgsIG9sZFksIHhOb3JtO1xuXG4gIGZvciAoIGkgPSAwLCBpbCA9IG9sZFB0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIHAgPSBvbGRQdHNbIGkgXTtcblxuICAgIG9sZFggPSBwLng7XG4gICAgb2xkWSA9IHAueTtcblxuICAgIHhOb3JtID0gb2xkWCAvIGJvdW5kcy5tYXhYO1xuXG4gICAgLy8gSWYgdXNpbmcgYWN0dWFsIGRpc3RhbmNlLCBmb3IgbGVuZ3RoID4gcGF0aCwgcmVxdWlyZXMgbGluZSBleHRydXNpb25zXG4gICAgLy94Tm9ybSA9IHBhdGguZ2V0VXRvVG1hcHBpbmcoeE5vcm0sIG9sZFgpOyAvLyAzIHN0eWxlcy4gMSkgd3JhcCBzdHJldGNoZWQuIDIpIHdyYXAgc3RyZXRjaCBieSBhcmMgbGVuZ3RoIDMpIHdhcnAgYnkgYWN0dWFsIGRpc3RhbmNlXG5cbiAgICB4Tm9ybSA9IHBhdGguZ2V0VXRvVG1hcHBpbmcoIHhOb3JtLCBvbGRYICk7XG5cbiAgICAvLyBjaGVjayBmb3Igb3V0IG9mIGJvdW5kcz9cblxuICAgIHZhciBwYXRoUHQgPSBwYXRoLmdldFBvaW50KCB4Tm9ybSApO1xuICAgIHZhciBub3JtYWwgPSBwYXRoLmdldFRhbmdlbnQoIHhOb3JtICk7XG4gICAgbm9ybWFsLnNldCggLSBub3JtYWwueSwgbm9ybWFsLnggKS5tdWx0aXBseVNjYWxhciggb2xkWSApO1xuXG4gICAgcC54ID0gcGF0aFB0LnggKyBub3JtYWwueDtcbiAgICBwLnkgPSBwYXRoUHQueSArIG5vcm1hbC55O1xuXG4gIH1cblxuICByZXR1cm4gb2xkUHRzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9HeXJvc2NvcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkd5cm9zY29wZSA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbn07XG5cblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5HeXJvc2NvcGU7XG5cblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdHJhbnNsYXRpb25PYmplY3QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgcXVhdGVybmlvbk9iamVjdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIHZhciBzY2FsZU9iamVjdCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgdmFyIHRyYW5zbGF0aW9uV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgcXVhdGVybmlvbldvcmxkID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdmFyIHNjYWxlV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGZvcmNlICkge1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICAvLyB1cGRhdGUgbWF0cml4V29ybGRcblxuICAgIGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xuXG4gICAgICBpZiAoIHRoaXMucGFyZW50ICkge1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHRyYW5zbGF0aW9uV29ybGQsIHF1YXRlcm5pb25Xb3JsZCwgc2NhbGVXb3JsZCApO1xuICAgICAgICB0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRyYW5zbGF0aW9uT2JqZWN0LCBxdWF0ZXJuaW9uT2JqZWN0LCBzY2FsZU9iamVjdCApO1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuY29tcG9zZSggdHJhbnNsYXRpb25Xb3JsZCwgcXVhdGVybmlvbk9iamVjdCwgc2NhbGVXb3JsZCApO1xuXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICB9XG5cblxuICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGZvcmNlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjaGlsZHJlblxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cbiAgICB9XG5cbiAgfTtcblxufSgpICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1BhdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cbiAqXG4gKiovXG5cblRIUkVFLlBhdGggPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICBUSFJFRS5DdXJ2ZVBhdGguY2FsbCh0aGlzKTtcblxuICB0aGlzLmFjdGlvbnMgPSBbXTtcblxuICBpZiAoIHBvaW50cyApIHtcblxuICAgIHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcblRIUkVFLlBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGF0aDtcblxuVEhSRUUuUGF0aEFjdGlvbnMgPSB7XG5cbiAgTU9WRV9UTzogJ21vdmVUbycsXG4gIExJTkVfVE86ICdsaW5lVG8nLFxuICBRVUFEUkFUSUNfQ1VSVkVfVE86ICdxdWFkcmF0aWNDdXJ2ZVRvJywgLy8gQmV6aWVyIHF1YWRyYXRpYyBjdXJ2ZVxuICBCRVpJRVJfQ1VSVkVfVE86ICdiZXppZXJDdXJ2ZVRvJywgICAgIC8vIEJlemllciBjdWJpYyBjdXJ2ZVxuICBDU1BMSU5FX1RIUlU6ICdzcGxpbmVUaHJ1JywgICAgICAgLy8gQ2F0bXVsbC1yb20gc3BsaW5lXG4gIEFSQzogJ2FyYycsICAgICAgICAgICAgICAgLy8gQ2lyY2xlXG4gIEVMTElQU0U6ICdlbGxpcHNlJ1xufTtcblxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxuXG4vLyBDcmVhdGUgcGF0aCB1c2luZyBzdHJhaWdodCBsaW5lcyB0byBjb25uZWN0IGFsbCBwb2ludHNcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gIHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcblxuICBmb3IgKCB2YXIgdiA9IDEsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDsgdiA8IHZsZW47IHYgKysgKSB7XG5cbiAgICB0aGlzLmxpbmVUbyggdmVjdG9yc1sgdiBdLngsIHZlY3RvcnNbIHYgXS55ICk7XG5cbiAgfVxuXG59O1xuXG4vLyBzdGFydFBhdGgoKSBlbmRQYXRoKCk/XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcbiAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiggYUNQMXgsIGFDUDF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFDUDJ4LCBhQ1AyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhWCwgYVkgKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5zcGxpbmVUaHJ1ID0gZnVuY3Rpb24oIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuLy8tLS1cbiAgdmFyIG5wdHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSBdO1xuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggbnB0cywgcHRzICk7XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBucHRzICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlUsIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG4vLyBGVVRVUkU6IENoYW5nZSB0aGUgQVBJIG9yIGZvbGxvdyBjYW52YXMgQVBJP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxXS5hcmdzO1xuICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gIHRoaXMuYWJzYXJjKGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG4gfTtcblxuIFRIUkVFLlBhdGgucHJvdG90eXBlLmFic2FyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuICB0aGlzLmFic2VsbGlwc2UoYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKTtcbiB9O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5lbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICB0aGlzLmFic2VsbGlwc2UoYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbiB9O1xuXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gIHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCgxKTtcbiAgYXJncy5wdXNoKGxhc3RQb2ludC54KTtcbiAgYXJncy5wdXNoKGxhc3RQb2ludC55KTtcblxuICB0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0UsIGFyZ3M6IGFyZ3MgfSApO1xuXG4gfTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XG5cbiAgaWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDQwO1xuXG4gIHZhciBwb2ludHMgPSBbXTtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkgKysgKSB7XG5cbiAgICBwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XG5cbiAgICAvL2lmKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcblxuICB9XG5cbiAgLy8gaWYgKCBjbG9zZWRQYXRoICkge1xuICAvL1xuICAvLyAgcG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG4gIC8vXG4gIC8vIH1cblxuICByZXR1cm4gcG9pbnRzO1xuXG59O1xuXG4vKiBSZXR1cm4gYW4gYXJyYXkgb2YgdmVjdG9ycyBiYXNlZCBvbiBjb250b3VyIG9mIHRoZSBwYXRoICovXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XG5cbiAgaWYgKHRoaXMudXNlU3BhY2VkUG9pbnRzKSB7XG4gICAgY29uc29sZS5sb2coJ3RhdGEnKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApO1xuICB9XG5cbiAgZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xuXG4gIHZhciBwb2ludHMgPSBbXTtcblxuICB2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcbiAgdmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxuICAgIGxhc3RlLCBqLFxuICAgIHQsIHR4LCB0eTtcblxuICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XG5cbiAgICBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcbiAgICBhcmdzID0gaXRlbS5hcmdzO1xuXG4gICAgc3dpdGNoICggYWN0aW9uICkge1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPOlxuXG4gICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE86XG5cbiAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPOlxuXG4gICAgICBjcHggID0gYXJnc1sgMiBdO1xuICAgICAgY3B5ICA9IGFyZ3NbIDMgXTtcblxuICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcbiAgICAgIGNweTEgPSBhcmdzWyAxIF07XG5cbiAgICAgIGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG4gICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcblxuICAgICAgICB0ID0gaiAvIGRpdmlzaW9ucztcblxuICAgICAgICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcbiAgICAgICAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE86XG5cbiAgICAgIGNweCAgPSBhcmdzWyA0IF07XG4gICAgICBjcHkgID0gYXJnc1sgNSBdO1xuXG4gICAgICBjcHgxID0gYXJnc1sgMCBdO1xuICAgICAgY3B5MSA9IGFyZ3NbIDEgXTtcblxuICAgICAgY3B4MiA9IGFyZ3NbIDIgXTtcbiAgICAgIGNweTIgPSBhcmdzWyAzIF07XG5cbiAgICAgIGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG4gICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG4gICAgICB9XG5cblxuICAgICAgZm9yICggaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xuXG4gICAgICAgIHQgPSBqIC8gZGl2aXNpb25zO1xuXG4gICAgICAgIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuICAgICAgICB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblxuICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVTpcblxuICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuICAgICAgdmFyIGxhc3QgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSwgbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXSApO1xuICAgICAgdmFyIHNwdHMgPSBbIGxhc3QgXTtcblxuICAgICAgdmFyIG4gPSBkaXZpc2lvbnMgKiBhcmdzWyAwIF0ubGVuZ3RoO1xuXG4gICAgICBzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xuXG4gICAgICB2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IG47IGogKysgKSB7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICkgO1xuXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5BUkM6XG5cbiAgICAgIHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXG4gICAgICAgIGFSYWRpdXMgPSBhcmdzWyAyIF0sXG4gICAgICAgIGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLCBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXG4gICAgICAgIGFDbG9ja3dpc2UgPSAhISBhcmdzWyA1IF07XG5cbiAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG4gICAgICB2YXIgYW5nbGU7XG4gICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cbiAgICAgICAgdCA9IGogLyB0ZGl2aXNpb25zO1xuXG4gICAgICAgIGlmICggISBhQ2xvY2t3aXNlICkge1xuXG4gICAgICAgICAgdCA9IDEgLSB0O1xuXG4gICAgICAgIH1cblxuICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgICAgICAgdHggPSBhWCArIGFSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgdHkgPSBhWSArIGFSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0U6XG5cbiAgICAgIHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXG4gICAgICAgIHhSYWRpdXMgPSBhcmdzWyAyIF0sXG4gICAgICAgIHlSYWRpdXMgPSBhcmdzWyAzIF0sXG4gICAgICAgIGFTdGFydEFuZ2xlID0gYXJnc1sgNCBdLCBhRW5kQW5nbGUgPSBhcmdzWyA1IF0sXG4gICAgICAgIGFDbG9ja3dpc2UgPSAhISBhcmdzWyA2IF07XG5cblxuICAgICAgdmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcbiAgICAgIHZhciBhbmdsZTtcbiAgICAgIHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcblxuICAgICAgZm9yICggaiA9IDE7IGogPD0gdGRpdmlzaW9uczsgaiArKyApIHtcblxuICAgICAgICB0ID0gaiAvIHRkaXZpc2lvbnM7XG5cbiAgICAgICAgaWYgKCAhIGFDbG9ja3dpc2UgKSB7XG5cbiAgICAgICAgICB0ID0gMSAtIHQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuICAgICAgICB0eCA9IGFYICsgeFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICAgICAgICB0eSA9IGFZICsgeVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcblxuICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgIH1cblxuICAgICAgLy9jb25zb2xlLmxvZyhwb2ludHMpO1xuXG4gICAgICBicmVhaztcblxuICAgIH0gLy8gZW5kIHN3aXRjaFxuXG4gIH1cblxuXG5cbiAgLy8gTm9ybWFsaXplIHRvIHJlbW92ZSB0aGUgY2xvc2luZyBwb2ludCBieSBkZWZhdWx0LlxuICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMV07XG4gIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuICBpZiAoIE1hdGguYWJzKGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCkgPCBFUFNJTE9OICYmXG4gICAgICAgTWF0aC5hYnMobGFzdFBvaW50LnkgLSBwb2ludHNbIDAgXS55KSA8IEVQU0lMT04pXG4gICAgcG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEpO1xuICBpZiAoIGNsb3NlZFBhdGggKSB7XG5cbiAgICBwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcblxufTtcblxuLy9cbi8vIEJyZWFrcyBwYXRoIGludG8gc2hhcGVzXG4vL1xuLy8gIEFzc3VtcHRpb25zIChpZiBwYXJhbWV0ZXIgaXNDQ1c9PXRydWUgdGhlIG9wcG9zaXRlIGhvbGRzKTpcbi8vICAtIHNvbGlkIHNoYXBlcyBhcmUgZGVmaW5lZCBjbG9ja3dpc2UgKENXKVxuLy8gIC0gaG9sZXMgYXJlIGRlZmluZWQgY291bnRlcmNsb2Nrd2lzZSAoQ0NXKVxuLy9cbi8vICBJZiBwYXJhbWV0ZXIgbm9Ib2xlcz09dHJ1ZTpcbi8vICAtIGFsbCBzdWJQYXRocyBhcmUgcmVnYXJkZWQgYXMgc29saWQgc2hhcGVzXG4vLyAgLSBkZWZpbml0aW9uIG9yZGVyIENXL0NDVyBoYXMgbm8gcmVsZXZhbmNlXG4vL1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS50b1NoYXBlcyA9IGZ1bmN0aW9uKCBpc0NDVywgbm9Ib2xlcyApIHtcblxuICBmdW5jdGlvbiBleHRyYWN0U3VicGF0aHMoIGluQWN0aW9ucyApIHtcblxuICAgIHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuXG4gICAgdmFyIHN1YlBhdGhzID0gW10sIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgaXRlbSA9IGluQWN0aW9uc1sgaSBdO1xuXG4gICAgICBhcmdzID0gaXRlbS5hcmdzO1xuICAgICAgYWN0aW9uID0gaXRlbS5hY3Rpb247XG5cbiAgICAgIGlmICggYWN0aW9uID09PSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPICkge1xuXG4gICAgICAgIGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICAgICAgICBzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgbGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcblxuICAgICAgc3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcblxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKHN1YlBhdGhzKTtcblxuICAgIHJldHVybiAgc3ViUGF0aHM7XG4gIH1cblxuICBmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XG5cbiAgICB2YXIgc2hhcGVzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XG5cbiAgICAgIHZhciB0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICAgICAgdG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcbiAgICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG4gICAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuICAgIHJldHVybiBzaGFwZXM7XG4gIH1cblxuICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xuICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgdmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3JcbiAgICAvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXG4gICAgLy8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuICAgIC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XG4gICAgICB2YXIgZWRnZUxvd1B0ICA9IGluUG9seWdvblsgcCBdO1xuICAgICAgdmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuICAgICAgdmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuICAgICAgdmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG4gICAgICBpZiAoIE1hdGguYWJzKGVkZ2VEeSkgPiBFUFNJTE9OICkgeyAgICAgLy8gbm90IHBhcmFsbGVsXG4gICAgICAgIGlmICggZWRnZUR5IDwgMCApIHtcbiAgICAgICAgICBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xuICAgICAgICAgIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHAgXTsgZWRnZUR5ID0gLSBlZGdlRHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcbiAgICAgICAgICBpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKSAgIHJldHVybiAgdHJ1ZTsgICAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgICAgICAgIC8vIGNvbnRpbnVlOyAgICAgICAgLy8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqIChpblB0LnggLSBlZGdlTG93UHQueCkgLSBlZGdlRHggKiAoaW5QdC55IC0gZWRnZUxvd1B0LnkpO1xuICAgICAgICAgIGlmICggcGVycEVkZ2UgPT09IDAgKSAgICAgICByZXR1cm4gIHRydWU7ICAgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cbiAgICAgICAgICBpZiAoIHBlcnBFZGdlIDwgMCApICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaW5zaWRlID0gISBpbnNpZGU7ICAgIC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAgICAvLyBwYXJhbGxlbCBvciBjb2xpbmVhclxuICAgICAgICBpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSAgICAgY29udGludWU7ICAgICAvLyBwYXJhbGxlbFxuICAgICAgICAvLyBlZ2RlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcbiAgICAgICAgaWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxuICAgICAgICAgICAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApICAgIHJldHVybiAgdHJ1ZTsgLy8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXG4gICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAgaW5zaWRlO1xuICB9XG5cblxuICB2YXIgc3ViUGF0aHMgPSBleHRyYWN0U3VicGF0aHMoIHRoaXMuYWN0aW9ucyApO1xuICBpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuICBpZiAoIG5vSG9sZXMgPT09IHRydWUgKSByZXR1cm4gIHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gIHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xuXG4gIGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxKSB7XG5cbiAgICB0bXBQYXRoID0gc3ViUGF0aHNbMF07XG4gICAgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICB0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgIHJldHVybiBzaGFwZXM7XG5cbiAgfVxuXG4gIHZhciBob2xlc0ZpcnN0ID0gISBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xuICBob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xuXG4gIC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cbiAgdmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcbiAgdmFyIG5ld1NoYXBlcyA9IFtdO1xuICB2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuICB2YXIgbWFpbklkeCA9IDA7XG4gIHZhciB0bXBQb2ludHM7XG5cbiAgbmV3U2hhcGVzW21haW5JZHhdID0gdW5kZWZpbmVkO1xuICBuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XG5cbiAgdmFyIGksIGlsO1xuXG4gIGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XG4gICAgdG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcbiAgICBzb2xpZCA9IFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcbiAgICBzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xuXG4gICAgaWYgKCBzb2xpZCApIHtcblxuICAgICAgaWYgKCAoISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbbWFpbklkeF0gKSApICBtYWluSWR4ICsrO1xuXG4gICAgICBuZXdTaGFwZXNbbWFpbklkeF0gPSB7IHM6IG5ldyBUSFJFRS5TaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcbiAgICAgIG5ld1NoYXBlc1ttYWluSWR4XS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG4gICAgICBuZXdTaGFwZXNbbWFpbklkeF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgICAgaWYgKCBob2xlc0ZpcnN0ICkgbWFpbklkeCArKztcbiAgICAgIG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTtcblxuICAgICAgLy9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIG5ld1NoYXBlSG9sZXNbbWFpbklkeF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbMF0gfSApO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXG4gIGlmICggISBuZXdTaGFwZXNbMF0gKSByZXR1cm4gIHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gIGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XG4gICAgdmFyIGFtYmlnaW91cyA9IGZhbHNlO1xuICAgIHZhciB0b0NoYW5nZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcbiAgICAgIGJldHRlclNoYXBlSG9sZXNbc0lkeF0gPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcbiAgICAgIHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzW3NJZHhdO1xuICAgICAgZm9yICh2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xuICAgICAgICB2YXIgaG8gPSBzaG9baElkeF07XG4gICAgICAgIHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBzMklkeCA9IDA7IHMySWR4IDwgbmV3U2hhcGVzLmxlbmd0aDsgczJJZHggKysgKSB7XG4gICAgICAgICAgaWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzW3MySWR4XS5wICkgKSB7XG4gICAgICAgICAgICBpZiAoIHNJZHggIT09IHMySWR4ICkgdG9DaGFuZ2UucHVzaCggeyBmcm9tczogc0lkeCwgdG9zOiBzMklkeCwgaG9sZTogaElkeCB9ICk7XG4gICAgICAgICAgICBpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcbiAgICAgICAgICAgICAgaG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbczJJZHhdLnB1c2goIGhvICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbWJpZ2lvdXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHsgYmV0dGVyU2hhcGVIb2xlc1tzSWR4XS5wdXNoKCBobyApOyB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiYW1iaWdpb3VzOiBcIiwgYW1iaWdpb3VzKTtcbiAgICBpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcbiAgICAgIGlmICghIGFtYmlnaW91cykgIG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0bXBIb2xlcywgaiwgamw7XG4gIGZvciAoIGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcbiAgICB0bXBTaGFwZSA9IG5ld1NoYXBlc1tpXS5zO1xuICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgIHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1tpXTtcbiAgICBmb3IgKCBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcbiAgICAgIHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzW2pdLmggKTtcbiAgICB9XG4gIH1cblxuICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuICByZXR1cm4gc2hhcGVzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9TaGFwZS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cbiAqKi9cblxuLy8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXG4vLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xuLy8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cblxuVEhSRUUuU2hhcGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuUGF0aC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gIHRoaXMuaG9sZXMgPSBbXTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUGF0aC5wcm90b3R5cGUgKTtcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIEV4dHJ1ZGVHZW9tZXRyeVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cnVkZSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuICB2YXIgZXh0cnVkZWQgPSBuZXcgVEhSRUUuRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gIHJldHVybiBleHRydWRlZDtcblxufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBTaGFwZUdlb21ldHJ5XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5tYWtlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcbiAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcblxuICB9XG5cbiAgcmV0dXJuIGhvbGVzUHRzO1xuXG59O1xuXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgdmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsIGhvbGVzUHRzID0gW107XG5cbiAgZm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xuXG4gIH1cblxuICByZXR1cm4gaG9sZXNQdHM7XG5cbn07XG5cblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgcmV0dXJuIHtcblxuICAgIHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMgKSxcbiAgICBob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuICB9O1xuXG59O1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIGlmICh0aGlzLnVzZVNwYWNlZFBvaW50cykge1xuICAgIHJldHVybiB0aGlzLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMoZGl2aXNpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmV4dHJhY3RBbGxQb2ludHMoZGl2aXNpb25zKTtcblxufTtcblxuLy9cbi8vIFRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzV2l0aEJlbmQgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucywgYmVuZCApIHtcbi8vXG4vLyAgcmV0dXJuIHtcbi8vXG4vLyAgICBzaGFwZTogdGhpcy50cmFuc2Zvcm0oIGJlbmQsIGRpdmlzaW9ucyApLFxuLy8gICAgaG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucywgYmVuZCApXG4vL1xuLy8gIH07XG4vL1xuLy8gfTtcblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIHJldHVybiB7XG5cbiAgICBzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXG4gICAgaG9sZXM6IHRoaXMuZ2V0U3BhY2VkUG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cbiAgfTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgVXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU2hhcGUuVXRpbHMgPSB7XG5cbiAgdHJpYW5ndWxhdGVTaGFwZTogZnVuY3Rpb24gKCBjb250b3VyLCBob2xlcyApIHtcblxuICAgIGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xuICAgICAgLy8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcbiAgICAgIGlmICggaW5TZWdQdDEueCAhPT0gaW5TZWdQdDIueCApIHtcbiAgICAgICAgaWYgKCBpblNlZ1B0MS54IDwgaW5TZWdQdDIueCApIHtcbiAgICAgICAgICByZXR1cm4gICggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gICggKCBpblNlZ1B0Mi54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0MS54ICkgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCBpblNlZ1B0MS55IDwgaW5TZWdQdDIueSApIHtcbiAgICAgICAgICByZXR1cm4gICggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gICggKCBpblNlZ1B0Mi55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0MS55ICkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSB7XG4gICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgdmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcbiAgICAgIHZhciBzZWcyZHggPSBpblNlZzJQdDIueCAtIGluU2VnMlB0MS54LCAgIHNlZzJkeSA9IGluU2VnMlB0Mi55IC0gaW5TZWcyUHQxLnk7XG5cbiAgICAgIHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcbiAgICAgIHZhciBzZWcxc2VnMmR5ID0gaW5TZWcxUHQxLnkgLSBpblNlZzJQdDEueTtcblxuICAgICAgdmFyIGxpbWl0ICAgPSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG4gICAgICB2YXIgcGVycFNlZzEgID0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMobGltaXQpID4gRVBTSUxPTiApIHsgICAgICAvLyBub3QgcGFyYWxsZWxcblxuICAgICAgICB2YXIgcGVycFNlZzI7XG4gICAgICAgIGlmICggbGltaXQgPiAwICkge1xuICAgICAgICAgIGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApICAgICByZXR1cm4gW107XG4gICAgICAgICAgcGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcbiAgICAgICAgICBpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApICAgICByZXR1cm4gW107XG4gICAgICAgICAgcGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcbiAgICAgICAgICBpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XG4gICAgICAgIGlmICggcGVycFNlZzIgPT09IDAgKSB7XG4gICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApICkgICByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBwZXJwU2VnMiA9PT0gbGltaXQgKSB7XG4gICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApICkgICByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQyIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMj9cbiAgICAgICAgaWYgKCBwZXJwU2VnMSA9PT0gMCApICAgcmV0dXJuIFsgaW5TZWcyUHQxIF07XG4gICAgICAgIGlmICggcGVycFNlZzEgPT09IGxpbWl0ICkgcmV0dXJuIFsgaW5TZWcyUHQyIF07XG5cbiAgICAgICAgLy8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcbiAgICAgICAgcmV0dXJuICBbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxuICAgICAgICAgICAgICB5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xuXG4gICAgICB9IGVsc2UgeyAgICAvLyBwYXJhbGxlbCBvciBjb2xpbmVhclxuICAgICAgICBpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxuICAgICAgICAgICAoIHNlZzJkeSAqIHNlZzFzZWcyZHggIT09IHNlZzJkeCAqIHNlZzFzZWcyZHkgKSApICAgICAgcmV0dXJuIFtdO1xuXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXG4gICAgICAgIHZhciBzZWcxUHQgPSAoIChzZWcxZHggPT09IDApICYmIChzZWcxZHkgPT09IDApICk7ICAvLyBzZWdtZW50MSBpc3QganVzdCBhIHBvaW50P1xuICAgICAgICB2YXIgc2VnMlB0ID0gKCAoc2VnMmR4ID09PSAwKSAmJiAoc2VnMmR5ID09PSAwKSApOyAgLy8gc2VnbWVudDIgaXN0IGp1c3QgYSBwb2ludD9cbiAgICAgICAgLy8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXG4gICAgICAgIGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcbiAgICAgICAgICBpZiAoIChpblNlZzFQdDEueCAhPT0gaW5TZWcyUHQxLngpIHx8XG4gICAgICAgICAgICAgKGluU2VnMVB0MS55ICE9PSBpblNlZzJQdDEueSkgKSAgICByZXR1cm4gW107ICAvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXG4gICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSB0aGUgc2FtZSBwb2ludFxuICAgICAgICB9XG4gICAgICAgIC8vIHNlZ21lbnQjMSAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgaWYgKCBzZWcxUHQgKSB7XG4gICAgICAgICAgaWYgKCEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluU2VnMVB0MSApICkgICAgcmV0dXJuIFtdOyAgICAvLyBidXQgbm90IGluIHNlZ21lbnQjMlxuICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgaWYgKCBzZWcyUHQgKSB7XG4gICAgICAgICAgaWYgKCEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApICkgICAgcmV0dXJuIFtdOyAgICAvLyBidXQgbm90IGluIHNlZ21lbnQjMVxuICAgICAgICAgIHJldHVybiBbIGluU2VnMlB0MSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXG4gICAgICAgIHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xuICAgICAgICB2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcbiAgICAgICAgaWYgKHNlZzFkeCAhPT0gMCkgeyAgIC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxuICAgICAgICAgIGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcbiAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcbiAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcbiAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxuICAgICAgICAgIGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcbiAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcbiAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xuICAgICAgICAgICAgc2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcbiAgICAgICAgICAgIHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG4gICAgICAgICAgaWYgKCBzZWcxbWF4VmFsIDwgIHNlZzJtaW5WYWwgKSByZXR1cm4gW107XG4gICAgICAgICAgaWYgKCBzZWcxbWF4VmFsID09PSBzZWcybWluVmFsICkgIHtcbiAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIFsgc2VnMm1pbiBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApIHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcbiAgICAgICAgICByZXR1cm4gIFsgc2VnMm1pbiwgc2VnMm1heCBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsICkgcmV0dXJuIFtdO1xuICAgICAgICAgIGlmICggc2VnMW1pblZhbCA9PT0gc2VnMm1heFZhbCApICB7XG4gICAgICAgICAgICBpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBbIHNlZzFtaW4gXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKSByZXR1cm4gWyBzZWcxbWluLCBzZWcxbWF4IF07XG4gICAgICAgICAgcmV0dXJuICBbIHNlZzFtaW4sIHNlZzJtYXggXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVBbmdsZSggaW5WZXJ0ZXgsIGluTGVnRnJvbVB0LCBpbkxlZ1RvUHQsIGluT3RoZXJQdCApIHtcbiAgICAgIC8vIFRoZSBvcmRlciBvZiBsZWdzIGlzIGltcG9ydGFudFxuXG4gICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgLy8gdHJhbnNsYXRpb24gb2YgYWxsIHBvaW50cywgc28gdGhhdCBWZXJ0ZXggaXMgYXQgKDAsMClcbiAgICAgIHZhciBsZWdGcm9tUHRYICA9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LCAgbGVnRnJvbVB0WSA9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuICAgICAgdmFyIGxlZ1RvUHRYICA9IGluTGVnVG9QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ1RvUHRZICAgPSBpbkxlZ1RvUHQueSAtIGluVmVydGV4Lnk7XG4gICAgICB2YXIgb3RoZXJQdFggID0gaW5PdGhlclB0LnggLSBpblZlcnRleC54LCAgb3RoZXJQdFkgICA9IGluT3RoZXJQdC55IC0gaW5WZXJ0ZXgueTtcblxuICAgICAgLy8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG4gICAgICB2YXIgZnJvbTJ0b0FuZ2xlICA9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcbiAgICAgIHZhciBmcm9tMm90aGVyQW5nbGUgPSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoZnJvbTJ0b0FuZ2xlKSA+IEVQU0lMT04gKSB7ICAgICAvLyBhbmdsZSAhPSAxODAgZGVnLlxuXG4gICAgICAgIHZhciBvdGhlcjJ0b0FuZ2xlICAgPSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG4gICAgICAgIGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHsgICAgICAgLy8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXG4gICAgICAgICAgcmV0dXJuICAoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSAmJiAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgIC8vIG1haW4gYW5nbGUgPiAxODAgZGVnLlxuICAgICAgICAgIHJldHVybiAgKCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLy8gYW5nbGUgPT0gMTgwIGRlZy5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xuICAgICAgICByZXR1cm4gICggZnJvbTJvdGhlckFuZ2xlID4gMCApO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xuXG4gICAgICB2YXIgc2hhcGUgPSBjb250b3VyLmNvbmNhdCgpOyAvLyB3b3JrIG9uIHRoaXMgc2hhcGVcbiAgICAgIHZhciBob2xlO1xuXG4gICAgICBmdW5jdGlvbiBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIGluU2hhcGVJZHgsIGluSG9sZUlkeCApIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcbiAgICAgICAgdmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdmFyIHByZXZTaGFwZUlkeCA9IGluU2hhcGVJZHggLSAxO1xuICAgICAgICBpZiAoIHByZXZTaGFwZUlkeCA8IDAgKSAgICAgcHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xuXG4gICAgICAgIHZhciBuZXh0U2hhcGVJZHggPSBpblNoYXBlSWR4ICsgMTtcbiAgICAgICAgaWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKSAgbmV4dFNoYXBlSWR4ID0gMDtcblxuICAgICAgICB2YXIgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIHNoYXBlW2luU2hhcGVJZHhdLCBzaGFwZVsgcHJldlNoYXBlSWR4IF0sIHNoYXBlWyBuZXh0U2hhcGVJZHggXSwgaG9sZVtpbkhvbGVJZHhdICk7XG4gICAgICAgIGlmICghIGluc2lkZUFuZ2xlICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoU2hhcGUpOiBcIiArIGluU2hhcGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgaG9sZVtpbkhvbGVJZHhdLnggKyBcIi9cIiArIGhvbGVbaW5Ib2xlSWR4XS55ICk7XG4gICAgICAgICAgcmV0dXJuICBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XG4gICAgICAgIHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcblxuICAgICAgICB2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xuICAgICAgICBpZiAoIHByZXZIb2xlSWR4IDwgMCApICAgICAgcHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcblxuICAgICAgICB2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xuICAgICAgICBpZiAoIG5leHRIb2xlSWR4ID4gbGFzdEhvbGVJZHggKSAgbmV4dEhvbGVJZHggPSAwO1xuXG4gICAgICAgIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlW2luSG9sZUlkeF0sIGhvbGVbIHByZXZIb2xlSWR4IF0sIGhvbGVbIG5leHRIb2xlSWR4IF0sIHNoYXBlW2luU2hhcGVJZHhdICk7XG4gICAgICAgIGlmICghIGluc2lkZUFuZ2xlICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoSG9sZSk6IFwiICsgaW5Ib2xlSWR4ICsgXCIsIFBvaW50OiBcIiArIHNoYXBlW2luU2hhcGVJZHhdLnggKyBcIi9cIiArIHNoYXBlW2luU2hhcGVJZHhdLnkgKTtcbiAgICAgICAgICByZXR1cm4gIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzU2hhcGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuICAgICAgICAvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBzaGFwZSBlZGdlc1xuICAgICAgICB2YXIgc0lkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuICAgICAgICBmb3IgKCBzSWR4ID0gMDsgc0lkeCA8IHNoYXBlLmxlbmd0aDsgc0lkeCArKyApIHtcbiAgICAgICAgICBuZXh0SWR4ID0gc0lkeCArIDE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xuICAgICAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbc0lkeF0sIHNoYXBlW25leHRJZHhdLCB0cnVlICk7XG4gICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApICAgIHJldHVybiAgdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRlcEhvbGVzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcbiAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xuICAgICAgICB2YXIgaWhJZHgsIGNoa0hvbGUsXG4gICAgICAgICAgaElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuICAgICAgICBmb3IgKCBpaElkeCA9IDA7IGloSWR4IDwgaW5kZXBIb2xlcy5sZW5ndGg7IGloSWR4ICsrICkge1xuICAgICAgICAgIGNoa0hvbGUgPSBob2xlc1tpbmRlcEhvbGVzW2loSWR4XV07XG4gICAgICAgICAgZm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcbiAgICAgICAgICAgIG5leHRJZHggPSBoSWR4ICsgMTsgbmV4dElkeCAlPSBjaGtIb2xlLmxlbmd0aDtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVtoSWR4XSwgY2hrSG9sZVtuZXh0SWR4XSwgdHJ1ZSApO1xuICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApICAgIHJldHVybiAgdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcbiAgICAgICAgc2hhcGVQdCwgaG9sZVB0LFxuICAgICAgICBob2xlSWR4LCBjdXRLZXksIGZhaWxlZEN1dHMgPSBbXSxcbiAgICAgICAgdG1wU2hhcGUxLCB0bXBTaGFwZTIsXG4gICAgICAgIHRtcEhvbGUxLCB0bXBIb2xlMjtcblxuICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICAgIGluZGVwSG9sZXMucHVzaCggaCApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5TaGFwZUluZGV4ID0gMDtcbiAgICAgIHZhciBjb3VudGVyID0gaW5kZXBIb2xlcy5sZW5ndGggKiAyO1xuICAgICAgd2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIGNvdW50ZXIgLS07XG4gICAgICAgIGlmICggY291bnRlciA8IDAgKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxuICAgICAgICAvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuICAgICAgICBmb3IgKCBzaGFwZUluZGV4ID0gbWluU2hhcGVJbmRleDsgc2hhcGVJbmRleCA8IHNoYXBlLmxlbmd0aDsgc2hhcGVJbmRleCArKyApIHtcblxuICAgICAgICAgIHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xuICAgICAgICAgIGhvbGVJbmRleCA9IC0gMTtcblxuICAgICAgICAgIC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICAgICAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaCArKyApIHtcbiAgICAgICAgICAgIGhvbGVJZHggPSBpbmRlcEhvbGVzW2hdO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xuICAgICAgICAgICAgY3V0S2V5ID0gc2hhcGVQdC54ICsgXCI6XCIgKyBzaGFwZVB0LnkgKyBcIjpcIiArIGhvbGVJZHg7XG4gICAgICAgICAgICBpZiAoIGZhaWxlZEN1dHNbY3V0S2V5XSAhPT0gdW5kZWZpbmVkICkgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBob2xlID0gaG9sZXNbaG9sZUlkeF07XG4gICAgICAgICAgICBmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcbiAgICAgICAgICAgICAgaG9sZVB0ID0gaG9sZVsgaDIgXTtcbiAgICAgICAgICAgICAgaWYgKCEgaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBzaGFwZUluZGV4LCBoMiApICkgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzU2hhcGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApICAgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgIGhvbGVJbmRleCA9IGgyO1xuICAgICAgICAgICAgICBpbmRlcEhvbGVzLnNwbGljZShoLCAxKTtcblxuICAgICAgICAgICAgICB0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCArIDEgKTtcbiAgICAgICAgICAgICAgdG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcbiAgICAgICAgICAgICAgdG1wSG9sZTEgPSBob2xlLnNsaWNlKCBob2xlSW5kZXggKTtcbiAgICAgICAgICAgICAgdG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKyAxICk7XG5cbiAgICAgICAgICAgICAgc2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG4gICAgICAgICAgICAgIG1pblNoYXBlSW5kZXggPSBzaGFwZUluZGV4O1xuXG4gICAgICAgICAgICAgIC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcbiAgICAgICAgICAgICAgLy8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGhvbGVJbmRleCA+PSAwICkgYnJlYWs7ICAgIC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cbiAgICAgICAgICAgIGZhaWxlZEN1dHNbY3V0S2V5XSA9IHRydWU7ICAgICAgLy8gcmVtZW1iZXIgZmFpbHVyZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGhvbGVJbmRleCA+PSAwICkgYnJlYWs7ICAgIC8vIGhvbGUtdmVydGV4IGZvdW5kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXBlOyAgICAgICAvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXG4gICAgfVxuXG5cbiAgICB2YXIgaSwgaWwsIGYsIGZhY2UsXG4gICAgICBrZXksIGluZGV4LFxuICAgICAgYWxsUG9pbnRzTWFwID0ge307XG5cbiAgICAvLyBUbyBtYWludGFpbiByZWZlcmVuY2UgdG8gb2xkIHNoYXBlLCBvbmUgbXVzdCBtYXRjaCBjb29yZGluYXRlcywgb3Igb2Zmc2V0IHRoZSBpbmRpY2VzIGZyb20gb3JpZ2luYWwgYXJyYXlzLiBJdCdzIHByb2JhYmx5IGVhc2llciB0byBkbyB0aGUgZmlyc3QuXG5cbiAgICB2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcblxuICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFsbHBvaW50cywgaG9sZXNbaF0gKTtcblxuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XG5cbiAgICAvLyBwcmVwYXJlIGFsbCBwb2ludHMgbWFwXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XG5cbiAgICAgIGlmICggYWxsUG9pbnRzTWFwWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5TaGFwZTogRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xuXG4gICAgICB9XG5cbiAgICAgIGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xuXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxuICAgIHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxuICAgIC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XG5cbiAgICAvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcblxuICAgICAgZm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xuXG4gICAgICAgIGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcblxuICAgICAgICBpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgZmFjZVsgZiBdID0gaW5kZXg7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xuXG4gIH0sXG5cbiAgaXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xuXG4gICAgcmV0dXJuIFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBwdHMgKSA8IDA7XG5cbiAgfSxcblxuICAvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuXG4gIC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gIGIycDA6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIGsgKiBrICogcDtcblxuICB9LFxuXG4gIGIycDE6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cbiAgfSxcblxuICBiMnAyOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICByZXR1cm4gdCAqIHQgKiBwO1xuXG4gIH0sXG5cbiAgYjI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcblxuICAgIHJldHVybiB0aGlzLmIycDAoIHQsIHAwICkgKyB0aGlzLmIycDEoIHQsIHAxICkgKyB0aGlzLmIycDIoIHQsIHAyICk7XG5cbiAgfSxcblxuICAvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cbiAgYjNwMDogZnVuY3Rpb24gKCB0LCBwICkge1xuXG4gICAgdmFyIGsgPSAxIC0gdDtcbiAgICByZXR1cm4gayAqIGsgKiBrICogcDtcblxuICB9LFxuXG4gIGIzcDE6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG4gIH0sXG5cbiAgYjNwMjogZnVuY3Rpb24gKCB0LCBwICkge1xuXG4gICAgdmFyIGsgPSAxIC0gdDtcbiAgICByZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cbiAgfSxcblxuICBiM3AzOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICByZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuICB9LFxuXG4gIGIzOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYjNwMCggdCwgcDAgKSArIHRoaXMuYjNwMSggdCwgcDEgKSArIHRoaXMuYjNwMiggdCwgcDIgKSArICB0aGlzLmIzcDMoIHQsIHAzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBMaW5lXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG4gIHRoaXMudjEgPSB2MTtcbiAgdGhpcy52MiA9IHYyO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUN1cnZlO1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gIHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XG4gIHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cbiAgcmV0dXJuIHBvaW50O1xuXG59O1xuXG4vLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG4gIHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtcblxuICByZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBRdWFkcmF0aWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cbiAgdGhpcy52MCA9IHYwO1xuICB0aGlzLnYxID0gdjE7XG4gIHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTtcblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgdmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuICB2ZWN0b3IueSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XG5cbiAgcmV0dXJuIHZlY3RvcjtcblxufTtcblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblxuICAvLyByZXR1cm5zIHVuaXQgdmVjdG9yXG5cbiAgcmV0dXJuIHZlY3Rvci5ub3JtYWxpemUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEN1YmljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuICB0aGlzLnYwID0gdjA7XG4gIHRoaXMudjEgPSB2MTtcbiAgdGhpcy52MiA9IHYyO1xuICB0aGlzLnYzID0gdjM7XG5cbn07XG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmljQmV6aWVyQ3VydmU7XG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gIHZhciB0eCwgdHk7XG5cbiAgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG4gIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xuXG4gIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG5cbn07XG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICB2YXIgdHgsIHR5O1xuXG4gIHR4ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcbiAgdHkgPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xuXG4gIHZhciB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xuICB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiB0YW5nZW50O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIFNwbGluZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5TcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XG5cbiAgdGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG59O1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gIHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcbiAgdmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcbiAgdmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG4gIHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcbiAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApO1xuXG4gIHJldHVybiB2ZWN0b3I7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEVsbGlwc2UgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuRWxsaXBzZUN1cnZlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgdGhpcy5hWCA9IGFYO1xuICB0aGlzLmFZID0gYVk7XG5cbiAgdGhpcy54UmFkaXVzID0geFJhZGl1cztcbiAgdGhpcy55UmFkaXVzID0geVJhZGl1cztcblxuICB0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG4gIHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuXG4gIHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cbn07XG5cblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FbGxpcHNlQ3VydmU7XG5cblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgdmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cbiAgaWYgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gIGlmICggZGVsdGFBbmdsZSA+IE1hdGguUEkgKiAyICkgZGVsdGFBbmdsZSAtPSBNYXRoLlBJICogMjtcblxuICB2YXIgYW5nbGU7XG5cbiAgaWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgKSB7XG5cbiAgICBhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcblxuICB9IGVsc2Uge1xuXG4gICAgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgfVxuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gIHZlY3Rvci54ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICB2ZWN0b3IueSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICByZXR1cm4gdmVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gIFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcbn07XG5cblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFyY0N1cnZlO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgTGluZTNEXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cbiAgICB0aGlzLnYxID0gdjE7XG4gICAgdGhpcy52MiA9IHYyO1xuXG4gIH0sXG5cbiAgZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2ZWN0b3Iuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApOyAvLyBkaWZmXG4gICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKCB0ICk7XG4gICAgdmVjdG9yLmFkZCggdGhpcy52MSApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxuICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIFF1YWRyYXRpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gIGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcblxuICAgIHRoaXMudjAgPSB2MDtcbiAgICB0aGlzLnYxID0gdjE7XG4gICAgdGhpcy52MiA9IHYyO1xuXG4gIH0sXG5cbiAgZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuICAgIHZlY3Rvci56ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEN1YmljIEJlemllciAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG4gICAgdGhpcy52MCA9IHYwO1xuICAgIHRoaXMudjEgPSB2MTtcbiAgICB0aGlzLnYyID0gdjI7XG4gICAgdGhpcy52MyA9IHYzO1xuXG4gIH0sXG5cbiAgZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcbiAgICB2ZWN0b3IueiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56LCB0aGlzLnYzLnogKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xuICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuICB9LFxuXG4gIGZ1bmN0aW9uICggdCApIHtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgIHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICAgIHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgdmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG4gICAgdmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG4gICAgdmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxuICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICpcbiAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cbiAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXG4gKlxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG4gKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XG4gKi9cblxuVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyA9ICggZnVuY3Rpb24oKSB7XG5cbiAgdmFyXG4gICAgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBweCA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBweSA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBweiA9IG5ldyBDdWJpY1BvbHkoKTtcblxuICAvKlxuICBCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gICAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXG4gICAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG4gIFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbiAgYnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXG4gIHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cbiAgKi9cblxuICBmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XG5cbiAgfVxuXG4gIC8qXG4gICAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcbiAgICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG4gICAqIHN1Y2ggdGhhdFxuICAgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXG4gICAqICBhbmRcbiAgICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuICAgKi9cbiAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIHgwLCB4MSwgdDAsIHQxICkge1xuXG4gICAgdGhpcy5jMCA9IHgwO1xuICAgIHRoaXMuYzEgPSB0MDtcbiAgICB0aGlzLmMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcbiAgICB0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblxuICB9O1xuXG4gIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG4gICAgLy8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuICAgIHZhciB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XG4gICAgdmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuICAgIC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuICAgIHQxICo9IGR0MTtcbiAgICB0MiAqPSBkdDE7XG5cbiAgICAvLyBpbml0Q3ViaWNQb2x5XG4gICAgdGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xuXG4gIH07XG5cbiAgLy8gc3RhbmRhcmQgQ2F0bXVsbC1Sb20gc3BsaW5lOiBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHgxIGFuZCB4MiB3aXRoIHByZXZpb3VzL2ZvbGxvd2luZyBwb2ludHMgeDEveDRcbiAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Q2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgdGVuc2lvbiApIHtcblxuICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG4gIH07XG5cbiAgQ3ViaWNQb2x5LnByb3RvdHlwZS5jYWxjID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdDIgPSB0ICogdDtcbiAgICB2YXIgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcblxuICB9O1xuXG4gIC8vIFN1YmNsYXNzIFRocmVlLmpzIGN1cnZlXG4gIHJldHVybiBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiAoIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgICAgdGhpcy5wb2ludHMgPSBwIHx8IFtdO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uICggdCApIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgbDtcblxuICAgICAgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGlmICggbCA8IDIgKSBjb25zb2xlLmxvZyggJ2R1aCwgeW91IG5lZWQgYXQgbGVhc3QgMiBwb2ludHMnICk7XG5cbiAgICAgIHBvaW50ID0gKCBsIC0gMSApICogdDtcbiAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcblxuICAgICAgICBpbnRQb2ludCA9IGwgLSAyO1xuICAgICAgICB3ZWlnaHQgPSAxO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBwMCwgcDEsIHAyLCBwMztcblxuICAgICAgaWYgKCBpbnRQb2ludCA9PT0gMCApIHtcblxuICAgICAgICAvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxuICAgICAgICB0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuICAgICAgICBwMCA9IHRtcDtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBwMCA9IHBvaW50c1sgaW50UG9pbnQgLSAxIF07XG5cbiAgICAgIH1cblxuICAgICAgcDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgICBwMiA9IHBvaW50c1sgaW50UG9pbnQgKyAxIF07XG5cbiAgICAgIGlmICggaW50UG9pbnQgKyAyIDwgbCApIHtcblxuICAgICAgICBwMyA9IHBvaW50c1sgaW50UG9pbnQgKyAyIF1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG4gICAgICAgIHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMiBdICk7XG4gICAgICAgIHAzID0gdG1wO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy50eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy50eXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG4gICAgICAgIC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG4gICAgICAgIHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG4gICAgICAgIHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xuICAgICAgICB2YXIgZHQxID0gTWF0aC5wb3coIHAxLmRpc3RhbmNlVG9TcXVhcmVkKCBwMiApLCBwb3cgKTtcbiAgICAgICAgdmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cbiAgICAgICAgLy8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcbiAgICAgICAgaWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xuICAgICAgICBpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG4gICAgICAgIGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcblxuICAgICAgICBweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcbiAgICAgICAgcHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG4gICAgICAgIHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xuXG4gICAgICB9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcblxuICAgICAgICB2YXIgdGVuc2lvbiA9IHRoaXMudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy50ZW5zaW9uIDogMC41O1xuICAgICAgICBweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGVuc2lvbiApO1xuICAgICAgICBweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xuICAgICAgICBwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGVuc2lvbiApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIHB4LmNhbGMoIHdlaWdodCApLFxuICAgICAgICBweS5jYWxjKCB3ZWlnaHQgKSxcbiAgICAgICAgcHouY2FsYyggd2VpZ2h0IClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB2O1xuXG4gICAgfVxuXG4gICk7XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0Nsb3NlZFNwbGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDbG9zZWQgU3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gIGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8pIHtcblxuICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuICB9LFxuXG4gIGZ1bmN0aW9uICggdCApIHtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAwICkgKiB0OyAvLyBUaGlzIG5lZWRzIHRvIGJlIGZyb20gMC1sZW5ndGggKzFcblxuICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XG5cbiAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgcG9pbnRzLmxlbmd0aCBdO1xuICAgIHZhciBwb2ludDEgPSBwb2ludHNbICggaW50UG9pbnQgICAgICkgJSBwb2ludHMubGVuZ3RoIF07XG4gICAgdmFyIHBvaW50MiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcbiAgICB2YXIgcG9pbnQzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgcG9pbnRzLmxlbmd0aCBdO1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApO1xuICAgIHZlY3Rvci56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0FuaW1hdGlvbkhhbmRsZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbkhhbmRsZXIgPSB7XG5cbiAgTElORUFSOiAwLFxuICBDQVRNVUxMUk9NOiAxLFxuICBDQVRNVUxMUk9NX0ZPUldBUkQ6IDIsXG5cbiAgLy9cblxuICBhZGQ6IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTsgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIuZ2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7IH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkgeyBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApOyB9LFxuXG4gIC8vXG5cbiAgYW5pbWF0aW9uczogW10sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCBkYXRhICkge1xuXG4gICAgaWYgKCBkYXRhLmluaXRpYWxpemVkID09PSB0cnVlICkgcmV0dXJuIGRhdGE7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGtleXNcblxuICAgIGZvciAoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApIHtcblxuICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICAvLyByZW1vdmUgbWludXMgdGltZXNcblxuICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPSAwO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgcXVhdGVybmlvbnNcblxuICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgISAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCBpbnN0YW5jZW9mIFRIUkVFLlF1YXRlcm5pb24gKSApIHtcblxuICAgICAgICAgIHZhciBxdWF0ID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90O1xuICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCBxdWF0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgbW9ycGggdGFyZ2V0IGtleXNcblxuICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoICYmIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIC8vIGdldCBhbGwgdXNlZFxuXG4gICAgICAgIHZhciB1c2VkTW9ycGhUYXJnZXRzID0ge307XG5cbiAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldE5hbWUgPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXTtcbiAgICAgICAgICAgIHVzZWRNb3JwaFRhcmdldHNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gLSAxO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLnVzZWRNb3JwaFRhcmdldHMgPSB1c2VkTW9ycGhUYXJnZXRzO1xuXG5cbiAgICAgICAgLy8gc2V0IGFsbCB1c2VkIG9uIGFsbCBmcmFtZXNcblxuICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xuXG4gICAgICAgICAgdmFyIGluZmx1ZW5jZXMgPSB7fTtcblxuICAgICAgICAgIGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gdXNlZE1vcnBoVGFyZ2V0cyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuICAgICAgICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdID09PSBtb3JwaFRhcmdldE5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBtID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgIGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gMDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcyA9IGluZmx1ZW5jZXM7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cblxuICAgICAgLy8gcmVtb3ZlIGFsbCBrZXlzIHRoYXQgYXJlIG9uIHRoZSBzYW1lIHRpbWVcblxuICAgICAgZm9yICggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICBpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayAtIDEgXS50aW1lICkge1xuXG4gICAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLnNwbGljZSggaywgMSApO1xuICAgICAgICAgIGsgLS07XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cblxuICAgICAgLy8gc2V0IGluZGV4XG5cbiAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0uaW5kZXggPSBrO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBkYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uICggcm9vdCApIHtcblxuICAgIHZhciBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkgPSBmdW5jdGlvbiAoIHJvb3QsIGhpZXJhcmNoeSApIHtcblxuICAgICAgaGllcmFyY2h5LnB1c2goIHJvb3QgKTtcblxuICAgICAgZm9yICggdmFyIGMgPSAwOyBjIDwgcm9vdC5jaGlsZHJlbi5sZW5ndGg7IGMgKysgKVxuICAgICAgICBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QuY2hpbGRyZW5bIGMgXSwgaGllcmFyY2h5ICk7XG5cbiAgICB9O1xuXG4gICAgLy8gc2V0dXAgaGllcmFyY2h5XG5cbiAgICB2YXIgaGllcmFyY2h5ID0gW107XG5cbiAgICBpZiAoIHJvb3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuICAgICAgZm9yICggdmFyIGIgPSAwOyBiIDwgcm9vdC5za2VsZXRvbi5ib25lcy5sZW5ndGg7IGIgKysgKSB7XG5cbiAgICAgICAgaGllcmFyY2h5LnB1c2goIHJvb3Quc2tlbGV0b24uYm9uZXNbIGIgXSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QsIGhpZXJhcmNoeSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZXJhcmNoeTtcblxuICB9LFxuXG4gIHBsYXk6IGZ1bmN0aW9uICggYW5pbWF0aW9uICkge1xuXG4gICAgaWYgKCB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICkgPT09IC0gMSApIHtcblxuICAgICAgdGhpcy5hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCBhbmltYXRpb24gKSB7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICk7XG5cbiAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGFUaW1lTVMgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbnNbIGkgXS5yZXNldEJsZW5kV2VpZ2h0cyggKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uc1sgaSBdLnVwZGF0ZSggZGVsdGFUaW1lTVMgKTtcblxuICAgIH1cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbiA9IGZ1bmN0aW9uICggcm9vdCwgZGF0YSApIHtcblxuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcbiAgdGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCByb290ICk7XG5cbiAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gIHRoaXMudGltZVNjYWxlID0gMTtcblxuICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICB0aGlzLmxvb3AgPSB0cnVlO1xuICB0aGlzLndlaWdodCA9IDA7XG5cbiAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSO1xuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb24sXG5cbiAga2V5VHlwZXM6ICBbIFwicG9zXCIsIFwicm90XCIsIFwic2NsXCIgXSxcblxuICBwbGF5OiBmdW5jdGlvbiAoIHN0YXJ0VGltZSwgd2VpZ2h0ICkge1xuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lIDogMDtcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodCAhPT0gdW5kZWZpbmVkID8gd2VpZ2h0IDogMTtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGxheSggdGhpcyApO1xuXG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5zdG9wKCB0aGlzICk7XG5cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgaWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPSB7XG4gICAgICAgICAgYW5pbWF0aW9uczoge30sXG4gICAgICAgICAgYmxlbmRpbmc6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uV2VpZ2h0OiAwLjAsXG4gICAgICAgICAgICBxdWF0ZXJuaW9uV2VpZ2h0OiAwLjAsXG4gICAgICAgICAgICBzY2FsZVdlaWdodDogMC4wXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9ucztcbiAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IGFuaW1hdGlvbnNbIG5hbWUgXTtcblxuICAgICAgaWYgKCBhbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGFuaW1hdGlvbkNhY2hlID0ge1xuICAgICAgICAgIHByZXZLZXk6IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9LFxuICAgICAgICAgIG5leHRLZXk6IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9LFxuICAgICAgICAgIG9yaWdpbmFsTWF0cml4OiBvYmplY3QubWF0cml4XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pbWF0aW9uc1sgbmFtZSBdID0gYW5pbWF0aW9uQ2FjaGU7XG5cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGtleXMgdG8gbWF0Y2ggb3VyIGN1cnJlbnQgdGltZVxuXG4gICAgICBmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5rZXlUeXBlc1sgdCBdO1xuXG4gICAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcbiAgICAgICAgdmFyIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cbiAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XG4gICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIHJlc2V0QmxlbmRXZWlnaHRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICBpZiAoIGFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIGJsZW5kaW5nID0gYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmc7XG5cbiAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgPSAwLjA7XG4gICAgICAgIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSAwLjA7XG4gICAgICAgIGJsZW5kaW5nLnNjYWxlV2VpZ2h0ID0gMC4wO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICB1cGRhdGU6ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5ld1ZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5ld1F1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgLy8gQ2F0bXVsbC1Sb20gc3BsaW5lXG5cbiAgICB2YXIgaW50ZXJwb2xhdGVDYXRtdWxsUm9tID0gZnVuY3Rpb24gKCBwb2ludHMsIHNjYWxlICkge1xuXG4gICAgICB2YXIgYyA9IFtdLCB2MyA9IFtdLFxuICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcbiAgICAgIHBhLCBwYiwgcGMsIHBkO1xuXG4gICAgICBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHNjYWxlO1xuICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgY1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcbiAgICAgIGNbIDEgXSA9IGludFBvaW50O1xuICAgICAgY1sgMiBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IGludFBvaW50IDogaW50UG9pbnQgKyAxO1xuICAgICAgY1sgMyBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IGludFBvaW50IDogaW50UG9pbnQgKyAyO1xuXG4gICAgICBwYSA9IHBvaW50c1sgY1sgMCBdIF07XG4gICAgICBwYiA9IHBvaW50c1sgY1sgMSBdIF07XG4gICAgICBwYyA9IHBvaW50c1sgY1sgMiBdIF07XG4gICAgICBwZCA9IHBvaW50c1sgY1sgMyBdIF07XG5cbiAgICAgIHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xuICAgICAgdzMgPSB3ZWlnaHQgKiB3MjtcblxuICAgICAgdjNbIDAgXSA9IGludGVycG9sYXRlKCBwYVsgMCBdLCBwYlsgMCBdLCBwY1sgMCBdLCBwZFsgMCBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgdjNbIDEgXSA9IGludGVycG9sYXRlKCBwYVsgMSBdLCBwYlsgMSBdLCBwY1sgMSBdLCBwZFsgMSBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgdjNbIDIgXSA9IGludGVycG9sYXRlKCBwYVsgMiBdLCBwYlsgMiBdLCBwY1sgMiBdLCBwZFsgMiBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuXG4gICAgICByZXR1cm4gdjM7XG5cbiAgICB9O1xuXG4gICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xuXG4gICAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcbiAgICAgICAgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgICAgcmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cbiAgICAgIGlmICggdGhpcy53ZWlnaHQgPT09IDAgKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vXG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG5cbiAgICAgIGlmICggdGhpcy5jdXJyZW50VGltZSA+IGR1cmF0aW9uIHx8IHRoaXMuY3VycmVudFRpbWUgPCAwICkge1xuXG4gICAgICAgIGlmICggdGhpcy5sb29wICkge1xuXG4gICAgICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcblxuICAgICAgICAgIGlmICggdGhpcy5jdXJyZW50VGltZSA8IDAgKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkdXJhdGlvbjtcblxuICAgICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbdGhpcy5kYXRhLm5hbWVdO1xuICAgICAgICB2YXIgYmxlbmRpbmcgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmc7XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHBvcy9yb3Qvc2NsXG5cbiAgICAgICAgZm9yICggdmFyIHQgPSAwOyB0IDwgMzsgdCArKyApIHtcblxuICAgICAgICAgIC8vIGdldCBrZXlzXG5cbiAgICAgICAgICB2YXIgdHlwZSAgICA9IHRoaXMua2V5VHlwZXNbIHQgXTtcbiAgICAgICAgICB2YXIgcHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXTtcbiAgICAgICAgICB2YXIgbmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXTtcblxuICAgICAgICAgIGlmICggKCB0aGlzLnRpbWVTY2FsZSA+IDAgJiYgbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB8fFxuICAgICAgICAgICAgKCB0aGlzLnRpbWVTY2FsZSA8IDAgJiYgcHJldktleS50aW1lID49IHRoaXMuY3VycmVudFRpbWUgKSApIHtcblxuICAgICAgICAgICAgcHJldktleSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG4gICAgICAgICAgICBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG4gICAgICAgICAgICB3aGlsZSAoIG5leHRLZXkudGltZSA8IHRoaXMuY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCA+IHByZXZLZXkuaW5kZXggKSB7XG5cbiAgICAgICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgICAgIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XG4gICAgICAgICAgICBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjYWxlID0gKCB0aGlzLmN1cnJlbnRUaW1lIC0gcHJldktleS50aW1lICkgLyAoIG5leHRLZXkudGltZSAtIHByZXZLZXkudGltZSApO1xuXG4gICAgICAgICAgdmFyIHByZXZYWVogPSBwcmV2S2V5WyB0eXBlIF07XG4gICAgICAgICAgdmFyIG5leHRYWVogPSBuZXh0S2V5WyB0eXBlIF07XG5cbiAgICAgICAgICBpZiAoIHNjYWxlIDwgMCApIHNjYWxlID0gMDtcbiAgICAgICAgICBpZiAoIHNjYWxlID4gMSApIHNjYWxlID0gMTtcblxuICAgICAgICAgIC8vIGludGVycG9sYXRlXG5cbiAgICAgICAgICBpZiAoIHR5cGUgPT09IFwicG9zXCIgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIgKSB7XG5cbiAgICAgICAgICAgICAgbmV3VmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XG4gICAgICAgICAgICAgIG5ld1ZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuICAgICAgICAgICAgICAvLyBibGVuZFxuICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgb2JqZWN0LnBvc2l0aW9uLmxlcnAoIG5ld1ZlY3RvciwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG4gICAgICAgICAgICAgIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICAgICAgICAgIHBvaW50c1sgMCBdID0gdGhpcy5nZXRQcmV2S2V5V2l0aCggXCJwb3NcIiwgaCwgcHJldktleS5pbmRleCAtIDEgKVsgXCJwb3NcIiBdO1xuICAgICAgICAgICAgICBwb2ludHNbIDEgXSA9IHByZXZYWVo7XG4gICAgICAgICAgICAgIHBvaW50c1sgMiBdID0gbmV4dFhZWjtcbiAgICAgICAgICAgICAgcG9pbnRzWyAzIF0gPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInBvc1wiLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApWyBcInBvc1wiIF07XG5cbiAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSAqIDAuMzMgKyAwLjMzO1xuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKTtcbiAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICk7XG4gICAgICAgICAgICAgIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICAgIC8vIGJsZW5kXG5cbiAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IG9iamVjdC5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICB2ZWN0b3IueCA9IHZlY3Rvci54ICsgKCBjdXJyZW50UG9pbnRbIDAgXSAtIHZlY3Rvci54ICkgKiBwcm9wb3J0aW9uYWxXZWlnaHQ7XG4gICAgICAgICAgICAgIHZlY3Rvci55ID0gdmVjdG9yLnkgKyAoIGN1cnJlbnRQb2ludFsgMSBdIC0gdmVjdG9yLnkgKSAqIHByb3BvcnRpb25hbFdlaWdodDtcbiAgICAgICAgICAgICAgdmVjdG9yLnogPSB2ZWN0b3IueiArICggY3VycmVudFBvaW50WyAyIF0gLSB2ZWN0b3IueiApICogcHJvcG9ydGlvbmFsV2VpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9yd2FyZFBvaW50ID0gaW50ZXJwb2xhdGVDYXRtdWxsUm9tKCBwb2ludHMsIHNjYWxlICogMS4wMSApO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldCggZm9yd2FyZFBvaW50WyAwIF0sIGZvcndhcmRQb2ludFsgMSBdLCBmb3J3YXJkUG9pbnRbIDIgXSApO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdWIoIHZlY3RvciApO1xuICAgICAgICAgICAgICAgIHRhcmdldC55ID0gMDtcbiAgICAgICAgICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKCB0YXJnZXQueCwgdGFyZ2V0LnogKTtcbiAgICAgICAgICAgICAgICBvYmplY3Qucm90YXRpb24uc2V0KCAwLCBhbmdsZSwgMCApO1xuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gXCJyb3RcIiApIHtcblxuICAgICAgICAgICAgVEhSRUUuUXVhdGVybmlvbi5zbGVycCggcHJldlhZWiwgbmV4dFhZWiwgbmV3UXVhdCwgc2NhbGUgKTtcblxuICAgICAgICAgICAgLy8gQXZvaWQgcGF5aW5nIHRoZSBjb3N0IG9mIGFuIGFkZGl0aW9uYWwgc2xlcnAgaWYgd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgICAgICAgaWYgKCBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID09PSAwICkge1xuXG4gICAgICAgICAgICAgIG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkobmV3UXVhdCk7XG4gICAgICAgICAgICAgIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCApO1xuICAgICAgICAgICAgICBUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwKCBvYmplY3QucXVhdGVybmlvbiwgbmV3UXVhdCwgb2JqZWN0LnF1YXRlcm5pb24sIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSBcInNjbFwiICkge1xuXG4gICAgICAgICAgICBuZXdWZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgIG5ld1ZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgbmV3VmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XG5cbiAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5zY2FsZVdlaWdodCApO1xuICAgICAgICAgICAgb2JqZWN0LnNjYWxlLmxlcnAoIG5ld1ZlY3RvciwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG4gICAgICAgICAgICBibGVuZGluZy5zY2FsZVdlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9O1xuXG4gIH0gKSgpLFxuXG4gIGdldE5leHRLZXlXaXRoOiBmdW5jdGlvbiAoIHR5cGUsIGgsIGtleSApIHtcblxuICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cbiAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICBrZXkgPSBrZXkgPCBrZXlzLmxlbmd0aCAtIDEgPyBrZXkgOiBrZXlzLmxlbmd0aCAtIDE7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcblxuICAgIH1cblxuICAgIGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSArKyApIHtcblxuICAgICAgaWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcblxuICB9LFxuXG4gIGdldFByZXZLZXlXaXRoOiBmdW5jdGlvbiAoIHR5cGUsIGgsIGtleSApIHtcblxuICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cbiAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgIGtleSA9IGtleSA+IDAgPyBrZXkgOiAwO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAga2V5ID0ga2V5ID49IDAgPyBrZXkgOiBrZXkgKyBrZXlzLmxlbmd0aDtcblxuICAgIH1cblxuXG4gICAgZm9yICggOyBrZXkgPj0gMDsga2V5IC0tICkge1xuXG4gICAgICBpZiAoIGtleXNbIGtleSBdWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0tleUZyYW1lQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBraGFuZyBkdW9uZ1xuICogQGF1dGhvciBlcmlrIGtpdHNvblxuICovXG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBkYXRhICkge1xuXG4gIHRoaXMucm9vdCA9IGRhdGEubm9kZTtcbiAgdGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5pbml0KCBkYXRhICk7XG4gIHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggdGhpcy5yb290ICk7XG4gIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB0aGlzLnRpbWVTY2FsZSA9IDAuMDAxO1xuICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgdGhpcy5sb29wID0gdHJ1ZTtcblxuICAvLyBpbml0aWFsaXplIHRvIGZpcnN0IGtleWZyYW1lc1xuXG4gIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5rZXlzLFxuICAgICAgc2lkcyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0uc2lkcyxcbiAgICAgIG9iaiA9IHRoaXMuaGllcmFyY2h5W2hdO1xuXG4gICAgaWYgKCBrZXlzLmxlbmd0aCAmJiBzaWRzICkge1xuXG4gICAgICBmb3IgKCB2YXIgcyA9IDA7IHMgPCBzaWRzLmxlbmd0aDsgcyArKyApIHtcblxuICAgICAgICB2YXIgc2lkID0gc2lkc1sgcyBdLFxuICAgICAgICAgIG5leHQgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBzaWQsIGgsIDAgKTtcblxuICAgICAgICBpZiAoIG5leHQgKSB7XG5cbiAgICAgICAgICBuZXh0LmFwcGx5KCBzaWQgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgb2JqLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgIG9iai5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICB9XG5cbn07XG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuS2V5RnJhbWVBbmltYXRpb24sXG5cbiAgcGxheTogZnVuY3Rpb24gKCBzdGFydFRpbWUgKSB7XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBzdGFydFRpbWUgOiAwO1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgICAgLy8gcmVzZXQga2V5IGNhY2hlXG5cbiAgICAgIHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBub2RlO1xuXG4gICAgICBmb3IgKCBoID0gMDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICAgIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgaWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlID0ge307XG4gICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXggPSBvYmplY3QubWF0cml4O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cztcblxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcblxuICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUucHJldktleSA9IGtleXNbIDAgXTtcbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBrZXlzWyAxIF07XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IE1hdGgubWluKCBrZXlzWzBdLnRpbWUsIHRoaXMuc3RhcnRUaW1lICk7XG4gICAgICAgICAgdGhpcy5lbmRUaW1lID0gTWF0aC5tYXgoIGtleXNba2V5cy5sZW5ndGggLSAxXS50aW1lLCB0aGlzLmVuZFRpbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoIDAgKTtcblxuICAgIH1cblxuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblxuICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGxheSggdGhpcyApO1xuXG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzUGF1c2VkICA9IGZhbHNlO1xuXG4gICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5zdG9wKCB0aGlzICk7XG5cbiAgICAvLyByZXNldCBKSVQgbWF0cml4IGFuZCByZW1vdmUgY2FjaGVcblxuICAgIGZvciAoIHZhciBoID0gMDsgaCA8IHRoaXMuZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoICsrICkge1xuXG4gICAgICB2YXIgb2JqID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICBpZiAoIG5vZGUuYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4O1xuXG4gICAgICAgIG9yaWdpbmFsLmNvcHkoIG9iai5tYXRyaXggKTtcbiAgICAgICAgb2JqLm1hdHJpeCA9IG9yaWdpbmFsO1xuXG4gICAgICAgIGRlbGV0ZSBub2RlLmFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGEgKiB0aGlzLnRpbWVTY2FsZTtcblxuICAgIC8vXG5cbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKCB0aGlzLmxvb3AgPT09IHRydWUgJiYgdGhpcy5jdXJyZW50VGltZSA+IGR1cmF0aW9uICkge1xuXG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICU9IGR1cmF0aW9uO1xuXG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IE1hdGgubWluKCB0aGlzLmN1cnJlbnRUaW1lLCBkdXJhdGlvbiApO1xuXG4gICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICB2YXIga2V5cyA9IG5vZGUua2V5cyxcbiAgICAgICAgYW5pbWF0aW9uQ2FjaGUgPSBub2RlLmFuaW1hdGlvbkNhY2hlO1xuXG5cbiAgICAgIGlmICgga2V5cy5sZW5ndGggKSB7XG5cbiAgICAgICAgdmFyIHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5O1xuICAgICAgICB2YXIgbmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXk7XG5cbiAgICAgICAgaWYgKCBuZXh0S2V5LnRpbWUgPD0gdGhpcy5jdXJyZW50VGltZSApIHtcblxuICAgICAgICAgIHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuICAgICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgICBuZXh0S2V5ID0ga2V5c1sgcHJldktleS5pbmRleCArIDEgXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBwcmV2S2V5O1xuICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBuZXh0S2V5O1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG5leHRLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkge1xuXG4gICAgICAgICAgcHJldktleS5pbnRlcnBvbGF0ZSggbmV4dEtleSwgdGhpcy5jdXJyZW50VGltZSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCBuZXh0S2V5LnRpbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLm5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0sXG5cbiAgZ2V0TmV4dEtleVdpdGg6IGZ1bmN0aW9uICggc2lkLCBoLCBrZXkgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuICAgIGtleSA9IGtleSAlIGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICggOyBrZXkgPCBrZXlzLmxlbmd0aDsga2V5ICsrICkge1xuXG4gICAgICBpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5c1sgMCBdO1xuXG4gIH0sXG5cbiAgZ2V0UHJldktleVdpdGg6IGZ1bmN0aW9uICggc2lkLCBoLCBrZXkgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuICAgIGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKCA7IGtleSA+PSAwOyBrZXkgLS0gKSB7XG5cbiAgICAgIGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vTW9ycGhBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKiBAYXV0aG9yIHdpbGx5LXZ2dSAvIGh0dHA6Ly93aWxseS12dnUuZ2l0aHViLmlvXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltYXRpb24gPSBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cbiAgdGhpcy5tZXNoID0gbWVzaDtcbiAgdGhpcy5mcmFtZXMgPSBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7XG4gIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB0aGlzLmR1cmF0aW9uID0gMTAwMDtcbiAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgdGhpcy5sYXN0RnJhbWUgPSAwO1xuICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Nb3JwaEFuaW1hdGlvbixcblxuICBwbGF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YTtcblxuICAgIGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICU9IHRoaXMuZHVyYXRpb247XG5cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuZHVyYXRpb24gKTtcblxuICAgIHZhciBpbnRlcnBvbGF0aW9uID0gdGhpcy5kdXJhdGlvbiAvIHRoaXMuZnJhbWVzO1xuICAgIHZhciBmcmFtZSA9IE1hdGguZmxvb3IoIHRoaXMuY3VycmVudFRpbWUgLyBpbnRlcnBvbGF0aW9uICk7XG5cbiAgICB2YXIgaW5mbHVlbmNlcyA9IHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBpZiAoIGZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSApIHtcblxuICAgICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0RnJhbWUgXSA9IDA7XG4gICAgICBpbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRGcmFtZSBdID0gMTtcbiAgICAgIGluZmx1ZW5jZXNbIGZyYW1lIF0gPSAwO1xuXG4gICAgICB0aGlzLmxhc3RGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcblxuICAgIH1cblxuICAgIGluZmx1ZW5jZXNbIGZyYW1lIF0gPSAoIHRoaXMuY3VycmVudFRpbWUgJSBpbnRlcnBvbGF0aW9uICkgLyBpbnRlcnBvbGF0aW9uO1xuICAgIGluZmx1ZW5jZXNbIHRoaXMubGFzdEZyYW1lIF0gPSAxIC0gaW5mbHVlbmNlc1sgZnJhbWUgXTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXG4gKi9cblxuVEhSRUUuQm94R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGRlcHRoOiBkZXB0aCxcbiAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG4gIH07XG5cbiAgdGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyB8fCAxO1xuICB0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcbiAgdGhpcy5kZXB0aFNlZ21lbnRzID0gZGVwdGhTZWdtZW50cyB8fCAxO1xuXG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgdmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG4gIHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG4gIHZhciBkZXB0aF9oYWxmID0gZGVwdGggLyAyO1xuXG4gIGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiApOyAvLyBweFxuICBidWlsZFBsYW5lKCAneicsICd5JywgICAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGhfaGFsZiApOyAvLyBueFxuICBidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAgIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0X2hhbGYgKTsgLy8gcHlcbiAgYnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0X2hhbGYgKTsgLy8gbnlcbiAgYnVpbGRQbGFuZSggJ3gnLCAneScsICAgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aF9oYWxmICk7IC8vIHB6XG4gIGJ1aWxkUGxhbmUoICd4JywgJ3knLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aF9oYWxmICk7IC8vIG56XG5cbiAgZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGggKSB7XG5cbiAgICB2YXIgdywgaXgsIGl5LFxuICAgIGdyaWRYID0gc2NvcGUud2lkdGhTZWdtZW50cyxcbiAgICBncmlkWSA9IHNjb3BlLmhlaWdodFNlZ21lbnRzLFxuICAgIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXG4gICAgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyLFxuICAgIG9mZnNldCA9IHNjb3BlLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3gnICkgKSB7XG5cbiAgICAgIHcgPSAneic7XG5cbiAgICB9IGVsc2UgaWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneicgKSB8fCAoIHUgPT09ICd6JyAmJiB2ID09PSAneCcgKSApIHtcblxuICAgICAgdyA9ICd5JztcbiAgICAgIGdyaWRZID0gc2NvcGUuZGVwdGhTZWdtZW50cztcblxuICAgIH0gZWxzZSBpZiAoICggdSA9PT0gJ3onICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd6JyApICkge1xuXG4gICAgICB3ID0gJ3gnO1xuICAgICAgZ3JpZFggPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG4gICAgfVxuXG4gICAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMSxcbiAgICBncmlkWTEgPSBncmlkWSArIDEsXG4gICAgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXG4gICAgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWSxcbiAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgbm9ybWFsWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG4gICAgZm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cbiAgICAgIGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcbiAgICAgICAgdmVjdG9yWyB2IF0gPSAoIGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZiApICogdmRpcjtcbiAgICAgICAgdmVjdG9yWyB3IF0gPSBkZXB0aDtcblxuICAgICAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuICAgICAgZm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuICAgICAgICB2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG4gICAgICAgIHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgICB2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgICB2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuICAgICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG4gICAgICAgIHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xuICAgICAgICB2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xuICAgICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcblxuICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSArIG9mZnNldCwgYiArIG9mZnNldCwgZCArIG9mZnNldCApO1xuICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcblxuICAgICAgICBzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIgKyBvZmZzZXQsIGMgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcbiAgICAgICAgZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG5cbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbn07XG5cblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94R2VvbWV0cnk7XG5cblRIUkVFLkN1YmVHZW9tZXRyeSA9IFRIUkVFLkJveEdlb21ldHJ5OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgaHVnaGVzXG4gKi9cblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdmFyIGksIHV2cyA9IFtdLFxuICBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBjZW50ZXJVViA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLjUsIDAuNSApO1xuXG4gIHRoaXMudmVydGljZXMucHVzaChjZW50ZXIpO1xuICB1dnMucHVzaCggY2VudGVyVVYgKTtcblxuICBmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG4gICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG4gICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gcmFkaXVzICsgMSApIC8gMiwgKCB2ZXJ0ZXgueSAvIHJhZGl1cyArIDEgKSAvIDIgKSApO1xuXG4gIH1cblxuICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgZm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggaSwgaSArIDEsIDAsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcbiAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgaSBdLmNsb25lKCksIHV2c1sgaSArIDEgXS5jbG9uZSgpLCBjZW50ZXJVVi5jbG9uZSgpIF0gKTtcblxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2lyY2xlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdmFyIHZlcnRpY2VzID0gc2VnbWVudHMgKyAyO1xuXG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMiApO1xuXG4gIC8vIGNlbnRlciBkYXRhIGlzIGFscmVhZHkgemVybywgYnV0IG5lZWQgdG8gc2V0IGEgZmV3IGV4dHJhc1xuICBub3JtYWxzWzNdID0gMS4wO1xuICB1dnNbMF0gPSAwLjU7XG4gIHV2c1sxXSA9IDAuNTtcblxuICBmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzKyssIGkgKz0gMywgaWkgKz0gMiApIHtcblxuICAgIHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG4gICAgcG9zaXRpb25zW2ldID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICBwb3NpdGlvbnNbaSArIDFdID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgIG5vcm1hbHNbaSArIDJdID0gMTsgLy8gbm9ybWFsIHpcblxuICAgIHV2c1tpaV0gPSAoIHBvc2l0aW9uc1tpXSAvIHJhZGl1cyArIDEgKSAvIDI7XG4gICAgdXZzW2lpICsgMV0gPSAoIHBvc2l0aW9uc1tpICsgMV0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG4gIH1cblxuICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gIGZvciAoIHZhciBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuICAgIGluZGljZXMucHVzaCggaSApO1xuICAgIGluZGljZXMucHVzaCggaSArIDEgKTtcbiAgICBpbmRpY2VzLnB1c2goIDAgKTtcblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggaW5kaWNlcyApLCAxICkgKTtcbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuICAgIHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgb3BlbkVuZGVkOiBvcGVuRW5kZWQsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDIwO1xuICByYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDIwO1xuICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IDEwMDtcblxuICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG4gIGhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcblxuICBvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogMiAqIE1hdGguUEk7XG5cbiAgdmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXG4gIHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcblxuICBmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuICAgIHZhciB1dnNSb3cgPSBbXTtcblxuICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuICAgIHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuICAgIGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XG4gICAgICB2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhlaWdodEhhbGY7XG4gICAgICB2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XG5cbiAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgIHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xuICAgICAgdXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XG5cbiAgICB9XG5cbiAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuICAgIHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuICB9XG5cbiAgdmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcbiAgdmFyIG5hLCBuYjtcblxuICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgaWYgKCByYWRpdXNUb3AgIT09IDAgKSB7XG5cbiAgICAgIG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCBdIF0uY2xvbmUoKTtcbiAgICAgIG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCArIDEgXSBdLmNsb25lKCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XG4gICAgICBuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgbmEuc2V0WSggTWF0aC5zcXJ0KCBuYS54ICogbmEueCArIG5hLnogKiBuYS56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xuICAgIG5iLnNldFkoIE1hdGguc3FydCggbmIueCAqIG5iLnggKyBuYi56ICogbmIueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcblxuICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggXTtcbiAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG4gICAgICB2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2NCA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG5cbiAgICAgIHZhciBuMSA9IG5hLmNsb25lKCk7XG4gICAgICB2YXIgbjIgPSBuYS5jbG9uZSgpO1xuICAgICAgdmFyIG4zID0gbmIuY2xvbmUoKTtcbiAgICAgIHZhciBuNCA9IG5iLmNsb25lKCk7XG5cbiAgICAgIHZhciB1djEgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djMgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djQgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2NCwgWyBuMSwgbjIsIG40IF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXY0IF0gKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYyLCB2MywgdjQsIFsgbjIuY2xvbmUoKSwgbjMsIG40LmNsb25lKCkgXSApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Mi5jbG9uZSgpLCB1djMsIHV2NC5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gdG9wIGNhcFxuXG4gIGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNUb3AgPiAwICkge1xuXG4gICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgMCBdWyB4IF07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdO1xuICAgICAgdmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gICAgICB2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuICAgICAgdmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcbiAgICAgIHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICAgIHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYyID0gdXZzWyAwIF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djMgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYyLngsIDAgKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIGJvdHRvbSBjYXBcblxuICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzQm90dG9tID4gMCApIHtcblxuICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gaGVpZ2h0SGFsZiwgMCApICk7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF07XG4gICAgICB2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcbiAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcbiAgICAgIHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcblxuICAgICAgdmFyIHV2MSA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRWRnZXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xuXG4gIHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhyZXNob2xkQW5nbGUgKSApO1xuXG4gIHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcbiAgdmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uICggYSwgYiApIHsgcmV0dXJuIGEgLSBiIH07XG5cbiAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICB2YXIgZ2VvbWV0cnkyO1xuXG4gIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgIGdlb21ldHJ5MiA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XG5cbiAgfVxuXG4gIGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XG4gIGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG4gIHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgICBlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBoYXNoWyBrZXkgXSA9IHsgdmVydDE6IGVkZ2VbIDAgXSwgdmVydDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgdmFyIGNvb3JkcyA9IFtdO1xuXG4gIGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcblxuICAgIHZhciBoID0gaGFzaFsga2V5IF07XG5cbiAgICBpZiAoIGguZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgaC5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBoLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xuXG4gICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDEgXTtcbiAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgICAgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcbiAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGNvb3JkcyApLCAzICkgKTtcblxufTtcblxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdlbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcbiAqXG4gKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICpcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlUGF0aD4gLy8gM2Qgc3BsaW5lIHBhdGggdG8gZXh0cnVkZSBzaGFwZSBhbG9uZy4gKGNyZWF0ZXMgRnJhbWVzIGlmIC5mcmFtZXMgYXJlbid0IGRlZmluZWQpXG4gKiAgZnJhbWVzOiA8VEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcz4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xuICpcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgaWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuICAgIHNoYXBlcyA9IFtdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcblxuICBzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XG5cbiAgdGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgLy8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcbiAgLy8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXG4gIC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcblxuICAvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcbiAgdmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcblxuICBmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcbiAgICB2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcbiAgICB0aGlzLmFkZFNoYXBlKCBzaGFwZSwgb3B0aW9ucyApO1xuICB9XG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuICB2YXIgYW1vdW50ID0gb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW1vdW50IDogMTAwO1xuXG4gIHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxuICB2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XG4gIHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xuXG4gIHZhciBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlOyAvLyBmYWxzZVxuXG4gIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICB2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblxuICB2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xuICB2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXG4gIC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxuICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XG5cbiAgdmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcbiAgaWYgKCBleHRydWRlUGF0aCApIHtcblxuICAgIGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XG5cbiAgICBleHRydWRlQnlQYXRoID0gdHJ1ZTtcbiAgICBiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG5cbiAgICAvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cbiAgICAvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxuICAgIC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cbiAgICBzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuICAgIGJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHBvc2l0aW9uMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgfVxuXG4gIC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG4gIGlmICggISBiZXZlbEVuYWJsZWQgKSB7XG5cbiAgICBiZXZlbFNlZ21lbnRzID0gMDtcbiAgICBiZXZlbFRoaWNrbmVzcyA9IDA7XG4gICAgYmV2ZWxTaXplID0gMDtcblxuICB9XG5cbiAgLy8gVmFyaWFibGVzIGluaXRhbGl6YXRpb25cblxuICB2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgdmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG4gIHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICB2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cbiAgdmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApIDtcblxuICBpZiAoIHJldmVyc2UgKSB7XG5cbiAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuICAgIC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgICBpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG4gICAgICAgIGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldmVyc2UgPSBmYWxzZTsgLy8gSWYgdmVydGljZXMgYXJlIGluIG9yZGVyIG5vdywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlbSBhZ2FpbiAoaG9wZWZ1bGx5KSFcblxuICB9XG5cblxuICB2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlICggdmVydGljZXMsIGhvbGVzICk7XG5cbiAgLyogVmVydGljZXMgKi9cblxuICB2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG4gIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XG5cbiAgfVxuXG5cbiAgZnVuY3Rpb24gc2NhbGVQdDIgKCBwdCwgdmVjLCBzaXplICkge1xuXG4gICAgaWYgKCAhIHZlYyApIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcIiApO1xuXG4gICAgcmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xuXG4gIH1cblxuICB2YXIgYiwgYnMsIHQsIHosXG4gICAgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcbiAgICBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG5cbiAgLy8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxuXG5cbiAgZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG4gICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXG4gICAgLy8gICBzaGlmdGV0IGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuICAgIC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxuICAgIC8vXG4gICAgLy8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cbiAgICAvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxuXG4gICAgdmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnkgPSAxOyAgICAvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XG5cbiAgICAvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG4gICAgLy8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuICAgIHZhciB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LCB2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xuICAgIHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LCB2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xuXG4gICAgdmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblxuICAgIC8vIGNoZWNrIGZvciBjb2xpbmVhciBlZGdlc1xuICAgIHZhciBjb2xpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cbiAgICBpZiAoIE1hdGguYWJzKCBjb2xpbmVhcjAgKSA+IEVQU0lMT04gKSB7ICAgIC8vIG5vdCBjb2xpbmVhclxuXG4gICAgICAvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcblxuICAgICAgdmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuICAgICAgdmFyIHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XG5cbiAgICAgIC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcblxuICAgICAgdmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG4gICAgICB2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblxuICAgICAgdmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG4gICAgICB2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblxuICAgICAgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgICAgdmFyIHNmID0gKCAgKCBwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCApICogdl9uZXh0X3kgLVxuICAgICAgICAgICAgKCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggICAgKSAvXG4gICAgICAgICAgICAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cbiAgICAgIC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgIHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcbiAgICAgIHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcblxuICAgICAgLy8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcbiAgICAgIC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcbiAgICAgIHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcbiAgICAgIGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xuICAgICAgICByZXR1cm4gIG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHsgICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xpbmVhciBlZGdlc1xuXG4gICAgICB2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7ICAgLy8gYXNzdW1lczogb3Bwb3NpdGVcbiAgICAgIGlmICggdl9wcmV2X3ggPiBFUFNJTE9OICkge1xuICAgICAgICBpZiAoIHZfbmV4dF94ID4gRVBTSUxPTiApIHsgZGlyZWN0aW9uX2VxID0gdHJ1ZTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCB2X3ByZXZfeCA8IC0gRVBTSUxPTiApIHtcbiAgICAgICAgICBpZiAoIHZfbmV4dF94IDwgLSBFUFNJTE9OICkgeyBkaXJlY3Rpb25fZXEgPSB0cnVlOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCBNYXRoLnNpZ24odl9wcmV2X3kpID09PSBNYXRoLnNpZ24odl9uZXh0X3kpICkgeyBkaXJlY3Rpb25fZXEgPSB0cnVlOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCBkaXJlY3Rpb25fZXEgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG4gICAgICAgIHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG4gICAgICAgIHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcbiAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG4gICAgICAgIHZfdHJhbnNfeCA9IHZfcHJldl94O1xuICAgICAgICB2X3RyYW5zX3kgPSB2X3ByZXZfeTtcbiAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gIG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG4gIH1cblxuXG4gIHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cbiAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuICAgIGlmICggaiA9PT0gaWwgKSBqID0gMDtcbiAgICBpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cbiAgICAvLyAgKGopLS0tKGkpLS0tKGspXG4gICAgLy8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cbiAgICBjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG4gIH1cblxuICB2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG4gIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgb25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuICAgICAgaWYgKCBqID09PSBpbCApIGogPSAwO1xuICAgICAgaWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG4gICAgICAvLyAgKGopLS0tKGkpLS0tKGspXG4gICAgICBvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG4gICAgfVxuXG4gICAgaG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuICAgIHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cbiAgfVxuXG5cbiAgLy8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cbiAgZm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuICAvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cbiAgICAvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XG4gICAgYnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luICggdCAqIE1hdGguUEkgLyAyICkgKSA7IC8vIGN1cnZlZFxuICAgIC8vYnMgPSBiZXZlbFNpemUgKiB0IDsgLy8gbGluZWFyXG5cbiAgICAvLyBjb250cmFjdCBzaGFwZVxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgICAgdiggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuICAgIH1cblxuICAgIC8vIGV4cGFuZCBob2xlc1xuXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcbiAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG4gICAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGJzID0gYmV2ZWxTaXplO1xuXG4gIC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXG5cbiAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG4gICAgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuICAgIGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcblxuICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1swXSApLm11bHRpcGx5U2NhbGFyKHZlcnQueCk7XG4gICAgICBiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1swXSApLm11bHRpcGx5U2NhbGFyKHZlcnQueSk7XG5cbiAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWzBdICkuYWRkKG5vcm1hbCkuYWRkKGJpbm9ybWFsKTtcblxuICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuICAvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cbiAgdmFyIHM7XG5cbiAgZm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cbiAgICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICAgIGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgICAgIHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cbiAgICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1tzXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcbiAgICAgICAgYmlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbc10gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cbiAgICAgICAgcG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbc10gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgICAgICB2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cblxuICAvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cbiAgLy9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuICBmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcblxuICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG4gICAgLy9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XG4gICAgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApIDtcblxuICAgIC8vIGNvbnRyYWN0IHNoYXBlXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuICAgICAgdiggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XG5cbiAgICB9XG5cbiAgICAvLyBleHBhbmQgaG9sZXNcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgICAgaWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cbiAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICAvKiBGYWNlcyAqL1xuXG4gIC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cbiAgYnVpbGRMaWRGYWNlcygpO1xuXG4gIC8vIFNpZGVzIGZhY2VzXG5cbiAgYnVpbGRTaWRlRmFjZXMoKTtcblxuXG4gIC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuXG4gICAgaWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cbiAgICAgIHZhciBsYXllciA9IDAgOyAvLyBzdGVwcyArIDFcbiAgICAgIHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cbiAgICAgIC8vIEJvdHRvbSBmYWNlc1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgICAgIGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cbiAgICAgIH1cblxuICAgICAgbGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuICAgICAgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgICAvLyBUb3AgZmFjZXNcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICBmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBCb3R0b20gZmFjZXNcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICBmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIFRvcCBmYWNlc1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IGZhY2VzWyBpIF07XG4gICAgICAgIGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cbiAgZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cbiAgICB2YXIgbGF5ZXJvZmZzZXQgPSAwO1xuICAgIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcbiAgICBsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICBzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xuXG4gICAgICAvLywgdHJ1ZVxuICAgICAgbGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG4gICAgdmFyIGosIGs7XG4gICAgaSA9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCAtLSBpID49IDAgKSB7XG5cbiAgICAgIGogPSBpO1xuICAgICAgayA9IGkgLSAxO1xuICAgICAgaWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgICB2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cbiAgICAgIGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cbiAgICAgICAgdmFyIHNsZW4xID0gdmxlbiAqIHM7XG4gICAgICAgIHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cbiAgICAgICAgdmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcbiAgICAgICAgICBiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG4gICAgICAgICAgYyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuICAgICAgICAgIGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuICAgICAgICBmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuICAgICAgfVxuICAgIH1cblxuICB9XG5cblxuICBmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG4gICAgc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuICAgIGEgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIGIgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG4gICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjICkgKTtcblxuICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xuXG4gICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XG5cbiAgICBhICs9IHNoYXBlc09mZnNldDtcbiAgICBiICs9IHNoYXBlc09mZnNldDtcbiAgICBjICs9IHNoYXBlc09mZnNldDtcbiAgICBkICs9IHNoYXBlc09mZnNldDtcblxuICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblxuICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XG5cbiAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcbiAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdIF0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xuXG4gIGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cbiAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuICAgIHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuICAgIHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgYi55ICksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYy54LCBjLnkgKVxuICAgIF07XG5cbiAgfSxcblxuICBnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgdmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG4gICAgdmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG4gICAgdmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG4gICAgdmFyIGQgPSB2ZXJ0aWNlc1sgaW5kZXhEIF07XG5cbiAgICBpZiAoIE1hdGguYWJzKCBhLnkgLSBiLnkgKSA8IDAuMDEgKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYS54LCAxIC0gYS56ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIDEgLSBiLnogKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgMSAtIGMueiApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggZC54LCAxIC0gZC56IClcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhLnksIDEgLSBhLnogKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGIueSwgMSAtIGIueiApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYy55LCAxIC0gYy56ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBkLnksIDEgLSBkLnogKVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cbiAqXG4gKiBDcmVhdGVzIGEgb25lLXNpZGVkIHBvbHlnb25hbCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS4gU2ltaWxhciB0b1xuICogRXh0cnVkZUdlb21ldHJ5LlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXG4gKlxuICogIG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuVEhSRUUuU2hhcGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cbiAgaWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSBzaGFwZXMgPSBbIHNoYXBlcyBdO1xuXG4gIHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZUdlb21ldHJ5O1xuXG4vKipcbiAqIEFkZCBhbiBhcnJheSBvZiBzaGFwZXMgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICB0aGlzLmFkZFNoYXBlKCBzaGFwZXNbIGkgXSwgb3B0aW9ucyApO1xuXG4gIH1cblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBBZGRzIGEgc2hhcGUgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeSwgYmFzZWQgb24gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LlxuICovXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XG5cbiAgaWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XG4gIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICB2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yID09PSB1bmRlZmluZWQgPyBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA6IG9wdGlvbnMuVVZHZW5lcmF0b3I7XG5cbiAgLy9cblxuICB2YXIgaSwgbCwgaG9sZTtcblxuICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gIHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICB2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cbiAgdmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG4gIGlmICggcmV2ZXJzZSApIHtcblxuICAgIHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxuXG4gICAgZm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBob2xlID0gaG9sZXNbIGkgXTtcblxuICAgICAgaWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggaG9sZSApICkge1xuXG4gICAgICAgIGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV2ZXJzZSA9IGZhbHNlO1xuXG4gIH1cblxuICB2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuICAvLyBWZXJ0aWNlc1xuXG4gIHZhciBjb250b3VyID0gdmVydGljZXM7XG5cbiAgZm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgaG9sZSA9IGhvbGVzWyBpIF07XG4gICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcblxuICB9XG5cbiAgLy9cblxuICB2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgdmFyIGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XG5cbiAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG4gICAgdmVydCA9IHZlcnRpY2VzWyBpIF07XG5cbiAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0LngsIHZlcnQueSwgMCApICk7XG5cbiAgfVxuXG4gIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgdmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XG4gICAgdmFyIGIgPSBmYWNlWyAxIF0gKyBzaGFwZXNPZmZzZXQ7XG4gICAgdmFyIGMgPSBmYWNlWyAyIF0gKyBzaGFwZXNPZmZzZXQ7XG5cbiAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgbWF0ZXJpYWwgKSApO1xuICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHRoaXMsIGEsIGIsIGMgKSApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYXN0cm9kdWQgLyBodHRwOi8vYXN0cm9kdWQuaXNncmVhdC5vcmcvXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzXG4vLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXG4vLyBzZWdtZW50cyAtIHRoZSBudW1iZXIgb2YgY2lyY3VtZmVyZW5jZSBzZWdtZW50cyB0byBjcmVhdGVcbi8vIHBoaVN0YXJ0IC0gdGhlIHN0YXJ0aW5nIHJhZGlhblxuLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyKlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cbi8vICAgIDIqcGkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxuXG5USFJFRS5MYXRoZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHBvaW50czogcG9pbnRzLFxuICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGhcbiAgfTtcblxuICBzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDEyO1xuICBwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XG4gIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCAyICogTWF0aC5QSTtcblxuICB2YXIgaW52ZXJzZVBvaW50TGVuZ3RoID0gMS4wIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuICB2YXIgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDw9IGlsOyBpICsrICkge1xuXG4gICAgdmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcblxuICAgIHZhciBjID0gTWF0aC5jb3MoIHBoaSApLFxuICAgICAgcyA9IE1hdGguc2luKCBwaGkgKTtcblxuICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgIHZhciBwdCA9IHBvaW50c1sgaiBdO1xuXG4gICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdmVydGV4LnggPSBjICogcHQueCAtIHMgKiBwdC55O1xuICAgICAgdmVydGV4LnkgPSBzICogcHQueCArIGMgKiBwdC55O1xuICAgICAgdmVydGV4LnogPSBwdC56O1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgfVxuXG4gIH1cblxuICB2YXIgbnAgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGggLSAxOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgIHZhciBiYXNlID0gaiArIG5wICogaTtcbiAgICAgIHZhciBhID0gYmFzZTtcbiAgICAgIHZhciBiID0gYmFzZSArIG5wO1xuICAgICAgdmFyIGMgPSBiYXNlICsgMSArIG5wO1xuICAgICAgdmFyIGQgPSBiYXNlICsgMTtcblxuICAgICAgdmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcbiAgICAgIHZhciB2MCA9IGogKiBpbnZlcnNlUG9pbnRMZW5ndGg7XG4gICAgICB2YXIgdTEgPSB1MCArIGludmVyc2VTZWdtZW50cztcbiAgICAgIHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXG5cbiAgICAgIF0gKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYxICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG4gICAgICBdICk7XG5cblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGF0aGVHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAqL1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcblxuICBjb25zb2xlLmxvZyggJ1RIUkVFLlBsYW5lR2VvbWV0cnk6IENvbnNpZGVyIHVzaW5nIFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgZm9yIGxvd2VyIG1lbW9yeSBmb290cHJpbnQuJyApO1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuICB9O1xuXG4gIHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuICB9O1xuXG4gIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXG4gIHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xuICB2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cbiAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcbiAgdmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcblxuICB2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG4gIHZhciBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xuXG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcbiAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XG4gIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAyICk7XG5cbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQyID0gMDtcblxuICBmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cbiAgICB2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuICAgIGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuICAgICAgdmFyIHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xuXG4gICAgICB2ZXJ0aWNlc1sgb2Zmc2V0ICAgICBdID0geDtcbiAgICAgIHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAtIHk7XG5cbiAgICAgIG5vcm1hbHNbIG9mZnNldCArIDIgXSA9IDE7XG5cbiAgICAgIHV2c1sgb2Zmc2V0MiAgICAgXSA9IGl4IC8gZ3JpZFg7XG4gICAgICB1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XG5cbiAgICAgIG9mZnNldCArPSAzO1xuICAgICAgb2Zmc2V0MiArPSAyO1xuXG4gICAgfVxuXG4gIH1cblxuICBvZmZzZXQgPSAwO1xuXG4gIHZhciBpbmRpY2VzID0gbmV3ICggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggZ3JpZFggKiBncmlkWSAqIDYgKTtcblxuICBmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuICAgIGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG4gICAgICB2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG4gICAgICB2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgIHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgICB2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuICAgICAgaW5kaWNlc1sgb2Zmc2V0ICAgICBdID0gYTtcbiAgICAgIGluZGljZXNbIG9mZnNldCArIDEgXSA9IGI7XG4gICAgICBpbmRpY2VzWyBvZmZzZXQgKyAyIF0gPSBkO1xuXG4gICAgICBpbmRpY2VzWyBvZmZzZXQgKyAzIF0gPSBiO1xuICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgNCBdID0gYztcbiAgICAgIGluZGljZXNbIG9mZnNldCArIDUgXSA9IGQ7XG5cbiAgICAgIG9mZnNldCArPSA2O1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxuICovXG5cblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uICggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG4gICAgcGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwO1xuICBvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIHx8IDUwO1xuXG4gIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICB0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XG4gIHBoaVNlZ21lbnRzID0gcGhpU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApIDogODtcblxuICB2YXIgaSwgbywgdXZzID0gW10sIHJhZGl1cyA9IGlubmVyUmFkaXVzLCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XG5cbiAgZm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50cyArIDE7IGkgKysgKSB7IC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xuXG4gICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzICsgMTsgbyArKyApIHsgLy8gbnVtYmVyIG9mIHNlZ21lbnRzIHBlciBjaXJjbGVcblxuICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBvIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcbiAgICB9XG5cbiAgICByYWRpdXMgKz0gcmFkaXVzU3RlcDtcblxuICB9XG5cbiAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHM7IGkgKysgKSB7IC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xuXG4gICAgdmFyIHRoZXRhU2VnbWVudCA9IGkgKiAodGhldGFTZWdtZW50cyArIDEpO1xuXG4gICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzIDsgbyArKyApIHsgLy8gbnVtYmVyIG9mIHNlZ21lbnRzIHBlciBjaXJjbGVcblxuICAgICAgdmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xuXG4gICAgICB2YXIgdjEgPSBzZWdtZW50O1xuICAgICAgdmFyIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuICAgICAgdmFyIHYzID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0pO1xuXG4gICAgICB2MSA9IHNlZ21lbnQ7XG4gICAgICB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcbiAgICAgIHYzID0gc2VnbWVudCArIDE7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSk7XG5cbiAgICB9XG4gIH1cblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJpbmdHZW9tZXRyeTtcblxuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIGNvbnNvbGUubG9nKCAnVEhSRUUuU3BoZXJlR2VvbWV0cnk6IENvbnNpZGVyIHVzaW5nIFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5IGZvciBsb3dlciBtZW1vcnkgZm9vdHByaW50LicgKTtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuXG4gIHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcbiAgaGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XG5cbiAgcGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xuICBwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xuXG4gIHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcblxuICBmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuICAgIHZhciB1dnNSb3cgPSBbXTtcblxuICAgIGZvciAoIHggPSAwOyB4IDw9IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICAgIHZhciB1ID0geCAvIHdpZHRoU2VnbWVudHM7XG4gICAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICB2ZXJ0ZXgueCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICAgIHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgdmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG4gICAgICB1dnNSb3cucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICkgKTtcblxuICAgIH1cblxuICAgIHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG4gICAgdXZzLnB1c2goIHV2c1JvdyApO1xuXG4gIH1cblxuICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgZm9yICggeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuICAgICAgdmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xuICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcbiAgICAgIHZhciB2NCA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuXG4gICAgICB2YXIgbjEgPSB0aGlzLnZlcnRpY2VzWyB2MSBdLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgICB2YXIgbjIgPSB0aGlzLnZlcnRpY2VzWyB2MiBdLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgICB2YXIgbjMgPSB0aGlzLnZlcnRpY2VzWyB2MyBdLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgICB2YXIgbjQgPSB0aGlzLnZlcnRpY2VzWyB2NCBdLmNsb25lKCkubm9ybWFsaXplKCk7XG5cbiAgICAgIHZhciB1djEgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djMgPSB1dnNbIHkgKyAxIF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2NCA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCB0aGlzLnZlcnRpY2VzWyB2MSBdLnkgKSA9PT0gcmFkaXVzICkge1xuXG4gICAgICAgIHV2MS54ID0gKCB1djEueCArIHV2Mi54ICkgLyAyO1xuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYzLCB2NCwgWyBuMSwgbjMsIG40IF0gKSApO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYzLCB1djQgXSApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBNYXRoLmFicyggdGhpcy52ZXJ0aWNlc1sgdjMgXS55ICkgPT09IHJhZGl1cyApIHtcblxuICAgICAgICB1djMueCA9ICggdXYzLnggKyB1djQueCApIC8gMjtcbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdICkgKTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2NCwgWyBuMSwgbjIsIG40IF0gKSApO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xuXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Mi5jbG9uZSgpLCB1djMsIHV2NC5jbG9uZSgpIF0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqIGJhc2VkIG9uIFRIUkVFLlNwaGVyZUdlb21ldHJ5XG4gKi9cblxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cbiAgd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuICBwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XG4gIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XG5cbiAgdmFyIHZlcnRleENvdW50ID0gKCAoIHdpZHRoU2VnbWVudHMgKyAxICkgKiAoIGhlaWdodFNlZ21lbnRzICsgMSApICk7XG5cbiAgdmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gIHZhciBub3JtYWxzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMpO1xuICB2YXIgdXZzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcblxuICB2YXIgaW5kZXggPSAwLCB2ZXJ0aWNlcyA9IFtdLCBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIGZvciAoIHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuICAgIHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG4gICAgdmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cbiAgICBmb3IgKCB2YXIgeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcblxuICAgICAgdmFyIHB4ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgICAgdmFyIHB5ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICAgIHZhciBweiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cbiAgICAgIG5vcm1hbC5zZXQoIHB4LCBweSwgcHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgcG9zaXRpb25zLnNldFhZWiggaW5kZXgsIHB4LCBweSwgcHogKTtcbiAgICAgIG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuICAgICAgdXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcblxuICAgICAgdmVydGljZXNSb3cucHVzaCggaW5kZXggKTtcblxuICAgICAgaW5kZXgrKztcblxuICAgIH1cblxuICAgIHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cbiAgfVxuXG4gIHZhciBpbmRpY2VzID0gW107XG5cbiAgZm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSAgICAgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyB5ICAgICBdWyB4ICAgICBdO1xuICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggICAgIF07XG4gICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuICAgICAgaWYgKCB5ICE9PSAwICkgaW5kaWNlcy5wdXNoKCB2MSwgdjIsIHY0ICk7XG4gICAgICBpZiAoIHkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBpbmRpY2VzICksIDEgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFscyApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgdXZzICk7XG5cbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXG4gKlxuICogVGV4dCA9IDNEIFRleHRcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIHNpemU6ICAgICAgIDxmbG9hdD4sICAvLyBzaXplIG9mIHRoZSB0ZXh0XG4gKiAgaGVpZ2h0OiAgICAgPGZsb2F0PiwgIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcbiAqICBjdXJ2ZVNlZ21lbnRzOiAgPGludD4sICAgIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICpcbiAqICBmb250OiAgICAgICA8c3RyaW5nPiwgICAvLyBmb250IG5hbWVcbiAqICB3ZWlnaHQ6ICAgICA8c3RyaW5nPiwgICAvLyBmb250IHdlaWdodCAobm9ybWFsLCBib2xkKVxuICogIHN0eWxlOiAgICAgIDxzdHJpbmc+LCAgIC8vIGZvbnQgc3R5bGUgIChub3JtYWwsIGl0YWxpY3MpXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAgICAgLy8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAgICAvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xuICogIGJldmVsU2l6ZTogICAgPGZsb2F0PiwgICAgLy8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxuICogIH1cbiAqXG4gKi9cblxuLyogIFVzYWdlIEV4YW1wbGVzXG5cbiAgLy8gVGV4dEdlb21ldHJ5IHdyYXBwZXJcblxuICB2YXIgdGV4dDNkID0gbmV3IFRleHRHZW9tZXRyeSggdGV4dCwgb3B0aW9ucyApO1xuXG4gIC8vIENvbXBsZXRlIG1hbm5lclxuXG4gIHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBvcHRpb25zICk7XG4gIHZhciB0ZXh0M2QgPSBuZXcgRXh0cnVkZUdlb21ldHJ5KCB0ZXh0U2hhcGVzLCBvcHRpb25zICk7XG5cbiovXG5cblxuVEhSRUUuVGV4dEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG4gIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gIHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzICk7XG5cbiAgLy8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxuXG4gIHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XG5cbiAgLy8gZGVmYXVsdHNcblxuICBpZiAoIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcbiAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xuICBpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xuXG4gIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5jYWxsKCB0aGlzLCB0ZXh0U2hhcGVzLCBwYXJhbWV0ZXJzICk7XG5cbiAgdGhpcy50eXBlID0gJ1RleHRHZW9tZXRyeSc7XG5cbn07XG5cblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV4dEdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XG4gKi9cblxuVEhSRUUuVG9ydXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgdHViZTogdHViZSxcbiAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgdHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgYXJjOiBhcmNcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuICB0dWJlID0gdHViZSB8fCA0MDtcbiAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcbiAgYXJjID0gYXJjIHx8IE1hdGguUEkgKiAyO1xuXG4gIHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB1dnMgPSBbXSwgbm9ybWFscyA9IFtdO1xuXG4gIGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICAgIHZhciB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcbiAgICAgIHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cbiAgICAgIGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcbiAgICAgIGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcblxuICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICB2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XG4gICAgICB2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XG4gICAgICB2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyB0dWJ1bGFyU2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApICk7XG4gICAgICBub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcblxuICAgIH1cblxuICB9XG5cbiAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuICAgICAgdmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcbiAgICAgIHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcbiAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuICAgICAgdmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG4gICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcbiAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGEgXS5jbG9uZSgpLCB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgWyBub3JtYWxzWyBiIF0uY2xvbmUoKSwgbm9ybWFsc1sgYyBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcbiAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNLbm90R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNEL3NyYy9hd2F5M2QvcHJpbWl0aXZlcy9Ub3J1c0tub3QuYXM/c3BlYz1zdm4yNDczJnI9MjQ3M1xuICovXG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIHAsIHEsIGhlaWdodFNjYWxlICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB0dWJlOiB0dWJlLFxuICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICB0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgaGVpZ2h0U2NhbGU6IGhlaWdodFNjYWxlXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcbiAgdHViZSA9IHR1YmUgfHwgNDA7XG4gIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgNjQ7XG4gIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA4O1xuICBwID0gcCB8fCAyO1xuICBxID0gcSB8fCAzO1xuICBoZWlnaHRTY2FsZSA9IGhlaWdodFNjYWxlIHx8IDE7XG5cbiAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XG4gIHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xuXG4gICAgZ3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICB2YXIgdSA9IGkgLyByYWRpYWxTZWdtZW50cyAqIDIgKiBwICogTWF0aC5QSTtcbiAgICB2YXIgcDEgPSBnZXRQb3MoIHUsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcbiAgICB2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG4gICAgdGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcbiAgICBuLmFkZFZlY3RvcnMoIHAyLCBwMSApO1xuXG4gICAgYml0YW4uY3Jvc3NWZWN0b3JzKCB0YW5nLCBuICk7XG4gICAgbi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XG4gICAgYml0YW4ubm9ybWFsaXplKCk7XG4gICAgbi5ub3JtYWxpemUoKTtcblxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuICAgICAgdmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XG4gICAgICB2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxuICAgICAgdmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgIHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgcG9zLnggPSBwMS54ICsgY3ggKiBuLnggKyBjeSAqIGJpdGFuLng7XG4gICAgICBwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcbiAgICAgIHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xuXG4gICAgICBncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xuXG4gICAgfVxuXG4gIH1cblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcblxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuICAgICAgdmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG4gICAgICB2YXIganAgPSAoIGogKyAxICkgJSB0dWJ1bGFyU2VnbWVudHM7XG5cbiAgICAgIHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XG4gICAgICB2YXIgYiA9IGdyaWRbIGlwIF1bIGogXTtcbiAgICAgIHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcbiAgICAgIHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgdmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG4gICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gIGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcblxuICAgIHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG4gICAgdmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcbiAgICB2YXIgcXVPdmVyUCA9IGluX3EgLyBpbl9wICogdTtcbiAgICB2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG4gICAgdmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuICAgIHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcbiAgICB2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuICB9XG5cbn07XG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxXG4gKlxuICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxuICpcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXG4gKlxuICogVXNlcyBwYXJhbGxlbCB0cmFuc3BvcnQgZnJhbWVzIGFzIGRlc2NyaWJlZCBpblxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG4gKi9cblxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBjbG9zZWQ6IGNsb3NlZFxuICB9O1xuXG4gIHNlZ21lbnRzID0gc2VnbWVudHMgfHwgNjQ7XG4gIHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG4gIGNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcbiAgdGFwZXIgPSB0YXBlciB8fCBUSFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlcjtcblxuICB2YXIgZ3JpZCA9IFtdO1xuXG4gIHZhciBzY29wZSA9IHRoaXMsXG5cbiAgICB0YW5nZW50LFxuICAgIG5vcm1hbCxcbiAgICBiaW5vcm1hbCxcblxuICAgIG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcblxuICAgIHUsIHYsIHIsXG5cbiAgICBjeCwgY3ksXG4gICAgcG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBpLCBqLFxuICAgIGlwLCBqcCxcbiAgICBhLCBiLCBjLCBkLFxuICAgIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICB2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcbiAgICB0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcbiAgICBub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXG4gICAgYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuICAvLyBwcm94eSBpbnRlcm5hbHNcbiAgdGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICB0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuICBmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xuXG4gICAgcmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XG5cbiAgfVxuXG4gIC8vIGNvbnNydWN0IHRoZSBncmlkXG5cbiAgZm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICBncmlkWyBpIF0gPSBbXTtcblxuICAgIHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICBwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuICAgIHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuICAgIG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcbiAgICBiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG4gICAgciA9IHJhZGl1cyAqIHRhcGVyKCB1ICk7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgICB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cbiAgICAgIGN4ID0gLSByICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cbiAgICAgIGN5ID0gciAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgIHBvczIuY29weSggcG9zICk7XG4gICAgICBwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcbiAgICAgIHBvczIueSArPSBjeCAqIG5vcm1hbC55ICsgY3kgKiBiaW5vcm1hbC55O1xuICAgICAgcG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XG5cbiAgICAgIGdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xuXG4gICAgfVxuICB9XG5cblxuICAvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcblxuICBmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgZm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgICAgaXAgPSAoIGNsb3NlZCApID8gKGkgKyAxKSAlIHNlZ21lbnRzIDogaSArIDE7XG4gICAgICBqcCA9IChqICsgMSkgJSByYWRpYWxTZWdtZW50cztcblxuICAgICAgYSA9IGdyaWRbIGkgXVsgaiBdOyAgIC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG4gICAgICBiID0gZ3JpZFsgaXAgXVsgaiBdO1xuICAgICAgYyA9IGdyaWRbIGlwIF1bIGpwIF07XG4gICAgICBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcbiAgICAgIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlR1YmVHZW9tZXRyeTtcblxuVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgcmV0dXJuIDE7XG5cbn07XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgcmV0dXJuIE1hdGguc2luKCBNYXRoLlBJICogdSApO1xuXG59O1xuXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcblRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSB7XG5cbiAgdmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICB0YW5nZW50cyA9IFtdLFxuICAgIG5vcm1hbHMgPSBbXSxcbiAgICBiaW5vcm1hbHMgPSBbXSxcblxuICAgIHZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgbWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuICAgIG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcbiAgICB0aGV0YSxcbiAgICBlcHNpbG9uID0gMC4wMDAxLFxuICAgIHNtYWxsZXN0LFxuXG4gICAgdHgsIHR5LCB0eixcbiAgICBpLCB1O1xuXG5cbiAgLy8gZXhwb3NlIGludGVybmFsc1xuICB0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG4gIHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XG4gIHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cbiAgZm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICB1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgdGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XG4gICAgdGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcblxuICB9XG5cbiAgaW5pdGlhbE5vcm1hbDMoKTtcblxuICAvKlxuICBmdW5jdGlvbiBpbml0aWFsTm9ybWFsMShsYXN0Qmlub3JtYWwpIHtcbiAgICAvLyBmaXhlZCBzdGFydCBiaW5vcm1hbC4gSGFzIGRhbmdlcnMgb2YgMCB2ZWN0b3JzXG4gICAgbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgaWYgKGxhc3RCaW5vcm1hbD09PXVuZGVmaW5lZCkgbGFzdEJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcbiAgICBub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBsYXN0Qmlub3JtYWwsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcbiAgICBiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDIoKSB7XG5cbiAgICAvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcbiAgICB2YXIgdDIgPSBwYXRoLmdldFRhbmdlbnRBdCggZXBzaWxvbiApO1xuXG4gICAgbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zdWJWZWN0b3JzKCB0MiwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXG4gICAgbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcbiAgICBiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXG4gIH1cbiAgKi9cblxuICBmdW5jdGlvbiBpbml0aWFsTm9ybWFsMygpIHtcbiAgICAvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG4gICAgLy8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG4gICAgbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgc21hbGxlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xuICAgIHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xuICAgIHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xuXG4gICAgaWYgKCB0eCA8PSBzbWFsbGVzdCApIHtcbiAgICAgIHNtYWxsZXN0ID0gdHg7XG4gICAgICBub3JtYWwuc2V0KCAxLCAwLCAwICk7XG4gICAgfVxuXG4gICAgaWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcbiAgICAgIHNtYWxsZXN0ID0gdHk7XG4gICAgICBub3JtYWwuc2V0KCAwLCAxLCAwICk7XG4gICAgfVxuXG4gICAgaWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcbiAgICAgIG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcbiAgICB9XG5cbiAgICB2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuICAgIG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuICAgIGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG4gIH1cblxuXG4gIC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cbiAgZm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICBub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cbiAgICBiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG4gICAgdmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcblxuICAgIGlmICggdmVjLmxlbmd0aCgpID4gZXBzaWxvbiApIHtcblxuICAgICAgdmVjLm5vcm1hbGl6ZSgpO1xuXG4gICAgICB0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuICAgICAgbm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xuXG4gICAgfVxuXG4gICAgYmlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuICB9XG5cblxuICAvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cbiAgaWYgKCBjbG9zZWQgKSB7XG5cbiAgICB0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICksIC0gMSwgMSApICk7XG4gICAgdGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICBpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApICkgPiAwICkge1xuXG4gICAgICB0aGV0YSA9IC0gdGhldGE7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuICAgICAgLy8gdHdpc3QgYSBsaXR0bGUuLi5cbiAgICAgIG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xuICAgICAgYmlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuICAgIH1cblxuICB9XG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Qb2x5aGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gIGRldGFpbCA9IGRldGFpbCB8fCAwO1xuXG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICBwcmVwYXJlKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcblxuICB9XG5cbiAgdmFyIHAgPSB0aGlzLnZlcnRpY2VzO1xuXG4gIHZhciBmYWNlcyA9IFtdO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaiArKyApIHtcblxuICAgIHZhciB2MSA9IHBbIGluZGljZXNbIGkgICAgIF0gXTtcbiAgICB2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XG4gICAgdmFyIHYzID0gcFsgaW5kaWNlc1sgaSArIDIgXSBdO1xuXG4gICAgZmFjZXNbIGogXSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0gKTtcblxuICB9XG5cbiAgdmFyIGNlbnRyb2lkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgc3ViZGl2aWRlKCBmYWNlc1sgaSBdLCBkZXRhaWwgKTtcblxuICB9XG5cblxuICAvLyBIYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtXG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgdmFyIHgwID0gdXZzWyAwIF0ueDtcbiAgICB2YXIgeDEgPSB1dnNbIDEgXS54O1xuICAgIHZhciB4MiA9IHV2c1sgMiBdLng7XG5cbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCBNYXRoLm1heCggeDEsIHgyICkgKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4oIHgwLCBNYXRoLm1pbiggeDEsIHgyICkgKTtcblxuICAgIGlmICggbWF4ID4gMC45ICYmIG1pbiA8IDAuMSApIHsgLy8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG4gICAgICBpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xuICAgICAgaWYgKCB4MSA8IDAuMiApIHV2c1sgMSBdLnggKz0gMTtcbiAgICAgIGlmICggeDIgPCAwLjIgKSB1dnNbIDIgXS54ICs9IDE7XG5cbiAgICB9XG5cbiAgfVxuXG5cbiAgLy8gQXBwbHkgcmFkaXVzXG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgdGhpcy52ZXJ0aWNlc1sgaSBdLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKTtcblxuICB9XG5cblxuICAvLyBNZXJnZSB2ZXJ0aWNlc1xuXG4gIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG5cbiAgLy8gUHJvamVjdCB2ZWN0b3Igb250byBzcGhlcmUncyBzdXJmYWNlXG5cbiAgZnVuY3Rpb24gcHJlcGFyZSggdmVjdG9yICkge1xuXG4gICAgdmFyIHZlcnRleCA9IHZlY3Rvci5ub3JtYWxpemUoKS5jbG9uZSgpO1xuICAgIHZlcnRleC5pbmRleCA9IHRoYXQudmVydGljZXMucHVzaCggdmVydGV4ICkgLSAxO1xuXG4gICAgLy8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxuXG4gICAgdmFyIHUgPSBhemltdXRoKCB2ZWN0b3IgKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuICAgIHZhciB2ID0gaW5jbGluYXRpb24oIHZlY3RvciApIC8gTWF0aC5QSSArIDAuNTtcbiAgICB2ZXJ0ZXgudXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKTtcblxuICAgIHJldHVybiB2ZXJ0ZXg7XG5cbiAgfVxuXG5cbiAgLy8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cblxuICBmdW5jdGlvbiBtYWtlKCB2MSwgdjIsIHYzICkge1xuXG4gICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdICk7XG4gICAgdGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICBjZW50cm9pZC5jb3B5KCB2MSApLmFkZCggdjIgKS5hZGQoIHYzICkuZGl2aWRlU2NhbGFyKCAzICk7XG5cbiAgICB2YXIgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcblxuICAgIHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcbiAgICAgIGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcbiAgICAgIGNvcnJlY3RVViggdjIudXYsIHYyLCBhemkgKSxcbiAgICAgIGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxuICAgIF0gKTtcblxuICB9XG5cblxuICAvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxuXG4gIGZ1bmN0aW9uIHN1YmRpdmlkZSggZmFjZSwgZGV0YWlsICkge1xuXG4gICAgdmFyIGNvbHMgPSBNYXRoLnBvdygyLCBkZXRhaWwpO1xuICAgIHZhciBhID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcbiAgICB2YXIgYiA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYiBdICk7XG4gICAgdmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xuICAgIHZhciB2ID0gW107XG5cbiAgICAvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvbi5cblxuICAgIGZvciAoIHZhciBpID0gMCA7IGkgPD0gY29sczsgaSArKyApIHtcblxuICAgICAgdlsgaSBdID0gW107XG5cbiAgICAgIHZhciBhaiA9IHByZXBhcmUoIGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XG4gICAgICB2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuICAgICAgdmFyIHJvd3MgPSBjb2xzIC0gaTtcblxuICAgICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJvd3M7IGogKyspIHtcblxuICAgICAgICBpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuICAgICAgICAgIHZbIGkgXVsgaiBdID0gYWo7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHZbIGkgXVsgaiBdID0gcHJlcGFyZSggYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzIDsgaSArKyApIHtcblxuICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMiAqIChjb2xzIC0gaSkgLSAxOyBqICsrICkge1xuXG4gICAgICAgIHZhciBrID0gTWF0aC5mbG9vciggaiAvIDIgKTtcblxuICAgICAgICBpZiAoIGogJSAyID09PSAwICkge1xuXG4gICAgICAgICAgbWFrZShcbiAgICAgICAgICAgIHZbIGkgXVsgayArIDFdLFxuICAgICAgICAgICAgdlsgaSArIDEgXVsgayBdLFxuICAgICAgICAgICAgdlsgaSBdWyBrIF1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBtYWtlKFxuICAgICAgICAgICAgdlsgaSBdWyBrICsgMSBdLFxuICAgICAgICAgICAgdlsgaSArIDFdWyBrICsgMV0sXG4gICAgICAgICAgICB2WyBpICsgMSBdWyBrIF1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuXG4gIC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuICBmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcblxuICB9XG5cblxuICAvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cbiAgZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG4gIH1cblxuXG4gIC8vIFRleHR1cmUgZml4aW5nIGhlbHBlci4gU3BoZXJlcyBoYXZlIHNvbWUgb2RkIGJlaGF2aW91cnMuXG5cbiAgZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xuXG4gICAgaWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1di54IC0gMSwgdXYueSApO1xuICAgIGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xuICAgIHJldHVybiB1di5jbG9uZSgpO1xuXG4gIH1cblxuXG59O1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXG4gKi9cblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9O1xuXG4gIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG4gIHZhciByID0gMSAvIHQ7XG5cbiAgdmFyIHZlcnRpY2VzID0gW1xuXG4gICAgLy8gKMKxMSwgwrExLCDCsTEpXG4gICAgLTEsIC0xLCAtMSwgICAgLTEsIC0xLCAgMSxcbiAgICAtMSwgIDEsIC0xLCAgICAtMSwgIDEsICAxLFxuICAgICAxLCAtMSwgLTEsICAgICAxLCAtMSwgIDEsXG4gICAgIDEsICAxLCAtMSwgICAgIDEsICAxLCAgMSxcblxuICAgIC8vICgwLCDCsTEvz4YsIMKxz4YpXG4gICAgIDAsIC1yLCAtdCwgICAgIDAsIC1yLCAgdCxcbiAgICAgMCwgIHIsIC10LCAgICAgMCwgIHIsICB0LFxuXG4gICAgLy8gKMKxMS/PhiwgwrHPhiwgMClcbiAgICAtciwgLXQsICAwLCAgICAtciwgIHQsICAwLFxuICAgICByLCAtdCwgIDAsICAgICByLCAgdCwgIDAsXG5cbiAgICAvLyAowrHPhiwgMCwgwrExL8+GKVxuICAgIC10LCAgMCwgLXIsICAgICB0LCAgMCwgLXIsXG4gICAgLXQsICAwLCAgciwgICAgIHQsICAwLCAgclxuICBdO1xuXG4gIHZhciBpbmRpY2VzID0gW1xuICAgICAzLCAxMSwgIDcsICAgICAgMywgIDcsIDE1LCAgICAgIDMsIDE1LCAxMyxcbiAgICAgNywgMTksIDE3LCAgICAgIDcsIDE3LCAgNiwgICAgICA3LCAgNiwgMTUsXG4gICAgMTcsICA0LCAgOCwgICAgIDE3LCAgOCwgMTAsICAgICAxNywgMTAsICA2LFxuICAgICA4LCAgMCwgMTYsICAgICAgOCwgMTYsICAyLCAgICAgIDgsICAyLCAxMCxcbiAgICAgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXG4gICAgIDYsIDEwLCAgMiwgICAgICA2LCAgMiwgMTMsICAgICAgNiwgMTMsIDE1LFxuICAgICAyLCAxNiwgMTgsICAgICAgMiwgMTgsICAzLCAgICAgIDIsICAzLCAxMyxcbiAgICAxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXG4gICAgIDQsIDE0LCAxMiwgICAgICA0LCAxMiwgIDAsICAgICAgNCwgIDAsICA4LFxuICAgIDExLCAgOSwgIDUsICAgICAxMSwgIDUsIDE5LCAgICAgMTEsIDE5LCAgNyxcbiAgICAxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXG4gICAgIDEsIDEyLCAxNCwgICAgICAxLCAxNCwgIDUsICAgICAgMSwgIDUsICA5XG4gIF07XG5cbiAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG59O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9JY29zYWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cbiAgdmFyIHZlcnRpY2VzID0gW1xuICAgIC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuICAgICAwLCAtIDEsICB0LCAgICAwLCAgMSwgIHQsICAgIDAsIC0gMSwgLSB0LCAgICAwLCAgMSwgLSB0LFxuICAgICB0LCAgMCwgLSAxLCAgICB0LCAgMCwgIDEsICAgLSB0LCAgMCwgLSAxLCAgIC0gdCwgIDAsICAxXG4gIF07XG5cbiAgdmFyIGluZGljZXMgPSBbXG4gICAgIDAsIDExLCAgNSwgICAgMCwgIDUsICAxLCAgICAwLCAgMSwgIDcsICAgIDAsICA3LCAxMCwgICAgMCwgMTAsIDExLFxuICAgICAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcbiAgICAgMywgIDksICA0LCAgICAzLCAgNCwgIDIsICAgIDMsICAyLCAgNiwgICAgMywgIDYsICA4LCAgICAzLCAgOCwgIDksXG4gICAgIDQsICA5LCAgNSwgICAgMiwgIDQsIDExLCAgICA2LCAgMiwgMTAsICAgIDgsICA2LCAgNywgICAgOSwgIDgsICAxXG4gIF07XG5cbiAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gIHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcbn07XG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL09jdGFoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9O1xuXG4gIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAxLCAwLCAwLCAgIC0gMSwgMCwgMCwgICAgMCwgMSwgMCwgICAgMCwtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsLSAxXG4gIF07XG5cbiAgdmFyIGluZGljZXMgPSBbXG4gICAgMCwgMiwgNCwgICAgMCwgNCwgMywgICAgMCwgMywgNSwgICAgMCwgNSwgMiwgICAgMSwgMiwgNSwgICAgMSwgNSwgMywgICAgMSwgMywgNCwgICAgMSwgNCwgMlxuICBdO1xuXG4gIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICB0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcbn07XG5cblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcbiAgXTtcblxuICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG4gIF07XG5cbiAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gIHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcblxufTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGFyYW1ldHJpY0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XG4gKlxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcbiAqXG4gKi9cblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIGZ1bmM6IGZ1bmMsXG4gICAgc2xpY2VzOiBzbGljZXMsXG4gICAgc3RhY2tzOiBzdGFja3NcbiAgfTtcblxuICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cbiAgdmFyIGksIGosIHA7XG4gIHZhciB1LCB2O1xuXG4gIHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcblxuICBmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XG5cbiAgICB2ID0gaSAvIHN0YWNrcztcblxuICAgIGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcblxuICAgICAgdSA9IGogLyBzbGljZXM7XG5cbiAgICAgIHAgPSBmdW5jKCB1LCB2ICk7XG4gICAgICB2ZXJ0cy5wdXNoKCBwICk7XG5cbiAgICB9XG4gIH1cblxuICB2YXIgYSwgYiwgYywgZDtcbiAgdmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICBmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcblxuICAgIGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG4gICAgICBhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuICAgICAgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG4gICAgICBjID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcbiAgICAgIGQgPSAoaSArIDEpICogc2xpY2VDb3VudCArIGo7XG5cbiAgICAgIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG4gICAgICB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG4gICAgICB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcbiAgICAgIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblxuICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgIHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICBmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgICAgdXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuICAvLyBtYWdpYyBidWxsZXRcbiAgLy8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcbiAgLy8gY29uc29sZS5sb2coJ3JlbW92ZWQgJywgZGlmZiwgJyB2ZXJ0aWNlcyBieSBtZXJnaW5nJyk7XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9XaXJlZnJhbWVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG4gIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiAoIGEsIGIgKSB7IHJldHVybiBhIC0gYiB9O1xuXG4gIHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cbiAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgdmFyIG51bUVkZ2VzID0gMDtcblxuICAgIC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxuICAgIHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggNiAqIGZhY2VzLmxlbmd0aCApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuICAgICAgICBlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcbiAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuICAgICAgICAgIGhhc2hbIGtleSBdID0gdHJ1ZTtcbiAgICAgICAgICBudW1FZGdlcyArKztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBlZGdlcyBbIDIgKiBpICsgal0gXTtcblxuICAgICAgICB2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XG4gICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0ZXgueTtcbiAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7IC8vIEluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcbiAgICAgIHZhciBkcmF3Y2FsbHMgPSBnZW9tZXRyeS5kcmF3Y2FsbHM7XG4gICAgICB2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgICBpZiAoIGRyYXdjYWxscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgZHJhd2NhbGxzID0gWyB7IGNvdW50IDogaW5kaWNlcy5sZW5ndGgsIGluZGV4IDogMCwgc3RhcnQgOiAwIH0gXTtcblxuICAgICAgfVxuXG4gICAgICAvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcbiAgICAgIHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggMiAqIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgIGZvciAoIHZhciBvID0gMCwgb2wgPSBkcmF3Y2FsbHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZHJhd2NhbGxzWyBvIF0uc3RhcnQ7XG4gICAgICAgIHZhciBjb3VudCA9IGRyYXdjYWxsc1sgbyBdLmNvdW50O1xuICAgICAgICB2YXIgaW5kZXggPSBkcmF3Y2FsbHNbIG8gXS5pbmRleDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgICAgICAgZWRnZVsgMCBdID0gaW5kZXggKyBpbmRpY2VzWyBpICsgaiBdO1xuICAgICAgICAgICAgZWRnZVsgMSBdID0gaW5kZXggKyBpbmRpY2VzWyBpICsgKCBqICsgMSApICUgMyBdO1xuICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgICAgICAgICAgdmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgXSA9IGVkZ2VbIDAgXTtcbiAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcbiAgICAgICAgICAgICAgaGFzaFsga2V5IF0gPSB0cnVlO1xuICAgICAgICAgICAgICBudW1FZGdlcyArKztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMjsgaiArKyApIHtcblxuICAgICAgICAgIHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XG4gICAgICAgICAgdmFyIGluZGV4MiA9IGVkZ2VzWzIgKiBpICsgal07XG5cbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXMuZ2V0WCggaW5kZXgyICk7XG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzLmdldFkoIGluZGV4MiApO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlcy5nZXRaKCBpbmRleDIgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICB9IGVsc2UgeyAvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG4gICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgdmFyIG51bUVkZ2VzID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICAgIHZhciBudW1UcmlzID0gbnVtRWRnZXMgLyAzO1xuXG4gICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1UcmlzOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgICAgICAgdmFyIGluZGV4ID0gMTggKiBpICsgNiAqIGo7XG5cbiAgICAgICAgICB2YXIgaW5kZXgxID0gOSAqIGkgKyAzICogajtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXNbIGluZGV4MSBdO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMSBdO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMiBdO1xuXG4gICAgICAgICAgdmFyIGluZGV4MiA9IDkgKiBpICsgMyAqICggKCBqICsgMSApICUgMyApO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAzIF0gPSB2ZXJ0aWNlc1sgaW5kZXgyIF07XG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDQgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAxIF07XG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDUgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAyIF07XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgfVxuXG4gIH1cblxufTtcblxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXhpc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXhpc0hlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuICBzaXplID0gc2l6ZSB8fCAxO1xuXG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAwLCAwLCAwLCAgc2l6ZSwgMCwgMCxcbiAgICAwLCAwLCAwLCAgMCwgc2l6ZSwgMCxcbiAgICAwLCAwLCAwLCAgMCwgMCwgc2l6ZVxuICBdICk7XG5cbiAgdmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAxLCAwLCAwLCAgMSwgMC42LCAwLFxuICAgIDAsIDEsIDAsICAwLjYsIDEsIDAsXG4gICAgMCwgMCwgMSwgIDAsIDAuNiwgMVxuICBdICk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn07XG5cblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BeGlzSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BcnJvd0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiAgZGlyIC0gVmVjdG9yM1xuICogIG9yaWdpbiAtIFZlY3RvcjNcbiAqICBsZW5ndGggLSBOdW1iZXJcbiAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcbiAqL1xuXG5USFJFRS5BcnJvd0hlbHBlciA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgbGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblxuICB2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xuICBjb25lR2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKCAwLCAtIDAuNSwgMCApICk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuICAgIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG4gICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XG4gICAgaWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuICAgIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG4gICAgdGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcblxuICAgIHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG4gICAgdGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cbiAgICB0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuICAgIHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG4gICAgdGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuICAgIHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXG4gIH1cblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJyb3dIZWxwZXI7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciByYWRpYW5zO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGRpciApIHtcblxuICAgIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIGlmICggZGlyLnkgPiAwLjk5OTk5ICkge1xuXG4gICAgICB0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XG5cbiAgICB9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcblxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMSwgMCwgMCwgMCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgYXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XG5cbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XG5cbiAgICB9XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG4gIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcbiAgaWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cbiAgdGhpcy5saW5lLnNjYWxlLnNldCggMSwgbGVuZ3RoIC0gaGVhZExlbmd0aCwgMSApO1xuICB0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XG5cbiAgdGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcbiAgdGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG4gIHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxufTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICB0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuICB0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDcyICksIDMgKSApO1xuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICkgKTtcblxuICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgdGhpcy51cGRhdGUoIG9iamVjdCApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hIZWxwZXI7XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICB9XG5cbiAgdmFyIG1pbiA9IGdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbjtcbiAgdmFyIG1heCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heDtcblxuICAvKlxuICAgIDVfX19fNFxuICAxL19fXzAvfFxuICB8IDZfX3xfN1xuICAyL19fXzMvXG5cbiAgMDogbWF4LngsIG1heC55LCBtYXguelxuICAxOiBtaW4ueCwgbWF4LnksIG1heC56XG4gIDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcbiAgMzogbWF4LngsIG1pbi55LCBtYXguelxuICA0OiBtYXgueCwgbWF4LnksIG1pbi56XG4gIDU6IG1pbi54LCBtYXgueSwgbWluLnpcbiAgNjogbWluLngsIG1pbi55LCBtaW4uelxuICA3OiBtYXgueCwgbWluLnksIG1pbi56XG4gICovXG5cbiAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gIHZlcnRpY2VzWyAgMCBdID0gbWF4Lng7IHZlcnRpY2VzWyAgMSBdID0gbWF4Lnk7IHZlcnRpY2VzWyAgMiBdID0gbWF4Lno7XG4gIHZlcnRpY2VzWyAgMyBdID0gbWluLng7IHZlcnRpY2VzWyAgNCBdID0gbWF4Lnk7IHZlcnRpY2VzWyAgNSBdID0gbWF4Lno7XG5cbiAgdmVydGljZXNbICA2IF0gPSBtaW4ueDsgdmVydGljZXNbICA3IF0gPSBtYXgueTsgdmVydGljZXNbICA4IF0gPSBtYXguejtcbiAgdmVydGljZXNbICA5IF0gPSBtaW4ueDsgdmVydGljZXNbIDEwIF0gPSBtaW4ueTsgdmVydGljZXNbIDExIF0gPSBtYXguejtcblxuICB2ZXJ0aWNlc1sgMTIgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMTMgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMTQgXSA9IG1heC56O1xuICB2ZXJ0aWNlc1sgMTUgXSA9IG1heC54OyB2ZXJ0aWNlc1sgMTYgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMTcgXSA9IG1heC56O1xuXG4gIHZlcnRpY2VzWyAxOCBdID0gbWF4Lng7IHZlcnRpY2VzWyAxOSBdID0gbWluLnk7IHZlcnRpY2VzWyAyMCBdID0gbWF4Lno7XG4gIHZlcnRpY2VzWyAyMSBdID0gbWF4Lng7IHZlcnRpY2VzWyAyMiBdID0gbWF4Lnk7IHZlcnRpY2VzWyAyMyBdID0gbWF4Lno7XG5cbiAgLy9cblxuICB2ZXJ0aWNlc1sgMjQgXSA9IG1heC54OyB2ZXJ0aWNlc1sgMjUgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMjYgXSA9IG1pbi56O1xuICB2ZXJ0aWNlc1sgMjcgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMjggXSA9IG1heC55OyB2ZXJ0aWNlc1sgMjkgXSA9IG1pbi56O1xuXG4gIHZlcnRpY2VzWyAzMCBdID0gbWluLng7IHZlcnRpY2VzWyAzMSBdID0gbWF4Lnk7IHZlcnRpY2VzWyAzMiBdID0gbWluLno7XG4gIHZlcnRpY2VzWyAzMyBdID0gbWluLng7IHZlcnRpY2VzWyAzNCBdID0gbWluLnk7IHZlcnRpY2VzWyAzNSBdID0gbWluLno7XG5cbiAgdmVydGljZXNbIDM2IF0gPSBtaW4ueDsgdmVydGljZXNbIDM3IF0gPSBtaW4ueTsgdmVydGljZXNbIDM4IF0gPSBtaW4uejtcbiAgdmVydGljZXNbIDM5IF0gPSBtYXgueDsgdmVydGljZXNbIDQwIF0gPSBtaW4ueTsgdmVydGljZXNbIDQxIF0gPSBtaW4uejtcblxuICB2ZXJ0aWNlc1sgNDIgXSA9IG1heC54OyB2ZXJ0aWNlc1sgNDMgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNDQgXSA9IG1pbi56O1xuICB2ZXJ0aWNlc1sgNDUgXSA9IG1heC54OyB2ZXJ0aWNlc1sgNDYgXSA9IG1heC55OyB2ZXJ0aWNlc1sgNDcgXSA9IG1pbi56O1xuXG4gIC8vXG5cbiAgdmVydGljZXNbIDQ4IF0gPSBtYXgueDsgdmVydGljZXNbIDQ5IF0gPSBtYXgueTsgdmVydGljZXNbIDUwIF0gPSBtYXguejtcbiAgdmVydGljZXNbIDUxIF0gPSBtYXgueDsgdmVydGljZXNbIDUyIF0gPSBtYXgueTsgdmVydGljZXNbIDUzIF0gPSBtaW4uejtcblxuICB2ZXJ0aWNlc1sgNTQgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNTUgXSA9IG1heC55OyB2ZXJ0aWNlc1sgNTYgXSA9IG1heC56O1xuICB2ZXJ0aWNlc1sgNTcgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNTggXSA9IG1heC55OyB2ZXJ0aWNlc1sgNTkgXSA9IG1pbi56O1xuXG4gIHZlcnRpY2VzWyA2MCBdID0gbWluLng7IHZlcnRpY2VzWyA2MSBdID0gbWluLnk7IHZlcnRpY2VzWyA2MiBdID0gbWF4Lno7XG4gIHZlcnRpY2VzWyA2MyBdID0gbWluLng7IHZlcnRpY2VzWyA2NCBdID0gbWluLnk7IHZlcnRpY2VzWyA2NSBdID0gbWluLno7XG5cbiAgdmVydGljZXNbIDY2IF0gPSBtYXgueDsgdmVydGljZXNbIDY3IF0gPSBtaW4ueTsgdmVydGljZXNbIDY4IF0gPSBtYXguejtcbiAgdmVydGljZXNbIDY5IF0gPSBtYXgueDsgdmVydGljZXNbIDcwIF0gPSBtaW4ueTsgdmVydGljZXNbIDcxIF0gPSBtaW4uejtcblxuICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gIHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3VuZGluZ0JveEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cbi8vIGEgaGVscGVyIHRvIHNob3cgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFuIG9iamVjdFxuXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XG5cbiAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHg4ODg4ODg7XG5cbiAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgdGhpcy5ib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gIFRIUkVFLk1lc2guY2FsbCggdGhpcywgbmV3IFRIUkVFLkJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHdpcmVmcmFtZTogdHJ1ZSB9ICkgKTtcblxufTtcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJvdW5kaW5nQm94SGVscGVyO1xuXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuYm94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XG5cbiAgdGhpcy5ib3guc2l6ZSggdGhpcy5zY2FsZSApO1xuXG4gIHRoaXMuYm94LmNlbnRlciggdGhpcy5wb3NpdGlvbiApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9DYW1lcmFIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqICAtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcbiAqICAtIHN1aXRhYmxlIGZvciBmYXN0IHVwZGF0ZXNcbiAqICAtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXG4gKiAgICBodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXG4gKi9cblxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XG5cbiAgdmFyIHBvaW50TWFwID0ge307XG5cbiAgLy8gY29sb3JzXG5cbiAgdmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcbiAgdmFyIGhleENvbmUgPSAweGZmMDAwMDtcbiAgdmFyIGhleFVwID0gMHgwMGFhZmY7XG4gIHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcbiAgdmFyIGhleENyb3NzID0gMHgzMzMzMzM7XG5cbiAgLy8gbmVhclxuXG4gIGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwibjRcIiwgXCJuM1wiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XG5cbiAgLy8gZmFyXG5cbiAgYWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcblxuICAvLyBzaWRlc1xuXG4gIGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG5cbiAgLy8gY29uZVxuXG4gIGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcbiAgYWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xuICBhZGRMaW5lKCBcInBcIiwgXCJuM1wiLCBoZXhDb25lICk7XG4gIGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcblxuICAvLyB1cFxuXG4gIGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xuICBhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcbiAgYWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGhleFVwICk7XG5cbiAgLy8gdGFyZ2V0XG5cbiAgYWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcbiAgYWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xuXG4gIC8vIGNyb3NzXG5cbiAgYWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcbiAgYWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcblxuICBhZGRMaW5lKCBcImNmMVwiLCBcImNmMlwiLCBoZXhDcm9zcyApO1xuICBhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xuXG4gIGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGhleCApIHtcblxuICAgIGFkZFBvaW50KCBhLCBoZXggKTtcbiAgICBhZGRQb2ludCggYiwgaGV4ICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xuXG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG5cbiAgICBpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHBvaW50TWFwWyBpZCBdID0gW107XG5cbiAgICB9XG5cbiAgICBwb2ludE1hcFsgaWQgXS5wdXNoKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG5cbiAgfVxuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgdGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbWVyYUhlbHBlcjtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGdlb21ldHJ5LCBwb2ludE1hcDtcblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuICB2YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCB4LCB5LCB6ICkge1xuXG4gICAgdmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XG5cbiAgICB2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cbiAgICBpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuICAgIHZhciB3ID0gMSwgaCA9IDE7XG5cbiAgICAvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG4gICAgLy8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuICAgIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIC8vIGNlbnRlciAvIHRhcmdldFxuXG4gICAgc2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XG5cbiAgICAvLyBuZWFyXG5cbiAgICBzZXRQb2ludCggXCJuMVwiLCAtIHcsIC0gaCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwibjJcIiwgICB3LCAtIGgsIC0gMSApO1xuICAgIHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJuNFwiLCAgIHcsICAgaCwgLSAxICk7XG5cbiAgICAvLyBmYXJcblxuICAgIHNldFBvaW50KCBcImYxXCIsIC0gdywgLSBoLCAxICk7XG4gICAgc2V0UG9pbnQoIFwiZjJcIiwgICB3LCAtIGgsIDEgKTtcbiAgICBzZXRQb2ludCggXCJmM1wiLCAtIHcsICAgaCwgMSApO1xuICAgIHNldFBvaW50KCBcImY0XCIsICAgdywgICBoLCAxICk7XG5cbiAgICAvLyB1cFxuXG4gICAgc2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJ1MlwiLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuICAgIHNldFBvaW50KCBcInUzXCIsICAgICAgICAgMCwgaCAqIDIsICAgLSAxICk7XG5cbiAgICAvLyBjcm9zc1xuXG4gICAgc2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XG4gICAgc2V0UG9pbnQoIFwiY2YyXCIsICAgdywgICAwLCAxICk7XG4gICAgc2V0UG9pbnQoIFwiY2YzXCIsICAgMCwgLSBoLCAxICk7XG4gICAgc2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XG5cbiAgICBzZXRQb2ludCggXCJjbjFcIiwgLSB3LCAgIDAsIC0gMSApO1xuICAgIHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwiY24zXCIsICAgMCwgLSBoLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJjbjRcIiwgICAwLCAgIGgsIC0gMSApO1xuXG4gICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0RpcmVjdGlvbmFsTGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzaXplICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICBzaXplID0gc2l6ZSB8fCAxO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApLFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsICAgc2l6ZSwgMCApLFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsIC0gc2l6ZSwgMCApLFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIC0gc2l6ZSwgMCApLFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApXG4gICk7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgdGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICB0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XG5cbiAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcbiAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgKTtcblxuICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcbiAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gIHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgdGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgdGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcbiAgICB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgdjMuc3ViVmVjdG9ycyggdjIsIHYxICk7XG5cbiAgICB0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuICAgIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB2MyApO1xuICAgIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IgKTtcblxuICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0VkZ2VzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAcGFyYW0gb2JqZWN0IFRIUkVFLk1lc2ggd2hvc2UgZ2VvbWV0cnkgd2lsbCBiZSB1c2VkXG4gKiBAcGFyYW0gaGV4IGxpbmUgY29sb3JcbiAqIEBwYXJhbSB0aHJlc2hvbGRBbmdsZSB0aGUgbWluaW1pbSBhbmdsZSAoaW4gZGVncmVlcyksXG4gKiBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgYWRqYWNlbnQgZmFjZXMsXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIHJlbmRlciBhbiBlZGdlLiBBIHZhbHVlIG9mIDEwIG1lYW5zXG4gKiBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIGlzIGF0IGxlYXN0IDEwIGRlZ3JlZXMuXG4gKi9cblxuVEhSRUUuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcblxuICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9GYWNlTm9ybWFsc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcblxuICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gIHZhciBmYWNlcyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cbiAgfVxuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLm5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cbiAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI7XG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcblxuICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3Q7XG4gIHZhciBvYmplY3RWZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcbiAgdmFyIG9iamVjdEZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuICB2YXIgb2JqZWN0V29ybGRNYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG5cbiAgb2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgdGhpcy5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3RXb3JsZE1hdHJpeCApO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaTIgPSAwLCBsID0gb2JqZWN0RmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKywgaTIgKz0gMiApIHtcblxuICAgIHZhciBmYWNlID0gb2JqZWN0RmFjZXNbIGkgXTtcblxuICAgIHZlcnRpY2VzWyBpMiBdLmNvcHkoIG9iamVjdFZlcnRpY2VzWyBmYWNlLmEgXSApXG4gICAgICAuYWRkKCBvYmplY3RWZXJ0aWNlc1sgZmFjZS5iIF0gKVxuICAgICAgLmFkZCggb2JqZWN0VmVydGljZXNbIGZhY2UuYyBdIClcbiAgICAgIC5kaXZpZGVTY2FsYXIoIDMgKVxuICAgICAgLmFwcGx5TWF0cml4NCggb2JqZWN0V29ybGRNYXRyaXggKTtcblxuICAgIHZlcnRpY2VzWyBpMiArIDEgXS5jb3B5KCBmYWNlLm5vcm1hbCApXG4gICAgICAuYXBwbHlNYXRyaXgzKCB0aGlzLm5vcm1hbE1hdHJpeCApXG4gICAgICAubm9ybWFsaXplKClcbiAgICAgIC5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplIClcbiAgICAgIC5hZGQoIHZlcnRpY2VzWyBpMiBdICk7XG5cbiAgfVxuXG4gIHRoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvR3JpZEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSwgc3RlcCApIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcblxuICB0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcbiAgdGhpcy5jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ODg4ODg4ICk7XG5cbiAgZm9yICggdmFyIGkgPSAtIHNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwICkge1xuXG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCAtIHNpemUgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIHNpemUgKVxuICAgICk7XG5cbiAgICB2YXIgY29sb3IgPSBpID09PSAwID8gdGhpcy5jb2xvcjEgOiB0aGlzLmNvbG9yMjtcblxuICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG4gIH1cblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbn07XG5cblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5HcmlkSGVscGVyO1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiggY29sb3JDZW50ZXJMaW5lLCBjb2xvckdyaWQgKSB7XG5cbiAgdGhpcy5jb2xvcjEuc2V0KCBjb2xvckNlbnRlckxpbmUgKTtcbiAgdGhpcy5jb2xvcjIuc2V0KCBjb2xvckdyaWQgKTtcblxuICB0aGlzLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9IZW1pc3BoZXJlTGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLmNvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gIGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoIC0gTWF0aC5QSSAvIDIgKSApO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuICB9XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcblxuICB0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICB0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuICAgIHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgdGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuICAgIHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgfVxuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1BvaW50TGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgLypcbiAgdmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xuICB2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cbiAgdGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xuICB0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXG4gIHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XG5cbiAgaWYgKCBkID09PSAwLjAgKSB7XG5cbiAgICB0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cbiAgfVxuXG4gIHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcbiAgKi9cblxufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0SGVscGVyO1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbn07XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAvKlxuICB2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cbiAgaWYgKCBkID09PSAwLjAgKSB7XG5cbiAgICB0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG4gIH1cbiAgKi9cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU2tlbGV0b25IZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxuICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QgKTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG4gICAgaWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDAsIDEgKSApO1xuICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMSwgMCApICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGdlb21ldHJ5LmR5bmFtaWMgPSB0cnVlO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycywgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgdGhpcy5yb290ID0gb2JqZWN0O1xuXG4gIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNrZWxldG9uSGVscGVyO1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gIHZhciBib25lTGlzdCA9IFtdO1xuXG4gIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgIGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xuXG4gIH1cblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgYm9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdC5jaGlsZHJlblsgaSBdICkgKTtcblxuICB9XG5cbiAgcmV0dXJuIGJvbmVMaXN0O1xuXG59O1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgdmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcblxuICB2YXIgYm9uZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgdmFyIGogPSAwO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cbiAgICBpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXNbIGogXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblxuICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBqICsgMSBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG4gICAgICBqICs9IDI7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMSwgMSwgOCwgMSwgdHJ1ZSApO1xuXG4gIGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbiggMCwgLSAwLjUsIDAgKSApO1xuICBnZW9tZXRyeS5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25YKCAtIE1hdGguUEkgLyAyICkgKTtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcblxuICB0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gIHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0SGVscGVyO1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG59O1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDA7XG4gICAgdmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xuXG4gICAgdGhpcy5jb25lLnNjYWxlLnNldCggY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGggKTtcblxuICAgIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcbiAgICB2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuICAgIHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xuXG4gICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleE5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcblxuICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gIHZhciBmYWNlcyA9IG9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXG4gICAgfVxuXG4gIH1cblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy5ub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJywgJ2QnIF07XG5cbiAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgdGhpcy5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIHZhciB2ZXJ0cyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgdmFyIGZhY2VzID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkuZmFjZXM7XG5cbiAgICB2YXIgd29ybGRNYXRyaXggPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuICAgIHZhciBpZHggPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhJZCA9IGZhY2VbIGtleXNbIGogXSBdO1xuICAgICAgICB2YXIgdmVydGV4ID0gdmVydHNbIHZlcnRleElkIF07XG5cbiAgICAgICAgdmFyIG5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdO1xuXG4gICAgICAgIHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIHdvcmxkTWF0cml4ICk7XG5cbiAgICAgICAgdjEuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCB0aGlzLm5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKTtcblxuICAgICAgICB2MS5hZGQoIHZlcnRpY2VzWyBpZHggXSApO1xuICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgIHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2MSApO1xuICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbn0oKSk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleFRhbmdlbnRzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cbiAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgdGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4MDAwMGZmO1xuXG4gIHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgdmFyIGZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXG4gICAgfVxuXG4gIH1cblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXI7XG5cblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJywgJ2QnIF07XG5cbiAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIHZhciB2ZXJ0cyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgdmFyIGZhY2VzID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkuZmFjZXM7XG5cbiAgICB2YXIgd29ybGRNYXRyaXggPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuICAgIHZhciBpZHggPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB2YXIgdmVydGV4SWQgPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRzWyB2ZXJ0ZXhJZCBdO1xuXG4gICAgICAgIHZhciB0YW5nZW50ID0gZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaiBdO1xuXG4gICAgICAgIHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIHdvcmxkTWF0cml4ICk7XG5cbiAgICAgICAgdjEuY29weSggdGFuZ2VudCApLnRyYW5zZm9ybURpcmVjdGlvbiggd29ybGRNYXRyaXggKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICk7XG5cbiAgICAgICAgdjEuYWRkKCB2ZXJ0aWNlc1sgaWR4IF0gKTtcbiAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICB2ZXJ0aWNlc1sgaWR4IF0uY29weSggdjEgKTtcbiAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG59KCkpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9XaXJlZnJhbWVIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldpcmVmcmFtZUhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XG5cbiAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cbiAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldpcmVmcmFtZUhlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvSW1tZWRpYXRlUmVuZGVyT2JqZWN0LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJDYWxsYmFjayApIHt9O1xuXG59O1xuXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gIFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgdGhpcy5hbmltYXRpb25zTWFwID0ge307XG4gIHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcblxuICAvLyBwcmVwYXJlIGRlZmF1bHQgYW5pbWF0aW9uXG4gIC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcblxuICB2YXIgbnVtRnJhbWVzID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xuXG4gIHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcblxuICB2YXIgc3RhcnRGcmFtZSA9IDA7XG4gIHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XG5cbiAgdmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XG5cbiAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcbiAgdGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1vcnBoQmxlbmRNZXNoO1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHtcblxuICAgIHN0YXJ0RnJhbWU6IHN0YXJ0LFxuICAgIGVuZEZyYW1lOiBlbmQsXG5cbiAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcblxuICAgIGZwczogZnBzLFxuICAgIGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXG5cbiAgICBsYXN0RnJhbWU6IDAsXG4gICAgY3VycmVudEZyYW1lOiAwLFxuXG4gICAgYWN0aXZlOiBmYWxzZSxcblxuICAgIHRpbWU6IDAsXG4gICAgZGlyZWN0aW9uOiAxLFxuICAgIHdlaWdodDogMSxcblxuICAgIGRpcmVjdGlvbkJhY2t3YXJkczogZmFsc2UsXG4gICAgbWlycm9yZWRMb29wOiBmYWxzZVxuXG4gIH07XG5cbiAgdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XG4gIHRoaXMuYW5pbWF0aW9uc0xpc3QucHVzaCggYW5pbWF0aW9uICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICggZnBzICkge1xuXG4gIHZhciBwYXR0ZXJuID0gLyhbYS16XSspXz8oXFxkKykvO1xuXG4gIHZhciBmaXJzdEFuaW1hdGlvbiwgZnJhbWVSYW5nZXMgPSB7fTtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICB2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcbiAgICB2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG4gICAgaWYgKCBjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgIHZhciBuYW1lID0gY2h1bmtzWyAxIF07XG5cbiAgICAgIGlmICggISBmcmFtZVJhbmdlc1sgbmFtZSBdICkgZnJhbWVSYW5nZXNbIG5hbWUgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcblxuICAgICAgdmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcblxuICAgICAgaWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XG4gICAgICBpZiAoIGkgPiByYW5nZS5lbmQgKSByYW5nZS5lbmQgPSBpO1xuXG4gICAgICBpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xuXG4gICAgdmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcbiAgICB0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgZnBzICk7XG5cbiAgfVxuXG4gIHRoaXMuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XG4gICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtIDE7XG4gICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID0gZnVuY3Rpb24gKCBuYW1lLCBmcHMgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLmZwcyA9IGZwcztcbiAgICBhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIGFuaW1hdGlvbi5mcHMgPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25XZWlnaHQgPSBmdW5jdGlvbiAoIG5hbWUsIHdlaWdodCApIHtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICBhbmltYXRpb24ud2VpZ2h0ID0gd2VpZ2h0O1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWUgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLnRpbWUgPSB0aW1lO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgdmFyIHRpbWUgPSAwO1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIHRpbWUgPSBhbmltYXRpb24udGltZTtcblxuICB9XG5cbiAgcmV0dXJuIHRpbWU7XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICB2YXIgZHVyYXRpb24gPSAtIDE7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgZHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbjtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLnRpbWUgPSAwO1xuICAgIGFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuTW9ycGhCbGVuZE1lc2g6IGFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIiApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTGlzdFsgaSBdO1xuXG4gICAgaWYgKCAhIGFuaW1hdGlvbi5hY3RpdmUgKSBjb250aW51ZTtcblxuICAgIHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xuXG4gICAgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmRpcmVjdGlvbiAqIGRlbHRhO1xuXG4gICAgaWYgKCBhbmltYXRpb24ubWlycm9yZWRMb29wICkge1xuXG4gICAgICBpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uICo9IC0gMTtcblxuICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uICkge1xuXG4gICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xuXG4gICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSAwO1xuICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLnRpbWUgJSBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgICAgIGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgfVxuXG4gICAgdmFyIGtleWZyYW1lID0gYW5pbWF0aW9uLnN0YXJ0RnJhbWUgKyBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCBhbmltYXRpb24udGltZSAvIGZyYW1lVGltZSApLCAwLCBhbmltYXRpb24ubGVuZ3RoIC0gMSApO1xuICAgIHZhciB3ZWlnaHQgPSBhbmltYXRpb24ud2VpZ2h0O1xuXG4gICAgaWYgKCBrZXlmcmFtZSAhPT0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSApIHtcblxuICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gMSAqIHdlaWdodDtcblxuICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xuXG4gICAgICBhbmltYXRpb24ubGFzdEZyYW1lID0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZTtcbiAgICAgIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcblxuICAgIH1cblxuICAgIHZhciBtaXggPSAoIGFuaW1hdGlvbi50aW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XG5cbiAgICBpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IG1peCAqIHdlaWdodDtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XG5cbiAgfVxuXG59O1xuXG4iLCIvKipcbiAqIEBhdXRob3IgZG1hcmNvcyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9kbWFyY29zXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKlxuICogV2ViVlIgU3BlYzogaHR0cDovL21venZyLmdpdGh1Yi5pby93ZWJ2ci1zcGVjL3dlYnZyLmh0bWxcbiAqXG4gKiBGaXJlZm94OiBodHRwOi8vbW96dnIuY29tL2Rvd25sb2Fkcy9cbiAqIENocm9taXVtOiBodHRwczovL2RyaXZlLmdvb2dsZS5jb20vZm9sZGVydmlldz9pZD0wQnp1ZEx0MjJCcUdSYlc5V1RITXRPV016TmpRJnVzcD1zaGFyaW5nI2xpc3RcbiAqXG4gKi9cblxuVEhSRUUuVlJFZmZlY3QgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBvbkVycm9yICkge1xuXG4gIHZhciB2ckhNRDtcbiAgdmFyIGV5ZVRyYW5zbGF0aW9uTCwgZXllRk9WTDtcbiAgdmFyIGV5ZVRyYW5zbGF0aW9uUiwgZXllRk9WUjtcblxuICBmdW5jdGlvbiBnb3RWUkRldmljZXMoIGRldmljZXMgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZXZpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgaWYgKCBkZXZpY2VzWyBpIF0gaW5zdGFuY2VvZiBITURWUkRldmljZSApIHtcblxuICAgICAgICB2ckhNRCA9IGRldmljZXNbIGkgXTtcblxuICAgICAgICBpZiAoIHZySE1ELmdldEV5ZVBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIHZhciBleWVQYXJhbXNMID0gdnJITUQuZ2V0RXllUGFyYW1ldGVycyggJ2xlZnQnICk7XG4gICAgICAgICAgdmFyIGV5ZVBhcmFtc1IgPSB2ckhNRC5nZXRFeWVQYXJhbWV0ZXJzKCAncmlnaHQnICk7XG5cbiAgICAgICAgICBleWVUcmFuc2xhdGlvbkwgPSBleWVQYXJhbXNMLmV5ZVRyYW5zbGF0aW9uO1xuICAgICAgICAgIGV5ZVRyYW5zbGF0aW9uUiA9IGV5ZVBhcmFtc1IuZXllVHJhbnNsYXRpb247XG4gICAgICAgICAgZXllRk9WTCA9IGV5ZVBhcmFtc0wucmVjb21tZW5kZWRGaWVsZE9mVmlldztcbiAgICAgICAgICBleWVGT1ZSID0gZXllUGFyYW1zUi5yZWNvbW1lbmRlZEZpZWxkT2ZWaWV3O1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGFuIG9sZGVyIGNvZGUgcGF0aCBhbmQgbm90IHNwZWMgY29tcGxpYW50LlxuICAgICAgICAgIC8vIEl0IHNob3VsZCBiZSByZW1vdmVkIGF0IHNvbWUgcG9pbnQgaW4gdGhlIG5lYXIgZnV0dXJlLlxuICAgICAgICAgIGV5ZVRyYW5zbGF0aW9uTCA9IHZySE1ELmdldEV5ZVRyYW5zbGF0aW9uKCAnbGVmdCcgKTtcbiAgICAgICAgICBleWVUcmFuc2xhdGlvblIgPSB2ckhNRC5nZXRFeWVUcmFuc2xhdGlvbiggJ3JpZ2h0JyApO1xuICAgICAgICAgIGV5ZUZPVkwgPSB2ckhNRC5nZXRSZWNvbW1lbmRlZEV5ZUZpZWxkT2ZWaWV3KCAnbGVmdCcgKTtcbiAgICAgICAgICBleWVGT1ZSID0gdnJITUQuZ2V0UmVjb21tZW5kZWRFeWVGaWVsZE9mVmlldyggJ3JpZ2h0JyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBicmVhazsgLy8gV2Uga2VlcCB0aGUgZmlyc3Qgd2UgZW5jb3VudGVyXG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggdnJITUQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaWYgKCBvbkVycm9yICkgb25FcnJvciggJ0hNRCBub3QgYXZhaWxhYmxlJyApO1xuXG4gICAgfVxuXG4gIH1cblxuICBpZiAoIG5hdmlnYXRvci5nZXRWUkRldmljZXMgKSB7XG5cbiAgICBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzKCkudGhlbiggZ290VlJEZXZpY2VzICk7XG5cbiAgfVxuXG4gIC8vXG5cbiAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICByZW5kZXJlci5zZXRTaXplKCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgfTtcblxuICAvLyBmdWxsc2NyZWVuXG5cbiAgdmFyIGlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuXG4gIHZhciBjYW52YXMgPSByZW5kZXJlci5kb21FbGVtZW50O1xuICB2YXIgZnVsbHNjcmVlbmNoYW5nZSA9IGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/ICdtb3pmdWxsc2NyZWVuY2hhbmdlJyA6ICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJztcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBmdWxsc2NyZWVuY2hhbmdlLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgaXNGdWxsc2NyZWVuID0gZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQ7XG5cbiAgfSwgZmFsc2UgKTtcblxuICB0aGlzLnNldEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XG5cbiAgICBpZiAoIHZySE1EID09PSB1bmRlZmluZWQgKSByZXR1cm47XG4gICAgaWYgKCBpc0Z1bGxzY3JlZW4gPT09IGJvb2xlYW4gKSByZXR1cm47XG5cbiAgICBpZiAoIGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbiApIHtcblxuICAgICAgY2FudmFzLm1velJlcXVlc3RGdWxsU2NyZWVuKCB7IHZyRGlzcGxheTogdnJITUQgfSApO1xuXG4gICAgfSBlbHNlIGlmICggY2FudmFzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuICkge1xuXG4gICAgICBjYW52YXMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oIHsgdnJEaXNwbGF5OiB2ckhNRCB9ICk7XG5cbiAgICB9XG5cbiAgfTtcblxuICAvLyByZW5kZXJcblxuICB2YXIgY2FtZXJhTCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICB2YXIgY2FtZXJhUiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgaWYgKCB2ckhNRCApIHtcblxuICAgICAgdmFyIHNjZW5lTCwgc2NlbmVSO1xuXG4gICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHNjZW5lICkgKSB7XG5cbiAgICAgICAgc2NlbmVMID0gc2NlbmVbIDAgXTtcbiAgICAgICAgc2NlbmVSID0gc2NlbmVbIDEgXTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzY2VuZUwgPSBzY2VuZTtcbiAgICAgICAgc2NlbmVSID0gc2NlbmU7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHNpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XG4gICAgICBzaXplLndpZHRoIC89IDI7XG5cbiAgICAgIHJlbmRlcmVyLmVuYWJsZVNjaXNzb3JUZXN0KCB0cnVlICk7XG4gICAgICByZW5kZXJlci5jbGVhcigpO1xuXG4gICAgICBpZiAoIGNhbWVyYS5wYXJlbnQgPT09IHVuZGVmaW5lZCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAvLyBPY3VsdXMgU0RLIG1hdHJpeCBoYXJkIGNvZGVkIGZyb20gZ2Vja29cbiAgICAgIC8vIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgLy8gbWF0cml4LnNldChcbiAgICAgIC8vICAgMC45Mjk3ODg5NDcsIDAsIDAsIDAsXG4gICAgICAvLyAgIDAsIDAuNzUwOTc0NDE3LCAwLCAwLFxuICAgICAgLy8gICAwLjAxNTY3MTc1OTgsIDAsIC0xLjAwMDAwMDk1LCAtMSxcbiAgICAgIC8vICAgMCwgMCwgLTAuMDEwMDAwMDEsIDBcbiAgICAgIC8vICk7XG4gICAgICAvLyBtYXRyaXgudHJhbnNwb3NlKCk7XG5cbiAgICAgIGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WTCwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcbiAgICAgIGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WUiwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcblxuICAgICAgY2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggY2FtZXJhTC5wb3NpdGlvbiwgY2FtZXJhTC5xdWF0ZXJuaW9uLCBjYW1lcmFMLnNjYWxlICk7XG4gICAgICBjYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKCBjYW1lcmFSLnBvc2l0aW9uLCBjYW1lcmFSLnF1YXRlcm5pb24sIGNhbWVyYVIuc2NhbGUgKTtcblxuICAgICAgY2FtZXJhTC50cmFuc2xhdGVYKCBleWVUcmFuc2xhdGlvbkwueCAqIHRoaXMuc2NhbGUgKTtcbiAgICAgIGNhbWVyYVIudHJhbnNsYXRlWCggZXllVHJhbnNsYXRpb25SLnggKiB0aGlzLnNjYWxlICk7XG5cbiAgICAgIC8vIHJlbmRlciBsZWZ0IGV5ZVxuICAgICAgcmVuZGVyZXIuc2V0Vmlld3BvcnQoIDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG4gICAgICByZW5kZXJlci5zZXRTY2lzc29yKCAwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZUwsIGNhbWVyYUwgKTtcblxuICAgICAgLy8gcmVuZGVyIHJpZ2h0IGV5ZVxuICAgICAgcmVuZGVyZXIuc2V0Vmlld3BvcnQoIHNpemUud2lkdGgsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG4gICAgICByZW5kZXJlci5zZXRTY2lzc29yKCBzaXplLndpZHRoLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZVIsIGNhbWVyYVIgKTtcblxuICAgICAgcmVuZGVyZXIuZW5hYmxlU2Npc3NvclRlc3QoIGZhbHNlICk7XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIC8vIFJlZ3VsYXIgcmVuZGVyIG1vZGUgaWYgbm90IEhNRFxuXG4gICAgaWYgKCBBcnJheS5pc0FycmF5KCBzY2VuZSApICkgc2NlbmUgPSBzY2VuZVsgMCBdO1xuXG4gICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cbiAgfTtcblxuICAvL1xuXG4gIGZ1bmN0aW9uIGZvdlRvTkRDU2NhbGVPZmZzZXQoIGZvdiApIHtcblxuICAgIHZhciBweHNjYWxlID0gMi4wIC8gKGZvdi5sZWZ0VGFuICsgZm92LnJpZ2h0VGFuKTtcbiAgICB2YXIgcHhvZmZzZXQgPSAoZm92LmxlZnRUYW4gLSBmb3YucmlnaHRUYW4pICogcHhzY2FsZSAqIDAuNTtcbiAgICB2YXIgcHlzY2FsZSA9IDIuMCAvIChmb3YudXBUYW4gKyBmb3YuZG93blRhbik7XG4gICAgdmFyIHB5b2Zmc2V0ID0gKGZvdi51cFRhbiAtIGZvdi5kb3duVGFuKSAqIHB5c2NhbGUgKiAwLjU7XG4gICAgcmV0dXJuIHsgc2NhbGU6IFsgcHhzY2FsZSwgcHlzY2FsZSBdLCBvZmZzZXQ6IFsgcHhvZmZzZXQsIHB5b2Zmc2V0IF0gfTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZm92UG9ydFRvUHJvamVjdGlvbiggZm92LCByaWdodEhhbmRlZCwgek5lYXIsIHpGYXIgKSB7XG5cbiAgICByaWdodEhhbmRlZCA9IHJpZ2h0SGFuZGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogcmlnaHRIYW5kZWQ7XG4gICAgek5lYXIgPSB6TmVhciA9PT0gdW5kZWZpbmVkID8gMC4wMSA6IHpOZWFyO1xuICAgIHpGYXIgPSB6RmFyID09PSB1bmRlZmluZWQgPyAxMDAwMC4wIDogekZhcjtcblxuICAgIHZhciBoYW5kZWRuZXNzU2NhbGUgPSByaWdodEhhbmRlZCA/IC0xLjAgOiAxLjA7XG5cbiAgICAvLyBzdGFydCB3aXRoIGFuIGlkZW50aXR5IG1hdHJpeFxuICAgIHZhciBtb2JqID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB2YXIgbSA9IG1vYmouZWxlbWVudHM7XG5cbiAgICAvLyBhbmQgd2l0aCBzY2FsZS9vZmZzZXQgaW5mbyBmb3Igbm9ybWFsaXplZCBkZXZpY2UgY29vcmRzXG4gICAgdmFyIHNjYWxlQW5kT2Zmc2V0ID0gZm92VG9ORENTY2FsZU9mZnNldChmb3YpO1xuXG4gICAgLy8gWCByZXN1bHQsIG1hcCBjbGlwIGVkZ2VzIHRvIFstdywrd11cbiAgICBtWzAgKiA0ICsgMF0gPSBzY2FsZUFuZE9mZnNldC5zY2FsZVswXTtcbiAgICBtWzAgKiA0ICsgMV0gPSAwLjA7XG4gICAgbVswICogNCArIDJdID0gc2NhbGVBbmRPZmZzZXQub2Zmc2V0WzBdICogaGFuZGVkbmVzc1NjYWxlO1xuICAgIG1bMCAqIDQgKyAzXSA9IDAuMDtcblxuICAgIC8vIFkgcmVzdWx0LCBtYXAgY2xpcCBlZGdlcyB0byBbLXcsK3ddXG4gICAgLy8gWSBvZmZzZXQgaXMgbmVnYXRlZCBiZWNhdXNlIHRoaXMgcHJvaiBtYXRyaXggdHJhbnNmb3JtcyBmcm9tIHdvcmxkIGNvb3JkcyB3aXRoIFk9dXAsXG4gICAgLy8gYnV0IHRoZSBOREMgc2NhbGluZyBoYXMgWT1kb3duICh0aGFua3MgRDNEPylcbiAgICBtWzEgKiA0ICsgMF0gPSAwLjA7XG4gICAgbVsxICogNCArIDFdID0gc2NhbGVBbmRPZmZzZXQuc2NhbGVbMV07XG4gICAgbVsxICogNCArIDJdID0gLXNjYWxlQW5kT2Zmc2V0Lm9mZnNldFsxXSAqIGhhbmRlZG5lc3NTY2FsZTtcbiAgICBtWzEgKiA0ICsgM10gPSAwLjA7XG5cbiAgICAvLyBaIHJlc3VsdCAodXAgdG8gdGhlIGFwcClcbiAgICBtWzIgKiA0ICsgMF0gPSAwLjA7XG4gICAgbVsyICogNCArIDFdID0gMC4wO1xuICAgIG1bMiAqIDQgKyAyXSA9IHpGYXIgLyAoek5lYXIgLSB6RmFyKSAqIC1oYW5kZWRuZXNzU2NhbGU7XG4gICAgbVsyICogNCArIDNdID0gKHpGYXIgKiB6TmVhcikgLyAoek5lYXIgLSB6RmFyKTtcblxuICAgIC8vIFcgcmVzdWx0ICg9IFogaW4pXG4gICAgbVszICogNCArIDBdID0gMC4wO1xuICAgIG1bMyAqIDQgKyAxXSA9IDAuMDtcbiAgICBtWzMgKiA0ICsgMl0gPSBoYW5kZWRuZXNzU2NhbGU7XG4gICAgbVszICogNCArIDNdID0gMC4wO1xuXG4gICAgbW9iai50cmFuc3Bvc2UoKTtcblxuICAgIHJldHVybiBtb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZm92VG9Qcm9qZWN0aW9uKCBmb3YsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApIHtcblxuICAgIHZhciBERUcyUkFEID0gTWF0aC5QSSAvIDE4MC4wO1xuXG4gICAgdmFyIGZvdlBvcnQgPSB7XG4gICAgICB1cFRhbjogTWF0aC50YW4oIGZvdi51cERlZ3JlZXMgKiBERUcyUkFEICksXG4gICAgICBkb3duVGFuOiBNYXRoLnRhbiggZm92LmRvd25EZWdyZWVzICogREVHMlJBRCApLFxuICAgICAgbGVmdFRhbjogTWF0aC50YW4oIGZvdi5sZWZ0RGVncmVlcyAqIERFRzJSQUQgKSxcbiAgICAgIHJpZ2h0VGFuOiBNYXRoLnRhbiggZm92LnJpZ2h0RGVncmVlcyAqIERFRzJSQUQgKVxuICAgIH07XG5cbiAgICByZXR1cm4gZm92UG9ydFRvUHJvamVjdGlvbiggZm92UG9ydCwgcmlnaHRIYW5kZWQsIHpOZWFyLCB6RmFyICk7XG5cbiAgfVxuXG59O1xuIiwiLyogZ2xvYmFscyBkZWZpbmUgKi9cbihmdW5jdGlvbihkZWZpbmUpeyd1c2Ugc3RyaWN0JztkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSxleHBvcnRzLG1vZHVsZSl7XG5cblx0dmFyIHByb3RvID0gIE9iamVjdC5jcmVhdGUoXG4gICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgXHR2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgXHRcdHZhciBzY2VuZSA9IHRoaXMuc2NlbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2ci1zY2VuZScpO1xuICAgIFx0XHR2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICBcdH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgIFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIFx0XHRwYXJlbnQuYWRkKCB0aGlzICk7XG4gICAgXHRcdHRoaXMudXBkYXRlKCk7XG4gICAgXHR9XG4gIFx0fSxcblxuICAgIGRldGFjaGVkQ2FsbGJhY2s6IHtcbiAgICBcdHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIFx0Y29uc29sZS5sb2coJ2xlYXZpbmcgdGhlIERPTSA6LSggKScpO1xuICAgIFx0fVxuICBcdH0sXG5cbiAgXHRpczNEcHJvcGVydHk6IHtcbiAgXHRcdHZhbHVlOiBmdW5jdGlvbihuYW1lKSB7XG4gIFx0XHRcdHJldHVybiBuYW1lID09PSAneCcgfHxcbiAgXHRcdFx0XHRcdFx0IG5hbWUgPT09ICd5JyB8fFxuICBcdFx0XHRcdFx0XHQgbmFtZSA9PT0gJ3onIHx8XG4gIFx0XHRcdFx0XHRcdCBuYW1lID09PSAncm90eCcgfHxcbiAgXHRcdFx0XHRcdFx0IG5hbWUgPT09ICdyb3R5JyB8fFxuICBcdFx0XHRcdFx0XHQgbmFtZSA9PT0gJ3JvdHonO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhZGQ6IHtcbiAgXHRcdHZhbHVlOiBmdW5jdGlvbihlbCkge1xuICBcdFx0XHR0aGlzLm9iamVjdC5hZGQoZWwub2JqZWN0KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiB7XG4gIFx0XHR2YWx1ZTogZnVuY3Rpb24oKSB7XG4gIFx0XHRcdC8vIFBvc2l0aW9uXG4gIFx0XHRcdHZhciB4ID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgneCcpKSB8fCAwO1xuXHRcdFx0XHR2YXIgeSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3knKSkgfHwgMDtcblx0XHRcdFx0dmFyIHogPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd6JykpIHx8IDA7XG5cblx0XHRcdFx0Ly8gT3JpZW50YXRpb25cblx0XHRcdFx0dmFyIG9yaWVudGF0aW9uWCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdFgnKSkgfHwgMDtcblx0XHRcdFx0dmFyIG9yaWVudGF0aW9uWSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdFknKSkgfHwgMDtcblx0XHRcdFx0dmFyIG9yaWVudGF0aW9uWiA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdFonKSkgfHwgMDtcblxuXHRcdFx0XHR2YXIgcm90WCA9IFRIUkVFLk1hdGguZGVnVG9SYWQob3JpZW50YXRpb25YKTtcblx0XHRcdFx0dmFyIHJvdFkgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKG9yaWVudGF0aW9uWSk7XG5cdFx0XHRcdHZhciByb3RaID0gVEhSRUUuTWF0aC5kZWdUb1JhZChvcmllbnRhdGlvblopO1xuXG4gIFx0XHRcdHRoaXMub2JqZWN0LnBvc2l0aW9uLnNldCh4LCAteSwgLXopO1xuICBcdFx0XHR0aGlzLm9iamVjdC5yb3RhdGlvbi5vcmRlciA9ICdZWFonO1xuICBcdFx0XHR0aGlzLm9iamVjdC5yb3RhdGlvbi5zZXQoLXJvdFgsIHJvdFksIHJvdFopO1xuXG4gIFx0XHRcdHRoaXMuc2NlbmUucmVuZGVyKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgIFx0dmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHByZXZpb3VzVmFsdWUsIHZhbHVlKSB7XG4gICAgXHRcdGlmICh0aGlzLmlzM0Rwcm9wZXJ0eShuYW1lKSkge1xuICAgIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gICAgXHRcdH1cbiAgICB9fVxuICB9KTtcblxuXHQvLyBSZWdpc3RlcmluZyBlbGVtZW50IGFuZCBleHBvcnRpbmcgcHJvdG90eXBlXG5cdG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCd2ci1vYmplY3QnLCB7IHByb3RvdHlwZTogcHJvdG8gfSk7XG5cbn0pO30pKHR5cGVvZiBkZWZpbmU9PSdmdW5jdGlvbicmJmRlZmluZS5hbWQ/ZGVmaW5lXG46KGZ1bmN0aW9uKG4sdyl7J3VzZSBzdHJpY3QnO3JldHVybiB0eXBlb2YgbW9kdWxlPT0nb2JqZWN0Jz9mdW5jdGlvbihjKXtcbmMocmVxdWlyZSxleHBvcnRzLG1vZHVsZSk7fTpmdW5jdGlvbihjKXt2YXIgbT17ZXhwb3J0czp7fX07YyhmdW5jdGlvbihuKXtcbnJldHVybiB3W25dO30sbS5leHBvcnRzLG0pO3dbbl09bS5leHBvcnRzO307fSkoJ1ZST2JqZWN0Jyx0aGlzKSk7IiwiLyogZ2xvYmFscyBkZWZpbmUgKi9cbihmdW5jdGlvbihkZWZpbmUpeyd1c2Ugc3RyaWN0JztkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSxleHBvcnRzLG1vZHVsZSl7XG5cblx0ZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuXHQgICd2ci1jYW1lcmEnLFxuXHQgIHtcblx0ICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcblx0ICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7fVxuXHQgICAgKVxuXHQgIH1cblx0KTtcblxufSk7fSkodHlwZW9mIGRlZmluZT09J2Z1bmN0aW9uJyYmZGVmaW5lLmFtZD9kZWZpbmVcbjooZnVuY3Rpb24obix3KXsndXNlIHN0cmljdCc7cmV0dXJuIHR5cGVvZiBtb2R1bGU9PSdvYmplY3QnP2Z1bmN0aW9uKGMpe1xuYyhyZXF1aXJlLGV4cG9ydHMsbW9kdWxlKTt9OmZ1bmN0aW9uKGMpe3ZhciBtPXtleHBvcnRzOnt9fTtjKGZ1bmN0aW9uKG4pe1xucmV0dXJuIHdbbl07fSxtLmV4cG9ydHMsbSk7d1tuXT1tLmV4cG9ydHM7fTt9KSgnVlJDYW1lcmEnLHRoaXMpKTsiLCIvKiBnbG9iYWxzIGRlZmluZSAqL1xuKGZ1bmN0aW9uKGRlZmluZSl7J3VzZSBzdHJpY3QnO2RlZmluZShmdW5jdGlvbihyZXF1aXJlLGV4cG9ydHMsbW9kdWxlKXtcblxuICB2YXIgcHJvdG8gPSBPYmplY3QuY3JlYXRlKFxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnNldHVwU2NlbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2xpdmUgb24gRE9NIDstKSAnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2xlYXZpbmcgdGhlIERPTSA6LSggKScpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHByZXZpb3VzVmFsdWUsIHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICdnb3QgYSBuZXcgYXR0cmlidXRlICcsIG5hbWUsXG4gICAgICAgICAgICAgICcgd2l0aCB2YWx1ZSAnLCB2YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnc29tZWJvZHkgcmVtb3ZlZCAnLCBuYW1lLFxuICAgICAgICAgICAgICAnIGl0cyB2YWx1ZSB3YXMgJywgcHJldmlvdXNWYWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICcgY2hhbmdlZCBmcm9tICcsIHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICAgICcgdG8gJywgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXR1cFNjZW5lOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBUaGUgY2FudmFzIHdoZXJlIHRoZSBXZWJHTCBjb250ZXQgd2lsbCBiZSBwYWludGVkXG4gICAgICAgICAgdGhpcy5zZXR1cENhbnZhcygpO1xuICAgICAgICAgIC8vIHRocmVlLmpzIGNhbWVyYSBzZXR1cFxuICAgICAgICAgIHRoaXMuc2V0dXBDYW1lcmEoKTtcbiAgICAgICAgICAvLyBUaGUgdGhyZWUuanMgcmVuZGVyZXIgc2V0dXBcbiAgICAgICAgICB0aGlzLnNldHVwUmVuZGVyZXIoKTtcbiAgICAgICAgICB0aGlzLnNldHVwQ2FtZXJhRWwoKTtcbiAgICAgICAgICB0aGlzLnNldHVwRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXR1cENhbnZhczoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgY2FudmFzLmNsYXNzTGlzdC5hZGQoJ3ZyLWNhbnZhcycpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVDYW52YXMuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXR1cENhbWVyYToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCA3MCwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDEsIDEwMDAwICk7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA0MDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNldHVwQ2FtZXJhRWw6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjYW1lcmFFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZyLWNhbWVyYScpO1xuICAgICAgICAgIGNhbWVyYUVsLmNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgICAgICAgIHZhciBlbHMgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjYW1lcmFFbC5hcHBlbmRDaGlsZChlbHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNhbWVyYUVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2V0dXBFdmVudEhhbmRsZXJzOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgb25mdWxsc2NyZWVuY2hhbmdlID0gdGhpcy5vbmZ1bGxzY3JlZW5jaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICB2YXIgcHJvY2Vzc0RldmljZXMgPSB0aGlzLnByb2Nlc3NEZXZpY2VzLmJpbmQodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc2l6ZUNhbnZhcyA9IHRoaXMucmVzaXplQ2FudmFzLmJpbmQodGhpcyk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiwgb25mdWxsc2NyZWVuY2hhbmdlKTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLCAgICBvbmZ1bGxzY3JlZW5jaGFuZ2UpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmdWxsc2NyZWVuY2hhbmdlXCIsICAgICAgIG9uZnVsbHNjcmVlbmNoYW5nZSk7XG4gICAgICAgICAgdGhpcy5nZXRWUkRldmljZXMoKS50aGVuKHByb2Nlc3NEZXZpY2VzKVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25mdWxsc2NyZWVuY2hhbmdlOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoICFkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCAmJiAhZG9jdW1lbnQud2Via2l0RnVsbFNjcmVlbkVsZW1lbnQgKSB7XG4gICAgICAgICAgICB0aGlzLnZyRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMubW9ub1JlbmRlcmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZyRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy52clJlbmRlcmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBnZXRWUkRldmljZXM6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLmdldFZSRGV2aWNlcykge1xuICAgICAgICAgICAgICBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlcyk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoJ05vIFZSIGRldmljZXMgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVudGVyVlI6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy52cikgeyByZXR1cm47IH1cbiAgICAgICAgICB0aGlzLm1velJlcXVlc3RGdWxsU2NyZWVuKHtcbiAgICAgICAgICAgIHZyRGlzcGxheTogdGhpcy52ci5oZWFkc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2V0U2Vuc29yOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy52ci5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy52ci5wb3NpdGlvbi5yZXNldFNlbnNvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcHJvY2Vzc0RldmljZXM6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGRldmljZXMpIHtcbiAgICAgICAgICBkZXZpY2VzID0gdGhpcy5maWx0ZXJJbnZhbGlkRGV2aWNlcyhkZXZpY2VzKTtcbiAgICAgICAgICB2YXIgaGVhZHNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRldmljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2UgPSBkZXZpY2VzW2ldO1xuICAgICAgICAgICAgaWYgKGRldmljZSBpbnN0YW5jZW9mIEhNRFZSRGV2aWNlKSB7XG4gICAgICAgICAgICAgIGhlYWRzZXQgPSBkZXZpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2aWNlIGluc3RhbmNlb2YgUG9zaXRpb25TZW5zb3JWUkRldmljZSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiA9IGRldmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiBoZWFkc2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMudnIgPSB7XG4gICAgICAgICAgICAgICAgaGVhZHNldDogaGVhZHNldCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGZpbHRlckludmFsaWREZXZpY2VzOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihkZXZpY2VzKSB7XG4gICAgICAgICAgdmFyIG9jdWx1c0RldmljZXMgPSBkZXZpY2VzLmZpbHRlcihmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlLmRldmljZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvY3VsdXMnKSAhPT0gLTE7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAob2N1bHVzRGV2aWNlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRldmljZS5kZXZpY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2FyZGJvYXJkJykgPT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2V0dXBSZW5kZXJlcjoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIgPSB0aGlzLm1vbm9SZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCB7IGNhbnZhczogY2FudmFzLCBhbnRpYWxpYXM6IHRydWUsIGFscGhhOiB0cnVlIH0gKTtcbiAgICAgICAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyApO1xuICAgICAgICAgIHJlbmRlcmVyLnNvcnRPYmplY3RzID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy52clJlbmRlcmVyID0gbmV3IFRIUkVFLlZSRWZmZWN0KHJlbmRlcmVyKTtcbiAgICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcmVzaXplQ2FudmFzOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgICAgICAgIC8vIE1ha2UgaXQgdmlzdWFsbHkgZmlsbCB0aGUgcG9zaXRpb25lZCBwYXJlbnRcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPScxMDAlJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0PScxMDAlJztcbiAgICAgICAgICAvLyBTZXQgdGhlIGludGVybmFsIHNpemUgdG8gbWF0Y2hcbiAgICAgICAgICBjYW52YXMud2lkdGggID0gY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIC8vIFVwZGF0ZXMgY2FtZXJhXG4gICAgICAgICAgY2FtZXJhLmFzcGVjdCA9IGNhbnZhcy5vZmZzZXRXaWR0aCAvIGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAvLyBOb3RpZnkgdGhlIHJlbmRlcmVyIG9mIHRoZSBzaXplIGNoYW5nZVxuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSggY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG4gICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYWRkOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKGVsLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlbmRlcjoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgZWxlbWVudCBhbmQgZXhwb3J0aW5nIHByb3RvdHlwZVxuICBtb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgndnItc2NlbmUnLCB7IHByb3RvdHlwZTogcHJvdG8gfSk7XG5cbn0pO30pKHR5cGVvZiBkZWZpbmU9PSdmdW5jdGlvbicmJmRlZmluZS5hbWQ/ZGVmaW5lXG46KGZ1bmN0aW9uKG4sdyl7J3VzZSBzdHJpY3QnO3JldHVybiB0eXBlb2YgbW9kdWxlPT0nb2JqZWN0Jz9mdW5jdGlvbihjKXtcbmMocmVxdWlyZSxleHBvcnRzLG1vZHVsZSk7fTpmdW5jdGlvbihjKXt2YXIgbT17ZXhwb3J0czp7fX07YyhmdW5jdGlvbihuKXtcbnJldHVybiB3W25dO30sbS5leHBvcnRzLG0pO3dbbl09bS5leHBvcnRzO307fSkoJ1ZSU2NlbmUnLHRoaXMpKTsiXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=