(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.vrComponents = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  'vr-audio': require('./vr-audio'),
  'vr-cube': require('./vr-cube'),
  'vr-curvedPlane1': require('./vr-curvedPlane1'),
  'vr-curvedPlane2': require('./vr-curvedPlane2'),
  'vr-cylinder': require('./vr-cylinder'),
  'vr-grid': require('./vr-grid'),
  'vr-hemispherelight': require('./vr-hemispherelight'),
  'vr-image': require('./vr-image'),
  'vr-model': require('./vr-model'),
  'vr-obj-loader': require('./vr-obj-loader'),
  'vr-plane': require('./vr-plane'),
  'vr-skybox': require('./vr-skybox'),
  'vr-skysphere': require('./vr-skysphere'),
  'vr-sphere': require('./vr-sphere'),
  'vr-video': require('./vr-video'),
  'vr-video360': require('./vr-video360')
};

},{"./vr-audio":2,"./vr-cube":3,"./vr-curvedPlane1":4,"./vr-curvedPlane2":5,"./vr-cylinder":6,"./vr-grid":7,"./vr-hemispherelight":8,"./vr-image":9,"./vr-model":10,"./vr-obj-loader":11,"./vr-plane":12,"./vr-skybox":13,"./vr-skysphere":14,"./vr-sphere":15,"./vr-video":16,"./vr-video360":17}],2:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-audio',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var listener = new THREE.AudioListener();

            var src = this.getAttribute('src');
            var volume = parseFloat(this.getAttribute('vol')) || 10;
            var loop = this.getAttribute('loop') || true;
            var sound = new THREE.Audio(listener);
            volume = volume * 10; // We multiple by ten so the user can define volume in more intuitive scale: 0-10.
            sound.source.start(0, 0);

            if (src) {
              sound.load(src);
              sound.setVolume(volume);
              sound.setLoop(loop);
              sound.connect();
            }

            this.object3D = sound;
            this.load();
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],3:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-cube',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var width = parseFloat(this.getAttribute('width')) || 5;
            var height = parseFloat(this.getAttribute('height')) || 5;
            var depth = parseFloat(this.getAttribute('depth')) || 5;
            return new THREE.BoxGeometry(width, height, depth);
          }
        },

        getMaterial: {
          value: function () {
            var color = this.getAttribute('color');
            var materialId = this.getAttribute('material');
            var materialEl;
            var material;

            if (materialId) {
              materialEl = materialId ? document.querySelector('#' + materialId) : {};
              material = materialEl.material;
              if (color) {
                material.color = new THREE.Color(color);
              }
            } else if (color) {
              material = new THREE.MeshPhongMaterial({color: color});
            } else {
              material = new THREE.MeshNormalMaterial();
            }

            return material;
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],4:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-curvedPlane1',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius')) || 10;
            var width = parseFloat(this.getAttribute('width')) || 4;
            var height = parseFloat(this.getAttribute('height')) || 1;

            var circumference = 2 * Math.PI * radius;
            var thetaLength = (Math.PI * 2) * (width / circumference);

            var geometry = new THREE.CylinderGeometry(
              radius, // radius top
              radius, // radius bottom
              height, // height
              30, // y segments
              10, // x segments
              true, // openended
              0,  // theta start
              thetaLength
            );

            geometry.applyMatrix(new THREE.Matrix4().makeScale(1, 1, -1));

            return geometry;
          }
        },

        getMaterial: {
          value: function () {
            var materialId = this.getAttribute('material');
            var materialEl = materialId ? document.querySelector('#' + materialId) : {};
            return (materialEl && materialEl.material) || new THREE.MeshNormalMaterial({color: Math.random() * 0xffffff, opacity: 1.0});
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],5:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-curvedPlane2',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius')) || 10;
            var height = parseFloat(this.getAttribute('height')) || 5;
            var thetaStart = parseFloat(this.getAttribute('thetaStart')) || Math.PI;
            var thetaLength = parseFloat(this.getAttribute('thetaLength')) || 90;
            var flipNormals = parseFloat(this.getAttribute('flip')) || true;

            var radiusSegments = thetaLength / 2;
            var heightSegments = 1;
            var length = thetaLength * Math.PI / 180;
            var start;

            if (flipNormals) {
              // Subtracting length from start has effect of enabling designer
              // to specify left edge position of the band (start), and
              // extending band rightwards.
              start = (thetaStart + 180) * Math.PI / 180;
            } else {
              start = (thetaStart - thetaLength) * Math.PI / 180;
            }

            var geometry = new THREE.CylinderGeometry(radius, radius, height, radiusSegments, heightSegments, true, start, length);

            if (flipNormals) {
              geometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
            }

            // Sets pivot to top of band.
            geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0 - height / 2, 0));

            return geometry;
          }
        },

        getMaterial: {
          value: function () {
            var imgSrc = this.getAttribute('tex');
            var color = this.getAttribute('color');
            var opacity = parseFloat(this.getAttribute('opacity')) || 1;

            var material = new THREE.MeshBasicMaterial({transparent: true, side: THREE.DoubleSide});

            if (imgSrc) {
              material.map = THREE.ImageUtils.loadTexture(imgSrc);
            } else if (color) {
              material.color = new THREE.Color(color);
            } else {
              material.color = new THREE.Color('#CCCCCC');
            }

            material.opacity = opacity;

            return material;
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],6:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-cylinder',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius') || 5);
            var height = parseFloat(this.getAttribute('height') || 1);
            var radiusSegments = parseFloat(this.getAttribute('radiusSegments') || 36);
            var heightSegments = parseFloat(this.getAttribute('heightSegments') || 10);
            var openEnded = this.hasAttribute('openended');

            var geometry = new THREE.CylinderGeometry(
              radius, // radius top
              radius, // radius bottom
              height, // height
              radiusSegments, // y segments
              heightSegments, // x segments
              openEnded // openended
            );

            return geometry;
          }
        },

        getMaterial: {
          value: function () {
            var color = parseFloat(this.getAttribute('color')) || 0xCC0000;
            var materialId = this.getAttribute('material');
            var materialEl = materialId ? document.querySelector('#' + materialId) : undefined;
            return (materialEl && materialEl.material) || new THREE.MeshNormalMaterial({
              color: color,
              opacity: 1.0
            });
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],7:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-grid',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var color = this.getAttribute('color') || '#666';
            var material = new THREE.LineBasicMaterial({color: color});
            var geometry = this.generateGeometry();
            this.object3D = new THREE.LineSegments(geometry, material, THREE.LinePieces);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            this.object3D.geometry = this.generateGeometry();
          }
        },

        generateGeometry: {
          value: function () {
            var size = parseFloat(this.getAttribute('size') || 14);
            var density = parseFloat(this.getAttribute('density') || 1);

            // Grid

            var geometry = new THREE.Geometry();

            for (var i = -size; i <= size; i += density) {
              geometry.vertices.push(new THREE.Vector3(-size, -0.04, i));
              geometry.vertices.push(new THREE.Vector3(size, -0.04, i));

              geometry.vertices.push(new THREE.Vector3(i, -0.04, -size));
              geometry.vertices.push(new THREE.Vector3(i, -0.04, size));
            }

            return geometry;
          }
        }
      }
    )
  }
);

},{"@mozvr/vr-markup":39}],8:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-hemispherelight',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var skyColor = this.getAttribute('skyColor') || '#FFFFFF';
            var groundColor = this.getAttribute('groundColor') || '#FFFFFF';
            var intensity = parseFloat(this.getAttribute('intensity') || 1);
            this.object3D = new THREE.HemisphereLight(skyColor, groundColor, intensity);
            this.load();
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],9:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-image',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var width = parseFloat(this.getAttribute('width') || 10);
            var height = parseFloat(this.getAttribute('height') || 10);
            return new THREE.PlaneGeometry(width, height, 1, 1);
          }
        },

        getMaterial: {
          value: function () {
            var imgSrc = this.getAttribute('src');
            return new THREE.MeshBasicMaterial({
              map: THREE.ImageUtils.loadTexture(imgSrc),
              side: THREE.DoubleSide
            });
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],10:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-model',
  {
    prototype: Object.create(
      VRObject.prototype, {

        createdCallback: {
          value: function () {
            var self = this;
            var src = this.getAttribute('src');

            // The default THREE.ColladaLoader scale of 0.01 ensures scales match across DAE and THREE scene (eg 1m - 1m)
            var scaleBase = 0.01;
            var scaleUser = parseFloat(this.getAttribute('scale')) || 1;
            var scale = scaleBase * scaleUser;

            // TODO: enable user to pass in material, and have that material apply to all nodes in the loaded object.
            // TODO: load and playback animations from loaded models.

            var loader = new THREE.ColladaLoader();
            loader.options.convertUpAxis = true; // Not sure if we need this. Doesn't appear to be the case. But it was in Three.js examples.
            loader.load(src, function (collada) {
              var dae = collada.scene;
              dae.scale.set(scale, scale, scale);
              self.object3D = dae;
              self.load();
            });
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],11:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-obj-loader',
  {
    prototype: Object.create(
      VRObject.prototype, {

        createdCallback: {
          value: function () {
            var self = this;
            var src = this.getAttribute('src');
            var material = this.getMaterial();

            // OBJ
            var manager = new THREE.LoadingManager();
            manager.onProgress = function (item, loaded, total) {
              console.log(item, loaded, total);
            };

            var loader = new THREE.OBJLoader(manager);
            loader.load(src, function (object) {
              object.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.geometry.computeTangents();
                  child.material = material;
                }
              });
              object.position.y = -15;
              self.object3D = object;
              self.load();
            });
          }
        },

        getMaterial: {
          value: function () {
            var materialId = this.getAttribute('material');
            var materialEl = materialId ? document.querySelector('#' + materialId) : undefined;
            return materialEl && materialEl.material;
          }
        }

      })
  }
);

},{"@mozvr/vr-markup":39}],12:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-plane',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var width = parseFloat(this.getAttribute('width')) || 10;
            var height = parseFloat(this.getAttribute('height')) || 10;
            return new THREE.PlaneGeometry(width, height, 1, 1);
          }
        },

        getMaterial: {
          value: function () {
            var color = this.getAttribute('color');
            var materialId = this.getAttribute('material');
            var materialEl;
            var material;

            if (materialId) {
              materialEl = materialId ? document.querySelector('#' + materialId) : undefined;
              material = materialEl.material;
              if (color) {
                material.color = new THREE.Color(color);
              }
            } else if (color) {
              material = new THREE.MeshPhongMaterial({color: color});
            } else {
              material = new THREE.MeshNormalMaterial();
            }

            return material;
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],13:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-skybox',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var size = parseFloat(this.getAttribute('size')) || 10000;
            return new THREE.BoxGeometry(size, size, size, 1, 1, 1);
          }
        },

        getMaterial: {
          value: function () {
            var self = this;

            var urlPrefix = this.getAttribute('src');
            var urls = [
              urlPrefix + 'right.jpg',
              urlPrefix + 'left.jpg',
              urlPrefix + 'top.jpg',
              urlPrefix + 'bottom.jpg',
              urlPrefix + 'front.jpg',
              urlPrefix + 'back.jpg'
            ];

            var textureCube = THREE.ImageUtils.loadTextureCube(urls, THREE.CubeReflectionMapping, function () {
              self.load();
            });
            textureCube.format = THREE.RGBFormat;

            var shader = THREE.ShaderLib.cube;

            var material = new THREE.ShaderMaterial({
              fragmentShader: shader.fragmentShader,
              vertexShader: shader.vertexShader,
              uniforms: shader.uniforms,
              side: THREE.BackSide
            });

            material.uniforms.tCube.value = textureCube;

            return material;
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],14:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-skysphere',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius')) || 5000;
            return new THREE.SphereGeometry(radius, 64, 40);
          }
        },

        getMaterial: {
          value: function () {
            var imgSrc = this.getAttribute('src');
            var color = this.getAttribute('color');
            var material = new THREE.MeshBasicMaterial({side: THREE.BackSide, fog: false});

            if (imgSrc) {
              material.map = THREE.ImageUtils.loadTexture(imgSrc);
            } else if (color) {
              material.color = new THREE.Color(color);
            } else {
              material.color = new THREE.Color('#CCCCCC');
            }

            return material;
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],15:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-sphere',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius')) || 5;
            return new THREE.SphereGeometry(radius, 20, 20);
          }
        },

        getMaterial: {
          value: function () {
            var color = this.getAttribute('color');
            var materialId = this.getAttribute('material');
            var materialEl;
            var material;

            if (materialId) {
              materialEl = materialId ? document.querySelector('#' + materialId) : undefined;
              material = materialEl.material;
              if (color) {
                material.color = new THREE.Color(color);
              }
            } else if (color) {
              material = new THREE.MeshPhongMaterial({color: color});
            } else {
              material = new THREE.MeshNormalMaterial();
            }

            return material;
          }
        }
      })
  }
);

},{"@mozvr/vr-markup":39}],16:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-video',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        /* no `update` function needed */

        getGeometry: {
          value: function () {
            var width = parseFloat(this.getAttribute('width') || 50);
            var height = parseFloat(this.getAttribute('height') || 50);
            return new THREE.PlaneGeometry(width, height, 1, 1);
          }
        },

        getMaterial: {
          value: function () {
            var video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.src = this.getAttribute('src');
            video.autoplay = this.hasAttribute('autoplay');
            video.loop = this.hasAttribute('loop');

            var texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.LinearFilter;
            texture.format = THREE.RGBFormat;
            texture.generateMipmaps = false;

            return new THREE.MeshBasicMaterial({
              map: texture
            });
          }
        }
      }
    )
  }
);

},{"@mozvr/vr-markup":39}],17:[function(require,module,exports){
var VRMarkup = require('@mozvr/vr-markup');

var THREE = VRMarkup.THREE;
var VRObject = VRMarkup.VRObject;

document.registerElement(
  'vr-video360',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        /* no `update` function needed */

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius') || 10000);
            return new THREE.SphereGeometry(radius, 64, 40);
          }
        },

        getMaterial: {
          value: function () {
            var video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.src = this.getAttribute('src');
            video.autoplay = this.hasAttribute('autoplay');
            video.loop = this.hasAttribute('loop');

            var texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.LinearFilter;
            texture.format = THREE.RGBFormat;

            texture.generateMipmaps = false;

            return new THREE.MeshBasicMaterial({
              map: texture,
              side: THREE.DoubleSide
            });
          }
        }
      }
    )
  }
);

},{"@mozvr/vr-markup":39}],18:[function(require,module,exports){
module.exports = {
  // Main library.
  VRMarkup: require('@mozvr/vr-markup'),

  // Core components.
  core: require('./core/'),

  // Boilerplate styles.
  css: require('./style/index.css')
};

},{"./core/":1,"./style/index.css":45,"@mozvr/vr-markup":39}],19:[function(require,module,exports){
/**
 * @author dmarcos - diego.marcos@gmail.com
 *
 * Reusable cursor for 3D scenes
 *
 */

module.exports = function (THREE) {

	var Cursor = function ( object, renderer ) {

		THREE.Object3D.call( this );

		var scope = this;

		var top = Math.tan( THREE.Math.degToRad( object.fov * 0.5 ) ) * object.near;
		var bottom = - top;
		var left = object.aspect * bottom;
		var right = object.aspect * top;
		var near = object.near;
		var far = object.far;

		var cursorPosition = new THREE.Vector3();
		var pixelsToDegreesFactor = 0.00030;

		this.object = object;
		this.lock = false;
		this.maxFOV = 30;
		this.deltaEuler = new THREE.Euler();
		this.mouseDeltaX = 0;
		this.mouseDeltaY = 0;

		this.pointerLocked = false;

		this.camera = new THREE.OrthographicCamera( left, right, top, bottom, near, far );
		this.scene = new THREE.Scene();
		this.renderer = renderer;

		this.domElement = ( renderer !== undefined ) ? renderer.domElement : document;
		this.domElement.style.cursor = 'none';

		this.pointer = new THREE.Mesh(
			new THREE.SphereGeometry( 0.008, 0.008, 0.008 ),
			new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } )
		);
		this.pointer.position.z = -75;
		this.add( this.pointer );
		this.scene.add( this );

		// Initialization of local variables
		// To avoid allocations in every frame
		this.mouseVector = new THREE.Vector3(0, 0, 0);
		this.deltaQuaternion = new THREE.Quaternion();
		this.deltaMouseQuat = new THREE.Quaternion();

		// update
		// It stores the camera orientation change between frames
		this.cameraDeltaQuaternion = new THREE.Quaternion();
		// It stores the inverse of the camera orientation
		this.cameraInverse = new THREE.Quaternion();

		// updateMouseQuaternion
		this.xDeltaQuaternion = new THREE.Quaternion();
		this.yDeltaQuaternion = new THREE.Quaternion();
		this.mouseMoveQuat = new THREE.Quaternion();
		this.xAxis = new THREE.Vector3(1, 0, 0);
		this.yAxis = new THREE.Vector3(0, 1, 0);
		this.mouseQuat = new THREE.Quaternion();

		this.update = function() {
			var deltaAngle;
			var cameraInverse = scope.cameraInverse;
			// If the pointer is locked we move the cursor radially
			if ( scope.pointerLocked ) {
				// First frame we initialize variables
				if ( !scope.previousCameraQuat ) {
					scope.deltaMouseQuat.copy( scope.object.quaternion );
					scope.previousCameraQuat = scope.object.quaternion.clone();
				}
				// Angle between camera and cursor
				deltaAngle = quaternionsAngle( scope.object.quaternion, scope.quaternion ) * ( 180 / Math.PI ) ;

				// It calculates how much the camera orientation has changed since last frame
				// diff * q1 = q2  --->  diff = q2 * inverse(q1)
				// where:  inverse(q1) = conjugate(q1) / abs(q1)
				// and:  conjugate( quaternion(re, i, j, k) ) = quaternion(re, -i, -j, -k)
				// http://stackoverflow.com/questions/22157435/difference-between-the-two-quaternions
				cameraInverse.copy( scope.object.quaternion ).inverse();
				scope.cameraDeltaQuaternion.copy( scope.previousCameraQuat ).multiply( cameraInverse );

				/**********/
				// PING PONG
				// If the cursor goes out of FOV it syncs camera and cursor oritentation
				if ( deltaAngle >= scope.maxFOV ) {
					scope.deltaQuaternion.multiply( scope.cameraDeltaQuaternion );
				}
				// PING PONG

				// // STICKY
				// if ( deltaAngle >= this.maxFOV ) {
				// 	scope.lock = true;
				// }
				// if ( scope.lock ) {
				//	scope.deltaQuaternion.multiply( scope.cameraDeltaQuaternion );
				// }
				// // STICKY
				/**********/

				scope.updateMouseQuaternion();

				// New cursor quaternion
				scope.quaternion.copy( scope.deltaQuaternion ).inverse();
				scope.quaternion.multiply( scope.deltaMouseQuat );

				// We copy current quaternion in previous for the next frame
				scope.previousCameraQuat.copy( scope.object.quaternion );
				scope.matrixAutoUpdate = false;
				scope.updateMatrix();

			} else { // If the pointer is not locked we move the pointer on a 2d plane

				scope.matrixAutoUpdate = true;
				scope.pointer.position.x = scope.mouseVector.x;
				scope.pointer.position.y = -scope.mouseVector.y;
				scope.render();

			}

		};

		this.updateMouseQuaternion = function() {
			var mouseQuat = scope.mouseQuat;
			var deltaAngle;
			var xDeltaQuaternion = scope.xDeltaQuaternion;
			var yDeltaQuaternion = scope.yDeltaQuaternion;
			var mouseMoveQuat = scope.mouseMoveQuat;
			var xAxis = scope.xAxis.set( 1, 0, 0 );
			var yAxis = scope.yAxis.set( 0, 1, 0 );
			var xInc = scope.mouseDeltaX;
			var yInc = scope.mouseDeltaY;
			var incSign;

			if ( xInc !== 0 || yInc !==0 ) {

				scope.object.localToWorld( xAxis );
				xDeltaQuaternion.setFromAxisAngle( xAxis, xInc * 2 * Math.PI );

				scope.object.localToWorld( yAxis );
				yDeltaQuaternion.setFromAxisAngle( yAxis, yInc * 2 * Math.PI );

				// Move the cursor in the two different axis of the polar coordinates: θ and φ
				mouseMoveQuat.copy( xDeltaQuaternion ).multiply( yDeltaQuaternion );
				// Test if the mouse delta moves the cursor out of FOV
				mouseQuat.copy( mouseMoveQuat ).multiply( scope.quaternion );
				// Angle between camera orientation and new cursor orientation
				deltaAngle = quaternionsAngle( scope.object.quaternion, mouseQuat ) * ( 180 / Math.PI );
				// If the cursor stays in FOV we apply the delta
				if (deltaAngle < scope.maxFOV) {
					scope.deltaMouseQuat.copy( mouseMoveQuat ).multiply( scope.quaternion );
					scope.deltaQuaternion = new THREE.Quaternion();
					// // STICKY
					// this.lock = false;
					// // STICKY
				}

				scope.mouseDeltaX = 0;
				scope.mouseDeltaY = 0;
			}
		};

		this.render = function() {
			if ( scope.pointerLocked ) {
				return;
			}
			var autoClear = scope.renderer.autoClear;
			if ( scope.parent !== scope.scene ) {
				storeParentScene();
				scope.parent.remove( scope );
				scope.scene.add( scope );
			}
			scope.renderer.autoClear = false;
			scope.renderer.render( scope.scene, scope.camera );
			scope.renderer.autoClear = autoClear;
		};

		function updateScreenPosition( e ) {
			// It converts from screen to camera coordinates
			var mouseX = ( e.clientX / window.innerWidth ) * 2 - 1;
			var mouseY = ( e.clientY / window.innerHeight ) * 2 - 1;

			// cursor position in camera coordinates
			cursorPosition.copy( scope.pointer.position );
			cursorPosition.project( scope.camera );

			scope.mouseVector.set( mouseX, mouseY, cursorPosition.z );
			scope.mouseVector.unproject( scope.camera );
		}

		function updateRadialPosition( e ) {
			var movementX = e.movementX ||
					e.mozMovementX ||
					e.webkitMovementX || 0;

			var movementY = e.movementY ||
					e.mozMovementY ||
					e.webkitMovementY || 0;

			scope.mouseDeltaX -= movementY * pixelsToDegreesFactor;
			scope.mouseDeltaY -= movementX * pixelsToDegreesFactor;
		}

		function quaternionsAngle(q1, q2) {
			var v1 = new THREE.Vector3( 0, 0, -1 );
			var v2 = new THREE.Vector3( 0, 0, -1 );
			v1.applyQuaternion(q1);
			v2.applyQuaternion(q2);
			return v1.angleTo(v2);
		}

		function onMouseMove( e ) {
			if ( scope.pointerLocked ) {
				if ( scope.mouseDown === true ) {
					return;
				}
				// The cursor moves radially around the user
				updateRadialPosition ( e );
			} else {
				// The cursor moves on the flat screen
				updateScreenPosition ( e )
			}
		}

		function resetPivot( object ) {
			scope.position.copy( object.position );
			scope.quaternion.copy( object.quaternion );
			scope.deltaQuaternion = new THREE.Quaternion();
		}

		function pointerLockChanged() {
			scope.pointerLocked =
				document.pointerLockElement === scope.domElement ||
				document.mozPointerLockElement === scope.domElement ||
				document.webkitPointerLockElement === scope.domElement;

			storeParentScene();

			if ( scope.pointerLocked === true ) {
				resetPivot( scope.object );
				scope.scene.remove( scope );
				scope.parentScene.add( scope );
				scope.pointer.scale.set( 50, 50, 50 );
				scope.previousCameraQuat = false;
			} else {
				resetPivot( scope.camera );
				scope.parentScene.remove( scope );
				scope.scene.add( scope );
				scope.pointer.scale.set( 1, 1, 1 );
				scope.pointerLocked = false;
			}
		}

		function onMouseUp() {
			scope.mouseDown = false;
		}

		function onMouseDown(e) {
			scope.mouseDown = true;
			scope.dispatchEvent( { type: 'click', data: e } );
		}

		function storeParentScene() {
			if ( !scope.parentScene && scope.parent !== scope.scene ) {
				scope.parentScene = scope.parent;
			}
		}

		this.domElement.addEventListener( 'mousemove', onMouseMove );
		this.domElement.addEventListener( 'mouseup', onMouseUp, false );
		this.domElement.addEventListener( 'mousedown', onMouseDown, false );

		document.addEventListener( 'pointerlockchange', pointerLockChanged, false );
		document.addEventListener( 'mozpointerlockchange', pointerLockChanged, false );
		document.addEventListener( 'webkitpointerlockchange', pointerLockChanged, false );

	};

	Cursor.prototype = Object.create( THREE.Object3D.prototype );

	return Cursor;

};

},{}],20:[function(require,module,exports){
var THREE = require('./vendor/three');

// TODO: Eventually include these only if they are needed by a component.
THREE.Cursor = require('../lib/cursor3D')(THREE);
THREE.Raycaster = require('../lib/vendor/Raycaster')(THREE);
THREE.ShaderLib.pbr = require('../src/shaders/pbr')(THREE);
THREE.VRControls = require('../lib/vendor/VRControls');
THREE.VREffect = require('../lib/vendor/VREffect');

module.exports = THREE;

},{"../lib/cursor3D":19,"../lib/vendor/Raycaster":21,"../lib/vendor/VRControls":22,"../lib/vendor/VREffect":23,"../src/shaders/pbr":32,"./vendor/three":24}],21:[function(require,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

module.exports = function (THREE) {

	var Raycaster = module.exports = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Sprite: {},
			Mesh: {},
			PointCloud: { threshold: 1 },
			LOD: {},
			Line: {}
		};

	};

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var intersectObject = function ( object, raycaster, intersects, recursive ) {

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	};

	//

	Raycaster.prototype = {

		constructor: Raycaster,

		precision: 0.0001,
		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			// camera is assumed _not_ to be a child of a transformed object

			if ( camera instanceof THREE.PerspectiveCamera ) {

				this.ray.origin.copy( camera.position );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();

			} else if ( camera instanceof THREE.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( objects instanceof Array === false ) {

				console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

	return Raycaster;

};

},{}],22:[function(require,module,exports){
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 */

var THREE = require('./three');

module.exports = function ( object, onError ) {

  var scope = this;

  var vrInputs = [];

  function filterInvalidDevices( devices ) {

    // Exclude Cardboard position sensor if Oculus exists.

    var oculusDevices = devices.filter( function ( device ) {

      return device.deviceName.toLowerCase().indexOf('oculus') !== -1;

    } );

    if ( oculusDevices.length >= 1 ) {

      return devices.filter( function ( device ) {

        return device.deviceName.toLowerCase().indexOf('cardboard') === -1;

      } );

    } else {

      return devices;

    }

  }

  function gotVRDevices( devices ) {

    devices = filterInvalidDevices( devices );

    for ( var i = 0; i < devices.length; i ++ ) {

      if ( devices[ i ] instanceof PositionSensorVRDevice ) {

        vrInputs.push( devices[ i ] );

      }

    }

    if ( onError ) onError( 'HMD not available' );

  }

  if ( navigator.getVRDevices ) {

    navigator.getVRDevices().then( gotVRDevices );

  }

  // the Rift SDK returns the position in meters
  // this scale factor allows the user to define how meters
  // are converted to scene units.

  this.scale = 1;

  this.update = function () {

    for ( var i = 0; i < vrInputs.length; i ++ ) {

      var vrInput = vrInputs[ i ];

      var state = this.state = vrInput.getState();

      if ( state.orientation !== null ) {

        object.quaternion.copy( state.orientation );

      }

      if ( state.position !== null ) {

        object.position.copy( state.position ).multiplyScalar( scope.scale );

      }

    }

  };

  this.resetSensor = function () {

    for ( var i = 0; i < vrInputs.length; i ++ ) {

      var vrInput = vrInputs[ i ];

      if ( vrInput.resetSensor !== undefined ) {

        vrInput.resetSensor();

      } else if ( vrInput.zeroSensor !== undefined ) {

        vrInput.zeroSensor();

      }

    }

  };

  this.zeroSensor = function () {

    console.warn( 'THREE.VRControls: .zeroSensor() is now .resetSensor().' );
    this.resetSensor();

  };

};

},{"./three":24}],23:[function(require,module,exports){
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 *
 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
 *
 * Firefox: http://mozvr.com/downloads/
 * Chromium: https://drive.google.com/folderview?id=0BzudLt22BqGRbW9WTHMtOWMzNjQ&usp=sharing#list
 *
 */

var THREE = require('./three');

module.exports = function ( renderer, onError ) {

  var vrHMD;
  var eyeTranslationL, eyeFOVL;
  var eyeTranslationR, eyeFOVR;

  function gotVRDevices( devices ) {

    for ( var i = 0; i < devices.length; i ++ ) {

      if ( devices[ i ] instanceof HMDVRDevice ) {

        vrHMD = devices[ i ];

        if ( vrHMD.getEyeParameters !== undefined ) {

          var eyeParamsL = vrHMD.getEyeParameters( 'left' );
          var eyeParamsR = vrHMD.getEyeParameters( 'right' );

          eyeTranslationL = eyeParamsL.eyeTranslation;
          eyeTranslationR = eyeParamsR.eyeTranslation;
          eyeFOVL = eyeParamsL.recommendedFieldOfView;
          eyeFOVR = eyeParamsR.recommendedFieldOfView;

        } else {

          // TODO: This is an older code path and not spec compliant.
          // It should be removed at some point in the near future.
          eyeTranslationL = vrHMD.getEyeTranslation( 'left' );
          eyeTranslationR = vrHMD.getEyeTranslation( 'right' );
          eyeFOVL = vrHMD.getRecommendedEyeFieldOfView( 'left' );
          eyeFOVR = vrHMD.getRecommendedEyeFieldOfView( 'right' );

        }

        break; // We keep the first we encounter

      }

    }

    if ( vrHMD === undefined ) {

      if ( onError ) onError( 'HMD not available' );

    }

  }

  if ( navigator.getVRDevices ) {

    navigator.getVRDevices().then( gotVRDevices );

  }

  //

  this.scale = 1;

  this.setSize = function( width, height ) {

    renderer.setSize( width, height );

  };

  // fullscreen

  var isFullscreen = false;

  var canvas = renderer.domElement;
  var fullscreenchange = canvas.mozRequestFullScreen ? 'mozfullscreenchange' : 'webkitfullscreenchange';

  document.addEventListener( fullscreenchange, function ( event ) {

    isFullscreen = document.mozFullScreenElement || document.webkitFullscreenElement;

  }, false );

  this.setFullScreen = function ( boolean ) {

    if ( vrHMD === undefined ) return;
    if ( isFullscreen === boolean ) return;

    if ( canvas.mozRequestFullScreen ) {

      canvas.mozRequestFullScreen( { vrDisplay: vrHMD } );

    } else if ( canvas.webkitRequestFullscreen ) {

      canvas.webkitRequestFullscreen( { vrDisplay: vrHMD } );

    }

  };

  // render

  var cameraL = new THREE.PerspectiveCamera();
  var cameraR = new THREE.PerspectiveCamera();

  this.render = function ( scene, camera ) {

    if ( vrHMD ) {

      var sceneL, sceneR;

      if ( Array.isArray( scene ) ) {

        sceneL = scene[ 0 ];
        sceneR = scene[ 1 ];

      } else {

        sceneL = scene;
        sceneR = scene;

      }

      var size = renderer.getSize();
      size.width /= 2;

      renderer.enableScissorTest( true );
      renderer.clear();

      if ( camera.parent === null ) camera.updateMatrixWorld();

      cameraL.projectionMatrix = fovToProjection( eyeFOVL, true, camera.near, camera.far );
      cameraR.projectionMatrix = fovToProjection( eyeFOVR, true, camera.near, camera.far );

      camera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );
      camera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );

      cameraL.translateX( eyeTranslationL.x * this.scale );
      cameraR.translateX( eyeTranslationR.x * this.scale );

      // render left eye
      renderer.setViewport( 0, 0, size.width, size.height );
      renderer.setScissor( 0, 0, size.width, size.height );
      renderer.render( sceneL, cameraL );

      // render right eye
      renderer.setViewport( size.width, 0, size.width, size.height );
      renderer.setScissor( size.width, 0, size.width, size.height );
      renderer.render( sceneR, cameraR );

      renderer.enableScissorTest( false );

      return;

    }

    // Regular render mode if not HMD

    if ( Array.isArray( scene ) ) scene = scene[ 0 ];

    renderer.render( scene, camera );

  };

  //

  function fovToNDCScaleOffset( fov ) {

    var pxscale = 2.0 / ( fov.leftTan + fov.rightTan );
    var pxoffset = ( fov.leftTan - fov.rightTan ) * pxscale * 0.5;
    var pyscale = 2.0 / ( fov.upTan + fov.downTan );
    var pyoffset = ( fov.upTan - fov.downTan ) * pyscale * 0.5;
    return { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };

  }

  function fovPortToProjection( fov, rightHanded, zNear, zFar ) {

    rightHanded = rightHanded === undefined ? true : rightHanded;
    zNear = zNear === undefined ? 0.01 : zNear;
    zFar = zFar === undefined ? 10000.0 : zFar;

    var handednessScale = rightHanded ? - 1.0 : 1.0;

    // start with an identity matrix
    var mobj = new THREE.Matrix4();
    var m = mobj.elements;

    // and with scale/offset info for normalized device coords
    var scaleAndOffset = fovToNDCScaleOffset( fov );

    // X result, map clip edges to [-w,+w]
    m[ 0 * 4 + 0 ] = scaleAndOffset.scale[ 0 ];
    m[ 0 * 4 + 1 ] = 0.0;
    m[ 0 * 4 + 2 ] = scaleAndOffset.offset[ 0 ] * handednessScale;
    m[ 0 * 4 + 3 ] = 0.0;

    // Y result, map clip edges to [-w,+w]
    // Y offset is negated because this proj matrix transforms from world coords with Y=up,
    // but the NDC scaling has Y=down (thanks D3D?)
    m[ 1 * 4 + 0 ] = 0.0;
    m[ 1 * 4 + 1 ] = scaleAndOffset.scale[ 1 ];
    m[ 1 * 4 + 2 ] = - scaleAndOffset.offset[ 1 ] * handednessScale;
    m[ 1 * 4 + 3 ] = 0.0;

    // Z result (up to the app)
    m[ 2 * 4 + 0 ] = 0.0;
    m[ 2 * 4 + 1 ] = 0.0;
    m[ 2 * 4 + 2 ] = zFar / ( zNear - zFar ) * - handednessScale;
    m[ 2 * 4 + 3 ] = ( zFar * zNear ) / ( zNear - zFar );

    // W result (= Z in)
    m[ 3 * 4 + 0 ] = 0.0;
    m[ 3 * 4 + 1 ] = 0.0;
    m[ 3 * 4 + 2 ] = handednessScale;
    m[ 3 * 4 + 3 ] = 0.0;

    mobj.transpose();

    return mobj;

  }

  function fovToProjection( fov, rightHanded, zNear, zFar ) {

    var DEG2RAD = Math.PI / 180.0;

    var fovPort = {
      upTan: Math.tan( fov.upDegrees * DEG2RAD ),
      downTan: Math.tan( fov.downDegrees * DEG2RAD ),
      leftTan: Math.tan( fov.leftDegrees * DEG2RAD ),
      rightTan: Math.tan( fov.rightDegrees * DEG2RAD )
    };

    return fovPortToProjection( fovPort, rightHanded, zNear, zFar );

  }

};

},{"./three":24}],24:[function(require,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '72dev' };

//

if ( typeof define === 'function' && define.amd ) {

    define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

    module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

  // Missing in Android stock browser.

  ( function () {

    var lastTime = 0;
    var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

    for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

      self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
      self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

    }

    if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

      self.requestAnimationFrame = function ( callback ) {

        var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
        var id = self.setTimeout( function () {

          callback( currTime + timeToCall );

        }, timeToCall );
        lastTime = currTime + timeToCall;
        return id;

      };

    }

    if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

      self.cancelAnimationFrame = function ( id ) {

        self.clearTimeout( id );

      };

    }

  }() );

}

if ( Math.sign === undefined ) {

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  Math.sign = function ( x ) {

    return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

  };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

  // Missing in IE9-11.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

  Object.defineProperty( Function.prototype, 'name', {

    get: function () {

      return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

    }

  } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// DEPRECATED

THREE.Projector = function () {

  console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

  this.projectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    vector.project( camera );

  };

  this.unprojectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    vector.unproject( camera );

  };

  this.pickingRay = function ( vector, camera ) {

    console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

  };

};

THREE.CanvasRenderer = function () {

  console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

  this.domElement = document.createElement( 'canvas' );
  this.clear = function () {};
  this.render = function () {};
  this.setClearColor = function () {};
  this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

  if ( arguments.length === 3 ) {

    return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

  }

  return this.set( color );

};

THREE.Color.prototype = {

  constructor: THREE.Color,

  r: 1, g: 1, b: 1,

  set: function ( value ) {

    if ( value instanceof THREE.Color ) {

      this.copy( value );

    } else if ( typeof value === 'number' ) {

      this.setHex( value );

    } else if ( typeof value === 'string' ) {

      this.setStyle( value );

    }

    return this;

  },

  setHex: function ( hex ) {

    hex = Math.floor( hex );

    this.r = ( hex >> 16 & 255 ) / 255;
    this.g = ( hex >> 8 & 255 ) / 255;
    this.b = ( hex & 255 ) / 255;

    return this;

  },

  setRGB: function ( r, g, b ) {

    this.r = r;
    this.g = g;
    this.b = b;

    return this;

  },

  setHSL: function () {

    function hue2rgb ( p, q, t ) {

      if ( t < 0 ) t += 1;
      if ( t > 1 ) t -= 1;
      if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
      if ( t < 1 / 2 ) return q;
      if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
      return p;

    }

    return function ( h, s, l ) {

      // h,s,l ranges are in 0.0 - 1.0
      h = THREE.Math.euclideanModulo( h, 1 );
      s = THREE.Math.clamp( s, 0, 1 );
      l = THREE.Math.clamp( l, 0, 1 );

      if ( s === 0 ) {

        this.r = this.g = this.b = l;

      } else {

        var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
        var q = ( 2 * l ) - p;

        this.r = hue2rgb( q, p, h + 1 / 3 );
        this.g = hue2rgb( q, p, h );
        this.b = hue2rgb( q, p, h - 1 / 3 );

      }

      return this;

    };

  }(),

  setStyle: function ( style ) {

    var parseAlpha = function ( strAlpha ) {

      var alpha = parseFloat( strAlpha );

      if ( alpha < 1 ) {

        console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );

      }

      return alpha;

    }


    var m;

    if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

      // rgb / hsl

      var color;
      var name = m[ 1 ];
      var components = m[ 2 ];

      switch ( name ) {

        case 'rgb':

          if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*$/.exec( components ) ) {

            // rgb(255,0,0)
            this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
            this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
            this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

            return this;

          }

          if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

            // rgb(100%,0%,0%)
            this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
            this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
            this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

            return this;

          }

          break;

        case 'rgba':

          if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

            // rgba(255,0,0,0.5)
            this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
            this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
            this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
            parseAlpha( color[ 4 ] );

            return this;

          }

          if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

            // rgba(100%,0%,0%,0.5)
            this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
            this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
            this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
            parseAlpha( color[ 4 ] );

            return this;

          }

          break;

        case 'hsl':

          if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

            // hsl(120,50%,50%)
            var h = parseFloat( color[ 1 ] );
            var s = parseInt( color[ 2 ], 10 ) / 100;
            var l = parseInt( color[ 3 ], 10 ) / 100;

            return this.setHSL( h, s, l );

          }

          break;

        case 'hsla':

          if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

            // hsla(120,50%,50%,0.5)
            var h = parseFloat( color[ 1 ] );
            var s = parseInt( color[ 2 ], 10 ) / 100;
            var l = parseInt( color[ 3 ], 10 ) / 100;
            parseAlpha( color[ 4 ] );

            return this.setHSL( h, s, l );

          }

          break;

      }

    } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

      // hex color

      var hex = m[ 1 ];
      var size = hex.length;

      if ( size === 3 ) {

        // #ff0
        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
        this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
        this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

        return this;

      } else if ( size === 6 ) {

        // #ff0000
        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
        this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
        this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

        return this;

      }

    }

    if ( style && style.length > 0 ) {

      // color keywords
      var hex = THREE.ColorKeywords[ style ];

      if ( hex !== undefined ) {

        // red
        this.setHex( hex );

      } else {

        // unknown color
        console.warn( 'THREE.Color: Unknown color ' + style );

      }

    }

    return this;

  },

  clone: function () {

    return new this.constructor( this.r, this.g, this.b );

  },

  copy: function ( color ) {

    this.r = color.r;
    this.g = color.g;
    this.b = color.b;

    return this;

  },

  copyGammaToLinear: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    this.r = Math.pow( color.r, gammaFactor );
    this.g = Math.pow( color.g, gammaFactor );
    this.b = Math.pow( color.b, gammaFactor );

    return this;

  },

  copyLinearToGamma: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    this.r = Math.pow( color.r, safeInverse );
    this.g = Math.pow( color.g, safeInverse );
    this.b = Math.pow( color.b, safeInverse );

    return this;

  },

  convertGammaToLinear: function () {

    var r = this.r, g = this.g, b = this.b;

    this.r = r * r;
    this.g = g * g;
    this.b = b * b;

    return this;

  },

  convertLinearToGamma: function () {

    this.r = Math.sqrt( this.r );
    this.g = Math.sqrt( this.g );
    this.b = Math.sqrt( this.b );

    return this;

  },

  getHex: function () {

    return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  },

  getHexString: function () {

    return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  },

  getHSL: function ( optionalTarget ) {

    // h,s,l ranges are in 0.0 - 1.0

    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    var r = this.r, g = this.g, b = this.b;

    var max = Math.max( r, g, b );
    var min = Math.min( r, g, b );

    var hue, saturation;
    var lightness = ( min + max ) / 2.0;

    if ( min === max ) {

      hue = 0;
      saturation = 0;

    } else {

      var delta = max - min;

      saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

      switch ( max ) {

        case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
        case g: hue = ( b - r ) / delta + 2; break;
        case b: hue = ( r - g ) / delta + 4; break;

      }

      hue /= 6;

    }

    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;

    return hsl;

  },

  getStyle: function () {

    return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  },

  offsetHSL: function ( h, s, l ) {

    var hsl = this.getHSL();

    hsl.h += h; hsl.s += s; hsl.l += l;

    this.setHSL( hsl.h, hsl.s, hsl.l );

    return this;

  },

  add: function ( color ) {

    this.r += color.r;
    this.g += color.g;
    this.b += color.b;

    return this;

  },

  addColors: function ( color1, color2 ) {

    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;

    return this;

  },

  addScalar: function ( s ) {

    this.r += s;
    this.g += s;
    this.b += s;

    return this;

  },

  multiply: function ( color ) {

    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.r *= s;
    this.g *= s;
    this.b *= s;

    return this;

  },

  lerp: function ( color, alpha ) {

    this.r += ( color.r - this.r ) * alpha;
    this.g += ( color.g - this.g ) * alpha;
    this.b += ( color.b - this.b ) * alpha;

    return this;

  },

  equals: function ( c ) {

    return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  },

  fromArray: function ( array ) {

    this.r = array[ 0 ];
    this.g = array[ 1 ];
    this.b = array[ 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.r;
    array[ offset + 1 ] = this.g;
    array[ offset + 2 ] = this.b;

    return array;

  }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

  constructor: THREE.Quaternion,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get w () {

    return this._w;

  },

  set w ( value ) {

    this._w = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, w ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;

  },

  clone: function () {

    return new this.constructor( this._x, this._y, this._z, this._w );

  },

  copy: function ( quaternion ) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;

  },

  setFromEuler: function ( euler, update ) {

    if ( euler instanceof THREE.Euler === false ) {

      throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //  content/SpinCalc.m

    var c1 = Math.cos( euler._x / 2 );
    var c2 = Math.cos( euler._y / 2 );
    var c3 = Math.cos( euler._z / 2 );
    var s1 = Math.sin( euler._x / 2 );
    var s2 = Math.sin( euler._y / 2 );
    var s3 = Math.sin( euler._z / 2 );

    if ( euler.order === 'XYZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'YXZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'ZXY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'ZYX' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'YZX' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'XZY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromAxisAngle: function ( axis, angle ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos( halfAngle );

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

      trace = m11 + m22 + m33,
      s;

    if ( trace > 0 ) {

      s = 0.5 / Math.sqrt( trace + 1.0 );

      this._w = 0.25 / s;
      this._x = ( m32 - m23 ) * s;
      this._y = ( m13 - m31 ) * s;
      this._z = ( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

      this._w = ( m32 - m23 ) / s;
      this._x = 0.25 * s;
      this._y = ( m12 + m21 ) / s;
      this._z = ( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

      this._w = ( m13 - m31 ) / s;
      this._x = ( m12 + m21 ) / s;
      this._y = 0.25 * s;
      this._z = ( m23 + m32 ) / s;

    } else {

      s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

      this._w = ( m21 - m12 ) / s;
      this._x = ( m13 + m31 ) / s;
      this._y = ( m23 + m32 ) / s;
      this._z = 0.25 * s;

    }

    this.onChangeCallback();

    return this;

  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function ( vFrom, vTo ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {

        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

          v1.set( - vFrom.y, vFrom.x, 0 );

        } else {

          v1.set( 0, - vFrom.z, vFrom.y );

        }

      } else {

        v1.crossVectors( vFrom, vTo );

      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      this.normalize();

      return this;

    }

  }(),

  inverse: function () {

    this.conjugate().normalize();

    return this;

  },

  conjugate: function () {

    this._x *= - 1;
    this._y *= - 1;
    this._z *= - 1;

    this.onChangeCallback();

    return this;

  },

  dot: function ( v ) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  },

  lengthSq: function () {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  },

  length: function () {

    return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  },

  normalize: function () {

    var l = this.length();

    if ( l === 0 ) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;

    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;

    }

    this.onChangeCallback();

    return this;

  },

  multiply: function ( q, p ) {

    if ( p !== undefined ) {

      console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
      return this.multiplyQuaternions( q, p );

    }

    return this.multiplyQuaternions( this, q );

  },

  multiplyQuaternions: function ( a, b ) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    return vector.applyQuaternion( this );

  },

  slerp: function ( qb, t ) {

    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this._x, y = this._y, z = this._z, w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if ( cosHalfTheta < 0 ) {

      this._w = - qb._w;
      this._x = - qb._x;
      this._y = - qb._y;
      this._z = - qb._z;

      cosHalfTheta = - cosHalfTheta;

    } else {

      this.copy( qb );

    }

    if ( cosHalfTheta >= 1.0 ) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;

    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {

      this._w = 0.5 * ( w + this._w );
      this._x = 0.5 * ( x + this._x );
      this._y = 0.5 * ( y + this._y );
      this._z = 0.5 * ( z + this._z );

      return this;

    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this._w = ( w * ratioA + this._w * ratioB );
    this._x = ( x * ratioA + this._x * ratioB );
    this._y = ( y * ratioA + this._y * ratioB );
    this._z = ( z * ratioA + this._z * ratioB );

    this.onChangeCallback();

    return this;

  },

  equals: function ( quaternion ) {

    return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this._x = array[ offset ];
    this._y = array[ offset + 1 ];
    this._z = array[ offset + 2 ];
    this._w = array[ offset + 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._w;

    return array;

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

  return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

  this.x = x || 0;
  this.y = y || 0;

};

THREE.Vector2.prototype = {

  constructor: THREE.Vector2,

  set: function ( x, y ) {

    this.x = x;
    this.y = y;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  clone: function () {

    return new this.constructor( this.x, this.y );

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;

  },

  addScaledVector: function ( v, s ) {

    this.x += v.x * s;
    this.y += v.y * s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;

  },

  multiply: function ( v ) {

    this.x *= v.x;
    this.y *= v.y;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.x *= s;
    this.y *= s;

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector2();
        max = new THREE.Vector2();

      }

      min.set( minVal, minVal );
      max.set( maxVal, maxVal );

      return this.clamp( min, max );

    };

  }(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y );

  },

  lengthManhattan: function() {

    return Math.abs( this.x ) + Math.abs( this.y );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );

    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];

    return this;

  }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

THREE.Vector3.prototype = {

  constructor: THREE.Vector3,

  set: function ( x, y, z ) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  clone: function () {

    return new this.constructor( this.x, this.y, this.z );

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  addScaledVector: function ( v, s ) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
      return this.multiplyVectors( v, w );

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;

    return this;

  },

  multiplyVectors: function ( a, b ) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyEuler: function () {

    var quaternion;

    return function applyEuler( euler ) {

      if ( euler instanceof THREE.Euler === false ) {

        console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

      }

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromEuler( euler ) );

      return this;

    };

  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function applyAxisAngle( axis, angle ) {

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      return this;

    };

  }(),

  applyMatrix3: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    return this;

  },

  applyMatrix4: function ( m ) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    return this;

  },

  applyProjection: function ( m ) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;
    var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    return this;

  },

  applyQuaternion: function ( q ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;

  },

  project: function () {

    var matrix;

    return function project( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
      return this.applyProjection( matrix );

    };

  }(),

  unproject: function () {

    var matrix;

    return function unproject( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
      return this.applyProjection( matrix );

    };

  }(),

  transformDirection: function ( m ) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    this.normalize();

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector3();
        max = new THREE.Vector3();

      }

      min.set( minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  }(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength  ) {

      this.multiplyScalar( l / oldLength );

    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  cross: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
      return this.crossVectors( v, w );

    }

    var x = this.x, y = this.y, z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function ( a, b ) {

    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function projectOnVector( vector ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( vector ).normalize();

      dot = this.dot( v1 );

      return this.copy( v1 ).multiplyScalar( dot );

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function projectOnPlane( planeNormal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( this ).projectOnVector( planeNormal );

      return this.sub( v1 );

    }

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function reflect( normal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    }

  }(),

  angleTo: function ( v ) {

    var theta = this.dot( v ) / ( this.length() * v.length() );

    // clamp, to handle numerical problems

    return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setEulerFromRotationMatrix: function ( m, order ) {

    console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  },

  setEulerFromQuaternion: function ( q, order ) {

    console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  },

  getPositionFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

    return this.setFromMatrixPosition( m );

  },

  getScaleFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

    return this.setFromMatrixScale( m );

  },

  getColumnFromMatrix: function ( index, matrix ) {

    console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

    return this.setFromMatrixColumn( index, matrix );

  },

  setFromMatrixPosition: function ( m ) {

    this.x = m.elements[ 12 ];
    this.y = m.elements[ 13 ];
    this.z = m.elements[ 14 ];

    return this;

  },

  setFromMatrixScale: function ( m ) {

    var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
    var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
    var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;

  },

  setFromMatrixColumn: function ( index, matrix ) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[ offset ];
    this.y = me[ offset + 1 ];
    this.z = me[ offset + 2 ];

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];

    return this;

  }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

  constructor: THREE.Vector4,

  set: function ( x, y, z, w ) {

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setW: function ( w ) {

    this.w = w;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      case 3: this.w = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      case 3: return this.w;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  clone: function () {

    return new this.constructor( this.x, this.y, this.z, this.w );

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = ( v.w !== undefined ) ? v.w : 1;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;

    return this;

  },

  addScaledVector: function ( v, s ) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;

    return this;

  },

  applyMatrix4: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
      this.w *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;

    }

    return this;

  },

  setAxisAngleFromQuaternion: function ( q ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos( q.w );

    var s = Math.sqrt( 1 - q.w * q.w );

    if ( s < 0.0001 ) {

       this.x = 1;
       this.y = 0;
       this.z = 0;

    } else {

       this.x = q.x / s;
       this.y = q.y / s;
       this.z = q.z / s;

    }

    return this;

  },

  setAxisAngleFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var angle, x, y, z,   // variables for result
      epsilon = 0.01,   // margin to allow for rounding errors
      epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees

      te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    if ( ( Math.abs( m12 - m21 ) < epsilon )
       && ( Math.abs( m13 - m31 ) < epsilon )
       && ( Math.abs( m23 - m32 ) < epsilon ) ) {

      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if ( ( Math.abs( m12 + m21 ) < epsilon2 )
         && ( Math.abs( m13 + m31 ) < epsilon2 )
         && ( Math.abs( m23 + m32 ) < epsilon2 )
         && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

        // this singularity is identity matrix so angle = 0

        this.set( 1, 0, 0, 0 );

        return this; // zero angle, arbitrary axis

      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;

      var xx = ( m11 + 1 ) / 2;
      var yy = ( m22 + 1 ) / 2;
      var zz = ( m33 + 1 ) / 2;
      var xy = ( m12 + m21 ) / 4;
      var xz = ( m13 + m31 ) / 4;
      var yz = ( m23 + m32 ) / 4;

      if ( ( xx > yy ) && ( xx > zz ) ) {

        // m11 is the largest diagonal term

        if ( xx < epsilon ) {

          x = 0;
          y = 0.707106781;
          z = 0.707106781;

        } else {

          x = Math.sqrt( xx );
          y = xy / x;
          z = xz / x;

        }

      } else if ( yy > zz ) {

        // m22 is the largest diagonal term

        if ( yy < epsilon ) {

          x = 0.707106781;
          y = 0;
          z = 0.707106781;

        } else {

          y = Math.sqrt( yy );
          x = xy / y;
          z = yz / y;

        }

      } else {

        // m33 is the largest diagonal term so base result on this

        if ( zz < epsilon ) {

          x = 0.707106781;
          y = 0.707106781;
          z = 0;

        } else {

          z = Math.sqrt( zz );
          x = xz / z;
          y = yz / z;

        }

      }

      this.set( x, y, z, angle );

      return this; // return 180 deg rotation

    }

    // as we have reached here there are no singularities so we can handle normally

    var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
              + ( m13 - m31 ) * ( m13 - m31 )
              + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    if ( Math.abs( s ) < 0.001 ) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = ( m32 - m23 ) / s;
    this.y = ( m13 - m31 ) / s;
    this.z = ( m21 - m12 ) / s;
    this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    if ( this.w > v.w ) {

      this.w = v.w;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    if ( this.w < v.w ) {

      this.w = v.w;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    if ( this.w < min.w ) {

      this.w = min.w;

    } else if ( this.w > max.w ) {

      this.w = max.w;

    }

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector4();
        max = new THREE.Vector4();

      }

      min.set( minVal, minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  }(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );
    this.w = Math.floor( this.w );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );
    this.w = Math.ceil( this.w );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );
    this.w = Math.round( this.w );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;
    this.w = - this.w;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );

    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;
    this.w += ( v.w - this.w ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];
    this.w = array[ offset + 3 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;
    array[ offset + 3 ] = this.w;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];
    this.w = attribute.array[ index + 3 ];

    return this;

  }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

  constructor: THREE.Euler,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get order () {

    return this._order;

  },

  set order ( value ) {

    this._order = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, order ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;

  },

  clone: function () {

    return new this.constructor( this._x, this._y, this._z, this._order);

  },

  copy: function ( euler ) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m, order, update ) {

    var clamp = THREE.Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._y = Math.asin( clamp( m13, - 1, 1 ) );

      if ( Math.abs( m13 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m33 );
        this._z = Math.atan2( - m12, m11 );

      } else {

        this._x = Math.atan2( m32, m22 );
        this._z = 0;

      }

    } else if ( order === 'YXZ' ) {

      this._x = Math.asin( - clamp( m23, - 1, 1 ) );

      if ( Math.abs( m23 ) < 0.99999 ) {

        this._y = Math.atan2( m13, m33 );
        this._z = Math.atan2( m21, m22 );

      } else {

        this._y = Math.atan2( - m31, m11 );
        this._z = 0;

      }

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin( clamp( m32, - 1, 1 ) );

      if ( Math.abs( m32 ) < 0.99999 ) {

        this._y = Math.atan2( - m31, m33 );
        this._z = Math.atan2( - m12, m22 );

      } else {

        this._y = 0;
        this._z = Math.atan2( m21, m11 );

      }

    } else if ( order === 'ZYX' ) {

      this._y = Math.asin( - clamp( m31, - 1, 1 ) );

      if ( Math.abs( m31 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m33 );
        this._z = Math.atan2( m21, m11 );

      } else {

        this._x = 0;
        this._z = Math.atan2( - m12, m22 );

      }

    } else if ( order === 'YZX' ) {

      this._z = Math.asin( clamp( m21, - 1, 1 ) );

      if ( Math.abs( m21 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m22 );
        this._y = Math.atan2( - m31, m11 );

      } else {

        this._x = 0;
        this._y = Math.atan2( m13, m33 );

      }

    } else if ( order === 'XZY' ) {

      this._z = Math.asin( - clamp( m12, - 1, 1 ) );

      if ( Math.abs( m12 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m22 );
        this._y = Math.atan2( m13, m11 );

      } else {

        this._x = Math.atan2( - m23, m33 );
        this._y = 0;

      }

    } else {

      console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

    }

    this._order = order;

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromQuaternion: function () {

    var matrix;

    return function ( q, order, update ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();
      matrix.makeRotationFromQuaternion( q );
      this.setFromRotationMatrix( matrix, order, update );

      return this;

    };

  }(),

  setFromVector3: function ( v, order ) {

    return this.set( v.x, v.y, v.z, order || this._order );

  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new THREE.Quaternion();

    return function ( newOrder ) {

      q.setFromEuler( this );
      this.setFromQuaternion( q, newOrder );

    };

  }(),

  equals: function ( euler ) {

    return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  },

  fromArray: function ( array ) {

    this._x = array[ 0 ];
    this._y = array[ 1 ];
    this._z = array[ 2 ];
    if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._order;

    return array;

  },

  toVector3: function ( optionalResult ) {

    if ( optionalResult ) {

      return optionalResult.set( this._x, this._y, this._z );

    } else {

      return new THREE.Vector3( this._x, this._y, this._z );

    }

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

  this.start = ( start !== undefined ) ? start : new THREE.Vector3();
  this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

  constructor: THREE.Line3,

  set: function ( start, end ) {

    this.start.copy( start );
    this.end.copy( end );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( line ) {

    this.start.copy( line.start );
    this.end.copy( line.end );

    return this;

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  },

  delta: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.end, this.start );

  },

  distanceSq: function () {

    return this.start.distanceToSquared( this.end );

  },

  distance: function () {

    return this.start.distanceTo( this.end );

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  closestPointToPointParameter: function () {

    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();

    return function ( point, clampToLine ) {

      startP.subVectors( point, this.start );
      startEnd.subVectors( this.end, this.start );

      var startEnd2 = startEnd.dot( startEnd );
      var startEnd_startP = startEnd.dot( startP );

      var t = startEnd_startP / startEnd2;

      if ( clampToLine ) {

        t = THREE.Math.clamp( t, 0, 1 );

      }

      return t;

    };

  }(),

  closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    var t = this.closestPointToPointParameter( point, clampToLine );

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  applyMatrix4: function ( matrix ) {

    this.start.applyMatrix4( matrix );
    this.end.applyMatrix4( matrix );

    return this;

  },

  equals: function ( line ) {

    return line.start.equals( this.start ) && line.end.equals( this.end );

  }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

  constructor: THREE.Box2,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] )

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector2();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
         ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector2();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector2();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

  constructor: THREE.Box3,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] );

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector3();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  setFromObject: function () {

    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms

    var v1 = new THREE.Vector3();

    return function ( object ) {

      var scope = this;

      object.updateMatrixWorld( true );

      this.makeEmpty();

      object.traverse( function ( node ) {

        var geometry = node.geometry;

        if ( geometry !== undefined ) {

          if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;

            for ( var i = 0, il = vertices.length; i < il; i ++ ) {

              v1.copy( vertices[ i ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          } else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

            var positions = geometry.attributes[ 'position' ].array;

            for ( var i = 0, il = positions.length; i < il; i += 3 ) {

              v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          }

        }

      } );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ||
         point.z < this.min.z || point.z > this.max.z ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
       ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
       ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector3();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
      ( point.z - this.min.z ) / ( this.max.z - this.min.z )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ||
         box.max.z < this.min.z || box.min.z > this.max.z ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  getBoundingSphere: function () {

    var v1 = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Sphere();

      result.center = this.center();
      result.radius = this.size( v1 ).length() * 0.5;

      return result;

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  applyMatrix4: function () {

    var points = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];

    return function ( matrix ) {

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
      points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
      points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
      points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
      points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
      points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
      points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
      points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

      this.makeEmpty();
      this.setFromPoints( points );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

  this.elements = new Float32Array( [

    1, 0, 0,
    0, 1, 0,
    0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix3.prototype = {

  constructor: THREE.Matrix3,

  set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
    te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
    te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0,
      0, 1, 0,
      0, 0, 1

    );

    return this;

  },

  clone: function () {

    return new this.constructor().fromArray( this.elements );

  },

  copy: function ( m ) {

    var me = m.elements;

    this.set(

      me[ 0 ], me[ 3 ], me[ 6 ],
      me[ 1 ], me[ 4 ], me[ 7 ],
      me[ 2 ], me[ 5 ], me[ 8 ]

    );

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    return vector.applyMatrix3( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix3( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix3( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    return this;

  },

  determinant: function () {

    var te = this.elements;

    var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
      d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
      g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  },

  getInverse: function ( matrix, throwOnInvertible ) {

    // input: THREE.Matrix4
    // ( based on http://code.google.com/p/webgl-mjs/ )

    var me = matrix.elements;
    var te = this.elements;

    te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
    te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
    te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
    te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
    te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
    te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
    te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
    te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
    te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

    var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

    // no inverse

    if ( det === 0 ) {

      var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1.0 / det );

    return this;

  },

  transpose: function () {

    var tmp, m = this.elements;

    tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];

    array[ offset + 3 ] = te[ 3 ];
    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];

    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];
    array[ offset + 8 ]  = te[ 8 ];

    return array;

  },

  getNormalMatrix: function ( m ) {

    // input: THREE.Matrix4

    this.getInverse( m ).transpose();

    return this;

  },

  transposeIntoArray: function ( r ) {

    var m = this.elements;

    r[ 0 ] = m[ 0 ];
    r[ 1 ] = m[ 3 ];
    r[ 2 ] = m[ 6 ];
    r[ 3 ] = m[ 1 ];
    r[ 4 ] = m[ 4 ];
    r[ 5 ] = m[ 7 ];
    r[ 6 ] = m[ 2 ];
    r[ 7 ] = m[ 5 ];
    r[ 8 ] = m[ 8 ];

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ],
      te[ 3 ], te[ 4 ], te[ 5 ],
      te[ 6 ], te[ 7 ], te[ 8 ]
    ];

  }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

  this.elements = new Float32Array( [

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix4.prototype = {

  constructor: THREE.Matrix4,

  set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  clone: function () {

    return new THREE.Matrix4().fromArray( this.elements );

  },

  copy: function ( m ) {

    this.elements.set( m.elements );

    return this;

  },

  extractPosition: function ( m ) {

    console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    return this.copyPosition( m );

  },

  copyPosition: function ( m ) {

    var te = this.elements;
    var me = m.elements;

    te[ 12 ] = me[ 12 ];
    te[ 13 ] = me[ 13 ];
    te[ 14 ] = me[ 14 ];

    return this;

  },

  extractBasis: function ( xAxis, yAxis, zAxis ) {

    var te = this.elements;

    xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
    yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
    zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

    return this;

  },

  makeBasis: function ( xAxis, yAxis, zAxis ) {

    this.set(
      xAxis.x, yAxis.x, zAxis.x, 0,
      xAxis.y, yAxis.y, zAxis.y, 0,
      xAxis.z, yAxis.z, zAxis.z, 0,
      0,       0,       0,       1
    );

    return this;

  },

  extractRotation: function () {

    var v1;

    return function ( m ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
      var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
      var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

      te[ 0 ] = me[ 0 ] * scaleX;
      te[ 1 ] = me[ 1 ] * scaleX;
      te[ 2 ] = me[ 2 ] * scaleX;

      te[ 4 ] = me[ 4 ] * scaleY;
      te[ 5 ] = me[ 5 ] * scaleY;
      te[ 6 ] = me[ 6 ] * scaleY;

      te[ 8 ] = me[ 8 ] * scaleZ;
      te[ 9 ] = me[ 9 ] * scaleZ;
      te[ 10 ] = me[ 10 ] * scaleZ;

      return this;

    };

  }(),

  makeRotationFromEuler: function ( euler ) {

    if ( euler instanceof THREE.Euler === false ) {

      console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    var te = this.elements;

    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos( x ), b = Math.sin( x );
    var c = Math.cos( y ), d = Math.sin( y );
    var e = Math.cos( z ), f = Math.sin( z );

    if ( euler.order === 'XYZ' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = - c * f;
      te[ 8 ] = d;

      te[ 1 ] = af + be * d;
      te[ 5 ] = ae - bf * d;
      te[ 9 ] = - b * c;

      te[ 2 ] = bf - ae * d;
      te[ 6 ] = be + af * d;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YXZ' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce + df * b;
      te[ 4 ] = de * b - cf;
      te[ 8 ] = a * d;

      te[ 1 ] = a * f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b;

      te[ 2 ] = cf * b - de;
      te[ 6 ] = df + ce * b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZXY' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce - df * b;
      te[ 4 ] = - a * f;
      te[ 8 ] = de + cf * b;

      te[ 1 ] = cf + de * b;
      te[ 5 ] = a * e;
      te[ 9 ] = df - ce * b;

      te[ 2 ] = - a * d;
      te[ 6 ] = b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZYX' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = be * d - af;
      te[ 8 ] = ae * d + bf;

      te[ 1 ] = c * f;
      te[ 5 ] = bf * d + ae;
      te[ 9 ] = af * d - be;

      te[ 2 ] = - d;
      te[ 6 ] = b * c;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YZX' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = bd - ac * f;
      te[ 8 ] = bc * f + ad;

      te[ 1 ] = f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b * e;

      te[ 2 ] = - d * e;
      te[ 6 ] = ad * f + bc;
      te[ 10 ] = ac - bd * f;

    } else if ( euler.order === 'XZY' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = - f;
      te[ 8 ] = d * e;

      te[ 1 ] = ac * f + bd;
      te[ 5 ] = a * e;
      te[ 9 ] = ad * f - bc;

      te[ 2 ] = bc * f - ad;
      te[ 6 ] = b * e;
      te[ 10 ] = bd * f + ac;

    }

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  setRotationFromQuaternion: function ( q ) {

    console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

    return this.makeRotationFromQuaternion( q );

  },

  makeRotationFromQuaternion: function ( q ) {

    var te = this.elements;

    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;

    te[ 0 ] = 1 - ( yy + zz );
    te[ 4 ] = xy - wz;
    te[ 8 ] = xz + wy;

    te[ 1 ] = xy + wz;
    te[ 5 ] = 1 - ( xx + zz );
    te[ 9 ] = yz - wx;

    te[ 2 ] = xz - wy;
    te[ 6 ] = yz + wx;
    te[ 10 ] = 1 - ( xx + yy );

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  lookAt: function () {

    var x, y, z;

    return function ( eye, target, up ) {

      if ( x === undefined ) x = new THREE.Vector3();
      if ( y === undefined ) y = new THREE.Vector3();
      if ( z === undefined ) z = new THREE.Vector3();

      var te = this.elements;

      z.subVectors( eye, target ).normalize();

      if ( z.length() === 0 ) {

        z.z = 1;

      }

      x.crossVectors( up, z ).normalize();

      if ( x.length() === 0 ) {

        z.x += 0.0001;
        x.crossVectors( up, z ).normalize();

      }

      y.crossVectors( z, x );


      te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
      te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
      te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

      return this;

    };

  }(),

  multiply: function ( m, n ) {

    if ( n !== undefined ) {

      console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
      return this.multiplyMatrices( m, n );

    }

    return this.multiplyMatrices( this, m );

  },

  multiplyMatrices: function ( a, b ) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;

  },

  multiplyToArray: function ( a, b, r ) {

    var te = this.elements;

    this.multiplyMatrices( a, b );

    r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    return this;

  },

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    return vector.applyProjection( this );

  },

  multiplyVector4: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix4( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix4( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  rotateAxis: function ( v ) {

    console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

    v.transformDirection( this );

  },

  crossVector: function ( vector ) {

    console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  determinant: function () {

    var te = this.elements;

    var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return (
      n41 * (
        + n14 * n23 * n32
         - n13 * n24 * n32
         - n14 * n22 * n33
         + n12 * n24 * n33
         + n13 * n22 * n34
         - n12 * n23 * n34
      ) +
      n42 * (
        + n11 * n23 * n34
         - n11 * n24 * n33
         + n14 * n21 * n33
         - n13 * n21 * n34
         + n13 * n24 * n31
         - n14 * n23 * n31
      ) +
      n43 * (
        + n11 * n24 * n32
         - n11 * n22 * n34
         - n14 * n21 * n32
         + n12 * n21 * n34
         + n14 * n22 * n31
         - n12 * n24 * n31
      ) +
      n44 * (
        - n13 * n22 * n31
         - n11 * n23 * n32
         + n11 * n22 * n33
         + n13 * n21 * n32
         - n12 * n21 * n33
         + n12 * n23 * n31
      )

    );

  },

  transpose: function () {

    var te = this.elements;
    var tmp;

    tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];
    array[ offset + 3 ] = te[ 3 ];

    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];
    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];

    array[ offset + 8 ]  = te[ 8 ];
    array[ offset + 9 ]  = te[ 9 ];
    array[ offset + 10 ] = te[ 10 ];
    array[ offset + 11 ] = te[ 11 ];

    array[ offset + 12 ] = te[ 12 ];
    array[ offset + 13 ] = te[ 13 ];
    array[ offset + 14 ] = te[ 14 ];
    array[ offset + 15 ] = te[ 15 ];

    return array;

  },

  getPosition: function () {

    var v1;

    return function () {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

      var te = this.elements;
      return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

    };

  }(),

  setPosition: function ( v ) {

    var te = this.elements;

    te[ 12 ] = v.x;
    te[ 13 ] = v.y;
    te[ 14 ] = v.z;

    return this;

  },

  getInverse: function ( m, throwOnInvertible ) {

    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements;
    var me = m.elements;

    var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
    var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
    var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
    var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

    te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

    var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

    if ( det === 0 ) {

      var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1 / det );

    return this;

  },

  translate: function ( v ) {

    console.error( 'THREE.Matrix4: .translate() has been removed.' );

  },

  rotateX: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  },

  rotateY: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  },

  rotateZ: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  },

  rotateByAxis: function ( axis, angle ) {

    console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  },

  scale: function ( v ) {

    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;

    te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    return this;

  },

  getMaxScaleOnAxis: function () {

    var te = this.elements;

    var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

  },

  makeTranslation: function ( x, y, z ) {

    this.set(

      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationX: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      1, 0,  0, 0,
      0, c, - s, 0,
      0, s,  c, 0,
      0, 0,  0, 1

    );

    return this;

  },

  makeRotationY: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

       c, 0, s, 0,
       0, 1, 0, 0,
      - s, 0, c, 0,
       0, 0, 0, 1

    );

    return this;

  },

  makeRotationZ: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      c, - s, 0, 0,
      s,  c, 0, 0,
      0,  0, 1, 0,
      0,  0, 0, 1

    );

    return this;

  },

  makeRotationAxis: function ( axis, angle ) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;

    this.set(

      tx * x + c, tx * y - s * z, tx * z + s * y, 0,
      tx * y + s * z, ty * y + c, ty * z - s * x, 0,
      tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
      0, 0, 0, 1

    );

     return this;

  },

  makeScale: function ( x, y, z ) {

    this.set(

      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1

    );

    return this;

  },

  compose: function ( position, quaternion, scale ) {

    this.makeRotationFromQuaternion( quaternion );
    this.scale( scale );
    this.setPosition( position );

    return this;

  },

  decompose: function () {

    var vector, matrix;

    return function ( position, quaternion, scale ) {

      if ( vector === undefined ) vector = new THREE.Vector3();
      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      var te = this.elements;

      var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
      var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
      var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if ( det < 0 ) {

        sx = - sx;

      }

      position.x = te[ 12 ];
      position.y = te[ 13 ];
      position.z = te[ 14 ];

      // scale the rotation part

      matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[ 0 ] *= invSX;
      matrix.elements[ 1 ] *= invSX;
      matrix.elements[ 2 ] *= invSX;

      matrix.elements[ 4 ] *= invSY;
      matrix.elements[ 5 ] *= invSY;
      matrix.elements[ 6 ] *= invSY;

      matrix.elements[ 8 ] *= invSZ;
      matrix.elements[ 9 ] *= invSZ;
      matrix.elements[ 10 ] *= invSZ;

      quaternion.setFromRotationMatrix( matrix );

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;

    };

  }(),

  makeFrustum: function ( left, right, bottom, top, near, far ) {

    var te = this.elements;
    var x = 2 * near / ( right - left );
    var y = 2 * near / ( top - bottom );

    var a = ( right + left ) / ( right - left );
    var b = ( top + bottom ) / ( top - bottom );
    var c = - ( far + near ) / ( far - near );
    var d = - 2 * far * near / ( far - near );

    te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;
    te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;

    return this;

  },

  makePerspective: function ( fov, aspect, near, far ) {

    var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
    var ymin = - ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

  },

  makeOrthographic: function ( left, right, top, bottom, near, far ) {

    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;

    var x = ( right + left ) / w;
    var y = ( top + bottom ) / h;
    var z = ( far + near ) / p;

    te[ 0 ] = 2 / w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;
    te[ 1 ] = 0;  te[ 5 ] = 2 / h;  te[ 9 ] = 0;  te[ 13 ] = - y;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 / p; te[ 14 ] = - z;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;

    return this;

  },

  equals: function ( matrix ) {

    var te = this.elements;
    var me = matrix.elements;

    for ( var i = 0; i < 16; i ++ ) {

      if ( te[ i ] !== me[ i ] ) return false;

    }

    return true;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
      te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
      te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
      te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
    ];

  }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

  this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
  this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

  constructor: THREE.Ray,

  set: function ( origin, direction ) {

    this.origin.copy( origin );
    this.direction.copy( direction );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( ray ) {

    this.origin.copy( ray.origin );
    this.direction.copy( ray.direction );

    return this;

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  },

  recast: function () {

    var v1 = new THREE.Vector3();

    return function ( t ) {

      this.origin.copy( this.at( t, v1 ) );

      return this;

    };

  }(),

  closestPointToPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    result.subVectors( point, this.origin );
    var directionDistance = result.dot( this.direction );

    if ( directionDistance < 0 ) {

      return result.copy( this.origin );

    }

    return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  },

  distanceToPoint: function ( point ) {

    return Math.sqrt( this.distanceSqToPoint( point ) );

  },

  distanceSqToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

      // point behind the ray

      if ( directionDistance < 0 ) {

        return this.origin.distanceToSquared( point );

      }

      v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

      return v1.distanceToSquared( point );

    };

  }(),

  distanceSqToSegment: function () {

    var segCenter = new THREE.Vector3();
    var segDir = new THREE.Vector3();
    var diff = new THREE.Vector3();

    return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

      // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
      segDir.copy( v1 ).sub( v0 ).normalize();
      diff.copy( this.origin ).sub( segCenter );

      var segExtent = v0.distanceTo( v1 ) * 0.5;
      var a01 = - this.direction.dot( segDir );
      var b0 = diff.dot( this.direction );
      var b1 = - diff.dot( segDir );
      var c = diff.lengthSq();
      var det = Math.abs( 1 - a01 * a01 );
      var s0, s1, sqrDist, extDet;

      if ( det > 0 ) {

        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if ( s0 >= 0 ) {

          if ( s1 >= - extDet ) {

            if ( s1 <= extDet ) {

              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

            } else {

              // region 1

              s1 = segExtent;
              s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

          } else {

            // region 5

            s1 = - segExtent;
            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        } else {

          if ( s1 <= - extDet ) {

            // region 4

            s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          } else if ( s1 <= extDet ) {

            // region 3

            s0 = 0;
            s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = s1 * ( s1 + 2 * b1 ) + c;

          } else {

            // region 2

            s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        }

      } else {

        // Ray and segment are parallel.

        s1 = ( a01 > 0 ) ? - segExtent : segExtent;
        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

      }

      if ( optionalPointOnRay ) {

        optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

      }

      if ( optionalPointOnSegment ) {

        optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

      }

      return sqrDist;

    };

  }(),


  isIntersectionSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) <= sphere.radius;

  },

  intersectSphere: function () {

    // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

    var v1 = new THREE.Vector3();

    return function ( sphere, optionalTarget ) {

      v1.subVectors( sphere.center, this.origin );

      var tca = v1.dot( this.direction );

      var d2 = v1.dot( v1 ) - tca * tca;

      var radius2 = sphere.radius * sphere.radius;

      if ( d2 > radius2 ) return null;

      var thc = Math.sqrt( radius2 - d2 );

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if both t0 and t1 are behind the ray - if so, return null
      if ( t0 < 0 && t1 < 0 ) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if ( t0 < 0 ) return this.at( t1, optionalTarget );

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at( t0, optionalTarget );

    }

  }(),

  isIntersectionPlane: function ( plane ) {

    // check if the ray lies on the plane first

    var distToPoint = plane.distanceToPoint( this.origin );

    if ( distToPoint === 0 ) {

      return true;

    }

    var denominator = plane.normal.dot( this.direction );

    if ( denominator * distToPoint < 0 ) {

      return true;

    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;

  },

  distanceToPlane: function ( plane ) {

    var denominator = plane.normal.dot( this.direction );
    if ( denominator === 0 ) {

      // line is coplanar, return origin
      if ( plane.distanceToPoint( this.origin ) === 0 ) {

        return 0;

      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;

    }

    var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t :  null;

  },

  intersectPlane: function ( plane, optionalTarget ) {

    var t = this.distanceToPlane( plane );

    if ( t === null ) {

      return null;

    }

    return this.at( t, optionalTarget );

  },

  isIntersectionBox: function () {

    var v = new THREE.Vector3();

    return function ( box ) {

      return this.intersectBox( box, v ) !== null;

    };

  }(),

  intersectBox: function ( box, optionalTarget ) {

    // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

    var tmin, tmax, tymin, tymax, tzmin, tzmax;

    var invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if ( invdirx >= 0 ) {

      tmin = ( box.min.x - origin.x ) * invdirx;
      tmax = ( box.max.x - origin.x ) * invdirx;

    } else {

      tmin = ( box.max.x - origin.x ) * invdirx;
      tmax = ( box.min.x - origin.x ) * invdirx;

    }

    if ( invdiry >= 0 ) {

      tymin = ( box.min.y - origin.y ) * invdiry;
      tymax = ( box.max.y - origin.y ) * invdiry;

    } else {

      tymin = ( box.max.y - origin.y ) * invdiry;
      tymax = ( box.min.y - origin.y ) * invdiry;

    }

    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    if ( invdirz >= 0 ) {

      tzmin = ( box.min.z - origin.z ) * invdirz;
      tzmax = ( box.max.z - origin.z ) * invdirz;

    } else {

      tzmin = ( box.max.z - origin.z ) * invdirz;
      tzmax = ( box.min.z - origin.z ) * invdirz;

    }

    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    //return point closest to the ray (positive side)

    if ( tmax < 0 ) return null;

    return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  },

  intersectTriangle: function () {

    // Compute the offset origin, edges, and normal.
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();

    return function ( a, b, c, backfaceCulling, optionalTarget ) {

      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

      edge1.subVectors( b, a );
      edge2.subVectors( c, a );
      normal.crossVectors( edge1, edge2 );

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot( normal );
      var sign;

      if ( DdN > 0 ) {

        if ( backfaceCulling ) return null;
        sign = 1;

      } else if ( DdN < 0 ) {

        sign = - 1;
        DdN = - DdN;

      } else {

        return null;

      }

      diff.subVectors( this.origin, a );
      var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

      // b1 < 0, no intersection
      if ( DdQxE2 < 0 ) {

        return null;

      }

      var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

      // b2 < 0, no intersection
      if ( DdE1xQ < 0 ) {

        return null;

      }

      // b1+b2 > 1, no intersection
      if ( DdQxE2 + DdE1xQ > DdN ) {

        return null;

      }

      // Line intersects triangle, check if ray does.
      var QdN = - sign * diff.dot( normal );

      // t < 0, no intersection
      if ( QdN < 0 ) {

        return null;

      }

      // Ray intersects triangle.
      return this.at( QdN / DdN, optionalTarget );

    };

  }(),

  applyMatrix4: function ( matrix4 ) {

    this.direction.add( this.origin ).applyMatrix4( matrix4 );
    this.origin.applyMatrix4( matrix4 );
    this.direction.sub( this.origin );
    this.direction.normalize();

    return this;

  },

  equals: function ( ray ) {

    return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

  this.center = ( center !== undefined ) ? center : new THREE.Vector3();
  this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

  constructor: THREE.Sphere,

  set: function ( center, radius ) {

    this.center.copy( center );
    this.radius = radius;

    return this;

  },

  setFromPoints: function () {

    var box = new THREE.Box3();

    return function ( points, optionalCenter ) {

      var center = this.center;

      if ( optionalCenter !== undefined ) {

        center.copy( optionalCenter );

      } else {

        box.setFromPoints( points ).center( center );

      }

      var maxRadiusSq = 0;

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

      }

      this.radius = Math.sqrt( maxRadiusSq );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( sphere ) {

    this.center.copy( sphere.center );
    this.radius = sphere.radius;

    return this;

  },

  empty: function () {

    return ( this.radius <= 0 );

  },

  containsPoint: function ( point ) {

    return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  },

  distanceToPoint: function ( point ) {

    return ( point.distanceTo( this.center ) - this.radius );

  },

  intersectsSphere: function ( sphere ) {

    var radiusSum = this.radius + sphere.radius;

    return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  },

  clampPoint: function ( point, optionalTarget ) {

    var deltaLengthSq = this.center.distanceToSquared( point );

    var result = optionalTarget || new THREE.Vector3();
    result.copy( point );

    if ( deltaLengthSq > ( this.radius * this.radius ) ) {

      result.sub( this.center ).normalize();
      result.multiplyScalar( this.radius ).add( this.center );

    }

    return result;

  },

  getBoundingBox: function ( optionalTarget ) {

    var box = optionalTarget || new THREE.Box3();

    box.set( this.center, this.center );
    box.expandByScalar( this.radius );

    return box;

  },

  applyMatrix4: function ( matrix ) {

    this.center.applyMatrix4( matrix );
    this.radius = this.radius * matrix.getMaxScaleOnAxis();

    return this;

  },

  translate: function ( offset ) {

    this.center.add( offset );

    return this;

  },

  equals: function ( sphere ) {

    return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

  this.planes = [

    ( p0 !== undefined ) ? p0 : new THREE.Plane(),
    ( p1 !== undefined ) ? p1 : new THREE.Plane(),
    ( p2 !== undefined ) ? p2 : new THREE.Plane(),
    ( p3 !== undefined ) ? p3 : new THREE.Plane(),
    ( p4 !== undefined ) ? p4 : new THREE.Plane(),
    ( p5 !== undefined ) ? p5 : new THREE.Plane()

  ];

};

THREE.Frustum.prototype = {

  constructor: THREE.Frustum,

  set: function ( p0, p1, p2, p3, p4, p5 ) {

    var planes = this.planes;

    planes[ 0 ].copy( p0 );
    planes[ 1 ].copy( p1 );
    planes[ 2 ].copy( p2 );
    planes[ 3 ].copy( p3 );
    planes[ 4 ].copy( p4 );
    planes[ 5 ].copy( p5 );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( frustum ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      planes[ i ].copy( frustum.planes[ i ] );

    }

    return this;

  },

  setFromMatrix: function ( m ) {

    var planes = this.planes;
    var me = m.elements;
    var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    return this;

  },

  intersectsObject: function () {

    var sphere = new THREE.Sphere();

    return function ( object ) {

      var geometry = object.geometry;

      if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

      sphere.copy( geometry.boundingSphere );
      sphere.applyMatrix4( object.matrixWorld );

      return this.intersectsSphere( sphere );

    };

  }(),

  intersectsSphere: function ( sphere ) {

    var planes = this.planes;
    var center = sphere.center;
    var negRadius = - sphere.radius;

    for ( var i = 0; i < 6; i ++ ) {

      var distance = planes[ i ].distanceToPoint( center );

      if ( distance < negRadius ) {

        return false;

      }

    }

    return true;

  },

  intersectsBox: function () {

    var p1 = new THREE.Vector3(),
      p2 = new THREE.Vector3();

    return function ( box ) {

      var planes = this.planes;

      for ( var i = 0; i < 6 ; i ++ ) {

        var plane = planes[ i ];

        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        var d1 = plane.distanceToPoint( p1 );
        var d2 = plane.distanceToPoint( p2 );

        // if both outside plane, no intersection

        if ( d1 < 0 && d2 < 0 ) {

          return false;

        }

      }

      return true;

    };

  }(),


  containsPoint: function ( point ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      if ( planes[ i ].distanceToPoint( point ) < 0 ) {

        return false;

      }

    }

    return true;

  }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

  this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
  this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

  constructor: THREE.Plane,

  set: function ( normal, constant ) {

    this.normal.copy( normal );
    this.constant = constant;

    return this;

  },

  setComponents: function ( x, y, z, w ) {

    this.normal.set( x, y, z );
    this.constant = w;

    return this;

  },

  setFromNormalAndCoplanarPoint: function ( normal, point ) {

    this.normal.copy( normal );
    this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

    return this;

  },

  setFromCoplanarPoints: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( a, b, c ) {

      var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint( normal, a );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( plane ) {

    this.normal.copy( plane.normal );
    this.constant = plane.constant;

    return this;

  },

  normalize: function () {

    // Note: will lead to a divide by zero if the plane is invalid.

    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar( inverseNormalLength );
    this.constant *= inverseNormalLength;

    return this;

  },

  negate: function () {

    this.constant *= - 1;
    this.normal.negate();

    return this;

  },

  distanceToPoint: function ( point ) {

    return this.normal.dot( point ) + this.constant;

  },

  distanceToSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) - sphere.radius;

  },

  projectPoint: function ( point, optionalTarget ) {

    return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

  },

  orthoPoint: function ( point, optionalTarget ) {

    var perpendicularMagnitude = this.distanceToPoint( point );

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

  },

  isIntersectionLine: function ( line ) {

    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    var startSign = this.distanceToPoint( line.start );
    var endSign = this.distanceToPoint( line.end );

    return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  },

  intersectLine: function () {

    var v1 = new THREE.Vector3();

    return function ( line, optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      var direction = line.delta( v1 );

      var denominator = this.normal.dot( direction );

      if ( denominator === 0 ) {

        // line is coplanar, return origin
        if ( this.distanceToPoint( line.start ) === 0 ) {

          return result.copy( line.start );

        }

        // Unsure if this is the correct method to handle this case.
        return undefined;

      }

      var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

      if ( t < 0 || t > 1 ) {

        return undefined;

      }

      return result.copy( direction ).multiplyScalar( t ).add( line.start );

    };

  }(),


  coplanarPoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( - this.constant );

  },

  applyMatrix4: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var m1 = new THREE.Matrix3();

    return function ( matrix, optionalNormalMatrix ) {

      // compute new normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
      var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

      var newCoplanarPoint = this.coplanarPoint( v2 );
      newCoplanarPoint.applyMatrix4( matrix );

      this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.constant = this.constant - offset.dot( this.normal );

    return this;

  },

  equals: function ( plane ) {

    return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    var uuid = new Array( 36 );
    var rnd = 0, r;

    return function () {

      for ( var i = 0; i < 36; i ++ ) {

        if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

          uuid[ i ] = '-';

        } else if ( i === 14 ) {

          uuid[ i ] = '4';

        } else {

          if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

        }

      }

      return uuid.join( '' );

    };

  }(),

  // Clamp value to range <a, b>

  clamp: function ( x, a, b ) {

    return ( x < a ) ? a : ( ( x > b ) ? b : x );

  },

  // Clamp value to range <a, inf)

  clampBottom: function ( x, a ) {

    return x < a ? a : x;

  },

  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation

  euclideanModulo: function ( n, m ) {

    return ( ( n % m ) + m ) % m;

  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function ( x, a1, a2, b1, b2 ) {

    return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * ( 3 - 2 * x );

  },

  smootherstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  },

  // Random float from <0, 1> with 16 bits of randomness
  // (standard Math.random() creates repetitive patterns when applied over larger space)

  random16: function () {

    return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

  },

  // Random integer from <low, high> interval

  randInt: function ( low, high ) {

    return low + Math.floor( Math.random() * ( high - low + 1 ) );

  },

  // Random float from <low, high> interval

  randFloat: function ( low, high ) {

    return low + Math.random() * ( high - low );

  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function ( range ) {

    return range * ( 0.5 - Math.random() );

  },

  degToRad: function () {

    var degreeToRadiansFactor = Math.PI / 180;

    return function ( degrees ) {

      return degrees * degreeToRadiansFactor;

    };

  }(),

  radToDeg: function () {

    var radianToDegreesFactor = 180 / Math.PI;

    return function ( radians ) {

      return radians * radianToDegreesFactor;

    };

  }(),

  isPowerOfTwo: function ( value ) {

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  },

  nextPowerOfTwo: function ( value ) {

    value --;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value ++;

    return value;

  }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

  this.points = points;

  var c = [], v3 = { x: 0, y: 0, z: 0 },
  point, intPoint, weight, w2, w3,
  pa, pb, pc, pd;

  this.initFromArray = function ( a ) {

    this.points = [];

    for ( var i = 0; i < a.length; i ++ ) {

      this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    }

  };

  this.getPoint = function ( k ) {

    point = ( this.points.length - 1 ) * k;
    intPoint = Math.floor( point );
    weight = point - intPoint;

    c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    c[ 1 ] = intPoint;
    c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    pa = this.points[ c[ 0 ] ];
    pb = this.points[ c[ 1 ] ];
    pc = this.points[ c[ 2 ] ];
    pd = this.points[ c[ 3 ] ];

    w2 = weight * weight;
    w3 = weight * w2;

    v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    return v3;

  };

  this.getControlPointsArray = function () {

    var i, p, l = this.points.length,
      coords = [];

    for ( i = 0; i < l; i ++ ) {

      p = this.points[ i ];
      coords[ i ] = [ p.x, p.y, p.z ];

    }

    return coords;

  };

  // approximate length by summing linear segments

  this.getLength = function ( nSubDivisions ) {

    var i, index, nSamples, position,
      point = 0, intPoint = 0, oldIntPoint = 0,
      oldPosition = new THREE.Vector3(),
      tmpVec = new THREE.Vector3(),
      chunkLengths = [],
      totalLength = 0;

    // first point has 0 length

    chunkLengths[ 0 ] = 0;

    if ( ! nSubDivisions ) nSubDivisions = 100;

    nSamples = this.points.length * nSubDivisions;

    oldPosition.copy( this.points[ 0 ] );

    for ( i = 1; i < nSamples; i ++ ) {

      index = i / nSamples;

      position = this.getPoint( index );
      tmpVec.copy( position );

      totalLength += tmpVec.distanceTo( oldPosition );

      oldPosition.copy( position );

      point = ( this.points.length - 1 ) * index;
      intPoint = Math.floor( point );

      if ( intPoint !== oldIntPoint ) {

        chunkLengths[ intPoint ] = totalLength;
        oldIntPoint = intPoint;

      }

    }

    // last point ends with total length

    chunkLengths[ chunkLengths.length ] = totalLength;

    return { chunks: chunkLengths, total: totalLength };

  };

  this.reparametrizeByArcLength = function ( samplingCoef ) {

    var i, j,
      index, indexCurrent, indexNext,
      realDistance,
      sampling, position,
      newpoints = [],
      tmpVec = new THREE.Vector3(),
      sl = this.getLength();

    newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    for ( i = 1; i < this.points.length; i ++ ) {

      //tmpVec.copy( this.points[ i - 1 ] );
      //linearDistance = tmpVec.distanceTo( this.points[ i ] );

      realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

      sampling = Math.ceil( samplingCoef * realDistance / sl.total );

      indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
      indexNext = i / ( this.points.length - 1 );

      for ( j = 1; j < sampling - 1; j ++ ) {

        index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

        position = this.getPoint( index );
        newpoints.push( tmpVec.copy( position ).clone() );

      }

      newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    }

    this.points = newpoints;

  };

  // Catmull-Rom

  function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    var v0 = ( p2 - p0 ) * 0.5,
      v1 = ( p3 - p1 ) * 0.5;

    return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

  this.a = ( a !== undefined ) ? a : new THREE.Vector3();
  this.b = ( b !== undefined ) ? b : new THREE.Vector3();
  this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

  var v0 = new THREE.Vector3();

  return function ( a, b, c, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    result.subVectors( c, b );
    v0.subVectors( a, b );
    result.cross( v0 );

    var resultLengthSq = result.lengthSq();
    if ( resultLengthSq > 0 ) {

      return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    }

    return result.set( 0, 0, 0 );

  };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( point, a, b, c, optionalTarget ) {

    v0.subVectors( c, a );
    v1.subVectors( b, a );
    v2.subVectors( point, a );

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var denom = ( dot00 * dot11 - dot01 * dot01 );

    var result = optionalTarget || new THREE.Vector3();

    // collinear or singular triangle
    if ( denom === 0 ) {

      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set( - 2, - 1, - 1 );

    }

    var invDenom = 1 / denom;
    var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    // barycentric coordinates must always sum to 1
    return result.set( 1 - u - v, v, u );

  };

}();

THREE.Triangle.containsPoint = function () {

  var v1 = new THREE.Vector3();

  return function ( point, a, b, c ) {

    var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

    return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  };

}();

THREE.Triangle.prototype = {

  constructor: THREE.Triangle,

  set: function ( a, b, c ) {

    this.a.copy( a );
    this.b.copy( b );
    this.c.copy( c );

    return this;

  },

  setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    this.a.copy( points[ i0 ] );
    this.b.copy( points[ i1 ] );
    this.c.copy( points[ i2 ] );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( triangle ) {

    this.a.copy( triangle.a );
    this.b.copy( triangle.b );
    this.c.copy( triangle.c );

    return this;

  },

  area: function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();

    return function () {

      v0.subVectors( this.c, this.b );
      v1.subVectors( this.a, this.b );

      return v0.cross( v1 ).length() * 0.5;

    };

  }(),

  midpoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  },

  normal: function ( optionalTarget ) {

    return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

  },

  plane: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Plane();

    return result.setFromCoplanarPoints( this.a, this.b, this.c );

  },

  barycoordFromPoint: function ( point, optionalTarget ) {

    return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  },

  containsPoint: function ( point ) {

    return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

  },

  equals: function ( triangle ) {

    return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

  this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;

  this.running = false;

};

THREE.Clock.prototype = {

  constructor: THREE.Clock,

  start: function () {

    this.startTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

    this.oldTime = this.startTime;
    this.running = true;

  },

  stop: function () {

    this.getElapsedTime();
    this.running = false;

  },

  getElapsedTime: function () {

    this.getDelta();
    return this.elapsedTime;

  },

  getDelta: function () {

    var diff = 0;

    if ( this.autoStart && ! this.running ) {

      this.start();

    }

    if ( this.running ) {

      var newTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

      diff = 0.001 * ( newTime - this.oldTime );
      this.oldTime = newTime;

      this.elapsedTime += diff;

    }

    return diff;

  }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

  constructor: THREE.EventDispatcher,

  apply: function ( object ) {

    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

  },

  addEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) this._listeners = {};

    var listeners = this._listeners;

    if ( listeners[ type ] === undefined ) {

      listeners[ type ] = [];

    }

    if ( listeners[ type ].indexOf( listener ) === - 1 ) {

      listeners[ type ].push( listener );

    }

  },

  hasEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return false;

    var listeners = this._listeners;

    if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

      return true;

    }

    return false;

  },

  removeEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ type ];

    if ( listenerArray !== undefined ) {

      var index = listenerArray.indexOf( listener );

      if ( index !== - 1 ) {

        listenerArray.splice( index, 1 );

      }

    }

  },

  dispatchEvent: function ( event ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ event.type ];

    if ( listenerArray !== undefined ) {

      event.target = this;

      var array = [];
      var length = listenerArray.length;

      for ( var i = 0; i < length; i ++ ) {

        array[ i ] = listenerArray[ i ];

      }

      for ( var i = 0; i < length; i ++ ) {

        array[ i ].call( this, event );

      }

    }

  }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

  THREE.Raycaster = function ( origin, direction, near, far ) {

    this.ray = new THREE.Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Sprite: {},
      Mesh: {},
      PointCloud: { threshold: 1 },
      LOD: {},
      Line: {}
    };

  };

  var descSort = function ( a, b ) {

    return a.distance - b.distance;

  };

  var intersectObject = function ( object, raycaster, intersects, recursive ) {

    if ( object.visible === false ) return;

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  };

  //

  THREE.Raycaster.prototype = {

    constructor: THREE.Raycaster,

    linePrecision: 1,

    set: function ( origin, direction ) {

      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set( origin, direction );

    },

    setFromCamera: function ( coords, camera ) {

      if ( camera instanceof THREE.PerspectiveCamera ) {

        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

      } else if ( camera instanceof THREE.OrthographicCamera ) {

        this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

      } else {

        console.error( 'THREE.Raycaster: Unsupported camera type.' );

      }

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( descSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( Array.isArray( objects ) === false ) {

        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( descSort );

      return intersects;

    }

  };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

  Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Object3D';

  this.parent = null;
  this.children = [];

  this.up = THREE.Object3D.DefaultUp.clone();

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3( 1, 1, 1 );

  var onRotationChange = function () {

    quaternion.setFromEuler( rotation, false );

  };

  var onQuaternionChange = function () {

    rotation.setFromQuaternion( quaternion, undefined, false );

  };

  rotation.onChange( onRotationChange );
  quaternion.onChange( onQuaternionChange );

  Object.defineProperties( this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new THREE.Matrix4()
    },
    normalMatrix: {
      value: new THREE.Matrix3()
    }
  } );

  this.rotationAutoUpdate = true;

  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();

  this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;

  this.visible = true;

  this.castShadow = false;
  this.receiveShadow = false;

  this.frustumCulled = true;
  this.renderOrder = 0;

  this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

  constructor: THREE.Object3D,

  get eulerOrder () {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    return this.rotation.order;

  },

  set eulerOrder ( value ) {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    this.rotation.order = value;

  },

  get useQuaternion () {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  set useQuaternion ( value ) {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  set renderDepth ( value ) {

    console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

  },

  applyMatrix: function ( matrix ) {

    this.matrix.multiplyMatrices( matrix, this.matrix );

    this.matrix.decompose( this.position, this.quaternion, this.scale );

  },

  setRotationFromAxisAngle: function ( axis, angle ) {

    // assumes axis is normalized

    this.quaternion.setFromAxisAngle( axis, angle );

  },

  setRotationFromEuler: function ( euler ) {

    this.quaternion.setFromEuler( euler, true );

  },

  setRotationFromMatrix: function ( m ) {

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    this.quaternion.setFromRotationMatrix( m );

  },

  setRotationFromQuaternion: function ( q ) {

    // assumes q is normalized

    this.quaternion.copy( q );

  },

  rotateOnAxis: function () {

    // rotate object on axis in object space
    // axis is assumed to be normalized

    var q1 = new THREE.Quaternion();

    return function ( axis, angle ) {

      q1.setFromAxisAngle( axis, angle );

      this.quaternion.multiply( q1 );

      return this;

    };

  }(),

  rotateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  translateOnAxis: function () {

    // translate object by distance along axis in object space
    // axis is assumed to be normalized

    var v1 = new THREE.Vector3();

    return function ( axis, distance ) {

      v1.copy( axis ).applyQuaternion( this.quaternion );

      this.position.add( v1.multiplyScalar( distance ) );

      return this;

    };

  }(),

  translate: function ( distance, axis ) {

    console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    return this.translateOnAxis( axis, distance );

  },

  translateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  localToWorld: function ( vector ) {

    return vector.applyMatrix4( this.matrixWorld );

  },

  worldToLocal: function () {

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    };

  }(),

  lookAt: function () {

    // This routine does not support objects with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      m1.lookAt( vector, this.position, this.up );

      this.quaternion.setFromRotationMatrix( m1 );

    };

  }(),

  add: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.add( arguments[ i ] );

      }

      return this;

    }

    if ( object === this ) {

      console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
      return this;

    }

    if ( object instanceof THREE.Object3D ) {

      if ( object.parent !== null ) {

        object.parent.remove( object );

      }

      object.parent = this;
      object.dispatchEvent( { type: 'added' } );

      this.children.push( object );

    } else {

      console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    }

    return this;

  },

  remove: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.remove( arguments[ i ] );

      }

    }

    var index = this.children.indexOf( object );

    if ( index !== - 1 ) {

      object.parent = null;

      object.dispatchEvent( { type: 'removed' } );

      this.children.splice( index, 1 );

    }

  },

  getChildByName: function ( name ) {

    console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    return this.getObjectByName( name );

  },

  getObjectById: function ( id ) {

    return this.getObjectByProperty( 'id', id );

  },

  getObjectByName: function ( name ) {

    return this.getObjectByProperty( 'name', name );

  },

  getObjectByProperty: function ( name, value ) {

    if ( this[ name ] === value ) return this;

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      var child = this.children[ i ];
      var object = child.getObjectByProperty( name, value );

      if ( object !== undefined ) {

        return object;

      }

    }

    return undefined;

  },

  getWorldPosition: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.updateMatrixWorld( true );

    return result.setFromMatrixPosition( this.matrixWorld );

  },

  getWorldQuaternion: function () {

    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Quaternion();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, result, scale );

      return result;

    };

  }(),

  getWorldRotation: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Euler();

      this.getWorldQuaternion( quaternion );

      return result.setFromQuaternion( quaternion, this.rotation.order, false );

    };

  }(),

  getWorldScale: function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, quaternion, result );

      return result;

    };

  }(),

  getWorldDirection: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.getWorldQuaternion( quaternion );

      return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    };

  }(),

  raycast: function () {},

  traverse: function ( callback ) {

    callback( this );

    var children = this.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      children[ i ].traverse( callback );

    }

  },

  traverseVisible: function ( callback ) {

    if ( this.visible === false ) return;

    callback( this );

    var children = this.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      children[ i ].traverseVisible( callback );

    }

  },

  traverseAncestors: function ( callback ) {

    var parent = this.parent;

    if ( parent !== null ) {

      callback( parent );

      parent.traverseAncestors( callback );

    }

  },

  updateMatrix: function () {

    this.matrix.compose( this.position, this.quaternion, this.scale );

    this.matrixWorldNeedsUpdate = true;

  },

  updateMatrixWorld: function ( force ) {

    if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    if ( this.matrixWorldNeedsUpdate === true || force === true ) {

      if ( this.parent === null ) {

        this.matrixWorld.copy( this.matrix );

      } else {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

      }

      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  },

  toJSON: function ( meta ) {

    var isRootObject = ( meta === undefined );

    var data = {};

    // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.
    if ( isRootObject ) {

      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };

      data.metadata = {
        version: 4.4,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };

    }

    // standard Object3D serialization

    data.uuid = this.uuid;
    data.type = this.type;

    if ( this.name !== '' ) data.name = this.name;
    if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
    if ( this.visible !== true ) data.visible = this.visible;

    data.matrix = this.matrix.toArray();

    if ( this.children.length > 0 ) {

      data.children = [];

      for ( var i = 0; i < this.children.length; i ++ ) {

        data.children.push( this.children[ i ].toJSON( meta ).object );

      }

    }

    var output = {};

    if ( isRootObject ) {

      var geometries = extractFromCache( meta.geometries );
      var materials = extractFromCache( meta.materials );
      var textures = extractFromCache( meta.textures );
      var images = extractFromCache( meta.images );

      if ( geometries.length > 0 ) output.geometries = geometries;
      if ( materials.length > 0 ) output.materials = materials;
      if ( textures.length > 0 ) output.textures = textures;
      if ( images.length > 0 ) output.images = images;

    }

    output.object = data;

    return output;

    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache ( cache ) {

      var values = [];
      for ( var key in cache ) {

        var data = cache[ key ];
        delete data.metadata;
        values.push( data );

      }
      return values;

    }

  },

  clone: function ( recursive ) {

    return new this.constructor().copy( this, recursive );

  },

  copy: function ( source, recursive ) {

    if ( recursive === undefined ) recursive = true;

    this.name = source.name;

    this.up.copy( source.up );

    this.position.copy( source.position );
    this.quaternion.copy( source.quaternion );
    this.scale.copy( source.scale );

    this.rotationAutoUpdate = source.rotationAutoUpdate;

    this.matrix.copy( source.matrix );
    this.matrixWorld.copy( source.matrixWorld );

    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    this.visible = source.visible;

    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;

    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;

    this.userData = JSON.parse( JSON.stringify( source.userData ) );

    if ( recursive === true ) {

      for ( var i = 0; i < source.children.length; i ++ ) {

        var child = source.children[ i ];
        this.add( child.clone() );

      }

    }

    return this;

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

  this.a = a;
  this.b = b;
  this.c = c;

  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = Array.isArray( normal ) ? normal : [];

  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = Array.isArray( color ) ? color : [];

  this.vertexTangents = [];

  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

  constructor: THREE.Face3,

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.a = source.a;
    this.b = source.b;
    this.c = source.c;

    this.normal.copy( source.normal );
    this.color.copy( source.color );

    this.materialIndex = source.materialIndex;

    for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

      this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

    }

    for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

      this.vertexColors[ i ] = source.vertexColors[ i ].clone();

    }

    for ( var i = 0, il = source.vertexTangents.length; i < il; i ++ ) {

      this.vertexTangents[ i ] = source.vertexTangents[ i ].clone();

    }

    return this;

  }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

  console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
  return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

  this.uuid = THREE.Math.generateUUID();

  this.array = array;
  this.itemSize = itemSize;

  this.version = 0;

};

THREE.BufferAttribute.prototype = {

  constructor: THREE.BufferAttribute,

  get length () {

    console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    return this.array.length;

  },

  get count() {

    return this.array.length / this.itemSize;

  },

  set needsUpdate( value ) {

    if ( value === true ) this.version ++;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  copyArray: function ( array ) {

    this.array.set( array );

    return this;

  },

  copyColorsArray: function ( colors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = colors.length; i < l; i ++ ) {

      var color = colors[ i ];

      if ( color === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
        color = new THREE.Color();

      }

      array[ offset ++ ] = color.r;
      array[ offset ++ ] = color.g;
      array[ offset ++ ] = color.b;

    }

    return this;

  },

  copyIndicesArray: function ( indices ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = indices.length; i < l; i ++ ) {

      var index = indices[ i ];

      array[ offset ++ ] = index.a;
      array[ offset ++ ] = index.b;
      array[ offset ++ ] = index.c;

    }

    return this;

  },

  copyVector2sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
        vector = new THREE.Vector2();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;

    }

    return this;

  },

  copyVector3sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
        vector = new THREE.Vector3();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;

    }

    return this;

  },

  copyVector4sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
        vector = new THREE.Vector4();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;
      array[ offset ++ ] = vector.w;

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  getX: function ( index ) {

    return this.array[ index * this.itemSize ];

  },

  setX: function ( index, x ) {

    this.array[ index * this.itemSize ] = x;

    return this;

  },

  getY: function ( index ) {

    return this.array[ index * this.itemSize + 1 ];

  },

  setY: function ( index, y ) {

    this.array[ index * this.itemSize + 1 ] = y;

    return this;

  },

  getZ: function ( index ) {

    return this.array[ index * this.itemSize + 2 ];

  },

  setZ: function ( index, z ) {

    this.array[ index * this.itemSize + 2 ] = z;

    return this;

  },

  getW: function ( index ) {

    return this.array[ index * this.itemSize + 3 ];

  },

  setW: function ( index, w ) {

    this.array[ index * this.itemSize + 3 ] = w;

    return this;

  },

  setXY: function ( index, x, y ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;
    this.array[ index + 3 ] = w;

    return this;

  },

  clone: function () {

    return new this.constructor( new this.array.constructor( this.array ), this.itemSize );

  }

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};

// File:src/core/DynamicBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

  THREE.BufferAttribute.call( this, array, itemSize );

  this.updateRange = { offset: 0, count: - 1 };

};

THREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;

// File:src/core/IndexBufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.IndexBufferAttribute = function ( array, itemSize ) {

  THREE.BufferAttribute.call( this, array, itemSize );

};

THREE.IndexBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.IndexBufferAttribute.prototype.constructor = THREE.IndexBufferAttribute;

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute, dynamic ) {

  THREE.DynamicBufferAttribute.call( this, array, itemSize );

  this.dynamic = dynamic || false;
  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.DynamicBufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.clone = function () {

  return new THREE.InstancedBufferAttribute( new this.array.constructor( this.array ), this.itemSize, this.meshPerAttribute, this.dynamic );

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride, dynamic ) {

  this.uuid = THREE.Math.generateUUID();

  this.array = array;
  this.stride = stride;

  this.version = 0;

  this.dynamic = dynamic || false;
  this.updateRange = { offset: 0, count: - 1 };

};

THREE.InterleavedBuffer.prototype = {

  constructor: THREE.InterleavedBuffer,

  get length () {

    return this.array.length;

  },

  get count () {

    return this.array.length / this.stride;

  },

  set needsUpdate( value ) {

    if ( value === true ) this.version ++;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.stride;
    index2 *= attribute.stride;

    for ( var i = 0, l = this.stride; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  clone: function () {

    return new this.constructor( new this.array.constructor( this.array ), this.stride, this.dynamic );

  }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, dynamic, meshPerAttribute ) {

  THREE.InterleavedBuffer.call( this, array, stride, dynamic );

  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.clone = function () {

  return new this.constructor( new this.array.constructor( this.array ), this.stride, this.dynamic, this.meshPerAttribute );

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

  this.uuid = THREE.Math.generateUUID();

  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

  constructor: THREE.InterleavedBufferAttribute,

  get length() {

    console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    return this.array.length;

  },

  get count() {

    return this.data.array.length / this.data.stride;

  },

  setX: function ( index, x ) {

    this.data.array[ index * this.data.stride + this.offset ] = x;

    return this;

  },

  setY: function ( index, y ) {

    this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    return this;

  },

  setZ: function ( index, z ) {

    this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    return this;

  },

  setW: function ( index, w ) {

    this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    return this;

  },

  getX: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset ];

  },

  getY: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 1 ];

  },

  getZ: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 2 ];

  },

  getW: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 3 ];

  },

  setXY: function ( index, x, y ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;
    this.data.array[ index + 3 ] = w;

    return this;

  }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Geometry';

  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [ [] ];

  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  this.hasTangents = false;

  // update flags

  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.tangentsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;

};

THREE.Geometry.prototype = {

  constructor: THREE.Geometry,

  applyMatrix: function ( matrix ) {

    var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

      var vertex = this.vertices[ i ];
      vertex.applyMatrix4( matrix );

    }

    for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

      var face = this.faces[ i ];
      face.normal.applyMatrix3( normalMatrix ).normalize();

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

      }

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;

  },

  rotateX: function () {

    // rotate geometry around world x-axis

    var m1;

    return function rotateX( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationX( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateY: function () {

    // rotate geometry around world y-axis

    var m1;

    return function rotateY( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationY( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateZ: function () {

    // rotate geometry around world z-axis

    var m1;

    return function rotateZ( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationZ( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  translate: function () {

    // translate geometry

    var m1;

    return function translate( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeTranslation( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  scale: function () {

    // scale geometry

    var m1;

    return function scale( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeScale( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  lookAt: function () {

    var obj;

    return function lookAt( vector ) {

      if ( obj === undefined ) obj = new THREE.Object3D();

      obj.lookAt( vector );

      obj.updateMatrix();

      this.applyMatrix( obj.matrix );

    };

  }(),

  fromBufferGeometry: function ( geometry ) {

    var scope = this;

    var attributes = geometry.attributes;

    var vertices = attributes.position.array;
    var indices = attributes.index !== undefined ? attributes.index.array : undefined;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
    var tangents = attributes.tangent !== undefined ? attributes.tangent.array : undefined;

    if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
    if ( tangents !== undefined ) this.hasTangents = true;

    var tempNormals = [];
    var tempUVs = [];
    var tempUVs2 = [];
    var tempTangents = [];

    for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

      scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

      if ( normals !== undefined ) {

        tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

      }

      if ( colors !== undefined ) {

        scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

      }

      if ( uvs !== undefined ) {

        tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

      }

      if ( uvs2 !== undefined ) {

        tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

      }

      if ( tangents !== undefined ) {

        tempTangents.push( new THREE.Vector4( tangents[ k ], tangents[ k + 1 ], tangents[ k + 2 ], tangents[ k + 3 ] ) );

      }

    }

    var addFace = function ( a, b, c ) {

      var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
      var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

      var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

      scope.faces.push( face );

      if ( uvs !== undefined ) {

        scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

      }

      if ( uvs2 !== undefined ) {

        scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

      }

      if ( tangents !== undefined ) {

        face.vertexTangents.push( tempTangents[ a ].clone(), tempTangents[ b ].clone(), tempTangents[ c ].clone() );

      }

    };

    if ( indices !== undefined ) {

      var groups = geometry.groups;

      if ( groups.length > 0 ) {

        for ( var i = 0; i < groups.length; i ++ ) {

          var group = groups[ i ];

          var start = group.start;
          var count = group.count;

          for ( var j = start, jl = start + count; j < jl; j += 3 ) {

            addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

          }

        }

      } else {

        for ( var i = 0; i < indices.length; i += 3 ) {

          addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

        }

      }

    } else {

      for ( var i = 0; i < vertices.length / 3; i += 3 ) {

        addFace( i, i + 1, i + 2 );

      }

    }

    this.computeFaceNormals();

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.translate( offset.x, offset.y, offset.z );

    return offset;

  },

  normalize: function () {

    this.computeBoundingSphere();

    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;

    var s = radius === 0 ? 1 : 1.0 / radius;

    var matrix = new THREE.Matrix4();
    matrix.set(
      s, 0, 0, - s * center.x,
      0, s, 0, - s * center.y,
      0, 0, s, - s * center.z,
      0, 0, 0, 1
    );

    this.applyMatrix( matrix );

    return this;

  },

  computeFaceNormals: function () {

    var cb = new THREE.Vector3(), ab = new THREE.Vector3();

    for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

      var face = this.faces[ f ];

      var vA = this.vertices[ face.a ];
      var vB = this.vertices[ face.b ];
      var vC = this.vertices[ face.c ];

      cb.subVectors( vC, vB );
      ab.subVectors( vA, vB );
      cb.cross( ab );

      cb.normalize();

      face.normal.copy( cb );

    }

  },

  computeVertexNormals: function ( areaWeighted ) {

    var v, vl, f, fl, face, vertices;

    vertices = new Array( this.vertices.length );

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ] = new THREE.Vector3();

    }

    if ( areaWeighted ) {

      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm

      var vA, vB, vC;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3();

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vA = this.vertices[ face.a ];
        vB = this.vertices[ face.b ];
        vC = this.vertices[ face.c ];

        cb.subVectors( vC, vB );
        ab.subVectors( vA, vB );
        cb.cross( ab );

        vertices[ face.a ].add( cb );
        vertices[ face.b ].add( cb );
        vertices[ face.c ].add( cb );

      }

    } else {

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vertices[ face.a ].add( face.normal );
        vertices[ face.b ].add( face.normal );
        vertices[ face.c ].add( face.normal );

      }

    }

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ].normalize();

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        vertexNormals[ 0 ].copy( vertices[ face.a ] );
        vertexNormals[ 1 ].copy( vertices[ face.b ] );
        vertexNormals[ 2 ].copy( vertices[ face.c ] );

      } else {

        vertexNormals[ 0 ] = vertices[ face.a ].clone();
        vertexNormals[ 1 ] = vertices[ face.b ].clone();
        vertexNormals[ 2 ] = vertices[ face.c ].clone();

      }

    }

  },

  computeMorphNormals: function () {

    var i, il, f, fl, face;

    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      if ( ! face.__originalFaceNormal ) {

        face.__originalFaceNormal = face.normal.clone();

      } else {

        face.__originalFaceNormal.copy( face.normal );

      }

      if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

      for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

        if ( ! face.__originalVertexNormals[ i ] ) {

          face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

        } else {

          face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

        }

      }

    }

    // use temp geometry to compute face and vertex normals for each morph

    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;

    for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

      // create on first access

      if ( ! this.morphNormals[ i ] ) {

        this.morphNormals[ i ] = {};
        this.morphNormals[ i ].faceNormals = [];
        this.morphNormals[ i ].vertexNormals = [];

        var dstNormalsFace = this.morphNormals[ i ].faceNormals;
        var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

        var faceNormal, vertexNormals;

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          faceNormal = new THREE.Vector3();
          vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

          dstNormalsFace.push( faceNormal );
          dstNormalsVertex.push( vertexNormals );

        }

      }

      var morphNormals = this.morphNormals[ i ];

      // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[ i ].vertices;

      // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();

      // store morph normals

      var faceNormal, vertexNormals;

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        faceNormal = morphNormals.faceNormals[ f ];
        vertexNormals = morphNormals.vertexNormals[ f ];

        faceNormal.copy( face.normal );

        vertexNormals.a.copy( face.vertexNormals[ 0 ] );
        vertexNormals.b.copy( face.vertexNormals[ 1 ] );
        vertexNormals.c.copy( face.vertexNormals[ 2 ] );

      }

    }

    // restore original normals

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // tangents go to vertices

    var f, fl, v, vl, i, vertexIndex,
      face, uv, vA, vB, vC, uvA, uvB, uvC,
      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r, t, test,
      tan1 = [], tan2 = [],
      sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
      tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
      n = new THREE.Vector3(), w;

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      tan1[ v ] = new THREE.Vector3();
      tan2[ v ] = new THREE.Vector3();

    }

    function handleTriangle( context, a, b, c, ua, ub, uc ) {

      vA = context.vertices[ a ];
      vB = context.vertices[ b ];
      vC = context.vertices[ c ];

      uvA = uv[ ua ];
      uvB = uv[ ub ];
      uvC = uv[ uc ];

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;
      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;
      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;
      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );
      sdir.set( ( t2 * x1 - t1 * x2 ) * r,
            ( t2 * y1 - t1 * y2 ) * r,
            ( t2 * z1 - t1 * z2 ) * r );
      tdir.set( ( s1 * x2 - s2 * x1 ) * r,
            ( s1 * y2 - s2 * y1 ) * r,
            ( s1 * z2 - s2 * z1 ) * r );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];
      uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

      handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

    }

    var faceIndex = [ 'a', 'b', 'c', 'd' ];

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

        n.copy( face.vertexNormals[ i ] );

        vertexIndex = face[ faceIndex[ i ] ];

        t = tan1[ vertexIndex ];

        // Gram-Schmidt orthogonalize

        tmp.copy( t );
        tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

        // Calculate handedness

        tmp2.crossVectors( face.vertexNormals[ i ], t );
        test = tmp2.dot( tan2[ vertexIndex ] );
        w = ( test < 0.0 ) ? - 1.0 : 1.0;

        face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

      }

    }

    this.hasTangents = true;

  },

  computeLineDistances: function () {

    var d = 0;
    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      if ( i > 0 ) {

        d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

      }

      this.lineDistances[ i ] = d;

    }

  },

  computeBoundingBox: function () {

    if ( this.boundingBox === null ) {

      this.boundingBox = new THREE.Box3();

    }

    this.boundingBox.setFromPoints( this.vertices );

  },

  computeBoundingSphere: function () {

    if ( this.boundingSphere === null ) {

      this.boundingSphere = new THREE.Sphere();

    }

    this.boundingSphere.setFromPoints( this.vertices );

  },

  merge: function ( geometry, matrix, materialIndexOffset ) {

    if ( geometry instanceof THREE.Geometry === false ) {

      console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
      return;

    }

    var normalMatrix,
    vertexOffset = this.vertices.length,
    vertices1 = this.vertices,
    vertices2 = geometry.vertices,
    faces1 = this.faces,
    faces2 = geometry.faces,
    uvs1 = this.faceVertexUvs[ 0 ],
    uvs2 = geometry.faceVertexUvs[ 0 ];

    if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    if ( matrix !== undefined ) {

      normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    }

    // vertices

    for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

      var vertex = vertices2[ i ];

      var vertexCopy = vertex.clone();

      if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

      vertices1.push( vertexCopy );

    }

    // faces

    for ( i = 0, il = faces2.length; i < il; i ++ ) {

      var face = faces2[ i ], faceCopy, normal, color,
      faceVertexNormals = face.vertexNormals,
      faceVertexColors = face.vertexColors;

      faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
      faceCopy.normal.copy( face.normal );

      if ( normalMatrix !== undefined ) {

        faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

      }

      for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

        normal = faceVertexNormals[ j ].clone();

        if ( normalMatrix !== undefined ) {

          normal.applyMatrix3( normalMatrix ).normalize();

        }

        faceCopy.vertexNormals.push( normal );

      }

      faceCopy.color.copy( face.color );

      for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

        color = faceVertexColors[ j ];
        faceCopy.vertexColors.push( color.clone() );

      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

      faces1.push( faceCopy );

    }

    // uvs

    for ( i = 0, il = uvs2.length; i < il; i ++ ) {

      var uv = uvs2[ i ], uvCopy = [];

      if ( uv === undefined ) {

        continue;

      }

      for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

        uvCopy.push( uv[ j ].clone() );

      }

      uvs1.push( uvCopy );

    }

  },

  mergeMesh: function ( mesh ) {

    if ( mesh instanceof THREE.Mesh === false ) {

      console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
      return;

    }

    mesh.matrixAutoUpdate && mesh.updateMatrix();

    this.merge( mesh.geometry, mesh.matrix );

  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */

  mergeVertices: function () {

    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    var unique = [], changes = [];

    var v, key;
    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
    var precision = Math.pow( 10, precisionPoints );
    var i, il, face;
    var indices, j, jl;

    for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

      v = this.vertices[ i ];
      key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

      if ( verticesMap[ key ] === undefined ) {

        verticesMap[ key ] = i;
        unique.push( this.vertices[ i ] );
        changes[ i ] = unique.length - 1;

      } else {

        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[ i ] = changes[ verticesMap[ key ] ];

      }

    }


    // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.
    var faceIndicesToRemove = [];

    for ( i = 0, il = this.faces.length; i < il; i ++ ) {

      face = this.faces[ i ];

      face.a = changes[ face.a ];
      face.b = changes[ face.b ];
      face.c = changes[ face.c ];

      indices = [ face.a, face.b, face.c ];

      var dupIndex = - 1;

      // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved
      for ( var n = 0; n < 3; n ++ ) {

        if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

          dupIndex = n;
          faceIndicesToRemove.push( i );
          break;

        }

      }

    }

    for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

      var idx = faceIndicesToRemove[ i ];

      this.faces.splice( idx, 1 );

      for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

        this.faceVertexUvs[ j ].splice( idx, 1 );

      }

    }

    // Use unique set of vertices

    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;

  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    };

    // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    var vertices = [];

    for ( var i = 0; i < this.vertices.length; i ++ ) {

      var vertex = this.vertices[ i ];
      vertices.push( vertex.x, vertex.y, vertex.z );

    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for ( var i = 0; i < this.faces.length; i ++ ) {

      var face = this.faces[ i ];

      var hasMaterial = false; // face.materialIndex !== undefined;
      var hasFaceUv = false; // deprecated
      var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;

      var faceType = 0;

      faceType = setBit( faceType, 0, 0 );
      faceType = setBit( faceType, 1, hasMaterial );
      faceType = setBit( faceType, 2, hasFaceUv );
      faceType = setBit( faceType, 3, hasFaceVertexUv );
      faceType = setBit( faceType, 4, hasFaceNormal );
      faceType = setBit( faceType, 5, hasFaceVertexNormal );
      faceType = setBit( faceType, 6, hasFaceColor );
      faceType = setBit( faceType, 7, hasFaceVertexColor );

      faces.push( faceType );
      faces.push( face.a, face.b, face.c );

      if ( hasFaceVertexUv ) {

        var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

        faces.push(
          getUvIndex( faceVertexUvs[ 0 ] ),
          getUvIndex( faceVertexUvs[ 1 ] ),
          getUvIndex( faceVertexUvs[ 2 ] )
        );

      }

      if ( hasFaceNormal ) {

        faces.push( getNormalIndex( face.normal ) );

      }

      if ( hasFaceVertexNormal ) {

        var vertexNormals = face.vertexNormals;

        faces.push(
          getNormalIndex( vertexNormals[ 0 ] ),
          getNormalIndex( vertexNormals[ 1 ] ),
          getNormalIndex( vertexNormals[ 2 ] )
        );

      }

      if ( hasFaceColor ) {

        faces.push( getColorIndex( face.color ) );

      }

      if ( hasFaceVertexColor ) {

        var vertexColors = face.vertexColors;

        faces.push(
          getColorIndex( vertexColors[ 0 ] ),
          getColorIndex( vertexColors[ 1 ] ),
          getColorIndex( vertexColors[ 2 ] )
        );

      }

    }

    function setBit( value, position, enabled ) {

      return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

    }

    function getNormalIndex( normal ) {

      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if ( normalsHash[ hash ] !== undefined ) {

        return normalsHash[ hash ];

      }

      normalsHash[ hash ] = normals.length / 3;
      normals.push( normal.x, normal.y, normal.z );

      return normalsHash[ hash ];

    }

    function getColorIndex( color ) {

      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if ( colorsHash[ hash ] !== undefined ) {

        return colorsHash[ hash ];

      }

      colorsHash[ hash ] = colors.length;
      colors.push( color.getHex() );

      return colorsHash[ hash ];

    }

    function getUvIndex( uv ) {

      var hash = uv.x.toString() + uv.y.toString();

      if ( uvsHash[ hash ] !== undefined ) {

        return uvsHash[ hash ];

      }

      uvsHash[ hash ] = uvs.length / 2;
      uvs.push( uv.x, uv.y );

      return uvsHash[ hash ];

    }

    data.data = {};

    data.data.vertices = vertices;
    data.data.normals = normals;
    if ( colors.length > 0 ) data.data.colors = colors;
    if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    data.data.faces = faces;

    return data;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.vertices = [];
    this.faces = [];
    this.faceVertexUvs = [ [] ];

    var vertices = source.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      this.vertices.push( vertices[ i ].clone() );

    }

    var faces = source.faces;

    for ( var i = 0, il = faces.length; i < il; i ++ ) {

      this.faces.push( faces[ i ].clone() );

    }

    for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

      var faceVertexUvs = source.faceVertexUvs[ i ];

      if ( this.faceVertexUvs[ i ] === undefined ) {

        this.faceVertexUvs[ i ] = [];

      }

      for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

        var uvs = faceVertexUvs[ j ], uvsCopy = [];

        for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

          var uv = uvs[ k ];

          uvsCopy.push( uv.clone() );

        }

        this.faceVertexUvs[ i ].push( uvsCopy );

      }

    }

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  },

  // Backwards compatibility

  set groupsNeedUpdate ( value ) {

    if ( value === true ) this.dispose();

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'DirectGeometry';

  this.indices = [];
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.tangents = [];

  this.groups = [];

  this.morphTargets = {};

  this.skinWeights = [];
  this.skinIndices = [];

  // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.tangentsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

  constructor: THREE.DirectGeometry,

  computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
  computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

  computeFaceNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
    return this;

  },

  computeVertexNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
    return this;

  },

  computeTangents: function () {

    console.warn( 'THREE.DirectGeometry: computeTangents() is not a method of this type of geometry.' );
    return this;

  },

  fromGeometry: function ( geometry ) {

    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;

    var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    var hasTangents = geometry.hasTangents;

    var group;
    var materialIndex;

    // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;

    if ( morphTargetsLength > 0 ) {

      var morphTargetsPosition = [];

      for ( var i = 0; i < morphTargetsLength; i ++ ) {

        morphTargetsPosition[ i ] = [];

      }

      this.morphTargets.position = morphTargetsPosition;

    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;

    if ( morphNormalsLength > 0 ) {

      var morphTargetsNormal = [];

      for ( var i = 0; i < morphNormalsLength; i ++ ) {

        morphTargetsNormal[ i ] = [];

      }

      this.morphTargets.normal = morphTargetsNormal;

    }

    // skins

    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;

    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;

    //

    for ( var i = 0, i3 = 0; i < faces.length; i ++, i3 += 3 ) {

      var face = faces[ i ];

      this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

      } else {

        var normal = face.normal;

        this.normals.push( normal, normal, normal );

      }

      var vertexColors = face.vertexColors;

      if ( vertexColors.length === 3 ) {

        this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

      } else {

        var color = face.color;

        this.colors.push( color, color, color );

      }

      if ( hasFaceVertexUv === true ) {

        var vertexUvs = faceVertexUvs[ 0 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

          this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      if ( hasFaceVertexUv2 === true ) {

        var vertexUvs = faceVertexUvs[ 1 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

          this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      // materials

      if ( face.materialIndex !== materialIndex ) {

        materialIndex = face.materialIndex;

        if ( group !== undefined ) {

          group.count = i3 - group.start;
          this.groups.push( group );

        }

        group = {
          start: i3,
          materialIndex: materialIndex
        };

      }

      // tangents

      if ( hasTangents === true ) {

        var vertexTangents = face.vertexTangents;

        if ( vertexTangents.length === 3 ) {

          this.tangents.push( vertexTangents[ 0 ], vertexTangents[ 1 ], vertexTangents[ 2 ] );

        } else {

          console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined tangents ', i );

          this.tangents.push( new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4() );

        }

      }

      // morphs

      for ( var j = 0; j < morphTargetsLength; j ++ ) {

        var morphTarget = morphTargets[ j ].vertices;

        morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

      }

      for ( var j = 0; j < morphNormalsLength; j ++ ) {

        var morphNormal = morphNormals[ j ].vertexNormals[ i ];

        morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

      }

      // skins

      if ( hasSkinIndices ) {

        this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

      }

      if ( hasSkinWeights ) {

        this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

      }

    }

    //

    if ( group !== undefined ) {

      group.count = i3 - group.start;
      this.groups.push( group );

    }

    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.tangentsNeedUpdate = geometry.tangentsNeedUpdate;

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'BufferGeometry';

  this.attributes = {};

  this.morphAttributes = {};

  this.groups = [];

  this.boundingBox = null;
  this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

  constructor: THREE.BufferGeometry,

  addAttribute: function ( name, attribute ) {

    if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

      console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

      this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

      return;

    }

    if ( name === 'index' && attribute instanceof THREE.IndexBufferAttribute === false ) {

      console.warn( 'THREE.BufferGeometry.addAttribute: Use THREE.IndexBufferAttribute for index attribute.' );
      attribute = new THREE.IndexBufferAttribute( attribute.array, attribute.itemSize );

    }

    this.attributes[ name ] = attribute;

  },

  getAttribute: function ( name ) {

    return this.attributes[ name ];

  },

  removeAttribute: function ( name ) {

    delete this.attributes[ name ];

  },

  get drawcalls() {

    console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
    return this.groups;

  },

  get offsets() {

    console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
    return this.groups;

  },

  addDrawCall: function ( start, count, indexOffset ) {

    if ( indexOffset !== undefined ) {

      console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

    }

    console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
    this.addGroup( start, count );

  },

  clearDrawCalls: function () {

    console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
    this.clearGroups();

  },

  addGroup: function ( start, count, materialIndex ) {

    this.groups.push( {

      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0

    } );

  },

  clearGroups: function () {

    this.groups = [];

  },

  applyMatrix: function ( matrix ) {

    var position = this.attributes.position;

    if ( position !== undefined ) {

      matrix.applyToVector3Array( position.array );
      position.needsUpdate = true;

    }

    var normal = this.attributes.normal;

    if ( normal !== undefined ) {

      var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

      normalMatrix.applyToVector3Array( normal.array );
      normal.needsUpdate = true;

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

  },

  rotateX: function () {

    // rotate geometry around world x-axis

    var m1;

    return function rotateX( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationX( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateY: function () {

    // rotate geometry around world y-axis

    var m1;

    return function rotateY( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationY( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateZ: function () {

    // rotate geometry around world z-axis

    var m1;

    return function rotateZ( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationZ( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  translate: function () {

    // translate geometry

    var m1;

    return function translate( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeTranslation( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  scale: function () {

    // scale geometry

    var m1;

    return function scale( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeScale( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  lookAt: function () {

    var obj;

    return function lookAt( vector ) {

      if ( obj === undefined ) obj = new THREE.Object3D();

      obj.lookAt( vector );

      obj.updateMatrix();

      this.applyMatrix( obj.matrix );

    };

  }(),

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.translate( offset.x, offset.y, offset.z );

    return offset;

  },

  setFromObject: function ( object ) {

    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    var geometry = object.geometry;

    if ( object instanceof THREE.PointCloud || object instanceof THREE.Line ) {

      var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
      var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

      this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
      this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

      if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

        var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

        this.addAttribute( 'lineDistance',  lineDistances.copyArray( geometry.lineDistances ) );

      }

      if ( geometry.boundingSphere !== null ) {

        this.boundingSphere = geometry.boundingSphere.clone();

      }

      if ( geometry.boundingBox !== null ) {

        this.boundingBox = geometry.boundingBox.clone();

      }

    } else if ( object instanceof THREE.Mesh ) {

      if ( geometry instanceof THREE.Geometry ) {

        this.fromGeometry( geometry );

      }

    }

    return this;

  },

  updateFromObject: function ( object ) {

    var geometry = object.geometry;

    if ( object instanceof THREE.Mesh ) {

      var direct = geometry.__directGeometry;

      if ( direct === undefined ) {

        return this.fromGeometry( geometry );

      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.tangentsNeedUpdate = geometry.tangentsNeedUpdate;

      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.tangentsNeedUpdate = false;

      geometry = direct;

    }

    if ( geometry.verticesNeedUpdate === true ) {

      var attribute = this.attributes.position;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.vertices );
        attribute.needsUpdate = true;

      }

      geometry.verticesNeedUpdate = false;

    }

    if ( geometry.normalsNeedUpdate === true ) {

      var attribute = this.attributes.normal;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.normals );
        attribute.needsUpdate = true;

      }

      geometry.normalsNeedUpdate = false;

    }

    if ( geometry.colorsNeedUpdate === true ) {

      var attribute = this.attributes.color;

      if ( attribute !== undefined ) {

        attribute.copyColorsArray( geometry.colors );
        attribute.needsUpdate = true;

      }

      geometry.colorsNeedUpdate = false;

    }

    if ( geometry.tangentsNeedUpdate === true ) {

      var attribute = this.attributes.tangent;

      if ( attribute !== undefined ) {

        attribute.copyVector4sArray( geometry.tangents );
        attribute.needsUpdate = true;

      }

      geometry.tangentsNeedUpdate = false;

    }

    if ( geometry.lineDistancesNeedUpdate ) {

      var attribute = this.attributes.lineDistance;

      if ( attribute !== undefined ) {

        attribute.copyArray( geometry.lineDistances );
        attribute.needsUpdate = true;

      }

      geometry.lineDistancesNeedUpdate = false;

    }

    return this;

  },

  fromGeometry: function ( geometry ) {

    geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

    return this.fromDirectGeometry( geometry.__directGeometry );

  },

  fromDirectGeometry: function ( geometry ) {

    var positions = new Float32Array( geometry.vertices.length * 3 );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    if ( geometry.normals.length > 0 ) {

      var normals = new Float32Array( geometry.normals.length * 3 );
      this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    }

    if ( geometry.colors.length > 0 ) {

      var colors = new Float32Array( geometry.colors.length * 3 );
      this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    }

    if ( geometry.uvs.length > 0 ) {

      var uvs = new Float32Array( geometry.uvs.length * 2 );
      this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    }

    if ( geometry.uvs2.length > 0 ) {

      var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
      this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

    }

    if ( geometry.tangents.length > 0 ) {

      var tangents = new Float32Array( geometry.tangents.length * 4 );
      this.addAttribute( 'tangent', new THREE.BufferAttribute( tangents, 4 ).copyVector4sArray( geometry.tangents ) );

    }

    if ( geometry.indices.length > 0 ) {

      var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
      var indices = new TypeArray( geometry.indices.length * 3 );
      this.addAttribute( 'index', new THREE.IndexBufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    }

    // groups

    this.groups = geometry.groups;

    // morphs

    for ( var name in geometry.morphTargets ) {

      var array = [];
      var morphTargets = geometry.morphTargets[ name ];

      for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

        var morphTarget = morphTargets[ i ];

        var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

        array.push( attribute.copyVector3sArray( morphTarget ) );

      }

      this.morphAttributes[ name ] = array;

    }

    // skinning

    if ( geometry.skinIndices.length > 0 ) {

      var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
      this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    }

    if ( geometry.skinWeights.length > 0 ) {

      var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
      this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    }

    //

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    return this;

  },

  computeBoundingBox: function () {

    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new THREE.Box3();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        var bb = this.boundingBox;
        bb.makeEmpty();

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          bb.expandByPoint( vector );

        }

      }

      if ( positions === undefined || positions.length === 0 ) {

        this.boundingBox.min.set( 0, 0, 0 );
        this.boundingBox.max.set( 0, 0, 0 );

      }

      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

      }

    };

  }(),

  computeBoundingSphere: function () {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingSphere === null ) {

        this.boundingSphere = new THREE.Sphere();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        box.makeEmpty();

        var center = this.boundingSphere.center;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          box.expandByPoint( vector );

        }

        box.center( center );

        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

        }

        this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

        if ( isNaN( this.boundingSphere.radius ) ) {

          console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

        }

      }

    };

  }(),

  computeFaceNormals: function () {

    // backwards compatibility

  },

  computeVertexNormals: function () {

    var attributes = this.attributes;
    var groups = this.groups;

    if ( attributes.position ) {

      var positions = attributes.position.array;

      if ( attributes.normal === undefined ) {

        this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

      } else {

        // reset existing normals to zero

        var normals = attributes.normal.array;

        for ( var i = 0, il = normals.length; i < il; i ++ ) {

          normals[ i ] = 0;

        }

      }

      var normals = attributes.normal.array;

      var vA, vB, vC,

      pA = new THREE.Vector3(),
      pB = new THREE.Vector3(),
      pC = new THREE.Vector3(),

      cb = new THREE.Vector3(),
      ab = new THREE.Vector3();

      // indexed elements

      if ( attributes.index ) {

        var indices = attributes.index.array;

        if ( groups.length === 0 ) {

          this.addGroup( 0, indices.length );

        }

        for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

          var group = groups[ j ];

          var start = group.start;
          var count = group.count;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            vA = indices[ i + 0 ] * 3;
            vB = indices[ i + 1 ] * 3;
            vC = indices[ i + 2 ] * 3;

            pA.fromArray( positions, vA );
            pB.fromArray( positions, vB );
            pC.fromArray( positions, vC );

            cb.subVectors( pC, pB );
            ab.subVectors( pA, pB );
            cb.cross( ab );

            normals[ vA ] += cb.x;
            normals[ vA + 1 ] += cb.y;
            normals[ vA + 2 ] += cb.z;

            normals[ vB ] += cb.x;
            normals[ vB + 1 ] += cb.y;
            normals[ vB + 2 ] += cb.z;

            normals[ vC ] += cb.x;
            normals[ vC + 1 ] += cb.y;
            normals[ vC + 2 ] += cb.z;

          }

        }

      } else {

        // non-indexed elements (unconnected triangle soup)

        for ( var i = 0, il = positions.length; i < il; i += 9 ) {

          pA.fromArray( positions, i );
          pB.fromArray( positions, i + 3 );
          pC.fromArray( positions, i + 6 );

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );

          normals[ i ] = cb.x;
          normals[ i + 1 ] = cb.y;
          normals[ i + 2 ] = cb.z;

          normals[ i + 3 ] = cb.x;
          normals[ i + 4 ] = cb.y;
          normals[ i + 5 ] = cb.z;

          normals[ i + 6 ] = cb.x;
          normals[ i + 7 ] = cb.y;
          normals[ i + 8 ] = cb.z;

        }

      }

      this.normalizeNormals();

      attributes.normal.needsUpdate = true;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if ( this.attributes.index === undefined ||
       this.attributes.position === undefined ||
       this.attributes.normal === undefined ||
       this.attributes.uv === undefined ) {

      console.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
      return;

    }

    var indices = this.attributes.index.array;
    var positions = this.attributes.position.array;
    var normals = this.attributes.normal.array;
    var uvs = this.attributes.uv.array;

    var nVertices = positions.length / 3;

    if ( this.attributes.tangent === undefined ) {

      this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

    }

    var tangents = this.attributes.tangent.array;

    var tan1 = [], tan2 = [];

    for ( var k = 0; k < nVertices; k ++ ) {

      tan1[ k ] = new THREE.Vector3();
      tan2[ k ] = new THREE.Vector3();

    }

    var vA = new THREE.Vector3(),
      vB = new THREE.Vector3(),
      vC = new THREE.Vector3(),

      uvA = new THREE.Vector2(),
      uvB = new THREE.Vector2(),
      uvC = new THREE.Vector2(),

      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r;

    var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

    function handleTriangle( a, b, c ) {

      vA.fromArray( positions, a * 3 );
      vB.fromArray( positions, b * 3 );
      vC.fromArray( positions, c * 3 );

      uvA.fromArray( uvs, a * 2 );
      uvB.fromArray( uvs, b * 2 );
      uvC.fromArray( uvs, c * 2 );

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;

      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;

      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;

      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );

      sdir.set(
        ( t2 * x1 - t1 * x2 ) * r,
        ( t2 * y1 - t1 * y2 ) * r,
        ( t2 * z1 - t1 * z2 ) * r
      );

      tdir.set(
        ( s1 * x2 - s2 * x1 ) * r,
        ( s1 * y2 - s2 * y1 ) * r,
        ( s1 * z2 - s2 * z1 ) * r
      );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    var i, il;
    var j, jl;
    var iA, iB, iC;

    if ( this.groups.length === 0 ) {

      this.addGroup( 0, indices.length );

    }

    var groups = this.groups;

    for ( j = 0, jl = groups.length; j < jl; ++ j ) {

      var group = groups[ j ];

      var start = group.start;
      var count = group.count;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = indices[ i + 0 ];
        iB = indices[ i + 1 ];
        iC = indices[ i + 2 ];

        handleTriangle( iA, iB, iC );

      }

    }

    var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(), n2 = new THREE.Vector3();
    var w, t, test;

    function handleVertex( v ) {

      n.fromArray( normals, v * 3 );
      n2.copy( n );

      t = tan1[ v ];

      // Gram-Schmidt orthogonalize

      tmp.copy( t );
      tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

      // Calculate handedness

      tmp2.crossVectors( n2, t );
      test = tmp2.dot( tan2[ v ] );
      w = ( test < 0.0 ) ? - 1.0 : 1.0;

      tangents[ v * 4 ] = tmp.x;
      tangents[ v * 4 + 1 ] = tmp.y;
      tangents[ v * 4 + 2 ] = tmp.z;
      tangents[ v * 4 + 3 ] = w;

    }

    for ( j = 0, jl = groups.length; j < jl; ++ j ) {

      var group = groups[ j ];

      var start = group.start;
      var count = group.count;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = indices[ i + 0 ];
        iB = indices[ i + 1 ];
        iC = indices[ i + 2 ];

        handleVertex( iA );
        handleVertex( iB );
        handleVertex( iC );

      }

    }

  },

  computeOffsets: function ( size ) {

    console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

  },

  merge: function ( geometry, offset ) {

    if ( geometry instanceof THREE.BufferGeometry === false ) {

      console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
      return;

    }

    if ( offset === undefined ) offset = 0;

    var attributes = this.attributes;

    for ( var key in attributes ) {

      if ( geometry.attributes[ key ] === undefined ) continue;

      var attribute1 = attributes[ key ];
      var attributeArray1 = attribute1.array;

      var attribute2 = geometry.attributes[ key ];
      var attributeArray2 = attribute2.array;

      var attributeSize = attribute2.itemSize;

      for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

        attributeArray1[ j ] = attributeArray2[ i ];

      }

    }

    return this;

  },

  normalizeNormals: function () {

    var normals = this.attributes.normal.array;

    var x, y, z, n;

    for ( var i = 0, il = normals.length; i < il; i += 3 ) {

      x = normals[ i ];
      y = normals[ i + 1 ];
      z = normals[ i + 2 ];

      n = 1.0 / Math.sqrt( x * x + y * y + z * z );

      normals[ i ] *= n;
      normals[ i + 1 ] *= n;
      normals[ i + 2 ] *= n;

    }

  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };

    // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    data.data = { attributes: {} };

    var attributes = this.attributes;
    var groups = this.groups;

    var boundingSphere = this.boundingSphere;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];

      var array = Array.prototype.slice.call( attribute.array );

      data.data.attributes[ key ] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array
      };

    }

    if ( groups.length > 0 ) {

      data.data.groups = JSON.parse( JSON.stringify( groups ) );

    }

    if ( boundingSphere !== null ) {

      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };

    }

    return data;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    var attributes = source.attributes;
    var groups = source.groups;

    for ( var name in attributes ) {

      var attribute = attributes[ name ];
      this.addAttribute( name, attribute.clone() );

    }

    for ( var i = 0, l = groups.length; i < l; i ++ ) {

      var group = groups[ i ];

      this.addGroup( group.start, group.count );

    }

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

  THREE.BufferGeometry.call( this );

  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addDrawCall = function ( start, count, instances ) {

  this.drawcalls.push( {

    start: start,
    count: count,
    instances: instances

  } );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

  for ( var attr in source.attributes ) {

    var sourceAttr = source.attributes[ attr ];
    this.addAttribute( attr, sourceAttr.clone() );

  }

  for ( var i = 0, il = source.drawcalls.length; i < il; i ++ ) {

    var offset = source.drawcalls[ i ];
    this.addDrawCall( offset.start, offset.count, offset.instances );

  }

  return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

  THREE.Object3D.call( this );

  this.type = 'Camera';

  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

  var quaternion = new THREE.Quaternion();

  return function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.getWorldQuaternion( quaternion );

    return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  };

}();

THREE.Camera.prototype.lookAt = function () {

  // This routine does not support cameras with rotated and/or translated parent(s)

  var m1 = new THREE.Matrix4();

  return function ( vector ) {

    m1.lookAt( this.position, vector, this.up );

    this.quaternion.setFromRotationMatrix( m1 );

  };

}();

THREE.Camera.prototype.clone = function () {

  return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.matrixWorldInverse.copy( source.matrixWorldInverse );
  this.projectionMatrix.copy( source.projectionMatrix );

  return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *  - renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

  THREE.Object3D.call( this );

  this.type = 'CubeCamera';

  var fov = 90, aspect = 1;

  var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPX.up.set( 0, - 1, 0 );
  cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
  this.add( cameraPX );

  var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNX.up.set( 0, - 1, 0 );
  cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
  this.add( cameraNX );

  var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPY.up.set( 0, 0, 1 );
  cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
  this.add( cameraPY );

  var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNY.up.set( 0, 0, - 1 );
  cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
  this.add( cameraNY );

  var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPZ.up.set( 0, - 1, 0 );
  cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
  this.add( cameraPZ );

  var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNZ.up.set( 0, - 1, 0 );
  cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
  this.add( cameraNZ );

  this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

  this.updateCubeMap = function ( renderer, scene ) {

    if ( this.parent === null ) this.updateMatrixWorld();

    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.generateMipmaps;

    renderTarget.generateMipmaps = false;

    renderTarget.activeCubeFace = 0;
    renderer.render( scene, cameraPX, renderTarget );

    renderTarget.activeCubeFace = 1;
    renderer.render( scene, cameraNX, renderTarget );

    renderTarget.activeCubeFace = 2;
    renderer.render( scene, cameraPY, renderTarget );

    renderTarget.activeCubeFace = 3;
    renderer.render( scene, cameraNY, renderTarget );

    renderTarget.activeCubeFace = 4;
    renderer.render( scene, cameraPZ, renderTarget );

    renderTarget.generateMipmaps = generateMipmaps;

    renderTarget.activeCubeFace = 5;
    renderer.render( scene, cameraNZ, renderTarget );

    renderer.setRenderTarget( null );

  };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

  THREE.Camera.call( this );

  this.type = 'OrthographicCamera';

  this.zoom = 1;

  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;

  this.near = ( near !== undefined ) ? near : 0.1;
  this.far = ( far !== undefined ) ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

  var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  var cx = ( this.right + this.left ) / 2;
  var cy = ( this.top + this.bottom ) / 2;

  this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {

  THREE.Camera.prototype.copy.call( this, source );

  this.left = source.left;
  this.right = source.right;
  this.top = source.top;
  this.bottom = source.bottom;
  this.near = source.near;
  this.far = source.far;

  this.zoom = source.zoom;

  return this;

};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.zoom = this.zoom;
  data.object.left = this.left;
  data.object.right = this.right;
  data.object.top = this.top;
  data.object.bottom = this.bottom;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

  THREE.Camera.call( this );

  this.type = 'PerspectiveCamera';

  this.zoom = 1;

  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

  if ( frameHeight === undefined ) frameHeight = 24;

  this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
  this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;

  this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

  var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

  if ( this.fullWidth ) {

    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
    var bottom = - top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs( right - left );
    var height = Math.abs( top - bottom );

    this.projectionMatrix.makeFrustum(
      left + this.x * width / this.fullWidth,
      left + ( this.x + this.width ) * width / this.fullWidth,
      top - ( this.y + this.height ) * height / this.fullHeight,
      top - this.y * height / this.fullHeight,
      this.near,
      this.far
    );

  } else {

    this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

  }

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {

  THREE.Camera.prototype.copy.call( this, source );

  this.fov = source.fov;
  this.aspect = source.aspect;
  this.near = source.near;
  this.far = source.far;

  this.zoom = source.zoom;

  return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.zoom = this.zoom;
  data.object.fov = this.fov;
  data.object.aspect = this.aspect;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

  THREE.Object3D.call( this );

  this.type = 'Light';

  this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.color.copy( source.color );

  return this;

};
// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

  THREE.Light.call( this, color );

  this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();

  return data;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 * @author prafullit
 */

THREE.AreaLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'AreaLight';

  this.normal = new THREE.Vector3( 0, - 1, 0 );
  this.right = new THREE.Vector3( 1, 0, 0 );

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.width = 1.0;
  this.height = 1.0;

  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
THREE.AreaLight.prototype.constructor = THREE.AreaLight;

THREE.AreaLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.intensity = source.intensity;
  this.normal.copy( source.normal );
  this.right.copy( source.right );
  this.width = source.width;
  this.height = source.height;
  this.constantAttenuation = source.constantAttenuation;
  this.linearAttenuation = source.linearAttenuation;
  this.quadraticAttenuation = source.quadraticAttenuation;

  return this;

};

THREE.AreaLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;

  return data;

};

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'DirectionalLight';

  this.position.set( 0, 1, 0 );
  this.updateMatrix();

  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.castShadow = false;
  this.onlyShadow = false;

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;

  this.shadowCameraLeft = - 500;
  this.shadowCameraRight = 500;
  this.shadowCameraTop = 500;
  this.shadowCameraBottom = - 500;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.intensity = source.intensity;
  this.target = source.target.clone();

  this.castShadow = source.castShadow;
  this.onlyShadow = source.onlyShadow;

  this.shadowCameraNear = source.shadowCameraNear;
  this.shadowCameraFar = source.shadowCameraFar;

  this.shadowCameraLeft = source.shadowCameraLeft;
  this.shadowCameraRight = source.shadowCameraRight;
  this.shadowCameraTop = source.shadowCameraTop;
  this.shadowCameraBottom = source.shadowCameraBottom;

  this.shadowCameraVisible = source.shadowCameraVisible;

  this.shadowBias = source.shadowBias;
  this.shadowDarkness = source.shadowDarkness;

  this.shadowMapWidth = source.shadowMapWidth;
  this.shadowMapHeight = source.shadowMapHeight;

  return this;

};

THREE.DirectionalLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;

  return data;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

  THREE.Light.call( this, skyColor );

  this.type = 'HemisphereLight';

  this.position.set( 0, 100, 0 );
  this.updateMatrix();

  this.groundColor = new THREE.Color( groundColor );
  this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.groundColor.copy( source.groundColor );
  this.intensity = source.intensity;

  return this;

};

THREE.HemisphereLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.groundColor = this.groundColor.getHex();
  data.object.intensity = this.intensity;

  return data;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance, decay ) {

  THREE.Light.call( this, color );

  this.type = 'PointLight';

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.intensity = source.intensity;
  this.distance = source.distance;
  this.decay = source.decay;

  return this;

};

THREE.PointLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  data.object.distance = this.distance;
  data.object.decay = this.decay;

  return data;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

  THREE.Light.call( this, color );

  this.type = 'SpotLight';

  this.position.set( 0, 1, 0 );
  this.updateMatrix();

  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  this.exponent = ( exponent !== undefined ) ? exponent : 10;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

  this.castShadow = false;
  this.onlyShadow = false;

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.intensity = source.intensity;
  this.distance = source.distance;
  this.angle = source.angle;
  this.exponent = source.exponent;
  this.decay = source.decay;

  this.target = source.target.clone();

  this.castShadow = source.castShadow;
  this.onlyShadow = source.onlyShadow;

  this.shadowCameraNear = source.shadowCameraNear;
  this.shadowCameraFar = source.shadowCameraFar;
  this.shadowCameraFov = source.shadowCameraFov;

  this.shadowCameraVisible = source.shadowCameraVisible;

  this.shadowBias = source.shadowBias;
  this.shadowDarkness = source.shadowDarkness;

  this.shadowMapWidth = source.shadowMapWidth;
  this.shadowMapHeight = source.shadowMapHeight;

  return this;
}

THREE.SpotLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  data.object.distance = this.distance;
  data.object.angle = this.angle;
  data.object.exponent = this.exponent;
  data.object.decay = this.decay;

  return data;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

  enabled: false,

  files: {},

  add: function ( key, file ) {

    if ( this.enabled === false ) return;

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[ key ] = file;

  },

  get: function ( key ) {

    if ( this.enabled === false ) return;

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[ key ];

  },

  remove: function ( key ) {

    delete this.files[ key ];

  },

  clear: function () {

    this.files = {};

  }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

  this.onLoadStart = function () {};
  this.onLoadProgress = function () {};
  this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

  constructor: THREE.Loader,

  crossOrigin: undefined,

  extractUrlBase: function ( url ) {

    var parts = url.split( '/' );

    if ( parts.length === 1 ) return './';

    parts.pop();

    return parts.join( '/' ) + '/';

  },

  initMaterials: function ( materials, texturePath, crossOrigin ) {

    var array = [];

    for ( var i = 0; i < materials.length; ++ i ) {

      array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

    }

    return array;

  },

  needsTangents: function ( materials ) {

    for ( var i = 0, il = materials.length; i < il; i ++ ) {

      var m = materials[ i ];

      if ( m instanceof THREE.ShaderMaterial ) return true;

    }

    return false;

  },

  createMaterial: ( function () {

    var imageLoader;

    return function createMaterial( m, texturePath, crossOrigin ) {

      var scope = this;

      if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;

      if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();

      function nearest_pow2( n ) {

        var l = Math.log( n ) / Math.LN2;
        return Math.pow( 2, Math.round(  l ) );

      }

      function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

        var fullPath = texturePath + sourceFile;

        var texture;

        var loader = THREE.Loader.Handlers.get( fullPath );

        if ( loader !== null ) {

          texture = loader.load( fullPath );

        } else {

          texture = new THREE.Texture();

          loader = imageLoader;
          loader.setCrossOrigin( crossOrigin );
          loader.load( fullPath, function ( image ) {

            if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
              THREE.Math.isPowerOfTwo( image.height ) === false ) {

              var width = nearest_pow2( image.width );
              var height = nearest_pow2( image.height );

              var canvas = document.createElement( 'canvas' );
              canvas.width = width;
              canvas.height = height;

              var context = canvas.getContext( '2d' );
              context.drawImage( image, 0, 0, width, height );

              texture.image = canvas;

            } else {

              texture.image = image;

            }

            texture.needsUpdate = true;

          } );

        }

        texture.sourceFile = sourceFile;

        if ( repeat ) {

          texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

          if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
          if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

        }

        if ( offset ) {

          texture.offset.set( offset[ 0 ], offset[ 1 ] );

        }

        if ( wrap ) {

          var wrapMap = {
            'repeat': THREE.RepeatWrapping,
            'mirror': THREE.MirroredRepeatWrapping
          };

          if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
          if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

        }

        if ( anisotropy ) {

          texture.anisotropy = anisotropy;

        }

        where[ name ] = texture;

      }

      function rgb2hex( rgb ) {

        return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

      }

      // defaults

      var mtype = 'MeshLambertMaterial';
      var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

      // parameters from model file

      if ( m.shading ) {

        var shading = m.shading.toLowerCase();

        if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
        else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

      }

      if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

        mpars.blending = THREE[ m.blending ];

      }

      if ( m.transparent !== undefined ) {

        mpars.transparent = m.transparent;

      }

      if ( m.opacity !== undefined && m.opacity < 1.0 ) {

        mpars.transparent = true;

      }

      if ( m.depthTest !== undefined ) {

        mpars.depthTest = m.depthTest;

      }

      if ( m.depthWrite !== undefined ) {

        mpars.depthWrite = m.depthWrite;

      }

      if ( m.visible !== undefined ) {

        mpars.visible = m.visible;

      }

      if ( m.flipSided !== undefined ) {

        mpars.side = THREE.BackSide;

      }

      if ( m.doubleSided !== undefined ) {

        mpars.side = THREE.DoubleSide;

      }

      if ( m.wireframe !== undefined ) {

        mpars.wireframe = m.wireframe;

      }

      if ( m.vertexColors !== undefined ) {

        if ( m.vertexColors === 'face' ) {

          mpars.vertexColors = THREE.FaceColors;

        } else if ( m.vertexColors ) {

          mpars.vertexColors = THREE.VertexColors;

        }

      }

      // colors

      if ( m.colorDiffuse ) {

        mpars.color = rgb2hex( m.colorDiffuse );

      } else if ( m.DbgColor ) {

        mpars.color = m.DbgColor;

      }

      if ( m.colorSpecular ) {

        mpars.specular = rgb2hex( m.colorSpecular );

      }

      if ( m.colorEmissive ) {

        mpars.emissive = rgb2hex( m.colorEmissive );

      }

      // modifiers

      if ( m.transparency !== undefined ) {

        console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
        m.opacity = m.transparency;

      }

      if ( m.opacity !== undefined ) {

        mpars.opacity = m.opacity;

      }

      if ( m.specularCoef ) {

        mpars.shininess = m.specularCoef;

      }

      // textures

      if ( m.mapDiffuse && texturePath ) {

        create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

      }

      if ( m.mapLight && texturePath ) {

        create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

      }

      if ( m.mapAO && texturePath ) {

        create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

      }

      if ( m.mapBump && texturePath ) {

        create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

      }

      if ( m.mapNormal && texturePath ) {

        create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

      }

      if ( m.mapSpecular && texturePath ) {

        create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

      }

      if ( m.mapAlpha && texturePath ) {

        create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

      }

      //

      if ( m.mapBumpScale ) {

        mpars.bumpScale = m.mapBumpScale;

      }

      if ( m.mapNormalFactor ) {

        mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

      }

      var material = new THREE[ mtype ]( mpars );

      if ( m.DbgName !== undefined ) material.name = m.DbgName;

      return material;

    };

  } )()

};

THREE.Loader.Handlers = {

  handlers: [],

  add: function ( regex, loader ) {

    this.handlers.push( regex, loader );

  },

  get: function ( file ) {

    for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

      var regex = this.handlers[ i ];
      var loader  = this.handlers[ i + 1 ];

      if ( regex.test( file ) ) {

        return loader;

      }

    }

    return null;

  }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

  constructor: THREE.XHRLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) {

        setTimeout( function () {

          onLoad( cached );

        }, 0 );

      }

      return cached;

    }

    var request = new XMLHttpRequest();
    request.open( 'GET', url, true );

    request.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this.response );

      if ( onLoad ) onLoad( this.response );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      request.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      request.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
    if ( this.responseType !== undefined ) request.responseType = this.responseType;
    if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

    request.send( null );

    scope.manager.itemStart( url );

    return request;

  },

  setResponseType: function ( value ) {

    this.responseType = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setWithCredentials: function ( value ) {

    this.withCredentials = value;

  }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

  constructor: THREE.ImageLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) {

        setTimeout( function () {

          onLoad( cached );

        }, 0 );

      }

      return cached;

    }

    var image = document.createElement( 'img' );

    image.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this );

      if ( onLoad ) onLoad( this );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      image.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      image.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

    scope.manager.itemStart( url );

    image.src = url;

    return image;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

  constructor: THREE.JSONLoader,

  load: function( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

    var loader = new THREE.XHRLoader( this.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.setWithCredentials( this.withCredentials );
    loader.load( url, function ( text ) {

      var json = JSON.parse( text );
      var metadata = json.metadata;

      if ( metadata !== undefined ) {

        if ( metadata.type === 'object' ) {

          console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
          return;

        }

        if ( metadata.type === 'scene' ) {

          console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
          return;

        }

      }

      var object = scope.parse( json, texturePath );
      onLoad( object.geometry, object.materials );

    } );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setTexturePath: function ( value ) {

    this.texturePath = value;

  },

  parse: function ( json, texturePath ) {

    var geometry = new THREE.Geometry(),
    scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    parseModel( scale );

    parseSkin();
    parseMorphing( scale );

    geometry.computeFaceNormals();
    geometry.computeBoundingSphere();

    function parseModel( scale ) {

      function isBitSet( value, position ) {

        return value & ( 1 << position );

      }

      var i, j, fi,

      offset, zLength,

    colorIndex, normalIndex, uvIndex, materialIndex,

      type,
      isQuad,
      hasMaterial,
      hasFaceVertexUv,
      hasFaceNormal, hasFaceVertexNormal,
      hasFaceColor, hasFaceVertexColor,

    vertex, face, faceA, faceB, hex, normal,

      uvLayer, uv, u, v,

      faces = json.faces,
      vertices = json.vertices,
      normals = json.normals,
      colors = json.colors,

      nUvLayers = 0;

      if ( json.uvs !== undefined ) {

        // disregard empty arrays

        for ( i = 0; i < json.uvs.length; i ++ ) {

          if ( json.uvs[ i ].length ) nUvLayers ++;

        }

        for ( i = 0; i < nUvLayers; i ++ ) {

          geometry.faceVertexUvs[ i ] = [];

        }

      }

      offset = 0;
      zLength = vertices.length;

      while ( offset < zLength ) {

        vertex = new THREE.Vector3();

        vertex.x = vertices[ offset ++ ] * scale;
        vertex.y = vertices[ offset ++ ] * scale;
        vertex.z = vertices[ offset ++ ] * scale;

        geometry.vertices.push( vertex );

      }

      offset = 0;
      zLength = faces.length;

      while ( offset < zLength ) {

        type = faces[ offset ++ ];


        isQuad              = isBitSet( type, 0 );
        hasMaterial         = isBitSet( type, 1 );
        hasFaceVertexUv     = isBitSet( type, 3 );
        hasFaceNormal       = isBitSet( type, 4 );
        hasFaceVertexNormal = isBitSet( type, 5 );
        hasFaceColor       = isBitSet( type, 6 );
        hasFaceVertexColor  = isBitSet( type, 7 );

        // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

        if ( isQuad ) {

          faceA = new THREE.Face3();
          faceA.a = faces[ offset ];
          faceA.b = faces[ offset + 1 ];
          faceA.c = faces[ offset + 3 ];

          faceB = new THREE.Face3();
          faceB.a = faces[ offset + 1 ];
          faceB.b = faces[ offset + 2 ];
          faceB.c = faces[ offset + 3 ];

          offset += 4;

          if ( hasMaterial ) {

            materialIndex = faces[ offset ++ ];
            faceA.materialIndex = materialIndex;
            faceB.materialIndex = materialIndex;

          }

          // to get face <=> uv index correspondence

          fi = geometry.faces.length;

          if ( hasFaceVertexUv ) {

            for ( i = 0; i < nUvLayers; i ++ ) {

              uvLayer = json.uvs[ i ];

              geometry.faceVertexUvs[ i ][ fi ] = [];
              geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

              for ( j = 0; j < 4; j ++ ) {

                uvIndex = faces[ offset ++ ];

                u = uvLayer[ uvIndex * 2 ];
                v = uvLayer[ uvIndex * 2 + 1 ];

                uv = new THREE.Vector2( u, v );

                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

              }

            }

          }

          if ( hasFaceNormal ) {

            normalIndex = faces[ offset ++ ] * 3;

            faceA.normal.set(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

            faceB.normal.copy( faceA.normal );

          }

          if ( hasFaceVertexNormal ) {

            for ( i = 0; i < 4; i ++ ) {

              normalIndex = faces[ offset ++ ] * 3;

              normal = new THREE.Vector3(
                normals[ normalIndex ++ ],
                normals[ normalIndex ++ ],
                normals[ normalIndex ]
              );


              if ( i !== 2 ) faceA.vertexNormals.push( normal );
              if ( i !== 0 ) faceB.vertexNormals.push( normal );

            }

          }


          if ( hasFaceColor ) {

            colorIndex = faces[ offset ++ ];
            hex = colors[ colorIndex ];

            faceA.color.setHex( hex );
            faceB.color.setHex( hex );

          }


          if ( hasFaceVertexColor ) {

            for ( i = 0; i < 4; i ++ ) {

              colorIndex = faces[ offset ++ ];
              hex = colors[ colorIndex ];

              if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
              if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

            }

          }

          geometry.faces.push( faceA );
          geometry.faces.push( faceB );

        } else {

          face = new THREE.Face3();
          face.a = faces[ offset ++ ];
          face.b = faces[ offset ++ ];
          face.c = faces[ offset ++ ];

          if ( hasMaterial ) {

            materialIndex = faces[ offset ++ ];
            face.materialIndex = materialIndex;

          }

          // to get face <=> uv index correspondence

          fi = geometry.faces.length;

          if ( hasFaceVertexUv ) {

            for ( i = 0; i < nUvLayers; i ++ ) {

              uvLayer = json.uvs[ i ];

              geometry.faceVertexUvs[ i ][ fi ] = [];

              for ( j = 0; j < 3; j ++ ) {

                uvIndex = faces[ offset ++ ];

                u = uvLayer[ uvIndex * 2 ];
                v = uvLayer[ uvIndex * 2 + 1 ];

                uv = new THREE.Vector2( u, v );

                geometry.faceVertexUvs[ i ][ fi ].push( uv );

              }

            }

          }

          if ( hasFaceNormal ) {

            normalIndex = faces[ offset ++ ] * 3;

            face.normal.set(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

          }

          if ( hasFaceVertexNormal ) {

            for ( i = 0; i < 3; i ++ ) {

              normalIndex = faces[ offset ++ ] * 3;

              normal = new THREE.Vector3(
                normals[ normalIndex ++ ],
                normals[ normalIndex ++ ],
                normals[ normalIndex ]
              );

              face.vertexNormals.push( normal );

            }

          }


          if ( hasFaceColor ) {

            colorIndex = faces[ offset ++ ];
            face.color.setHex( colors[ colorIndex ] );

          }


          if ( hasFaceVertexColor ) {

            for ( i = 0; i < 3; i ++ ) {

              colorIndex = faces[ offset ++ ];
              face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

            }

          }

          geometry.faces.push( face );

        }

      }

    };

    function parseSkin() {

      var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

      if ( json.skinWeights ) {

        for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

          var x =                               json.skinWeights[ i ];
          var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
          var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
          var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

          geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

        }

      }

      if ( json.skinIndices ) {

        for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

          var a =                               json.skinIndices[ i ];
          var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
          var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
          var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

          geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

        }

      }

      geometry.bones = json.bones;

      if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

        console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
          geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

      }


      // could change this to json.animations[0] or remove completely

      geometry.animation = json.animation;
      geometry.animations = json.animations;

    };

    function parseMorphing( scale ) {

      if ( json.morphTargets !== undefined ) {

        var i, l, v, vl, dstVertices, srcVertices;

        for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

          geometry.morphTargets[ i ] = {};
          geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
          geometry.morphTargets[ i ].vertices = [];

          dstVertices = geometry.morphTargets[ i ].vertices;
          srcVertices = json.morphTargets[ i ].vertices;

          for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

            var vertex = new THREE.Vector3();
            vertex.x = srcVertices[ v ] * scale;
            vertex.y = srcVertices[ v + 1 ] * scale;
            vertex.z = srcVertices[ v + 2 ] * scale;

            dstVertices.push( vertex );

          }

        }

      }

      if ( json.morphColors !== undefined ) {

        var i, l, c, cl, dstColors, srcColors, color;

        for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

          geometry.morphColors[ i ] = {};
          geometry.morphColors[ i ].name = json.morphColors[ i ].name;
          geometry.morphColors[ i ].colors = [];

          dstColors = geometry.morphColors[ i ].colors;
          srcColors = json.morphColors[ i ].colors;

          for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

            color = new THREE.Color( 0xffaa00 );
            color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
            dstColors.push( color );

          }

        }

      }

    };

    if ( json.materials === undefined || json.materials.length === 0 ) {

      return { geometry: geometry };

    } else {

      var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

      if ( THREE.Loader.prototype.needsTangents( materials ) ) {

        geometry.computeTangents();

      }

      return { geometry: geometry, materials: materials };

    }

  }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

  var scope = this;

  var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function ( url ) {

    itemsTotal ++;

    if ( isLoading === false ) {

      if ( scope.onStart !== undefined ) {

        scope.onStart( url, itemsLoaded, itemsTotal );

      }

    }

    isLoading = true;

  };

  this.itemEnd = function ( url ) {

    itemsLoaded ++;

    if ( scope.onProgress !== undefined ) {

      scope.onProgress( url, itemsLoaded, itemsTotal );

    }

    if ( itemsLoaded === itemsTotal ) {

      isLoading = false;

      if ( scope.onLoad !== undefined ) {

        scope.onLoad();

      }

    }

  };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

  constructor: THREE.BufferGeometryLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var geometry = new THREE.BufferGeometry();

    var attributes = json.data.attributes;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];
      var typedArray = new self[ attribute.type ]( attribute.array );

      geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

    }

    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if ( groups !== undefined ) {

      for ( var i = 0, n = groups.length; i !== n; ++ i ) {

        var group = groups[ i ];

        geometry.addGroup( group.start, group.count );

      }

    }

    var boundingSphere = json.data.boundingSphere;

    if ( boundingSphere !== undefined ) {

      var center = new THREE.Vector3();

      if ( boundingSphere.center !== undefined ) {

        center.fromArray( boundingSphere.center );

      }

      geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

    }

    return geometry;

  }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

  constructor: THREE.MaterialLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var material = new THREE[ json.type ];

    if ( json.color !== undefined ) material.color.setHex( json.color );
    if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    if ( json.shininess !== undefined ) material.shininess = json.shininess;
    if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    if ( json.attributes !== undefined ) material.attributes = json.attributes;
    if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    if ( json.shading !== undefined ) material.shading = json.shading;
    if ( json.blending !== undefined ) material.blending = json.blending;
    if ( json.side !== undefined ) material.side = json.side;
    if ( json.opacity !== undefined ) material.opacity = json.opacity;
    if ( json.transparent !== undefined ) material.transparent = json.transparent;
    if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
    if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

    // for PointCloudMaterial
    if ( json.size !== undefined ) material.size = json.size;
    if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    if ( json.materials !== undefined ) {

      for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

        material.materials.push( this.parse( json.materials[ i ] ) );

      }

    }

    return material;

  }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
  this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

  constructor: THREE.ObjectLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    if ( this.texturePath === '' ) {

      this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    }

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      scope.parse( JSON.parse( text ), onLoad );

    }, onProgress, onError );

  },

  setTexturePath: function ( value ) {

    this.texturePath = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json, onLoad ) {

    var geometries = this.parseGeometries( json.geometries );

    var images = this.parseImages( json.images, function () {

      if ( onLoad !== undefined ) onLoad( object );

    } );

    var textures  = this.parseTextures( json.textures, images );
    var materials = this.parseMaterials( json.materials, textures );
    var object = this.parseObject( json.object, geometries, materials );

    if ( json.images === undefined || json.images.length === 0 ) {

      if ( onLoad !== undefined ) onLoad( object );

    }

    return object;

  },

  parseGeometries: function ( json ) {

    var geometries = {};

    if ( json !== undefined ) {

      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var geometry;
        var data = json[ i ];

        switch ( data.type ) {

          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':

            geometry = new THREE[ data.type ](
              data.width,
              data.height,
              data.widthSegments,
              data.heightSegments
            );

            break;

          case 'BoxGeometry':
          case 'CubeGeometry': // backwards compatible

            geometry = new THREE.BoxGeometry(
              data.width,
              data.height,
              data.depth,
              data.widthSegments,
              data.heightSegments,
              data.depthSegments
            );

            break;

          case 'CircleBufferGeometry':

            geometry = new THREE.CircleBufferGeometry(
              data.radius,
              data.segments,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'CircleGeometry':

            geometry = new THREE.CircleGeometry(
              data.radius,
              data.segments,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'CylinderGeometry':

            geometry = new THREE.CylinderGeometry(
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'SphereGeometry':

            geometry = new THREE.SphereGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'SphereBufferGeometry':

            geometry = new THREE.SphereBufferGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'DodecahedronGeometry':

            geometry = new THREE.DodecahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'IcosahedronGeometry':

            geometry = new THREE.IcosahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'OctahedronGeometry':

            geometry = new THREE.OctahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'TetrahedronGeometry':

            geometry = new THREE.TetrahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'RingGeometry':

            geometry = new THREE.RingGeometry(
              data.innerRadius,
              data.outerRadius,
              data.thetaSegments,
              data.phiSegments,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'TorusGeometry':

            geometry = new THREE.TorusGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.arc
            );

            break;

          case 'TorusKnotGeometry':

            geometry = new THREE.TorusKnotGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.p,
              data.q,
              data.heightScale
            );

            break;

          case 'BufferGeometry':

            geometry = bufferGeometryLoader.parse( data );

            break;

          case 'Geometry':

            geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

            break;

          case 'TextGeometry':

            geometry = new THREE.TextGeometry(
              data.text,
              data.data
            );

            break;

        }

        geometry.uuid = data.uuid;

        if ( data.name !== undefined ) geometry.name = data.name;

        geometries[ data.uuid ] = geometry;

      }

    }

    return geometries;

  },

  parseMaterials: function ( json, textures ) {

    var materials = {};

    if ( json !== undefined ) {

      var getTexture = function ( name ) {

        if ( textures[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined texture', name );

        }

        return textures[ name ];

      };

      var loader = new THREE.MaterialLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];
        var material = loader.parse( data );

        material.uuid = data.uuid;

        if ( data.depthTest !== undefined ) material.depthTest = data.depthTest;
        if ( data.depthWrite !== undefined ) material.depthWrite = data.depthWrite;

        if ( data.name !== undefined ) material.name = data.name;

        if ( data.map !== undefined ) material.map = getTexture( data.map );

        if ( data.alphaMap !== undefined ) {

          material.alphaMap = getTexture( data.alphaMap );
          material.transparent = true;

        }

        if ( data.bumpMap !== undefined ) material.bumpMap = getTexture( data.bumpMap );
        if ( data.bumpScale !== undefined ) material.bumpScale = data.bumpScale;

        if ( data.normalMap !== undefined ) material.normalMap = getTexture( data.normalMap );
        if ( data.normalScale ) material.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );

        if ( data.specularMap !== undefined ) material.specularMap = getTexture( data.specularMap );

        if ( data.envMap !== undefined ) {

          material.envMap = getTexture( data.envMap );
          material.combine = THREE.MultiplyOperation;

        }

        if ( data.reflectivity ) material.reflectivity = data.reflectivity;

        if ( data.lightMap !== undefined ) material.lightMap = getTexture( data.lightMap );
        if ( data.lightMapIntensity !== undefined ) material.lightMapIntensity = data.lightMapIntensity;

        if ( data.aoMap !== undefined ) material.aoMap = getTexture( data.aoMap );
        if ( data.aoMapIntensity !== undefined ) material.aoMapIntensity = data.aoMapIntensity;

        materials[ data.uuid ] = material;

      }

    }

    return materials;

  },

  parseImages: function ( json, onLoad ) {

    var scope = this;
    var images = {};

    if ( json !== undefined && json.length > 0 ) {

      var manager = new THREE.LoadingManager( onLoad );

      var loader = new THREE.ImageLoader( manager );
      loader.setCrossOrigin( this.crossOrigin );

      var loadImage = function ( url ) {

        url = scope.texturePath + url;

        scope.manager.itemStart( url );

        return loader.load( url, function () {

          scope.manager.itemEnd( url );

        } );

      };

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var image = json[ i ];
        images[ image.uuid ] = loadImage( image.url );

      }

    }

    return images;

  },

  parseTextures: function ( json, images ) {

    function parseConstant( value ) {

      if ( typeof( value ) === 'number' ) return value;

      console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

      return THREE[ value ];

    }

    var textures = {};

    if ( json !== undefined ) {

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];

        if ( data.image === undefined ) {

          console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

        }

        if ( images[ data.image ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

        }

        var texture = new THREE.Texture( images[ data.image ] );
        texture.needsUpdate = true;

        texture.uuid = data.uuid;

        if ( data.name !== undefined ) texture.name = data.name;
        if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
        if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
        if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
        if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
        if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
        if ( Array.isArray( data.wrap ) ) {

          texture.wrapS = parseConstant( data.wrap[ 0 ] );
          texture.wrapT = parseConstant( data.wrap[ 1 ] );

        }

        textures[ data.uuid ] = texture;

      }

    }

    return textures;

  },

  parseObject: function () {

    var matrix = new THREE.Matrix4();

    return function ( data, geometries, materials ) {

      var object;

      var getGeometry = function ( name ) {

        if ( geometries[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

        }

        return geometries[ name ];

      };

      var getMaterial = function ( name ) {

        if ( materials[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined material', name );

        }

        return materials[ name ];

      };

      switch ( data.type ) {

        case 'Scene':

          object = new THREE.Scene();

          break;

        case 'PerspectiveCamera':

          object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

          break;

        case 'OrthographicCamera':

          object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

          break;

        case 'AmbientLight':

          object = new THREE.AmbientLight( data.color );

          break;


        case 'AreaLight':

          object = new THREE.AreaLight( data.color, data.intensity );

          break;

        case 'DirectionalLight':

          object = new THREE.DirectionalLight( data.color, data.intensity );

          break;

        case 'PointLight':

          object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

          break;

        case 'SpotLight':

          object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

          break;

        case 'HemisphereLight':

          object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

          break;

        case 'Mesh':

          object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Line':

          object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

          break;

        case 'PointCloud':

          object = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Sprite':

          object = new THREE.Sprite( getMaterial( data.material ) );

          break;

        case 'Group':

          object = new THREE.Group();

          break;

        default:

          object = new THREE.Object3D();

      }

      object.uuid = data.uuid;

      if ( data.name !== undefined ) object.name = data.name;
      if ( data.matrix !== undefined ) {

        matrix.fromArray( data.matrix );
        matrix.decompose( object.position, object.quaternion, object.scale );

      } else {

        if ( data.position !== undefined ) object.position.fromArray( data.position );
        if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
        if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

      }

      if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
      if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

      if ( data.visible !== undefined ) object.visible = data.visible;
      if ( data.userData !== undefined ) object.userData = data.userData;

      if ( data.children !== undefined ) {

        for ( var child in data.children ) {

          object.add( this.parseObject( data.children[ child ], geometries, materials ) );

        }

      }

      return object;

    }

  }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

  constructor: THREE.TextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.ImageLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( image ) {

      var texture = new THREE.Texture( image );
      texture.needsUpdate = true;

      if ( onLoad !== undefined ) {

        onLoad( texture );

      }

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  // override in sub classes
  this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

  constructor: THREE.BinaryTextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texture = new THREE.DataTexture();

    var loader = new THREE.XHRLoader( this.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.setResponseType( 'arraybuffer' );

    loader.load( url, function ( buffer ) {

      var texData = scope._parser( buffer );

      if ( ! texData ) return;

      if ( undefined !== texData.image ) {

        texture.image = texData.image;

      } else if ( undefined !== texData.data ) {

        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;

      }

      texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
      texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

      texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
      texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

      texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

      if ( undefined !== texData.format ) {

        texture.format = texData.format;

      }
      if ( undefined !== texData.type ) {

        texture.type = texData.type;

      }

      if ( undefined !== texData.mipmaps ) {

        texture.mipmaps = texData.mipmaps;

      }

      if ( 1 === texData.mipmapCount ) {

        texture.minFilter = THREE.LinearFilter;

      }

      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture, texData );

    }, onProgress, onError );


    return texture;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  // override in sub classes
  this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

  constructor: THREE.CompressedTextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var images = [];

    var texture = new THREE.CompressedTexture();
    texture.image = images;

    var loader = new THREE.XHRLoader( this.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.setResponseType( 'arraybuffer' );

    if ( Array.isArray( url ) ) {

      var loaded = 0;

      var loadTexture = function ( i ) {

        loader.load( url[ i ], function ( buffer ) {

          var texDatas = scope._parser( buffer, true );

          images[ i ] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };

          loaded += 1;

          if ( loaded === 6 ) {

            if ( texDatas.mipmapCount === 1 )
              texture.minFilter = THREE.LinearFilter;

            texture.format = texDatas.format;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

          }

        }, onProgress, onError );

      };

      for ( var i = 0, il = url.length; i < il; ++ i ) {

        loadTexture( i );

      }

    } else {

      // compressed cubemap texture stored in a single DDS file

      loader.load( url, function ( buffer ) {

        var texDatas = scope._parser( buffer, true );

        if ( texDatas.isCubemap ) {

          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for ( var f = 0; f < faces; f ++ ) {

            images[ f ] = { mipmaps : [] };

            for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

              images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
              images[ f ].format = texDatas.format;
              images[ f ].width = texDatas.width;
              images[ f ].height = texDatas.height;

            }

          }

        } else {

          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;

        }

        if ( texDatas.mipmapCount === 1 ) {

          texture.minFilter = THREE.LinearFilter;

        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;

        if ( onLoad ) onLoad( texture );

      }, onProgress, onError );

    }

    return texture;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

  Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Material';

  this.side = THREE.FrontSide;

  this.opacity = 1;
  this.transparent = false;

  this.blending = THREE.NormalBlending;

  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;

  this.depthFunc = THREE.LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;

  this.colorWrite = true;

  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;

  this.alphaTest = 0;

  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  this.visible = true;

  this._needsUpdate = true;

};

THREE.Material.prototype = {

  constructor: THREE.Material,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  setValues: function ( values ) {

    if ( values === undefined ) return;

    for ( var key in values ) {

      var newValue = values[ key ];

      if ( newValue === undefined ) {

        console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
        continue;

      }

      if ( key in this ) {

        var currentValue = this[ key ];

        if ( currentValue instanceof THREE.Color ) {

          currentValue.set( newValue );

        } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

          currentValue.copy( newValue );

        } else if ( key === 'overdraw' ) {

          // ensure overdraw is backwards-compatible with legacy boolean type
          this[ key ] = Number( newValue );

        } else {

          this[ key ] = newValue;

        }

      }

    }

  },

  toJSON: function ( meta ) {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    };

    // standard Material serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
    if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
    if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
    if ( this.shininess !== undefined ) data.shininess = this.shininess;

    if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
    if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    if ( this.bumpMap instanceof THREE.Texture ) {

      data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
      data.bumpScale = this.bumpScale;

    }
    if ( this.normalMap instanceof THREE.Texture ) {

      data.normalMap = this.normalMap.toJSON( meta ).uuid;
      data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

    }
    if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
    if ( this.envMap instanceof THREE.Texture ) {

      data.envMap = this.envMap.toJSON( meta ).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap

    }

    if ( this.size !== undefined ) data.size = this.size;
    if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
    if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
    if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
    if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

    if ( this.opacity < 1 ) data.opacity = this.opacity;
    if ( this.transparent === true ) data.transparent = this.transparent;
    if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    if ( this.wireframe === true ) data.wireframe = this.wireframe;
    if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

    return data;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.name = source.name;

    this.side = source.side;

    this.opacity = source.opacity;
    this.transparent = source.transparent;

    this.blending = source.blending;

    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;

    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;

    this.precision = source.precision;

    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;

    this.alphaTest = source.alphaTest;

    this.overdraw = source.overdraw;

    this.visible = source.visible;

    return this;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineBasicMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;

  this.vertexColors = source.vertexColors;

  this.fog = source.fog;

  return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineDashedMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;

  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;

  this.vertexColors = false;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.linewidth = source.linewidth;

  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;

  this.vertexColors = source.vertexColors;

  this.fog = source.fog;

  return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshBasicMaterial';

  this.color = new THREE.Color( 0xffffff ); // emissive

  this.map = null;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.map = source.map;

  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;

  this.specularMap = source.specularMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;

  return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshLambertMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );

  this.map = null;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.emissive.copy( source.emissive );

  this.map = source.map;

  this.specularMap = source.specularMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshPhongMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );
  this.specular = new THREE.Color( 0x111111 );
  this.shininess = 30;

  this.metal = false;

  this.map = null;

  this.lightMap = null;
  this.lightMapIntensity = 1.0;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.emissiveMap = null;

  this.bumpMap = null;
  this.bumpScale = 1;

  this.normalMap = null;
  this.normalScale = new THREE.Vector2( 1, 1 );

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.emissive.copy( source.emissive );
  this.specular.copy( source.specular );
  this.shininess = source.shininess;

  this.metal = source.metal;

  this.map = source.map;

  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;

  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;

  this.emissiveMap = source.emissiveMap;

  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;

  this.normalMap = source.normalMap;
  this.normalScale.copy( source.normalScale );

  this.specularMap = source.specularMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshDepthMaterial';

  this.morphTargets = false;
  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;

  return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

  THREE.Material.call( this, parameters );

  this.type = 'MeshNormalMaterial';

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;

  return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

  this.uuid = THREE.Math.generateUUID();

  this.type = 'MultiMaterial';

  this.materials = materials instanceof Array ? materials : [];

  this.visible = true;

};

THREE.MultiMaterial.prototype = {

  constructor: THREE.MultiMaterial,

  toJSON: function () {

    var output = {
      metadata: {
        version: 4.2,
        type: 'material',
        generator: 'MaterialExporter'
      },
      uuid: this.uuid,
      type: this.type,
      materials: []
    };

    for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

      output.materials.push( this.materials[ i ].toJSON() );

    }

    output.visible = this.visible;

    return output;

  },

  clone: function () {

    var material = new this.constructor();

    for ( var i = 0; i < this.materials.length; i ++ ) {

      material.materials.push( this.materials[ i ].clone() );

    }

    material.visible = this.visible;

    return material;

  }

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'PointCloudMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.map = null;

  this.size = 1;
  this.sizeAttenuation = true;

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

THREE.PointCloudMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.map = source.map;

  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;

  this.vertexColors = source.vertexColors;

  this.fog = source.fog;

  return this;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'ShaderMaterial';

  this.defines = {};
  this.uniforms = {};
  this.attributes = [];

  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  this.shading = THREE.SmoothShading;

  this.linewidth = 1;

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets
  this.morphNormals = false; // set to use morph normals

  this.derivatives = false; // set to use derivatives

  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [ 1, 1, 1 ],
    'uv': [ 0, 0 ],
    'uv2': [ 0, 0 ]
  };

  this.index0AttributeName = undefined;

  if ( parameters !== undefined ) {

    if ( parameters.attributes !== undefined && Array.isArray( parameters.attributes ) === false ) {

      console.warn( 'THREE.ShaderMaterial: attributes should now be an array of attribute names.' );
      parameters.attributes = Object.keys( parameters.attributes );

    }

    this.setValues( parameters );

  }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;

  this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

  this.attributes = source.attributes;
  this.defines = source.defines;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;

  this.fog = source.fog;

  this.lights = source.lights;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;

  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

  var data = THREE.Material.prototype.toJSON.call( this, meta );

  data.uniforms = this.uniforms;
  data.attributes = this.attributes;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;

  return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

  THREE.ShaderMaterial.call( this, parameters );

  this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  uvOffset: new THREE.Vector2(),
 *  uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'SpriteMaterial';

  this.color = new THREE.Color( 0xffffff );
  this.map = null;

  this.rotation = 0;

  this.fog = false;

  // set parameters

  this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.map = source.map;

  this.rotation = source.rotation;

  this.fog = source.fog;

  return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.sourceFile = '';

  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];

  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  this.version = 0;
  this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

  constructor: THREE.Texture,

  set needsUpdate ( value ) {

    if ( value === true ) this.version ++;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.image = source.image;
    this.mipmaps = source.mipmaps.slice( 0 );

    this.mapping = source.mapping;

    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;

    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;

    this.anisotropy = source.anisotropy;

    this.format = source.format;
    this.type = source.type;

    this.offset.copy( source.offset );
    this.repeat.copy( source.repeat );

    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;

    return this;

  },

  toJSON: function ( meta ) {

    if ( meta.textures[ this.uuid ] !== undefined ) {

      return meta.textures[ this.uuid ];

    }

    function getDataURL( image ) {

      var canvas;

      if ( image.toDataURL !== undefined ) {

        canvas = image;

      } else {

        canvas = document.createElement( 'canvas' );
        canvas.width = image.width;
        canvas.height = image.height;

        canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

      }

      if ( canvas.width > 2048 || canvas.height > 2048 ) {

        return canvas.toDataURL( 'image/jpeg', 0.6 );

      } else {

        return canvas.toDataURL( 'image/png' );

      }

    }

    var output = {
      metadata: {
        version: 4.4,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },

      uuid: this.uuid,
      name: this.name,

      mapping: this.mapping,

      repeat: [ this.repeat.x, this.repeat.y ],
      offset: [ this.offset.x, this.offset.y ],
      wrap: [ this.wrapS, this.wrapT ],

      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy
    };

    if ( this.image !== undefined ) {

      // TODO: Move to THREE.Image

      var image = this.image;

      if ( image.uuid === undefined ) {

        image.uuid = THREE.Math.generateUUID(); // UGH

      }

      if ( meta.images[ image.uuid ] === undefined ) {

        meta.images[ image.uuid ] = {
          uuid: image.uuid,
          url: getDataURL( image )
        };

      }

      output.image = image.uuid;

    }

    meta.textures[ this.uuid ] = output;

    return output;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

  THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.images = images;
  this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

  THREE.Texture.prototype.copy.call( this, source );

  this.images = source.images;

  return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { width: width, height: height };
  this.mipmaps = mipmaps;

  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false;

  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;
// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.generateMipmaps = false;

  var scope = this;

  var update = function () {

    requestAnimationFrame( update );

    if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

      scope.needsUpdate = true;

    }

  };

  update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

  THREE.Object3D.call( this );

  this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'PointCloud';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
THREE.PointCloud.prototype.constructor = THREE.PointCloud;

THREE.PointCloud.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();

  return function raycast( raycaster, intersects ) {

    var object = this;
    var geometry = object.geometry;
    var threshold = raycaster.params.PointCloud.threshold;

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    var localThresholdSq = localThreshold * localThreshold;
    var position = new THREE.Vector3();

    var testPoint = function ( point, index ) {

      var rayPointDistanceSq = ray.distanceSqToPoint( point );

      if ( rayPointDistanceSq < localThresholdSq ) {

        var intersectPoint = ray.closestPointToPoint( point );
        intersectPoint.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) return;

        intersects.push( {

          distance: distance,
          distanceToRay: Math.sqrt( rayPointDistanceSq ),
          point: intersectPoint.clone(),
          index: index,
          face: null,
          object: object

        } );

      }

    };

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var offsets = geometry.drawcalls;

        if ( offsets.length === 0 ) {

          geometry.addDrawCall( 0, indices.length );

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

          var offset = offsets[ oi ];

          var start = offset.start;
          var count = offset.count;

          for ( var i = start, il = start + count; i < il; i ++ ) {

            var a = indices[ i ];

            position.fromArray( positions, a * 3 );

            testPoint( position, a );

          }

        }

      } else {

        for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

          position.fromArray( positions, i * 3 );

          testPoint( position, i );

        }

      }

    } else {

      var vertices = geometry.vertices;

      for ( var i = 0, l = vertices.length; i < l; i ++ ) {

        testPoint( vertices[ i ], i );

      }

    }

  };

}() );

THREE.PointCloud.prototype.clone = function () {

  return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.PointCloud.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {

    meta.materials[ this.material.uuid ] = this.material.toJSON();

  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

  console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
  return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

  if ( mode === 1 ) {

    console.error( 'THREE.Line: THREE.LinePieces mode has been removed. Use THREE.LineSegments instead.' );

  }

  THREE.Object3D.call( this );

  this.type = 'Line';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  return function raycast( raycaster, intersects ) {

    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;

    var geometry = this.geometry;

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    // Checking boundingSphere distance to ray

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    var vStart = new THREE.Vector3();
    var vEnd = new THREE.Vector3();
    var interSegment = new THREE.Vector3();
    var interRay = new THREE.Vector3();
    var step = this instanceof THREE.LineSegments ? 2 : 1;

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.drawcalls;

        if ( offsets.length === 0 ) {

          geometry.addDrawCall( 0, indices.length );

        }

        for ( var oi = 0; oi < offsets.length; oi ++ ) {

          var offset = offsets[ oi ];

          var start = offset.start;
          var count = offset.count;

          for ( var i = start; i < start + count - 1; i += step ) {

            var a = indices[ i ];
            var b = indices[ i + 1 ];

            vStart.fromArray( positions, a * 3 );
            vEnd.fromArray( positions, b * 3 );

            var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

            if ( distSq > precisionSq ) continue;

            var distance = ray.origin.distanceTo( interRay );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4( this.matrixWorld ),
              index: i,
              offsetIndex: oi,
              face: null,
              faceIndex: null,
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0; i < positions.length / 3 - 1; i += step ) {

          vStart.fromArray( positions, 3 * i );
          vEnd.fromArray( positions, 3 * i + 3 );

          var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

          if ( distSq > precisionSq ) continue;

          var distance = ray.origin.distanceTo( interRay );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
            index: i,
            face: null,
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var vertices = geometry.vertices;
      var nbVertices = vertices.length;

      for ( var i = 0; i < nbVertices - 1; i += step ) {

        var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

        if ( distSq > precisionSq ) continue;

        var distance = ray.origin.distanceTo( interRay );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4( this.matrixWorld ),
          index: i,
          face: null,
          faceIndex: null,
          object: this

        } );

      }

    }

  };

}() );

THREE.Line.prototype.clone = function () {

  return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Line.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {

    meta.materials[ this.material.uuid ] = this.material.toJSON();

  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

  THREE.Line.call( this, geometry, material );

  this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'Mesh';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

  if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

    this.morphTargetBase = - 1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};

    for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

      this.morphTargetInfluences.push( 0 );
      this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

    }

  }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

  if ( this.morphTargetDictionary[ name ] !== undefined ) {

    return this.morphTargetDictionary[ name ];

  }

  console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

  return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();

  var tempA = new THREE.Vector3();
  var tempB = new THREE.Vector3();
  var tempC = new THREE.Vector3();

  return function raycast( raycaster, intersects ) {

    var geometry = this.geometry;
    var material = this.material;

    if ( material === undefined ) return;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    // Check boundingBox before continuing

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    var a, b, c;

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.drawcalls;

        if ( offsets.length === 0 ) {

          geometry.addDrawCall( 0, indices.length );

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

          var offset = offsets[ oi ];

          var start = offset.start;
          var count = offset.count;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            a = indices[ i ];
            b = indices[ i + 1 ];
            c = indices[ i + 2 ];

            vA.fromArray( positions, a * 3 );
            vB.fromArray( positions, b * 3 );
            vC.fromArray( positions, c * 3 );

            if ( material.side === THREE.BackSide ) {

              var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

            } else {

              var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

            }

            if ( intersectionPoint === null ) continue;

            intersectionPoint.applyMatrix4( this.matrixWorld );

            var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              point: intersectionPoint,
              face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
              faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0, il = positions.length; i < il; i += 9 ) {

          vA.fromArray( positions, i );
          vB.fromArray( positions, i + 3 );
          vC.fromArray( positions, i + 6 );

          if ( material.side === THREE.BackSide ) {

            var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

          } else {

            var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

          }

          if ( intersectionPoint === null ) continue;

          intersectionPoint.applyMatrix4( this.matrixWorld );

          var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          a = i / 3;
          b = a + 1;
          c = a + 2;

          intersects.push( {

            distance: distance,
            point: intersectionPoint,
            face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
            index: a, // triangle number in positions buffer semantics
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
      var materials = isFaceMaterial === true ? material.materials : null;

      var vertices = geometry.vertices;
      var faces = geometry.faces;

      for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

        var face = faces[ f ];
        var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

        if ( faceMaterial === undefined ) continue;

        a = vertices[ face.a ];
        b = vertices[ face.b ];
        c = vertices[ face.c ];

        if ( faceMaterial.morphTargets === true ) {

          var morphTargets = geometry.morphTargets;
          var morphInfluences = this.morphTargetInfluences;

          vA.set( 0, 0, 0 );
          vB.set( 0, 0, 0 );
          vC.set( 0, 0, 0 );

          for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

            var influence = morphInfluences[ t ];

            if ( influence === 0 ) continue;

            var targets = morphTargets[ t ].vertices;

            vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );
            vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );
            vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );

          }

          vA.add( a );
          vB.add( b );
          vC.add( c );

          a = vA;
          b = vB;
          c = vC;

        }

        if ( faceMaterial.side === THREE.BackSide ) {

          var intersectionPoint = ray.intersectTriangle( c, b, a, true );

        } else {

          var intersectionPoint = ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide );

        }

        if ( intersectionPoint === null ) continue;

        intersectionPoint.applyMatrix4( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          point: intersectionPoint,
          face: face,
          faceIndex: f,
          object: this

        } );

      }

    }

  };

}() );

THREE.Mesh.prototype.clone = function () {

  return new this.constructor( this.geometry, this.material ).copy( this );

};

THREE.Mesh.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {

    meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

  THREE.Object3D.call( this );

  this.type = 'Bone';

  this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.skin = source.skin;

  return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

  this.identityMatrix = new THREE.Matrix4();

  // copy the bone array

  bones = bones || [];

  this.bones = bones.slice( 0 );

  // create a bone texture or an array of floats

  if ( this.useVertexTexture ) {

    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


    var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
    size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
    size = Math.max( size, 4 );

    this.boneTextureWidth = size;
    this.boneTextureHeight = size;

    this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
    this.boneTexture.minFilter = THREE.NearestFilter;
    this.boneTexture.magFilter = THREE.NearestFilter;
    this.boneTexture.generateMipmaps = false;
    this.boneTexture.flipY = false;

  } else {

    this.boneMatrices = new Float32Array( 16 * this.bones.length );

  }

  // use the supplied bone inverses or calculate the inverses

  if ( boneInverses === undefined ) {

    this.calculateInverses();

  } else {

    if ( this.bones.length === boneInverses.length ) {

      this.boneInverses = boneInverses.slice( 0 );

    } else {

      console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

      this.boneInverses = [];

      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        this.boneInverses.push( new THREE.Matrix4() );

      }

    }

  }

};

THREE.Skeleton.prototype.calculateInverses = function () {

  this.boneInverses = [];

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    var inverse = new THREE.Matrix4();

    if ( this.bones[ b ] ) {

      inverse.getInverse( this.bones[ b ].matrixWorld );

    }

    this.boneInverses.push( inverse );

  }

};

THREE.Skeleton.prototype.pose = function () {

  var bone;

  // recover the bind-time world matrices

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    }

  }

  // compute the local matrices, positions, rotations and scales

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      if ( bone.parent ) {

        bone.matrix.getInverse( bone.parent.matrixWorld );
        bone.matrix.multiply( bone.matrixWorld );

      } else {

        bone.matrix.copy( bone.matrixWorld );

      }

      bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    }

  }

};

THREE.Skeleton.prototype.update = ( function () {

  var offsetMatrix = new THREE.Matrix4();

  return function update() {

    // flatten bone matrices to array

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

      // compute the offset between the current and the original transform

      var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

      offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
      offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

    }

    if ( this.useVertexTexture ) {

      this.boneTexture.needsUpdate = true;

    }

  };

} )();

THREE.Skeleton.prototype.clone = function () {

  return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'SkinnedMesh';

  this.bindMode = "attached";
  this.bindMatrix = new THREE.Matrix4();
  this.bindMatrixInverse = new THREE.Matrix4();

  // init bones

  // TODO: remove bone creation as there is no reason (other than
  // convenience) for THREE.SkinnedMesh to do this.

  var bones = [];

  if ( this.geometry && this.geometry.bones !== undefined ) {

    var bone, gbone;

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      bone = new THREE.Bone( this );
      bones.push( bone );

      bone.name = gbone.name;
      bone.position.fromArray( gbone.pos );
      bone.quaternion.fromArray( gbone.rotq );
      if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

    }

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      if ( gbone.parent !== - 1 ) {

        bones[ gbone.parent ].add( bones[ b ] );

      } else {

        this.add( bones[ b ] );

      }

    }

  }

  this.normalizeSkinWeights();

  this.updateMatrixWorld( true );
  this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

  this.skeleton = skeleton;

  if ( bindMatrix === undefined ) {

    this.updateMatrixWorld( true );

    this.skeleton.calculateInverses();

    bindMatrix = this.matrixWorld;

  }

  this.bindMatrix.copy( bindMatrix );
  this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

  this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

  if ( this.geometry instanceof THREE.Geometry ) {

    for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

      var sw = this.geometry.skinWeights[ i ];

      var scale = 1.0 / sw.lengthManhattan();

      if ( scale !== Infinity ) {

        sw.multiplyScalar( scale );

      } else {

        sw.set( 1 ); // this will be normalized by the shader anyway

      }

    }

  } else {

    // skinning weights assumed to be normalized for THREE.BufferGeometry

  }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

  THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

  if ( this.bindMode === "attached" ) {

    this.bindMatrixInverse.getInverse( this.matrixWorld );

  } else if ( this.bindMode === "detached" ) {

    this.bindMatrixInverse.getInverse( this.bindMatrix );

  } else {

    console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

  }

};

THREE.SkinnedMesh.prototype.clone = function() {

  return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'MorphAnimMesh';

  // API

  this.duration = 1000; // milliseconds
  this.mirroredLoop = false;
  this.time = 0;

  // internals

  this.lastKeyframe = 0;
  this.currentKeyframe = 0;

  this.direction = 1;
  this.directionBackwards = false;

  this.setFrameRange( 0, geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

  this.startKeyframe = start;
  this.endKeyframe = end;

  this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

  this.direction = 1;
  this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

  this.direction = - 1;
  this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

  var geometry = this.geometry;

  if ( ! geometry.animations ) geometry.animations = {};

  var firstAnimation, animations = geometry.animations;

  var pattern = /([a-z]+)_?(\d+)/;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var parts = morph.name.match( pattern );

    if ( parts && parts.length > 1 ) {

      var label = parts[ 1 ];

      if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

      var animation = animations[ label ];

      if ( i < animation.start ) animation.start = i;
      if ( i > animation.end ) animation.end = i;

      if ( ! firstAnimation ) firstAnimation = label;

    }

  }

  geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

  if ( ! this.geometry.animations ) this.geometry.animations = {};

  this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

  var animation = this.geometry.animations[ label ];

  if ( animation ) {

    this.setFrameRange( animation.start, animation.end );
    this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
    this.time = 0;

  } else {

    console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

  }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

  var frameTime = this.duration / this.length;

  this.time += this.direction * delta;

  if ( this.mirroredLoop ) {

    if ( this.time > this.duration || this.time < 0 ) {

      this.direction *= - 1;

      if ( this.time > this.duration ) {

        this.time = this.duration;
        this.directionBackwards = true;

      }

      if ( this.time < 0 ) {

        this.time = 0;
        this.directionBackwards = false;

      }

    }

  } else {

    this.time = this.time % this.duration;

    if ( this.time < 0 ) this.time += this.duration;

  }

  var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

  var influences = this.morphTargetInfluences;

  if ( keyframe !== this.currentKeyframe ) {

    influences[ this.lastKeyframe ] = 0;
    influences[ this.currentKeyframe ] = 1;
    influences[ keyframe ] = 0;

    this.lastKeyframe = this.currentKeyframe;
    this.currentKeyframe = keyframe;

  }

  var mix = ( this.time % frameTime ) / frameTime;

  if ( this.directionBackwards ) {

    mix = 1 - mix;

  }

  influences[ this.currentKeyframe ] = mix;
  influences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

  var influences = this.morphTargetInfluences;

  for ( var i = 0, l = influences.length; i < l; i ++ ) {

    influences[ i ] = 0;

  }

  if ( a > - 1 ) influences[ a ] = 1 - t;
  if ( b > - 1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.duration = source.duration;
  this.mirroredLoop = source.mirroredLoop;
  this.time = source.time;

  this.lastKeyframe = source.lastKeyframe;
  this.currentKeyframe = source.currentKeyframe;

  this.direction = source.direction;
  this.directionBackwards = source.directionBackwards;

  return this;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

  THREE.Object3D.call( this );

  Object.defineProperties( this, {
    levels: {
      enumerable: true,
      value: []
    },
    objects: {
      get: function () {

        console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
        return this.levels;

      }
    }
  } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

  if ( distance === undefined ) distance = 0;

  distance = Math.abs( distance );

  var levels = this.levels;

  for ( var l = 0; l < levels.length; l ++ ) {

    if ( distance < levels[ l ].distance ) {

      break;

    }

  }

  levels.splice( l, 0, { distance: distance, object: object } );

  this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

  var levels = this.levels;

  for ( var i = 1, l = levels.length; i < l; i ++ ) {

    if ( distance < levels[ i ].distance ) {

      break;

    }

  }

  return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function raycast( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  };

}() );

THREE.LOD.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function update( camera ) {

    var levels = this.levels;

    if ( levels.length > 1 ) {

      v1.setFromMatrixPosition( camera.matrixWorld );
      v2.setFromMatrixPosition( this.matrixWorld );

      var distance = v1.distanceTo( v2 );

      levels[ 0 ].object.visible = true;

      for ( var i = 1, l = levels.length; i < l; i ++ ) {

        if ( distance >= levels[ i ].distance ) {

          levels[ i - 1 ].object.visible = false;
          levels[ i ].object.visible = true;

        } else {

          break;

        }

      }

      for ( ; i < l; i ++ ) {

        levels[ i ].object.visible = false;

      }

    }

  };

}();

THREE.LOD.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source, false );

  var levels = source.levels;

  for ( var i = 0, l = levels.length; i < l; i ++ ) {

    var level = levels[ i ];

    this.addLevel( level.object.clone(), level.distance );

  }

  return this;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

  var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
  var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
  var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'index', new THREE.IndexBufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  return function Sprite( material ) {

    THREE.Object3D.call( this );

    this.type = 'Sprite';

    this.geometry = geometry;
    this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

  };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function raycast( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
    var guessSizeSq = this.scale.x * this.scale.y;

    if ( distanceSq > guessSizeSq ) {

      return;

    }

    intersects.push( {

      distance: Math.sqrt( distanceSq ),
      point: this.position,
      face: null,
      object: this

    } );

  };

}() );

THREE.Sprite.prototype.clone = function () {

  return new this.constructor( this.material ).copy( this );

};

THREE.Sprite.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {

    meta.materials[ this.material.uuid ] = this.material.toJSON();

  }

  data.object.material = this.material.uuid;

  return data;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

  THREE.Object3D.call( this );

  this.lensFlares = [];

  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;

  if ( texture !== undefined ) {

    this.add( texture, size, distance, blending, color );

  }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

  if ( size === undefined ) size = - 1;
  if ( distance === undefined ) distance = 0;
  if ( opacity === undefined ) opacity = 1;
  if ( color === undefined ) color = new THREE.Color( 0xffffff );
  if ( blending === undefined ) blending = THREE.NormalBlending;

  distance = Math.min( distance, Math.max( 0, distance ) );

  this.lensFlares.push( {
    texture: texture, // THREE.Texture
    size: size,     // size in pixels (-1 = use texture.width)
    distance: distance,   // distance (0-1) from light source (0=at light source)
    x: 0, y: 0, z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
    scale: 1,     // scale
    rotation: 0,    // rotation
    opacity: opacity, // opacity
    color: color,   // color
    blending: blending  // blending
  } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = - this.positionScreen.x * 2;
  var vecY = - this.positionScreen.y * 2;

  for ( f = 0; f < fl; f ++ ) {

    flare = this.lensFlares[ f ];

    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;

    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  }

};

THREE.LensFlare.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.positionScreen.copy( source.positionScreen );
  this.customUpdateCallback = source.customUpdateCallback;

  for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

    this.lensFlares.push( source.lensFlares[ i ] );

  }

  return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

  THREE.Object3D.call( this );

  this.type = 'Scene';

  this.fog = null;
  this.overrideMaterial = null;

  this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  if ( source.fog !== null ) this.fog = source.fog.clone();
  if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  this.autoUpdate = source.autoUpdate;
  this.matrixAutoUpdate = source.matrixAutoUpdate;

  return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

  this.name = '';

  this.color = new THREE.Color( color );

  this.near = ( near !== undefined ) ? near : 1;
  this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

  return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

  this.name = '';

  this.color = new THREE.Color( color );
  this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

  return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n  diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n  if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n  totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n  uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n  uniform float bumpScale;\n\n  // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n    vec2 dSTdx = dFdx( vUv );\n   vec2 dSTdy = dFdy( vUv );\n\n   float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n    float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n    float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n    return vec2( dBx, dBy );\n\n  }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n    vec3 vSigmaX = dFdx( surf_pos );\n    vec3 vSigmaY = dFdy( surf_pos );\n    vec3 vN = surf_norm;    // normalized\n\n   vec3 R1 = cross( vSigmaY, vN );\n   vec3 R2 = cross( vN, vSigmaX );\n\n   float fDet = dot( vSigmaX, R1 );\n\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n  }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n  diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n  vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n  float distance = dot( planeNormal, point - pointOnPlane );\n\n  return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n  return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n if ( decayExponent > 0.0 ) {\n\n    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n }\n\n return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n return ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 ) + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\n\n  return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n // factor of 1/PI in distribution term omitted\n\n  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n  vec3 halfDir = normalize( lightDir + viewDir );\n\n //float dotNL = saturate( dot( normal, lightDir ) );\n  //float dotNV = saturate( dot( normal, viewDir ) );\n float dotNH = saturate( dot( normal, halfDir ) );\n float dotLH = saturate( dot( lightDir, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n  float D = D_BlinnPhong( shininess, dotNH );\n\n return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n #ifdef GAMMA_INPUT\n\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n #else\n\n   return a;\n\n #endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n #ifdef GAMMA_OUTPUT\n\n   return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n #else\n\n   return a;\n\n #endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "#ifdef USE_SKINNING\n\n vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n vec3 objectNormal = morphedNormal;\n\n#else\n\n vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n  objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n  vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n   // Transforming Normal Vectors with the Inverse Transformation\n    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n   #ifdef ENVMAP_MODE_REFLECTION\n\n     vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n   #else\n\n     vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n  #else\n\n   vec3 reflectVec = vReflect;\n\n #endif\n\n  #ifdef DOUBLE_SIDED\n   float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n #else\n   float flipNormal = 1.0;\n #endif\n\n  #ifdef ENVMAP_TYPE_CUBE\n   vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n    vec2 sampleUV;\n    sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n   sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n   vec4 envColor = texture2D( envMap, sampleUV );\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n   vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n    vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n  #endif\n\n  envColor.xyz = inputToLinear( envColor.xyz );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n   outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n  #elif defined( ENVMAP_BLENDING_MIX )\n\n    outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n  #elif defined( ENVMAP_BLENDING_ADD )\n\n    outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n uniform float reflectivity;\n #ifdef ENVMAP_TYPE_CUBE\n   uniform samplerCube envMap;\n #else\n   uniform sampler2D envMap;\n #endif\n  uniform float flipEnvMap;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    uniform float refractionRatio;\n\n  #else\n\n   varying vec3 vReflect;\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n varying vec3 vReflect;\n\n  uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n  vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n #else\n\n   float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  #endif\n\n  #ifdef FOG_EXP2\n\n   float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n  #else\n\n   float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n #endif\n  \n  outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n\n  #ifdef FOG_EXP2\n\n   uniform float fogDensity;\n\n #else\n\n   uniform float fogNear;\n    uniform float fogFar;\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n  totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n  vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec3 lightColor = pointLightColor[ i ];\n\n   vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n    vec3 lightDir = normalize( lVector );\n\n   // attenuation\n\n    float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n    #endif\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec3 lightColor = spotLightColor[ i ];\n\n    vec3 lightPosition = spotLightPosition[ i ];\n    vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n    vec3 lightDir = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( lightPosition - worldPosition.xyz ) );\n\n    if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n     // attenuation\n\n      float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     attenuation *= spotEffect;\n\n      // diffuse\n\n      float dotProduct = dot( normal, lightDir );\n\n     vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n     #ifdef DOUBLE_SIDED\n\n       vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n      #endif\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n   vec3 lightColor = directionalLightColor[ i ];\n\n   vec3 lightDir = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   vLightFront += lightColor * saturate( dotProduct );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += lightColor * saturate( - dotProduct );\n\n    #endif\n\n  }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n    vec3 lightDir = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n    // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n   #ifdef DOUBLE_SIDED\n\n     float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n     vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n    #endif\n\n  }\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n vLightBack += ambientLightColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n  vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n   normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n #endif\n\n#else\n\n vec3 fdx = dFdx( vViewPosition );\n vec3 fdy = dFdy( vViewPosition );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec3 lightColor = pointLightColor[ i ];\n\n   vec3 lightPosition = pointLightPosition[ i ];\n   vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n   vec3 lightDir = normalize( lVector );\n\n   // attenuation\n\n    float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n   // diffuse\n\n    float cosineTerm = saturate( dot( normal, lightDir ) );\n\n   totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n   // specular\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec3 lightColor = spotLightColor[ i ];\n\n    vec3 lightPosition = spotLightPosition[ i ];\n    vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n   vec3 lightDir = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( lightPosition - vWorldPosition ) );\n\n   if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n     // attenuation\n\n      float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     attenuation *= spotEffect;\n\n      // diffuse\n\n      float cosineTerm = saturate( dot( normal, lightDir ) );\n\n     totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n     // specular\n\n     vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n      totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n    vec3 lightColor = directionalLightColor[ i ];\n\n   vec3 lightDir = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n   // diffuse\n\n    float cosineTerm = saturate( dot( normal, lightDir ) );\n\n   totalDiffuseLight += lightColor * cosineTerm;\n\n   // specular\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n  }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n   vec3 lightDir = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n    // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n    totalDiffuseLight += lightColor;\n\n    // specular (sky term only)\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n  }\n\n#endif\n\n#ifdef METAL\n\n outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n#else\n\n  outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n  varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n  outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n  gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n uniform float logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    varying float vFragDepth;\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n    varying float vFragDepth;\n\n #endif\n\n  uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n  gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n    gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n  #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n  vec4 texelColor = texture2D( map, vUv );\n\n  texelColor.xyz = inputToLinear( texelColor.xyz );\n\n diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n  uniform vec4 offsetRepeat;\n  uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n vec3 morphedNormal = vec3( 0.0 );\n\n morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n  morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n  morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n  morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n  morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n  #ifndef USE_MORPHNORMALS\n\n  uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n vec3 morphed = vec3( 0.0 );\n morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n  #ifndef USE_MORPHNORMALS\n\n  morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n  #endif\n\n  morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n // Per-Pixel Tangent Space Normal Mapping\n // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n    vec3 q0 = dFdx( eye_pos.xyz );\n    vec3 q1 = dFdy( eye_pos.xyz );\n    vec2 st0 = dFdx( vUv.st );\n    vec2 st1 = dFdy( vUv.st );\n\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n   vec3 N = normalize( surf_norm );\n\n    vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n    mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n   return normalize( tsn * mapN );\n\n }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n  #ifdef SHADOWMAP_DEBUG\n\n    vec3 frustumColors[3];\n    frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n   frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n   frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n #endif\n\n  float fDepth;\n vec3 shadowColor = vec3( 1.0 );\n\n for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n       // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n\n   bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n    bool frustumTest = all( frustumTestVec );\n\n   if ( frustumTest ) {\n\n      shadowCoord.z += shadowBias[ i ];\n\n     #if defined( SHADOWMAP_TYPE_PCF )\n\n           // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n   /*\n            // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n            // must enroll loop manually\n\n        for ( float y = -1.25; y <= 1.25; y += 1.25 )\n         for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n           vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n               //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n           float fDepth = unpackDepth( rgbaDepth );\n\n            if ( fDepth < shadowCoord.z )\n             shadow += 1.0;\n\n        }\n\n       shadow /= 9.0;\n\n    */\n\n        const float shadowDelta = 1.0 / 9.0;\n\n        float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.25 * xPixelOffset;\n       float dy0 = -1.25 * yPixelOffset;\n       float dx1 = 1.25 * xPixelOffset;\n        float dy1 = 1.25 * yPixelOffset;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n        if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n       float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.0 * xPixelOffset;\n        float dy0 = -1.0 * yPixelOffset;\n        float dx1 = 1.0 * xPixelOffset;\n       float dy1 = 1.0 * yPixelOffset;\n\n       mat3 shadowKernel;\n        mat3 depthKernel;\n\n       depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n        depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n        depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n        depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n        depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n       depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n        depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n        depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n        depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n        vec3 shadowZ = vec3( shadowCoord.z );\n       shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n       shadowKernel[0] *= vec3(0.25);\n\n        shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n       shadowKernel[1] *= vec3(0.25);\n\n        shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n       shadowKernel[2] *= vec3(0.25);\n\n        vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n       shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n       shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n       vec4 shadowValues;\n        shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n        shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n        shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n        shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n        shadow = dot( shadowValues, vec4( 1.0 ) );\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #else\n\n       vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n       float fDepth = unpackDepth( rgbaDepth );\n\n        if ( fDepth < shadowCoord.z )\n\n   // spot with multiple shadows is darker\n\n         shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n    // spot with multiple shadows has the same color as single shadow spot\n\n    //          shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n      #endif\n\n    }\n\n\n   #ifdef SHADOWMAP_DEBUG\n\n      if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n   #endif\n\n  }\n\n outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n uniform sampler2D shadowMap[ MAX_SHADOWS ];\n uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n  uniform float shadowDarkness[ MAX_SHADOWS ];\n  uniform float shadowBias[ MAX_SHADOWS ];\n\n  varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n float unpackDepth( const in vec4 rgba_depth ) {\n\n   const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n    float depth = dot( rgba_depth, bit_shift );\n   return depth;\n\n }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n varying vec4 vShadowCoord[ MAX_SHADOWS ];\n uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n  for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n uniform mat4 bindMatrix;\n  uniform mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n   uniform sampler2D boneTexture;\n    uniform int boneTextureWidth;\n   uniform int boneTextureHeight;\n\n    mat4 getBoneMatrix( const in float i ) {\n\n      float j = i * 4.0;\n      float x = mod( j, float( boneTextureWidth ) );\n      float y = floor( j / float( boneTextureWidth ) );\n\n     float dx = 1.0 / float( boneTextureWidth );\n     float dy = 1.0 / float( boneTextureHeight );\n\n      y = dy * ( y + 0.5 );\n\n     vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n      vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n      vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n      vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n      mat4 bone = mat4( v1, v2, v3, v4 );\n\n     return bone;\n\n    }\n\n #else\n\n   uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n   mat4 getBoneMatrix( const in float i ) {\n\n      mat4 bone = boneGlobalMatrices[ int(i) ];\n     return bone;\n\n    }\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n  #ifdef USE_MORPHTARGETS\n\n vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n #endif\n\n  vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n  skinned += boneMatY * skinVertex * skinWeight.y;\n  skinned += boneMatZ * skinVertex * skinWeight.z;\n  skinned += boneMatW * skinVertex * skinWeight.w;\n  skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 skinMatrix = mat4( 0.0 );\n  skinMatrix += skinWeight.x * boneMatX;\n  skinMatrix += skinWeight.y * boneMatY;\n  skinMatrix += skinWeight.z * boneMatZ;\n  skinMatrix += skinWeight.w * boneMatW;\n  skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n  #ifdef USE_MORPHNORMALS\n\n vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n #else\n\n vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n  specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n  varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n  attribute vec2 uv2;\n varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n varying vec2 vUv;\n uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n  vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n #ifdef USE_SKINNING\n\n   vec4 worldPosition = modelMatrix * skinned;\n\n #elif defined( USE_MORPHTARGETS )\n\n   vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n   vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

  merge: function ( uniforms ) {

    var merged = {};

    for ( var u = 0; u < uniforms.length; u ++ ) {

      var tmp = this.clone( uniforms[ u ] );

      for ( var p in tmp ) {

        merged[ p ] = tmp[ p ];

      }

    }

    return merged;

  },

  clone: function ( uniforms_src ) {

    var uniforms_dst = {};

    for ( var u in uniforms_src ) {

      uniforms_dst[ u ] = {};

      for ( var p in uniforms_src[ u ] ) {

        var parameter_src = uniforms_src[ u ][ p ];

        if ( parameter_src instanceof THREE.Color ||
           parameter_src instanceof THREE.Vector2 ||
           parameter_src instanceof THREE.Vector3 ||
           parameter_src instanceof THREE.Vector4 ||
           parameter_src instanceof THREE.Matrix3 ||
           parameter_src instanceof THREE.Matrix4 ||
           parameter_src instanceof THREE.Texture ) {

          uniforms_dst[ u ][ p ] = parameter_src.clone();

        } else if ( Array.isArray( parameter_src ) ) {

          uniforms_dst[ u ][ p ] = parameter_src.slice();

        } else {

          uniforms_dst[ u ][ p ] = parameter_src;

        }

      }

    }

    return uniforms_dst;

  }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

  common: {

    "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },

    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "specularMap" : { type: "t", value: null },
    "alphaMap" : { type: "t", value: null },

    "envMap" : { type: "t", value: null },
    "flipEnvMap" : { type: "f", value: - 1 },
    "reflectivity" : { type: "f", value: 1.0 },
    "refractionRatio" : { type: "f", value: 0.98 }

  },

  aomap: {

    "aoMap" : { type: "t", value: null },
    "aoMapIntensity" : { type: "f", value: 1 },

  },

  lightmap: {

    "lightMap" : { type: "t", value: null },
    "lightMapIntensity" : { type: "f", value: 1 },

  },

  emissivemap: {

    "emissiveMap" : { type: "t", value: null },

  },

  bump: {

    "bumpMap" : { type: "t", value: null },
    "bumpScale" : { type: "f", value: 1 }

  },

  normalmap: {

    "normalMap" : { type: "t", value: null },
    "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
  },

  fog : {

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  lights: {

    "ambientLightColor" : { type: "fv", value: [] },

    "directionalLightDirection" : { type: "fv", value: [] },
    "directionalLightColor" : { type: "fv", value: [] },

    "hemisphereLightDirection" : { type: "fv", value: [] },
    "hemisphereLightSkyColor" : { type: "fv", value: [] },
    "hemisphereLightGroundColor" : { type: "fv", value: [] },

    "pointLightColor" : { type: "fv", value: [] },
    "pointLightPosition" : { type: "fv", value: [] },
    "pointLightDistance" : { type: "fv1", value: [] },
    "pointLightDecay" : { type: "fv1", value: [] },

    "spotLightColor" : { type: "fv", value: [] },
    "spotLightPosition" : { type: "fv", value: [] },
    "spotLightDirection" : { type: "fv", value: [] },
    "spotLightDistance" : { type: "fv1", value: [] },
    "spotLightAngleCos" : { type: "fv1", value: [] },
    "spotLightExponent" : { type: "fv1", value: [] },
    "spotLightDecay" : { type: "fv1", value: [] }

  },

  particle: {

    "psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },
    "size" : { type: "f", value: 1.0 },
    "scale" : { type: "f", value: 1.0 },
    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  shadowmap: {

    "shadowMap": { type: "tv", value: [] },
    "shadowMapSize": { type: "v2v", value: [] },

    "shadowBias" : { type: "fv1", value: [] },
    "shadowDarkness": { type: "fv1", value: [] },

    "shadowMatrix" : { type: "m4v", value: [] }

  }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

  'basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],

      " #ifdef USE_ENVMAP",

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      " #endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "aomap_fragment" ],

      " outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],    // TODO: Shadows on an otherwise unlit surface doesn't make sense.

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'lambert': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
      }

    ] ),

    vertexShader: [

      "#define LAMBERT",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_lambert_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform float opacity;",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],

      " #ifdef DOUBLE_SIDED",

      "   if ( gl_FrontFacing )",
      "     outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
      "   else",
      "     outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

      " #else",

      "   outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

      " #endif",

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'phong': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "lightmap" ],
      THREE.UniformsLib[ "emissivemap" ],
      THREE.UniformsLib[ "bump" ],
      THREE.UniformsLib[ "normalmap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
        "shininess": { type: "f", value: 30 }
      }

    ] ),

    vertexShader: [

      "#define PHONG",

      "varying vec3 vViewPosition;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

      " vNormal = normalize( transformedNormal );",

      "#endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      " vViewPosition = - mvPosition.xyz;",

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_phong_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "#define PHONG",

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform vec3 specular;",
      "uniform float shininess;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
      THREE.ShaderChunk[ "normalmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = ambientLightColor;",
      " vec3 totalEmissiveLight = emissive;",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "lightmap_fragment" ],
        THREE.ShaderChunk[ "aomap_fragment" ],
        THREE.ShaderChunk[ "emissivemap_fragment" ],

        THREE.ShaderChunk[ "lights_phong_fragment" ],

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'particle_basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "particle" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      "uniform float size;",
      "uniform float scale;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

      " #ifdef USE_SIZEATTENUATION",
      "   gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
      " #else",
      "   gl_PointSize = size;",
      " #endif",

      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],
        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 psColor;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_particle_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( psColor, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_particle_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "shadowmap_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'dashed': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],

      {
        "scale"    : { type: "f", value: 1 },
        "dashSize" : { type: "f", value: 1 },
        "totalSize": { type: "f", value: 2 }
      }

    ] ),

    vertexShader: [

      "uniform float scale;",
      "attribute float lineDistance;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vLineDistance = scale * lineDistance;",

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "uniform float dashSize;",
      "uniform float totalSize;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " if ( mod( vLineDistance, totalSize ) > dashSize ) {",

      "   discard;",

      " }",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'depth': {

    uniforms: {

      "mNear": { type: "f", value: 1.0 },
      "mFar" : { type: "f", value: 2000.0 },
      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform float mNear;",
      "uniform float mFar;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   float depth = gl_FragDepthEXT / gl_FragCoord.w;",

      " #else",

      "   float depth = gl_FragCoord.z / gl_FragCoord.w;",

      " #endif",

      " float color = 1.0 - smoothstep( mNear, mFar, depth );",
      " gl_FragColor = vec4( vec3( color ), opacity );",

      "}"

    ].join( "\n" )

  },

  'normal': {

    uniforms: {

      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vNormal = normalize( normalMatrix * normal );",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform float opacity;",
      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join( "\n" )

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'cube': {

    uniforms: { "tCube": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform samplerCube tCube;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join( "\n" )

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'equirect': {

    uniforms: { "tEquirect": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform sampler2D tEquirect;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        // "  gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
        "vec3 direction = normalize( vWorldPosition );",
        "vec2 sampleUV;",
        "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
        "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
        "gl_FragColor = texture2D( tEquirect, sampleUV );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join( "\n" )

  },

  /* Depth encoding into RGBA texture
   *
   * based on SpiderGL shadow map example
   * http://spidergl.org/example.php?id=6
   *
   * originally from
   * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
   *
   * see also
   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
   */

  'depthRGBA': {

    uniforms: {},

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "vec4 pack_depth( const in float depth ) {",

      " const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
      " const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
      " vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "  vec4 res = fract( depth * bit_shift );",
      " res -= res.xxyz * bit_mask;",
      " return res;",

      "}",

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

      " #else",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

      " #endif",

        //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
        //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
        //"gl_FragData[ 0 ] = pack_depth( z );",
        //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

      "}"

    ].join( "\n" )

  }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

  console.log( 'THREE.WebGLRenderer', THREE.REVISION );

  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
  _context = parameters.context !== undefined ? parameters.context : null,

  _width = _canvas.width,
  _height = _canvas.height,

  pixelRatio = 1,

  _precision = parameters.precision !== undefined ? parameters.precision : 'highp',

  _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  _depth = parameters.depth !== undefined ? parameters.depth : true,
  _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

  _clearColor = new THREE.Color( 0x000000 ),
  _clearAlpha = 0;

  var lights = [];

  var opaqueObjects = [];
  var transparentObjects = [];

  var opaqueImmediateObjects = [];
  var transparentImmediateObjects = [];

  var morphInfluences = new Float32Array( 8 );

  var sprites = [];
  var lensFlares = [];

  // public properties

  this.domElement = _canvas;
  this.context = null;

  // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;

  // scene graph

  this.sortObjects = true;

  // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility
  this.gammaInput = false;
  this.gammaOutput = false;

  // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;

  // flags

  this.autoScaleCubemaps = true;

  // internal properties

  var _this = this,

  _programs = [],

  // internal state cache

  _currentProgram = null,
  _currentFramebuffer = null,
  _currentMaterialId = - 1,
  _currentGeometryProgram = '',
  _currentCamera = null,

  _usedTextureUnits = 0,

  _viewportX = 0,
  _viewportY = 0,
  _viewportWidth = _canvas.width,
  _viewportHeight = _canvas.height,
  _currentWidth = 0,
  _currentHeight = 0,

  // frustum

  _frustum = new THREE.Frustum(),

   // camera matrices cache

  _projScreenMatrix = new THREE.Matrix4(),

  _vector3 = new THREE.Vector3(),

  // light arrays cache

  _direction = new THREE.Vector3(),

  _lightsNeedUpdate = true,

  _lights = {

    ambient: [ 0, 0, 0 ],
    directional: { length: 0, colors: [], positions: [] },
    point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
    spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
    hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

  },

  // info

  _infoMemory = {

    programs: 0,
    geometries: 0,
    textures: 0

  },

  _infoRender = {

    calls: 0,
    vertices: 0,
    faces: 0,
    points: 0

  };

  this.info = {

    render: _infoRender,
    memory: _infoMemory,
    programs: _programs

  };

  // initialize

  var _gl;

  try {

    var attributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };

    _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    if ( _gl === null ) {

      if ( _canvas.getContext( 'webgl' ) !== null ) {

        throw 'Error creating WebGL context with your selected attributes.';

      } else {

        throw 'Error creating WebGL context.';

      }

    }

    _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

  } catch ( error ) {

    console.error( 'THREE.WebGLRenderer: ' + error );

  }

  var extensions = new THREE.WebGLExtensions( _gl );

  extensions.get( 'OES_texture_float' );
  extensions.get( 'OES_texture_float_linear' );
  extensions.get( 'OES_texture_half_float' );
  extensions.get( 'OES_texture_half_float_linear' );
  extensions.get( 'OES_standard_derivatives' );
  extensions.get( 'ANGLE_instanced_arrays' );

  if ( extensions.get( 'OES_element_index_uint' ) ) {

    THREE.BufferGeometry.MaxIndex = 4294967296;

  }

  if ( _logarithmicDepthBuffer ) {

    extensions.get( 'EXT_frag_depth' );

  }

  var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
  var properties = new THREE.WebGLProperties();
  var objects = new THREE.WebGLObjects( _gl, properties, this.info );

  var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
  var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

  //

  function glClearColor( r, g, b, a ) {

    if ( _premultipliedAlpha === true ) {

      r *= a; g *= a; b *= a;

    }

    _gl.clearColor( r, g, b, a );

  }

  function setDefaultGLState() {

    state.init();

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  }

  function resetGLState() {

    _currentProgram = null;
    _currentCamera = null;

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;

    _lightsNeedUpdate = true;

    state.reset();

  }

  setDefaultGLState();

  this.context = _gl;
  this.extensions = extensions;
  this.state = state;

  // shadow map

  var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

  this.shadowMap = shadowMap;

  // GPU capabilities

  var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
  var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
  var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );
  var _supportsInstancedArrays = extensions.get( 'ANGLE_instanced_arrays' );

  //



  //

  var _maxPrecision = state.getMaxPrecision( _precision );

  if ( _maxPrecision !== _precision ) {

    console.warn( 'THREE.WebGLRenderer:', _precision, 'not supported, using', _maxPrecision, 'instead.' );
    _precision = _maxPrecision;

  }

  // Plugins

  var spritePlugin = new THREE.SpritePlugin( this, sprites );
  var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

  // API

  this.getContext = function () {

    return _gl;

  };

  this.getContextAttributes = function () {

    return _gl.getContextAttributes();

  };

  this.forceContextLoss = function () {

    extensions.get( 'WEBGL_lose_context' ).loseContext();

  };

  this.supportsVertexTextures = function () {

    return _supportsVertexTextures;

  };

  this.supportsInstancedArrays = function () {

    return _supportsInstancedArrays;

  };

  this.getMaxAnisotropy = ( function () {

    var value;

    return function getMaxAnisotropy() {

      if ( value !== undefined ) return value;

      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      if ( extension !== null ) {

        value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

      } else {

        value = 0;

      }

      return value;

    }

  } )();

  this.getPrecision = function () {

    return _precision;

  };

  this.getPixelRatio = function () {

    return pixelRatio;

  };

  this.setPixelRatio = function ( value ) {

    if ( value !== undefined ) pixelRatio = value;

  };

  this.getSize = function () {

    return {
      width: _width,
      height: _height
    };

  };

  this.setSize = function ( width, height, updateStyle ) {

    _width = width;
    _height = height;

    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;

    if ( updateStyle !== false ) {

      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';

    }

    this.setViewport( 0, 0, width, height );

  };

  this.setViewport = function ( x, y, width, height ) {

    _viewportX = x * pixelRatio;
    _viewportY = y * pixelRatio;

    _viewportWidth = width * pixelRatio;
    _viewportHeight = height * pixelRatio;

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

  };

  this.setScissor = function ( x, y, width, height ) {

    _gl.scissor(
      x * pixelRatio,
      y * pixelRatio,
      width * pixelRatio,
      height * pixelRatio
    );

  };

  this.enableScissorTest = function ( boolean ) {

    state.setScissorTest( boolean );

  };

  // Clearing

  this.getClearColor = function () {

    return _clearColor;

  };

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );

    _clearAlpha = alpha !== undefined ? alpha : 1;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.getClearAlpha = function () {

    return _clearAlpha;

  };

  this.setClearAlpha = function ( alpha ) {

    _clearAlpha = alpha;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.clear = function ( color, depth, stencil ) {

    var bits = 0;

    if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    _gl.clear( bits );

  };

  this.clearColor = function () {

    _gl.clear( _gl.COLOR_BUFFER_BIT );

  };

  this.clearDepth = function () {

    _gl.clear( _gl.DEPTH_BUFFER_BIT );

  };

  this.clearStencil = function () {

    _gl.clear( _gl.STENCIL_BUFFER_BIT );

  };

  this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    this.setRenderTarget( renderTarget );
    this.clear( color, depth, stencil );

  };

  // Reset

  this.resetGLState = resetGLState;

  this.dispose = function() {

    _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

  };

  // Events

  function onContextLost( event ) {

    event.preventDefault();

    resetGLState();
    setDefaultGLState();

    properties.clear();

  };

  function onTextureDispose( event ) {

    var texture = event.target;

    texture.removeEventListener( 'dispose', onTextureDispose );

    deallocateTexture( texture );

    _infoMemory.textures --;


  }

  function onRenderTargetDispose( event ) {

    var renderTarget = event.target;

    renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    deallocateRenderTarget( renderTarget );

    _infoMemory.textures --;

  }

  function onMaterialDispose( event ) {

    var material = event.target;

    material.removeEventListener( 'dispose', onMaterialDispose );

    deallocateMaterial( material );

  }

  // Buffer deallocation

  function deallocateTexture( texture ) {

    var textureProperties = properties.get( texture );

    if ( texture.image && textureProperties.__image__webglTextureCube ) {

      // cube texture

      _gl.deleteTexture( textureProperties.__image__webglTextureCube );

    } else {

      // 2D texture

      if ( textureProperties.__webglInit === undefined ) return;

      _gl.deleteTexture( textureProperties.__webglTexture );

    }

    // remove all webgl properties
    properties.delete( texture );

  }

  function deallocateRenderTarget( renderTarget ) {

    var renderTargetProperties = properties.get( renderTarget );

    if ( ! renderTarget || renderTargetProperties.__webglTexture === undefined ) return;

    _gl.deleteTexture( renderTargetProperties.__webglTexture );

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      for ( var i = 0; i < 6; i ++ ) {

        _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
        _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

      }

    } else {

      _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
      _gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

    }

    properties.delete( renderTarget );

  }

  function deallocateMaterial( material ) {

    releaseMaterialProgramReference( material );

    properties.delete( material );

  }


  function releaseMaterialProgramReference( material ) {

    var program = properties.get( material ).program.program;

    if ( program === undefined ) return;

    material.program = undefined;

    for ( var i = 0, n = _programs.length; i !== n; ++ i ) {

      var programInfo = _programs[ i ];

      if ( programInfo.program === program ) {

        var newReferenceCount = -- programInfo.usedTimes;

        if ( newReferenceCount === 0 ) {

          // the last meterial that has been using the program let
          // go of it, so remove it from the (unordered) _programs
          // set and deallocate the GL resource

          var newLength = n - 1;

          _programs[ i ] = _programs[ newLength ];
          _programs.pop();

          _gl.deleteProgram( program );

          _infoMemory.programs = newLength;

        }

        break;

      }

    }

  }

  // Buffer rendering

  this.renderBufferImmediate = function ( object, program, material ) {

    state.initAttributes();

    var buffers = properties.get( object );

    if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
    if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
    if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
    if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

    var attributes = program.getAttributes();

    if ( object.hasPositions ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.position );
      _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasNormals ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

      if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

        for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

          var array = object.normalArray;

          var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
          var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
          var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

          array[ i + 0 ] = nx;
          array[ i + 1 ] = ny;
          array[ i + 2 ] = nz;

          array[ i + 3 ] = nx;
          array[ i + 4 ] = ny;
          array[ i + 5 ] = nz;

          array[ i + 6 ] = nx;
          array[ i + 7 ] = ny;
          array[ i + 8 ] = nz;

        }

      }

      _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.normal );

      _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasUvs && material.map ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.uv );

      _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.color );

      _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    }

    state.disableUnusedAttributes();

    _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    object.count = 0;

  };

  this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

    if ( material.visible === false ) return;

    setMaterial( material );

    var program = setProgram( camera, lights, fog, material, object );

    var updateBuffers = false;
    var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

    if ( geometryProgram !== _currentGeometryProgram ) {

      _currentGeometryProgram = geometryProgram;
      updateBuffers = true;

    }

    // morph targets

    var morphTargetInfluences = object.morphTargetInfluences;

    if ( morphTargetInfluences !== undefined ) {

      var activeInfluences = [];

      for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

        var influence = morphTargetInfluences[ i ];
        activeInfluences.push( [ influence, i ] );

      }

      activeInfluences.sort( numericalSort );

      if ( activeInfluences.length > 8 ) {

        activeInfluences.length = 8;

      }

      var morphAttributes = geometry.morphAttributes;

      for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

        var influence = activeInfluences[ i ];
        morphInfluences[ i ] = influence[ 0 ];

        if ( influence[ 0 ] !== 0 ) {

          var index = influence[ 1 ];

          if ( material.morphTargets === true ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
          if ( material.morphNormals === true ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

        } else {

          if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
          if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

        }

      }

      var uniforms = program.getUniforms();

      if ( uniforms.morphTargetInfluences !== null ) {

        _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

      }

      updateBuffers = true;

    }

    //

    var index = geometry.attributes.index;
    var position = geometry.attributes.position;

    if ( material.wireframe === true ) {

      index = objects.getWireframeAttribute( geometry );

    }

    var renderer;

    if ( index !== undefined ) {

      renderer = indexedBufferRenderer;
      renderer.setIndex( index );

    } else {

      renderer = bufferRenderer;

    }

    if ( updateBuffers ) {

      setupVertexAttributes( material, program, geometry );

      if ( index !== undefined ) {

        _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

      }

    }

    if ( group === undefined ) {

      var count;

      if ( index !== undefined ) {

        count = index.array.length;

      } else if ( position instanceof THREE.InterleavedBufferAttribute ) {

        count = position.data.array.length / 3;

      } else {

        count = position.array.length / 3;

      }

      group = {
        start: 0,
        count: count
      };

    }

    if ( object instanceof THREE.Mesh ) {

      if ( material.wireframe === true ) {

        state.setLineWidth( material.wireframeLinewidth * pixelRatio );
        renderer.setMode( _gl.LINES );

      } else {

        renderer.setMode( _gl.TRIANGLES );

      }

      if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

        renderer.renderInstances( geometry );

      } else if ( position instanceof THREE.InterleavedBufferAttribute ) {

        renderer.render( 0, position.data.count );

      } else {

        renderer.render( group.start, group.count );

      }

    } else if ( object instanceof THREE.Line ) {

      var lineWidth = material.linewidth;

      if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

      state.setLineWidth( lineWidth * pixelRatio );

      if ( object instanceof THREE.LineSegments ) {

        renderer.setMode( _gl.LINES );

      } else {

        renderer.setMode( _gl.LINE_STRIP );

      }

      renderer.render( group.start, group.count );

    } else if ( object instanceof THREE.PointCloud ) {

      renderer.setMode( _gl.POINTS );
      renderer.render( group.start, group.count );

    }

  };

  function setupVertexAttributes( material, program, geometry, startIndex ) {

    var extension;

    if ( geometry instanceof THREE.InstancedBufferGeometry ) {

      extension = extensions.get( 'ANGLE_instanced_arrays' );

      if ( extension === null ) {

        console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
        return;

      }

    }

    if ( startIndex === undefined ) startIndex = 0;

    state.initAttributes();

    var geometryAttributes = geometry.attributes;

    var programAttributes = program.getAttributes();

    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for ( var name in programAttributes ) {

      var programAttribute = programAttributes[ name ];

      if ( programAttribute >= 0 ) {

        var geometryAttribute = geometryAttributes[ name ];

        if ( geometryAttribute !== undefined ) {

          state.enableAttribute( programAttribute );

          var size = geometryAttribute.itemSize;
          var buffer = objects.getAttributeBuffer( geometryAttribute );

          if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

            if ( data instanceof THREE.InstancedInterleavedBuffer ) {

              if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

              }

              extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

              }

            }

          } else {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

            if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

              if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

              }

              extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

              }

            }

          }

        } else if ( materialDefaultAttributeValues !== undefined ) {

          var value = materialDefaultAttributeValues[ name ];

          if ( value !== undefined ) {

            switch ( value.length ) {

              case 2:
                _gl.vertexAttrib2fv( programAttribute, value );
                break;

              case 3:
                _gl.vertexAttrib3fv( programAttribute, value );
                break;

              case 4:
                _gl.vertexAttrib4fv( programAttribute, value );
                break;

              default:
                _gl.vertexAttrib1fv( programAttribute, value );

            }

          }

        }

      }

    }

    state.disableUnusedAttributes();

  }

  // Sorting

  function numericalSort ( a, b ) {

    return b[ 0 ] - a[ 0 ];

  }

  function painterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } else if ( a.material.id !== b.material.id ) {

      return a.material.id - b.material.id;

    } else if ( a.z !== b.z ) {

      return a.z - b.z;

    } else {

      return a.id - b.id;

    }

  }

  function reversePainterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return a.id - b.id;

    }

  }

  // Rendering

  this.render = function ( scene, camera, renderTarget, forceClear ) {

    if ( camera instanceof THREE.Camera === false ) {

      console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var fog = scene.fog;

    // reset caching for this frame

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;
    _currentCamera = null;
    _lightsNeedUpdate = true;

    // update scene graph

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    // update camera matrices and frustum

    if ( camera.parent === null ) camera.updateMatrixWorld();

    camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    _frustum.setFromMatrix( _projScreenMatrix );

    lights.length = 0;

    opaqueObjects.length = 0;
    transparentObjects.length = 0;

    opaqueImmediateObjects.length = 0;
    transparentImmediateObjects.length = 0;

    sprites.length = 0;
    lensFlares.length = 0;

    projectObject( scene );

    if ( _this.sortObjects === true ) {

      opaqueObjects.sort( painterSortStable );
      transparentObjects.sort( reversePainterSortStable );

    }

    //

    shadowMap.render( scene, camera );

    //

    _infoRender.calls = 0;
    _infoRender.vertices = 0;
    _infoRender.faces = 0;
    _infoRender.points = 0;

    this.setRenderTarget( renderTarget );

    if ( this.autoClear || forceClear ) {

      this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    }

    //

    if ( scene.overrideMaterial ) {

      var overrideMaterial = scene.overrideMaterial;

      renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
      renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

      renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );
      renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );

    } else {

      // opaque pass (front-to-back order)

      state.setBlending( THREE.NoBlending );

      renderObjects( opaqueObjects, camera, lights, fog );
      renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );

      // transparent pass (back-to-front order)

      renderObjects( transparentObjects, camera, lights, fog );
      renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );

    }

    // custom render plugins (post pass)

    spritePlugin.render( scene, camera );
    lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

    // Generate mipmap if we're using any kind of mipmap filtering

    if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

      updateRenderTargetMipmap( renderTarget );

    }

    // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.setDepthTest( true );
    state.setDepthWrite( true );
    state.setColorWrite( true );

    // _gl.finish();

  };

  function projectObject( object ) {

    if ( object.visible === false ) return;

    if ( object instanceof THREE.Light ) {

      lights.push( object );

    } else if ( object instanceof THREE.Sprite ) {

      sprites.push( object );

    } else if ( object instanceof THREE.LensFlare ) {

      lensFlares.push( object );

    } else if ( object instanceof THREE.ImmediateRenderObject ) {

      var material = object.material;

      if ( material.transparent ) {

        transparentImmediateObjects.push( object );

      } else {

        opaqueImmediateObjects.push( object );

      }

    } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ){

      if ( object instanceof THREE.SkinnedMesh ) {

        object.skeleton.update();

      }

      if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

        var material = object.material;

        if ( material.visible === true ) {

          if ( _this.sortObjects === true ) {

            _vector3.setFromMatrixPosition( object.matrixWorld );
            _vector3.applyProjection( _projScreenMatrix );

          }

          if ( material instanceof THREE.MeshFaceMaterial ) {

            var materials = material.materials;

            for ( var i = 0, l = materials.length; i < l; i ++ ) {

              materials[ i ].program = properties.get( materials[ i ] ).program;

            }

          } else {

            material.program = properties.get( material ).program;

          }

          var renderItem = {
            id: object.id,
            object: object,
            material: object.material,
            z: _vector3.z
          };

          if ( material.transparent ) {

            transparentObjects.push( renderItem );

          } else {

            opaqueObjects.push( renderItem );

          }

        }

      }

    }

    var children = object.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      projectObject( children[ i ] );

    }

  }

  function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

    var material = overrideMaterial;

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var renderItem = renderList[ i ];
      var object = renderItem.object;
      var geometry = objects.update( object );

      object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
      object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

      if ( overrideMaterial === undefined ) material = object.material;

      if ( material instanceof THREE.MeshFaceMaterial ) {

        var groups = geometry.groups;
        var materials = material.materials;

        for ( var j = 0, jl = groups.length; j < jl; j ++ ) {

          var group = groups[ j ];
          var groupMaterial = materials[ group.materialIndex ];

          if ( groupMaterial !== undefined ) {

            _this.renderBufferDirect( camera, lights, fog, geometry, groupMaterial, object, group );

          }

        }

      } else {

        _this.renderBufferDirect( camera, lights, fog, geometry, material, object );

      }

    }

  }

  function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {

    var material = overrideMaterial;

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var object = renderList[ i ];

      object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
      object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

      if ( overrideMaterial === undefined ) material = object.material;

      setMaterial( material );

      var program = setProgram( camera, lights, fog, material, object );

      _currentGeometryProgram = '';

      object.render( function ( object ) {

        _this.renderBufferImmediate( object, program, material );

      } );

    }

  }

  // Materials

  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointCloudMaterial: 'particle_basic'
  };

  function initMaterial( material, lights, fog, object ) {

    var materialProperties = properties.get( material );

    var shaderID = shaderIDs[ material.type ];

    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxLightCount = allocateLights( lights );
    var maxShadows = allocateShadows( lights );
    var maxBones = allocateBones( object );
    var precision = _precision;

    if ( material.precision !== null ) {

      precision = state.getMaxPrecision( material.precision );

      if ( precision !== material.precision ) {

        console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

      }

    }

    var parameters = {

      precision: precision,
      supportsVertexTextures: _supportsVertexTextures,

      map: !! material.map,
      envMap: !! material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      lightMap: !! material.lightMap,
      aoMap: !! material.aoMap,
      emissiveMap: !! material.emissiveMap,
      bumpMap: !! material.bumpMap,
      normalMap: !! material.normalMap,
      specularMap: !! material.specularMap,
      alphaMap: !! material.alphaMap,

      combine: material.combine,

      vertexColors: material.vertexColors,

      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,

      flatShading: material.shading === THREE.FlatShading,

      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: _logarithmicDepthBuffer,

      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: _this.maxMorphTargets,
      maxMorphNormals: _this.maxMorphNormals,

      maxDirLights: maxLightCount.directional,
      maxPointLights: maxLightCount.point,
      maxSpotLights: maxLightCount.spot,
      maxHemiLights: maxLightCount.hemi,

      maxShadows: maxShadows,
      shadowMapEnabled: shadowMap.enabled && object.receiveShadow && maxShadows > 0,
      shadowMapType: shadowMap.type,
      shadowMapDebug: shadowMap.debug,

      alphaTest: material.alphaTest,
      metal: material.metal,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide

    };

    // Generate code

    var chunks = [];

    if ( shaderID ) {

      chunks.push( shaderID );

    } else {

      chunks.push( material.fragmentShader );
      chunks.push( material.vertexShader );

    }

    if ( material.defines !== undefined ) {

      for ( var name in material.defines ) {

        chunks.push( name );
        chunks.push( material.defines[ name ] );

      }

    }

    for ( var name in parameters ) {

      chunks.push( name );
      chunks.push( parameters[ name ] );

    }

    var code = chunks.join();
    var programChange = true;

    if ( ! materialProperties.program ) {

      // new material
      material.addEventListener( 'dispose', onMaterialDispose );

    } else if ( materialProperties.program.code !== code ) {

      // changed glsl or parameters
      releaseMaterialProgramReference( material );

    } else if ( shaderID !== undefined ) {

      // same glsl and uniform list
      return;

    } else {

      // only rebuild uniform list
      programChange = false;

    }

    if ( shaderID ) {

      var shader = THREE.ShaderLib[ shaderID ];

      materialProperties.__webglShader = {
        name: material.type,
        uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      };

    } else {

      materialProperties.__webglShader = {
        name: material.type,
        uniforms: material.uniforms,
        vertexShader: material.vertexShader,
        fragmentShader: material.fragmentShader
      };

    }

    var program;

    // Check if code has been already compiled

    for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

      var programInfo = _programs[ p ];

      if ( programInfo.code === code ) {

        program = programInfo;

        if ( programChange ) {

          program.usedTimes ++;

        }

        break;

      }

    }

    if ( program === undefined ) {

      material.__webglShader = materialProperties.__webglShader;
      program = new THREE.WebGLProgram( _this, code, material, parameters );
      _programs.push( program );

      _infoMemory.programs = _programs.length;

    }

    materialProperties.program = program;

    var attributes = program.getAttributes();

    if ( material.morphTargets ) {

      material.numSupportedMorphTargets = 0;

      for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

        if ( attributes[ 'morphTarget' + i ] >= 0 ) {

          material.numSupportedMorphTargets ++;

        }

      }

    }

    if ( material.morphNormals ) {

      material.numSupportedMorphNormals = 0;

      for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

        if ( attributes[ 'morphNormal' + i ] >= 0 ) {

          material.numSupportedMorphNormals ++;

        }

      }

    }

    materialProperties.uniformsList = [];

    var uniformLocations = materialProperties.program.getUniforms();
    for ( var u in materialProperties.__webglShader.uniforms ) {

      var location = uniformLocations[ u ];

      if ( location ) {

        materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

      }

    }

  }

  function setMaterial( material ) {

    setMaterialFaces( material );

    if ( material.transparent === true ) {

      state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

    } else {

      state.setBlending( THREE.NoBlending );

    }

    state.setDepthFunc( material.depthFunc );
    state.setDepthTest( material.depthTest );
    state.setDepthWrite( material.depthWrite );
    state.setColorWrite( material.colorWrite );
    state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  }

  function setMaterialFaces( material ) {

    material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
    state.setFlipSided( material.side === THREE.BackSide );

  }

  function setProgram( camera, lights, fog, material, object ) {

    _usedTextureUnits = 0;

    var materialProperties = properties.get( material );

    if ( material.needsUpdate || ! materialProperties.program ) {

      initMaterial( material, lights, fog, object );
      material.needsUpdate = false;

    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;

    var program = materialProperties.program,
      p_uniforms = program.getUniforms(),
      m_uniforms = materialProperties.__webglShader.uniforms;

    if ( program.id !== _currentProgram ) {

      _gl.useProgram( program.program );
      _currentProgram = program.id;

      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;

    }

    if ( material.id !== _currentMaterialId ) {

      if ( _currentMaterialId === - 1 ) refreshLights = true;
      _currentMaterialId = material.id;

      refreshMaterial = true;

    }

    if ( refreshProgram || camera !== _currentCamera ) {

      _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

      if ( _logarithmicDepthBuffer ) {

        _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

      }


      if ( camera !== _currentCamera ) _currentCamera = camera;

      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)

      if ( material instanceof THREE.ShaderMaterial ||
         material instanceof THREE.MeshPhongMaterial ||
         material.envMap ) {

        if ( p_uniforms.cameraPosition !== undefined ) {

          _vector3.setFromMatrixPosition( camera.matrixWorld );
          _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

        }

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.ShaderMaterial ||
         material.skinning ) {

        if ( p_uniforms.viewMatrix !== undefined ) {

          _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

        }

      }

    }

    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen

    if ( material.skinning ) {

      if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

      }

      if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

      }

      if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

        if ( p_uniforms.boneTexture !== undefined ) {

          var textureUnit = getTextureUnit();

          _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
          _this.setTexture( object.skeleton.boneTexture, textureUnit );

        }

        if ( p_uniforms.boneTextureWidth !== undefined ) {

          _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

        }

        if ( p_uniforms.boneTextureHeight !== undefined ) {

          _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

        }

      } else if ( object.skeleton && object.skeleton.boneMatrices ) {

        if ( p_uniforms.boneGlobalMatrices !== undefined ) {

          _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

        }

      }

    }

    if ( refreshMaterial ) {

      // refresh uniforms common to several materials

      if ( fog && material.fog ) {

        refreshUniformsFog( m_uniforms, fog );

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material.lights ) {

        if ( _lightsNeedUpdate ) {

          refreshLights = true;
          setupLights( lights );
          _lightsNeedUpdate = false;

        }

        if ( refreshLights ) {

          refreshUniformsLights( m_uniforms, _lights );
          markUniformsLightsNeedsUpdate( m_uniforms, true );

        } else {

          markUniformsLightsNeedsUpdate( m_uniforms, false );

        }

      }

      if ( material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsCommon( m_uniforms, material );

      }

      // refresh single material specific uniforms

      if ( material instanceof THREE.LineBasicMaterial ) {

        refreshUniformsLine( m_uniforms, material );

      } else if ( material instanceof THREE.LineDashedMaterial ) {

        refreshUniformsLine( m_uniforms, material );
        refreshUniformsDash( m_uniforms, material );

      } else if ( material instanceof THREE.PointCloudMaterial ) {

        refreshUniformsParticle( m_uniforms, material );

      } else if ( material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsPhong( m_uniforms, material );

      } else if ( material instanceof THREE.MeshLambertMaterial ) {

        refreshUniformsLambert( m_uniforms, material );

      } else if ( material instanceof THREE.MeshBasicMaterial ) {

        refreshUniformsBasic( m_uniforms, material );

      } else if ( material instanceof THREE.MeshDepthMaterial ) {

        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;

      } else if ( material instanceof THREE.MeshNormalMaterial ) {

        m_uniforms.opacity.value = material.opacity;

      }

      if ( object.receiveShadow && ! material._shadowPass ) {

        refreshUniformsShadow( m_uniforms, lights );

      }

      // load common uniforms

      loadUniformsGeneric( materialProperties.uniformsList );

    }

    loadUniformsMatrices( p_uniforms, object );

    if ( p_uniforms.modelMatrix !== undefined ) {

      _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

    }

    return program;

  }

  // Uniforms (refresh uniforms objects)

  function refreshUniformsCommon ( uniforms, material ) {

    uniforms.opacity.value = material.opacity;

    uniforms.diffuse.value = material.color;

    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;

    if ( material.bumpMap ) {

      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;

    }

    if ( material.normalMap ) {

      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy( material.normalScale );

    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map

    var uvScaleMap;

    if ( material.map ) {

      uvScaleMap = material.map;

    } else if ( material.specularMap ) {

      uvScaleMap = material.specularMap;

    } else if ( material.normalMap ) {

      uvScaleMap = material.normalMap;

    } else if ( material.bumpMap ) {

      uvScaleMap = material.bumpMap;

    } else if ( material.alphaMap ) {

      uvScaleMap = material.alphaMap;

    } else if ( material.emissiveMap ) {

      uvScaleMap = material.emissiveMap;

    }

    if ( uvScaleMap !== undefined ) {

      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;

  }

  function refreshUniformsLine ( uniforms, material ) {

    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;

  }

  function refreshUniformsDash ( uniforms, material ) {

    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;

  }

  function refreshUniformsParticle ( uniforms, material ) {

    uniforms.psColor.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

    uniforms.map.value = material.map;

    if ( material.map !== null ) {

      var offset = material.map.offset;
      var repeat = material.map.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

  }

  function refreshUniformsFog ( uniforms, fog ) {

    uniforms.fogColor.value = fog.color;

    if ( fog instanceof THREE.Fog ) {

      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;

    } else if ( fog instanceof THREE.FogExp2 ) {

      uniforms.fogDensity.value = fog.density;

    }

  }

  function refreshUniformsPhong ( uniforms, material ) {

    uniforms.shininess.value = material.shininess;

    uniforms.emissive.value = material.emissive;
    uniforms.specular.value = material.specular;

    uniforms.lightMap.value = material.lightMap;
    uniforms.lightMapIntensity.value = material.lightMapIntensity;

    uniforms.aoMap.value = material.aoMap;
    uniforms.aoMapIntensity.value = material.aoMapIntensity;

    uniforms.emissiveMap.value = material.emissiveMap;

  }

  function refreshUniformsLambert ( uniforms, material ) {

    uniforms.emissive.value = material.emissive;

  }

  function refreshUniformsBasic ( uniforms, material ) {

    uniforms.aoMap.value = material.aoMap;
    uniforms.aoMapIntensity.value = material.aoMapIntensity;

  }

  function refreshUniformsLights ( uniforms, lights ) {

    uniforms.ambientLightColor.value = lights.ambient;

    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;

    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;
    uniforms.pointLightDecay.value = lights.point.decays;

    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;
    uniforms.spotLightDecay.value = lights.spot.decays;

    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;

  }

  // If uniforms are marked as clean, they don't need to be loaded to the GPU.

  function markUniformsLightsNeedsUpdate ( uniforms, value ) {

    uniforms.ambientLightColor.needsUpdate = value;

    uniforms.directionalLightColor.needsUpdate = value;
    uniforms.directionalLightDirection.needsUpdate = value;

    uniforms.pointLightColor.needsUpdate = value;
    uniforms.pointLightPosition.needsUpdate = value;
    uniforms.pointLightDistance.needsUpdate = value;
    uniforms.pointLightDecay.needsUpdate = value;

    uniforms.spotLightColor.needsUpdate = value;
    uniforms.spotLightPosition.needsUpdate = value;
    uniforms.spotLightDistance.needsUpdate = value;
    uniforms.spotLightDirection.needsUpdate = value;
    uniforms.spotLightAngleCos.needsUpdate = value;
    uniforms.spotLightExponent.needsUpdate = value;
    uniforms.spotLightDecay.needsUpdate = value;

    uniforms.hemisphereLightSkyColor.needsUpdate = value;
    uniforms.hemisphereLightGroundColor.needsUpdate = value;
    uniforms.hemisphereLightDirection.needsUpdate = value;

  }

  function refreshUniformsShadow ( uniforms, lights ) {

    if ( uniforms.shadowMatrix ) {

      var j = 0;

      for ( var i = 0, il = lights.length; i < il; i ++ ) {

        var light = lights[ i ];

        if ( ! light.castShadow ) continue;

        if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {

          uniforms.shadowMap.value[ j ] = light.shadowMap;
          uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

          uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

          uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
          uniforms.shadowBias.value[ j ] = light.shadowBias;

          j ++;

        }

      }

    }

  }

  // Uniforms (load to GPU)

  function loadUniformsMatrices ( uniforms, object ) {

    _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

    if ( uniforms.normalMatrix ) {

      _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

    }

  }

  function getTextureUnit() {

    var textureUnit = _usedTextureUnits;

    if ( textureUnit >= _maxTextures ) {

      console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

    }

    _usedTextureUnits += 1;

    return textureUnit;

  }

  function loadUniformsGeneric ( uniforms ) {

    var texture, textureUnit, offset;

    for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

      var uniform = uniforms[ j ][ 0 ];

      // needsUpdate property is not added to all uniforms.
      if ( uniform.needsUpdate === false ) continue;

      var type = uniform.type;
      var value = uniform.value;
      var location = uniforms[ j ][ 1 ];

      switch ( type ) {

        case '1i':
          _gl.uniform1i( location, value );
          break;

        case '1f':
          _gl.uniform1f( location, value );
          break;

        case '2f':
          _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
          break;

        case '3f':
          _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
          break;

        case '4f':
          _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
          break;

        case '1iv':
          _gl.uniform1iv( location, value );
          break;

        case '3iv':
          _gl.uniform3iv( location, value );
          break;

        case '1fv':
          _gl.uniform1fv( location, value );
          break;

        case '2fv':
          _gl.uniform2fv( location, value );
          break;

        case '3fv':
          _gl.uniform3fv( location, value );
          break;

        case '4fv':
          _gl.uniform4fv( location, value );
          break;

        case 'Matrix3fv':
          _gl.uniformMatrix3fv( location, false, value );
          break;

        case 'Matrix4fv':
          _gl.uniformMatrix4fv( location, false, value );
          break;

        //

        case 'i':

          // single integer
          _gl.uniform1i( location, value );

          break;

        case 'f':

          // single float
          _gl.uniform1f( location, value );

          break;

        case 'v2':

          // single THREE.Vector2
          _gl.uniform2f( location, value.x, value.y );

          break;

        case 'v3':

          // single THREE.Vector3
          _gl.uniform3f( location, value.x, value.y, value.z );

          break;

        case 'v4':

          // single THREE.Vector4
          _gl.uniform4f( location, value.x, value.y, value.z, value.w );

          break;

        case 'c':

          // single THREE.Color
          _gl.uniform3f( location, value.r, value.g, value.b );

          break;

        case 'iv1':

          // flat array of integers (JS or typed array)
          _gl.uniform1iv( location, value );

          break;

        case 'iv':

          // flat array of integers with 3 x N size (JS or typed array)
          _gl.uniform3iv( location, value );

          break;

        case 'fv1':

          // flat array of floats (JS or typed array)
          _gl.uniform1fv( location, value );

          break;

        case 'fv':

          // flat array of floats with 3 x N size (JS or typed array)
          _gl.uniform3fv( location, value );

          break;

        case 'v2v':

          // array of THREE.Vector2

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 2 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 2;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;

          }

          _gl.uniform2fv( location, uniform._array );

          break;

        case 'v3v':

          // array of THREE.Vector3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 3 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 3;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;

          }

          _gl.uniform3fv( location, uniform._array );

          break;

        case 'v4v':

          // array of THREE.Vector4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 4 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 4;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;
            uniform._array[ offset + 3 ] = value[ i ].w;

          }

          _gl.uniform4fv( location, uniform._array );

          break;

        case 'm3':

          // single THREE.Matrix3
          _gl.uniformMatrix3fv( location, false, value.elements );

          break;

        case 'm3v':

          // array of THREE.Matrix3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 9 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

          }

          _gl.uniformMatrix3fv( location, false, uniform._array );

          break;

        case 'm4':

          // single THREE.Matrix4
          _gl.uniformMatrix4fv( location, false, value.elements );

          break;

        case 'm4v':

          // array of THREE.Matrix4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 16 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

          }

          _gl.uniformMatrix4fv( location, false, uniform._array );

          break;

        case 't':

          // single THREE.Texture (2d or cube)

          texture = value;
          textureUnit = getTextureUnit();

          _gl.uniform1i( location, textureUnit );

          if ( ! texture ) continue;

          if ( texture instanceof THREE.CubeTexture ||
             ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

            // CompressedTexture can have Array in image :/

            setCubeTexture( texture, textureUnit );

          } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

            setCubeTextureDynamic( texture, textureUnit );

          } else {

            _this.setTexture( texture, textureUnit );

          }

          break;

        case 'tv':

          // array of THREE.Texture (2d)

          if ( uniform._array === undefined ) {

            uniform._array = [];

          }

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            uniform._array[ i ] = getTextureUnit();

          }

          _gl.uniform1iv( location, uniform._array );

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            texture = uniform.value[ i ];
            textureUnit = uniform._array[ i ];

            if ( ! texture ) continue;

            _this.setTexture( texture, textureUnit );

          }

          break;

        default:

          console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

      }

    }

  }

  function setColorLinear( array, offset, color, intensity ) {

    array[ offset + 0 ] = color.r * intensity;
    array[ offset + 1 ] = color.g * intensity;
    array[ offset + 2 ] = color.b * intensity;

  }

  function setupLights ( lights ) {

    var l, ll, light,
    r = 0, g = 0, b = 0,
    color, skyColor, groundColor,
    intensity,
    distance,

    zlights = _lights,

    dirColors = zlights.directional.colors,
    dirPositions = zlights.directional.positions,

    pointColors = zlights.point.colors,
    pointPositions = zlights.point.positions,
    pointDistances = zlights.point.distances,
    pointDecays = zlights.point.decays,

    spotColors = zlights.spot.colors,
    spotPositions = zlights.spot.positions,
    spotDistances = zlights.spot.distances,
    spotDirections = zlights.spot.directions,
    spotAnglesCos = zlights.spot.anglesCos,
    spotExponents = zlights.spot.exponents,
    spotDecays = zlights.spot.decays,

    hemiSkyColors = zlights.hemi.skyColors,
    hemiGroundColors = zlights.hemi.groundColors,
    hemiPositions = zlights.hemi.positions,

    dirLength = 0,
    pointLength = 0,
    spotLength = 0,
    hemiLength = 0,

    dirCount = 0,
    pointCount = 0,
    spotCount = 0,
    hemiCount = 0,

    dirOffset = 0,
    pointOffset = 0,
    spotOffset = 0,
    hemiOffset = 0;

    for ( l = 0, ll = lights.length; l < ll; l ++ ) {

      light = lights[ l ];

      if ( light.onlyShadow ) continue;

      color = light.color;
      intensity = light.intensity;
      distance = light.distance;

      if ( light instanceof THREE.AmbientLight ) {

        if ( ! light.visible ) continue;

        r += color.r;
        g += color.g;
        b += color.b;

      } else if ( light instanceof THREE.DirectionalLight ) {

        dirCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        dirOffset = dirLength * 3;

        dirPositions[ dirOffset + 0 ] = _direction.x;
        dirPositions[ dirOffset + 1 ] = _direction.y;
        dirPositions[ dirOffset + 2 ] = _direction.z;

        setColorLinear( dirColors, dirOffset, color, intensity );

        dirLength += 1;

      } else if ( light instanceof THREE.PointLight ) {

        pointCount += 1;

        if ( ! light.visible ) continue;

        pointOffset = pointLength * 3;

        setColorLinear( pointColors, pointOffset, color, intensity );

        _vector3.setFromMatrixPosition( light.matrixWorld );

        pointPositions[ pointOffset + 0 ] = _vector3.x;
        pointPositions[ pointOffset + 1 ] = _vector3.y;
        pointPositions[ pointOffset + 2 ] = _vector3.z;

        // distance is 0 if decay is 0, because there is no attenuation at all.
        pointDistances[ pointLength ] = distance;
        pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

        pointLength += 1;

      } else if ( light instanceof THREE.SpotLight ) {

        spotCount += 1;

        if ( ! light.visible ) continue;

        spotOffset = spotLength * 3;

        setColorLinear( spotColors, spotOffset, color, intensity );

        _direction.setFromMatrixPosition( light.matrixWorld );

        spotPositions[ spotOffset + 0 ] = _direction.x;
        spotPositions[ spotOffset + 1 ] = _direction.y;
        spotPositions[ spotOffset + 2 ] = _direction.z;

        spotDistances[ spotLength ] = distance;

        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        spotDirections[ spotOffset + 0 ] = _direction.x;
        spotDirections[ spotOffset + 1 ] = _direction.y;
        spotDirections[ spotOffset + 2 ] = _direction.z;

        spotAnglesCos[ spotLength ] = Math.cos( light.angle );
        spotExponents[ spotLength ] = light.exponent;
        spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

        spotLength += 1;

      } else if ( light instanceof THREE.HemisphereLight ) {

        hemiCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _direction.normalize();

        hemiOffset = hemiLength * 3;

        hemiPositions[ hemiOffset + 0 ] = _direction.x;
        hemiPositions[ hemiOffset + 1 ] = _direction.y;
        hemiPositions[ hemiOffset + 2 ] = _direction.z;

        skyColor = light.color;
        groundColor = light.groundColor;

        setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
        setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

        hemiLength += 1;

      }

    }

    // null eventual remains from removed lights
    // (this is to avoid if in shader)

    for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
    for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
    for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;

    zlights.ambient[ 0 ] = r;
    zlights.ambient[ 1 ] = g;
    zlights.ambient[ 2 ] = b;

  }

  // GL state setting

  this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    if ( cullFace === THREE.CullFaceNone ) {

      state.disable( _gl.CULL_FACE );

    } else {

      if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

        _gl.frontFace( _gl.CW );

      } else {

        _gl.frontFace( _gl.CCW );

      }

      if ( cullFace === THREE.CullFaceBack ) {

        _gl.cullFace( _gl.BACK );

      } else if ( cullFace === THREE.CullFaceFront ) {

        _gl.cullFace( _gl.FRONT );

      } else {

        _gl.cullFace( _gl.FRONT_AND_BACK );

      }

      state.enable( _gl.CULL_FACE );

    }

  };

  // Textures

  function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

    var extension;

    if ( isImagePowerOfTwo ) {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    } else {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

      if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

      }

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

      if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

      }

    }

    extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {

      if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

        _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
        properties.get( texture ).__currentAnisotropy = texture.anisotropy;

      }

    }

  }

  function uploadTexture( textureProperties, texture, slot ) {

    if ( textureProperties.__webglInit === undefined ) {

      textureProperties.__webglInit = true;

      texture.__webglInit = true;

      texture.addEventListener( 'dispose', onTextureDispose );

      textureProperties.__webglTexture = _gl.createTexture();

      _infoMemory.textures ++;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    texture.image = clampToMaxSize( texture.image, _maxTextureSize );

    var image = texture.image,
    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
    glFormat = paramThreeToGL( texture.format ),
    glType = paramThreeToGL( texture.type );

    setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

    var mipmap, mipmaps = texture.mipmaps;

    if ( texture instanceof THREE.DataTexture ) {

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

      }

    } else if ( texture instanceof THREE.CompressedTexture ) {

      for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

        mipmap = mipmaps[ i ];

        if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

          if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

            state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

          } else {

            console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

          }

        } else {

          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

      }

    } else {

      // regular Texture (image, video, canvas)

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

      }

    }

    if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

    textureProperties.__version = texture.version;

    if ( texture.onUpdate ) texture.onUpdate( texture );

  }

  this.setTexture = function ( texture, slot ) {

    var textureProperties = properties.get( texture );

    if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

      var image = texture.image;

      if ( image === undefined ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
        return;

      }

      if ( image.complete === false ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
        return;

      }

      uploadTexture( textureProperties, texture, slot );
      return;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  };

  function clampToMaxSize ( image, maxSize ) {

    if ( image.width > maxSize || image.height > maxSize ) {

      // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.

      var scale = maxSize / Math.max( image.width, image.height );

      var canvas = document.createElement( 'canvas' );
      canvas.width = Math.floor( image.width * scale );
      canvas.height = Math.floor( image.height * scale );

      var context = canvas.getContext( '2d' );
      context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

      console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

      return canvas;

    }

    return image;

  }

  function setCubeTexture ( texture, slot ) {

    var textureProperties = properties.get( texture );

    if ( texture.image.length === 6 ) {

      if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

        if ( ! textureProperties.__image__webglTextureCube ) {

          texture.addEventListener( 'dispose', onTextureDispose );

          textureProperties.__image__webglTextureCube = _gl.createTexture();

          _infoMemory.textures ++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

        var isCompressed = texture instanceof THREE.CompressedTexture;
        var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

        var cubeImage = [];

        for ( var i = 0; i < 6; i ++ ) {

          if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

            cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

          } else {

            cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

          }

        }

        var image = cubeImage[ 0 ],
        isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
        glFormat = paramThreeToGL( texture.format ),
        glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          if ( ! isCompressed ) {

            if ( isDataTexture ) {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

            } else {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

            }

          } else {

            var mipmap, mipmaps = cubeImage[ i ].mipmaps;

            for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

              mipmap = mipmaps[ j ];

              if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                  state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                } else {

                  console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                }

              } else {

                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

              }

            }

          }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) {

          _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

        }

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

      } else {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

      }

    }

  }

  function setCubeTextureDynamic ( texture, slot ) {

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

  }

  // Render targets

  function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

    _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );

  }

  function setupRenderBuffer ( renderbuffer, renderTarget ) {

    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    /* For some reason this is not working. Defaulting to RGBA4.
    } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
    */

    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    } else {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    }

  }

  this.setRenderTarget = function ( renderTarget ) {

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

    if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

      var renderTargetProperties = properties.get( renderTarget );

      if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
      if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

      renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

      renderTargetProperties.__webglTexture = _gl.createTexture();

      _infoMemory.textures ++;

      // Setup texture, create render and frame buffers

      var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
        glFormat = paramThreeToGL( renderTarget.format ),
        glType = paramThreeToGL( renderTarget.type );

      if ( isCube ) {

        renderTargetProperties.__webglFramebuffer = [];
        renderTargetProperties.__webglRenderbuffer = [];

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
          renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

          state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

          setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
          setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

        }

        if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

      } else {

        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

        if ( renderTarget.shareDepthFrom ) {

          renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

        } else {

          renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

        }

        state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );
        setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

        setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

        if ( renderTarget.shareDepthFrom ) {

          if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

          } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

          }

        } else {

          setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

        }

        if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

      }

      // Release everything

      if ( isCube ) {

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

      } else {

        state.bindTexture( _gl.TEXTURE_2D, null );

      }

      _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    }

    var framebuffer, width, height, vx, vy;

    if ( renderTarget ) {

      var renderTargetProperties = properties.get( renderTarget );

      if ( isCube ) {

        framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

      } else {

        framebuffer = renderTargetProperties.__webglFramebuffer;

      }

      width = renderTarget.width;
      height = renderTarget.height;

      vx = 0;
      vy = 0;

    } else {

      framebuffer = null;

      width = _viewportWidth;
      height = _viewportHeight;

      vx = _viewportX;
      vy = _viewportY;

    }

    if ( framebuffer !== _currentFramebuffer ) {

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
      _gl.viewport( vx, vy, width, height );

      _currentFramebuffer = framebuffer;

    }

    _currentWidth = width;
    _currentHeight = height;

  };

  this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

    if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

      console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
      return;

    }

    if ( properties.get( renderTarget ).__webglFramebuffer ) {

      if ( renderTarget.format !== THREE.RGBAFormat ) {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
        return;

      }

      var restore = false;

      if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );

        restore = true;

      }

      if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

        _gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

      } else {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

      }

      if ( restore ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

      }

    }

  };

  function updateRenderTargetMipmap ( renderTarget ) {

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
      state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    } else {

      state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_2D );
      state.bindTexture( _gl.TEXTURE_2D, null );

    }

  }

  // Fallback filters for non-power-of-2 textures

  function filterFallback ( f ) {

    if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

      return _gl.NEAREST;

    }

    return _gl.LINEAR;

  }

  // Map three.js constants to WebGL constants

  function paramThreeToGL ( p ) {

    var extension;

    if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
    if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    if ( p === THREE.NearestFilter ) return _gl.NEAREST;
    if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    if ( p === THREE.LinearFilter ) return _gl.LINEAR;
    if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    if ( p === THREE.ByteType ) return _gl.BYTE;
    if ( p === THREE.ShortType ) return _gl.SHORT;
    if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    if ( p === THREE.IntType ) return _gl.INT;
    if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
    if ( p === THREE.FloatType ) return _gl.FLOAT;

    extension = extensions.get( 'OES_texture_half_float' );

    if ( extension !== null ) {

      if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

    }

    if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
    if ( p === THREE.RGBFormat ) return _gl.RGB;
    if ( p === THREE.RGBAFormat ) return _gl.RGBA;
    if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
    if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

    if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
    if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
    if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    if ( p === THREE.ZeroFactor ) return _gl.ZERO;
    if ( p === THREE.OneFactor ) return _gl.ONE;
    if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
    if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
    if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
    if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
    if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    }

    extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    }

    extension = extensions.get( 'EXT_blend_minmax' );

    if ( extension !== null ) {

      if ( p === THREE.MinEquation ) return extension.MIN_EXT;
      if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

    }

    return 0;

  }

  // Allocations

  function allocateBones ( object ) {

    if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

      return 1024;

    } else {

      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)

      var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
      var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

      var maxBones = nVertexMatrices;

      if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

        maxBones = Math.min( object.skeleton.bones.length, maxBones );

        if ( maxBones < object.skeleton.bones.length ) {

          console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

        }

      }

      return maxBones;

    }

  }

  function allocateLights( lights ) {

    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( light.onlyShadow || light.visible === false ) continue;

      if ( light instanceof THREE.DirectionalLight ) dirLights ++;
      if ( light instanceof THREE.PointLight ) pointLights ++;
      if ( light instanceof THREE.SpotLight ) spotLights ++;
      if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

    }

    return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

  }

  function allocateShadows( lights ) {

    var maxShadows = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( ! light.castShadow ) continue;

      if ( light instanceof THREE.SpotLight ) maxShadows ++;
      if ( light instanceof THREE.DirectionalLight ) maxShadows ++;

    }

    return maxShadows;

  }

  // DEPRECATED

  this.supportsFloatTextures = function () {

    console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
    return extensions.get( 'OES_texture_float' );

  };

  this.supportsHalfFloatTextures = function () {

    console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
    return extensions.get( 'OES_texture_half_float' );

  };

  this.supportsStandardDerivatives = function () {

    console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
    return extensions.get( 'OES_standard_derivatives' );

  };

  this.supportsCompressedTextureS3TC = function () {

    console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
    return extensions.get( 'WEBGL_compressed_texture_s3tc' );

  };

  this.supportsCompressedTexturePVRTC = function () {

    console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
    return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  };

  this.supportsBlendMinMax = function () {

    console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
    return extensions.get( 'EXT_blend_minmax' );

  };

  this.initMaterial = function () {

    console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  };

  this.addPrePlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  };

  this.addPostPlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  };

  this.updateShadowMap = function () {

    console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  };

  Object.defineProperties( this, {
    shadowMapEnabled: {
      get: function () {

        return shadowMap.enabled;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
        shadowMap.enabled = value;

      }
    },
    shadowMapType: {
      get: function () {

        return shadowMap.type;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
        shadowMap.type = value;

      }
    },
    shadowMapCullFace: {
      get: function () {

        return shadowMap.cullFace;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
        shadowMap.cullFace = value;

      }
    },
    shadowMapDebug: {
      get: function () {

        return shadowMap.debug;

      },
      set: function ( value ) {

        console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
        shadowMap.debug = value;

      }
    }
  } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

  this.uuid = THREE.Math.generateUUID();

  this.width = width;
  this.height = height;

  options = options || {};

  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

  this.generateMipmaps = true;

  this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

  constructor: THREE.WebGLRenderTarget,

  setSize: function ( width, height ) {

    if ( this.width !== width || this.height !== height ) {

      this.width = width;
      this.height = height;

      this.dispose();

    }

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.width = source.width;
    this.height = source.height;

    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;

    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;

    this.anisotropy = source.anisotropy;

    this.offset.copy( source.offset );
    this.repeat.copy( source.repeat );

    this.format = source.format;
    this.type = source.type;

    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;

    this.generateMipmaps = source.generateMipmaps;

    this.shareDepthFrom = source.shareDepthFrom;

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

  THREE.WebGLRenderTarget.call( this, width, height, options );

  this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

  var mode;

  function setMode( value ) {

    mode = value;

  }

  function render( start, count ) {

    _gl.drawArrays( mode, start, count );

    _infoRender.calls ++;
    _infoRender.vertices += count;
    if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

  }

  function renderInstances( geometry ) {

    var extension = extensions.get( 'ANGLE_instanced_arrays' );

    if ( extension === null ) {

      console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
      return;

    }

    var position = geometry.attributes.position;

    if ( position instanceof THREE.InterleavedBufferAttribute ) {

      extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

    } else {

      extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

    }

  }

  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

  var mode;

  function setMode( value ) {

    mode = value;

  }

  var type, size;

  function setIndex( index ) {

    if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

      type = _gl.UNSIGNED_INT;
      size = 4;

    } else {

      type = _gl.UNSIGNED_SHORT;
      size = 2;

    }

  }

  function render( start, count ) {

    _gl.drawElements( mode, count, type, start * size );

    _infoRender.calls ++;
    _infoRender.vertices += count;
    if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

  }

  function renderInstances( geometry ) {

    var extension = extensions.get( 'ANGLE_instanced_arrays' );

    if ( extension === null ) {

      console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
      return;

    }

    var index = geometry.attributes.index;

    extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

  }

  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

  var extensions = {};

  this.get = function ( name ) {

    if ( extensions[ name ] !== undefined ) {

      return extensions[ name ];

    }

    var extension;

    switch ( name ) {

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
        break;

      default:
        extension = gl.getExtension( name );

    }

    if ( extension === null ) {

      console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    }

    extensions[ name ] = extension;

    return extension;

  };

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, properties, info ) {

  var geometries = {};

  function get( object ) {

    var geometry = object.geometry;

    if ( geometries[ geometry.id ] !== undefined ) {

      return geometries[ geometry.id ];

    }

    geometry.addEventListener( 'dispose', onGeometryDispose );

    var buffergeometry;

    if ( geometry instanceof THREE.BufferGeometry ) {

      buffergeometry = geometry;

    } else if ( geometry instanceof THREE.Geometry ) {

      if ( geometry._bufferGeometry === undefined ) {

        geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

      }

      buffergeometry = geometry._bufferGeometry;

    }

    geometries[ geometry.id ] = buffergeometry;

    info.memory.geometries ++;

    return buffergeometry;

  }

  function onGeometryDispose( event ) {

    var geometry = event.target;
    var buffergeometry = geometries[ geometry.id ];

    deleteAttributes( buffergeometry.attributes );

    geometry.removeEventListener( 'dispose', onGeometryDispose );

    delete geometries[ geometry.id ];

    var property = properties.get( geometry );
    if ( property.wireframe ) deleteAttribute( property.wireframe );

    info.memory.geometries --;

  }

  function getAttributeBuffer( attribute ) {

    if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

      return properties.get( attribute.data ).__webglBuffer;

    }

    return properties.get( attribute ).__webglBuffer;

  }

  function deleteAttribute( attribute ) {

    var buffer = getAttributeBuffer( attribute );

    if ( buffer !== undefined ) {

      gl.deleteBuffer( buffer );
      removeAttributeBuffer( attribute );

    }

  }

  function deleteAttributes( attributes ) {

    for ( var name in attributes ) {

      deleteAttribute( attributes[ name ] );

    }

  }

  function removeAttributeBuffer( attribute ) {

    if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

      properties.delete( attribute.data );

    } else {

      properties.delete( attribute );

    }

  }

  this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, properties, info ) {

  var geometries = new THREE.WebGLGeometries( gl, properties, info );

  //

  function update( object ) {

    // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

    var geometry = geometries.get( object );

    if ( object.geometry instanceof THREE.Geometry ) {

      geometry.updateFromObject( object );

    }

    var attributes = geometry.attributes;

    for ( var name in attributes ) {

      updateAttribute( attributes[ name ] );

    }

    // morph targets

    var morphAttributes = geometry.morphAttributes;

    for ( var name in morphAttributes ) {

      var array = morphAttributes[ name ];

      for ( var i = 0, l = array.length; i < l; i ++ ) {

        updateAttribute( array[ i ] );

      }

    }

    return geometry;

  }

  function updateAttribute( attribute ) {

    var bufferType;

    if ( attribute instanceof THREE.IndexBufferAttribute ) {

      bufferType = gl.ELEMENT_ARRAY_BUFFER;

    } else {

      bufferType = gl.ARRAY_BUFFER;

    }

    var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

    var attributeProperties = properties.get( data );

    if ( attributeProperties.__webglBuffer === undefined ) {

      createBuffer( attributeProperties, data, bufferType );

    } else if ( attributeProperties.version !== data.version ) {

      updateBuffer( attributeProperties, data, bufferType );

    }

  }

  function createBuffer( attributeProperties, data, bufferType ) {

    attributeProperties.__webglBuffer = gl.createBuffer();
    gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    var usage = gl.STATIC_DRAW;

    if ( data instanceof THREE.DynamicBufferAttribute
       || ( data instanceof THREE.InstancedBufferAttribute && data.dynamic === true )
       || ( data instanceof THREE.InterleavedBuffer && data.dynamic === true ) ) {

      usage = gl.DYNAMIC_DRAW;

    }

    gl.bufferData( bufferType, data.array, usage );

    attributeProperties.version = data.version;

  }

  function updateBuffer( attributeProperties, data, bufferType ) {

    gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    if ( data.updateRange === undefined || data.updateRange.count === - 1 ) {

      // Not using update ranges

      gl.bufferSubData( bufferType, 0, data.array );

    } else if ( data.updateRange.count === 0 ) {

      console.error( 'THREE.WebGLObjects.updateBuffer: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );

    } else {

      gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

      data.updateRange.count = 0; // reset range

    }

    attributeProperties.version = data.version;

  }

  function getAttributeBuffer( attribute ) {

    if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

      return properties.get( attribute.data ).__webglBuffer;

    }

    return properties.get( attribute ).__webglBuffer;

  }

  function getWireframeAttribute( geometry ) {

    var property = properties.get( geometry );

    if ( property.wireframe !== undefined ) {

      return property.wireframe;

    }

    var indices = [];

    var attributes = geometry.attributes;

    var index = attributes.index;
    var position = attributes.position;

    // console.time( 'wireframe' );

    if ( index !== undefined ) {

      var edges = {};
      var array = index.array;

      for ( var i = 0, l = array.length; i < l; i += 3 ) {

        var a = array[ i + 0 ];
        var b = array[ i + 1 ];
        var c = array[ i + 2 ];

        if ( checkEdge( edges, a, b ) ) indices.push( a, b );
        if ( checkEdge( edges, b, c ) ) indices.push( b, c );
        if ( checkEdge( edges, c, a ) ) indices.push( c, a );

      }

    } else {

      var array = position.array;

      for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

        var a = i + 0;
        var b = i + 1;
        var c = i + 2;

        indices.push( a, b, b, c, c, a );

      }

    }

    // console.timeEnd( 'wireframe' );

    var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    var attribute = new THREE.IndexBufferAttribute( new TypeArray( indices ), 1 );

    updateAttribute( attribute );

    property.wireframe = attribute;

    return attribute;

  }

  function checkEdge( edges, a, b ) {

    var hash = a < b ? a + '_' + b : b + '_' + a;

    if ( edges.hasOwnProperty( hash ) ) return false;

    edges[ hash ] = 1;

    return true;

  }

  this.getAttributeBuffer = getAttributeBuffer;
  this.getWireframeAttribute = getWireframeAttribute;

  this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

  var programIdCount = 0;

  function generateDefines( defines ) {

    var chunks = [];

    for ( var name in defines ) {

      var value = defines[ name ];

      if ( value === false ) continue;

      chunks.push( '#define ' + name + ' ' + value );

    }

    return chunks.join( '\n' );

  }

  function fetchUniformLocations( gl, program, identifiers ) {

    var uniforms = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveUniform( program, i );
      var name = info.name;
      var location = gl.getUniformLocation( program, name );

      // console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

      var suffixPos = name.lastIndexOf( '[0]' );
      if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

        uniforms[ name.substr( 0, suffixPos ) ] = location;

      }

      uniforms[ name ] = location;

    }

    return uniforms;

  }

  function fetchAttributeLocations( gl, program, identifiers ) {

    var attributes = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveAttrib( program, i );
      var name = info.name;

      // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

      attributes[ name ] = gl.getAttribLocation( program, name );

    }

    return attributes;

  }

  function filterEmptyLine( string ) {

    return string !== '';

  }

  return function WebGLProgram( renderer, code, material, parameters ) {

    var gl = renderer.context;

    var defines = material.defines;

    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;

    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    }

    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    if ( parameters.envMap ) {

      switch ( material.envMap.mapping ) {

        case THREE.CubeReflectionMapping:
        case THREE.CubeRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          break;

        case THREE.EquirectangularReflectionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
          break;

        case THREE.SphericalReflectionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
          break;

      }

      switch ( material.envMap.mapping ) {

        case THREE.CubeRefractionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
          break;

      }

      switch ( material.combine ) {

        case THREE.MultiplyOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
          break;

        case THREE.MixOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
          break;

        case THREE.AddOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
          break;

      }

    }

    var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    // console.log( 'building new program ' );

    //

    var customDefines = generateDefines( defines );

    //

    var program = gl.createProgram();

    var prefixVertex, prefixFragment;

    if ( material instanceof THREE.RawShaderMaterial ) {

      prefixVertex = '';
      prefixFragment = '';

    } else {

      prefixVertex = [

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        '#define SHADER_NAME ' + material.__webglShader.name,

        customDefines,

        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

        '#define MAX_SHADOWS ' + parameters.maxShadows,

        '#define MAX_BONES ' + parameters.maxBones,

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED' : '',

        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',

        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',

        '#ifdef USE_COLOR',

        ' attribute vec3 color;',

        '#endif',

        '#ifdef USE_MORPHTARGETS',

        ' attribute vec3 morphTarget0;',
        ' attribute vec3 morphTarget1;',
        ' attribute vec3 morphTarget2;',
        ' attribute vec3 morphTarget3;',

        ' #ifdef USE_MORPHNORMALS',

        '   attribute vec3 morphNormal0;',
        '   attribute vec3 morphNormal1;',
        '   attribute vec3 morphNormal2;',
        '   attribute vec3 morphNormal3;',

        ' #else',

        '   attribute vec3 morphTarget4;',
        '   attribute vec3 morphTarget5;',
        '   attribute vec3 morphTarget6;',
        '   attribute vec3 morphTarget7;',

        ' #endif',

        '#endif',

        '#ifdef USE_SKINNING',

        ' attribute vec4 skinIndex;',
        ' attribute vec4 skinWeight;',

        '#endif',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

      prefixFragment = [

        parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        '#define SHADER_NAME ' + material.__webglShader.name,

        customDefines,

        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

        '#define MAX_SHADOWS ' + parameters.maxShadows,

        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED' : '',

        parameters.metal ? '#define METAL' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

    }

    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;

    var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    gl.attachShader( program, glVertexShader );
    gl.attachShader( program, glFragmentShader );

    // Force a particular attribute to index 0.

    if ( material.index0AttributeName !== undefined ) {

      gl.bindAttribLocation( program, 0, material.index0AttributeName );

    } else if ( parameters.morphTargets === true ) {

      // programs with morphTargets displace position out of attribute 0
      gl.bindAttribLocation( program, 0, 'position' );

    }

    gl.linkProgram( program );

    var programLog = gl.getProgramInfoLog( program );
    var vertexLog = gl.getShaderInfoLog( glVertexShader );
    var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    var runnable = true;
    var haveDiagnostics = true;

    if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

      runnable = false;

      console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    } else if ( programLog !== '' ) {

      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    } else if ( vertexLog === '' || fragmentLog === '' ) {

      haveDiagnostics = false;

    }

    if ( haveDiagnostics ) {

      this.diagnostics = {

        runnable: runnable,
        material: material,

        programLog: programLog,

        vertexShader: {

          log: vertexLog,
          prefix: prefixVertex

        },

        fragmentShader: {

          log: fragmentLog,
          prefix: prefixFragment

        }

      };

    }

    // clean up

    gl.deleteShader( glVertexShader );
    gl.deleteShader( glFragmentShader );

    // set up caching for uniform locations

    var cachedUniforms;

    this.getUniforms = function() {

      if ( cachedUniforms === undefined ) {

        cachedUniforms = fetchUniformLocations( gl, program );

      }

      return cachedUniforms;

    };

    // set up caching for attribute locations

    var cachedAttributes;

    this.getAttributes = function() {

      if ( cachedAttributes === undefined ) {

        cachedAttributes = fetchAttributeLocations( gl, program );

      }

      return cachedAttributes;

    };

    // DEPRECATED

    Object.defineProperties( this, {

      uniforms: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
          return this.getUniforms();

        }
      },

      attributes: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
          return this.getAttributes();

        }
      }

    } );


    //

    this.id = programIdCount ++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;

    return this;

  };

} )();

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

THREE.WebGLProperties = function () {

  var properties = {};

  this.get = function ( object ) {

    var uuid = object.uuid;
    var map = properties[ uuid ];

    if ( map === undefined ) {

      map = {};
      properties[ uuid ] = map;

    }

    return map;

  };

  this.delete = function ( object ) {

    delete properties[ object.uuid ];

  };

  this.clear = function () {

    properties = {};

  };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

  var addLineNumbers = function ( string ) {

    var lines = string.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    }

    return lines.join( '\n' );

  };

  return function WebGLShader( gl, type, string ) {

    var shader = gl.createShader( type );

    gl.shaderSource( shader, string );
    gl.compileShader( shader );

    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

      console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    }

    if ( gl.getShaderInfoLog( shader ) !== '' ) {

      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    }

    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    return shader;

  };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

  var _gl = _renderer.context,
  _state = _renderer.state,
  _frustum = new THREE.Frustum(),
  _projScreenMatrix = new THREE.Matrix4(),

  _min = new THREE.Vector3(),
  _max = new THREE.Vector3(),

  _matrixPosition = new THREE.Vector3(),

  _renderList = [];

  // init

  var depthShader = THREE.ShaderLib[ "depthRGBA" ];
  var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

  var _depthMaterial = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader
   } );

  var _depthMaterialMorph = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true
  } );

  var _depthMaterialSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    skinning: true
  } );

  var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true,
    skinning: true
  } );

  _depthMaterial._shadowPass = true;
  _depthMaterialMorph._shadowPass = true;
  _depthMaterialSkin._shadowPass = true;
  _depthMaterialMorphSkin._shadowPass = true;

  //

  var scope = this;

  this.enabled = false;

  this.autoUpdate = true;
  this.needsUpdate = false;

  this.type = THREE.PCFShadowMap;
  this.cullFace = THREE.CullFaceFront;

  this.render = function ( scene, camera ) {

    if ( scope.enabled === false ) return;
    if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    // set GL state for depth map

    _gl.clearColor( 1, 1, 1, 1 );
    _state.disable( _gl.BLEND );

    _state.enable( _gl.CULL_FACE );
    _gl.frontFace( _gl.CCW );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.FRONT );

    } else {

      _gl.cullFace( _gl.BACK );

    }

    _state.setDepthTest( true );

    // render depth map

    for ( var i = 0, il = _lights.length; i < il; i ++ ) {

      var light = _lights[ i ];

      if ( ! light.castShadow ) continue;

      if ( ! light.shadowMap ) {

        var shadowFilter = THREE.LinearFilter;

        if ( scope.type === THREE.PCFSoftShadowMap ) {

          shadowFilter = THREE.NearestFilter;

        }

        var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

        light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
        light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

        light.shadowMatrix = new THREE.Matrix4();

      }

      if ( ! light.shadowCamera ) {

        if ( light instanceof THREE.SpotLight ) {

          light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

        } else if ( light instanceof THREE.DirectionalLight ) {

          light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

        } else {

          console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
          continue;

        }

        scene.add( light.shadowCamera );

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

      }

      if ( light.shadowCameraVisible && ! light.cameraHelper ) {

        light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
        scene.add( light.cameraHelper );

      }

      var shadowMap = light.shadowMap;
      var shadowMatrix = light.shadowMatrix;
      var shadowCamera = light.shadowCamera;

      //

      shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
      _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
      shadowCamera.lookAt( _matrixPosition );
      shadowCamera.updateMatrixWorld();

      shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

      //

      if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
      if ( light.shadowCameraVisible ) light.cameraHelper.update();

      // compute shadow matrix

      shadowMatrix.set(
        0.5, 0.0, 0.0, 0.5,
        0.0, 0.5, 0.0, 0.5,
        0.0, 0.0, 0.5, 0.5,
        0.0, 0.0, 0.0, 1.0
      );

      shadowMatrix.multiply( shadowCamera.projectionMatrix );
      shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

      // update camera matrices and frustum

      _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );

      // render shadow map

      _renderer.setRenderTarget( shadowMap );
      _renderer.clear();

      // set object matrices & frustum culling

      _renderList.length = 0;

      projectObject( scene, shadowCamera );


      // render regular objects

      for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

        var object = _renderList[ j ];
        var geometry = _objects.update( object );
        var material = object.material;

        if ( material instanceof THREE.MeshFaceMaterial ) {

          var groups = geometry.groups;
          var materials = material.materials;

          for ( var j = 0, jl = groups.length; j < jl; j ++ ) {

            var group = groups[ j ];
            var groupMaterial = materials[ group.materialIndex ];

            if ( groupMaterial !== undefined ) {

              _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );

            }

          }

        } else {

          _renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );

        }

      }

    }

    // restore GL state

    var clearColor = _renderer.getClearColor(),
    clearAlpha = _renderer.getClearAlpha();

    _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
    _state.enable( _gl.BLEND );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.resetGLState();

    scope.needsUpdate = false;

  };

  function getDepthMaterial( object, material ) {

    var geometry = object.geometry;

    var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
    var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

    var depthMaterial;

    if ( object.customDepthMaterial ) {

      depthMaterial = object.customDepthMaterial;

    } else if ( useSkinning ) {

      depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

    } else if ( useMorphing ) {

      depthMaterial = _depthMaterialMorph;

    } else {

      depthMaterial = _depthMaterial;

    }

    depthMaterial.visible = material.visible;
    depthMaterial.wireframe = material.wireframe;
    depthMaterial.wireframeLinewidth = material.wireframeLinewidth;

    return depthMaterial;

  }

  function projectObject( object, camera ) {

    if ( object.visible === false ) return;

    if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

      if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

        var material = object.material;

        if ( material.visible === true ) {

          object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
          _renderList.push( object );

        }

      }

    }

    var children = object.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      projectObject( children[ i ], camera );

    }

  }

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

  var _this = this;

  var newAttributes = new Uint8Array( 16 );
  var enabledAttributes = new Uint8Array( 16 );

  var capabilities = {};

  var compressedTextureFormats = null;

  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;

  var currentDepthFunc = null;
  var currentDepthWrite = null;

  var currentColorWrite = null;

  var currentFlipSided = null;

  var currentLineWidth = null;

  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;

  var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

  var currentTextureSlot = undefined;
  var currentBoundTextures = {};

  this.init = function () {

    gl.clearColor( 0, 0, 0, 1 );
    gl.clearDepth( 1 );
    gl.clearStencil( 0 );

    this.enable( gl.DEPTH_TEST );
    gl.depthFunc( gl.LEQUAL );

    gl.frontFace( gl.CCW );
    gl.cullFace( gl.BACK );
    this.enable( gl.CULL_FACE );

    this.enable( gl.BLEND );
    gl.blendEquation( gl.FUNC_ADD );
    gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

  };

  this.initAttributes = function () {

    for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

      newAttributes[ i ] = 0;

    }

  };

  this.enableAttribute = function ( attribute ) {

    newAttributes[ attribute ] = 1;

    if ( enabledAttributes[ attribute ] === 0 ) {

      gl.enableVertexAttribArray( attribute );
      enabledAttributes[ attribute ] = 1;

    }

  };

  this.disableUnusedAttributes = function () {

    for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

      if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

  };

  this.enable = function ( id ) {

    if ( capabilities[ id ] !== true ) {

      gl.enable( id );
      capabilities[ id ] = true;

    }

  };

  this.disable = function ( id ) {

    if ( capabilities[ id ] !== false ) {

      gl.disable( id );
      capabilities[ id ] = false;

    }

  };

  this.getCompressedTextureFormats = function () {

    if ( compressedTextureFormats === null ) {

      compressedTextureFormats = [];

      if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
           extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

        var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

        for ( var i = 0; i < formats.length; i ++ ) {

          compressedTextureFormats.push( formats[ i ] );

        }

      }

    }

    return compressedTextureFormats;

  };

  this.getMaxPrecision = function ( precision ) {

    if ( precision === 'highp' ) {

      if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
           gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

        return 'highp';

      }

      precision = 'mediump';

    }

    if ( precision === 'mediump' ) {

      if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
           gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

        return 'mediump';

      }

    }

    return 'lowp';

  };

  this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

    if ( blending !== currentBlending ) {

      if ( blending === THREE.NoBlending ) {

        this.disable( gl.BLEND );

      } else if ( blending === THREE.AdditiveBlending ) {

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

      } else if ( blending === THREE.SubtractiveBlending ) {

        // TODO: Find blendFuncSeparate() combination

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

      } else if ( blending === THREE.MultiplyBlending ) {

        // TODO: Find blendFuncSeparate() combination

        this.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

      } else if ( blending === THREE.CustomBlending ) {

        this.enable( gl.BLEND );

      } else {

        this.enable( gl.BLEND );
        gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
        gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

      }

      currentBlending = blending;

    }

    if ( blending === THREE.CustomBlending ) {

      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;

      if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

        gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;

      }

      if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

        gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;

      }

    } else {

      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;

    }

  };

  this.setDepthFunc = function ( depthFunc ) {

    if ( currentDepthFunc !== depthFunc ) {

      if ( depthFunc ) {

        switch ( depthFunc ) {

          case THREE.NeverDepth:

            gl.depthFunc( gl.NEVER );
            break;

          case THREE.AlwaysDepth:

            gl.depthFunc( gl.ALWAYS );
            break;

          case THREE.LessDepth:

            gl.depthFunc( gl.LESS );
            break;

          case THREE.LessEqualDepth:

            gl.depthFunc( gl.LEQUAL );
            break;

          case THREE.EqualDepth:

            gl.depthFunc( gl.EQUAL );
            break;

          case THREE.GreaterEqualDepth:

            gl.depthFunc( gl.GEQUAL );
            break;

          case THREE.GreaterDepth:

            gl.depthFunc( gl.GREATER );
            break;

          case THREE.NotEqualDepth:

            gl.depthFunc( gl.NOTEQUAL );
            break;

          default:

            gl.depthFunc( gl.LEQUAL );

        }

      } else {

        gl.depthFunc( gl.LEQUAL );

      }

      currentDepthFunc = depthFunc;

    }

  };

  this.setDepthTest = function ( depthTest ) {

    if ( depthTest ) {

      this.enable( gl.DEPTH_TEST );

    } else {

      this.disable( gl.DEPTH_TEST );

    }

  };

  this.setDepthWrite = function ( depthWrite ) {

    if ( currentDepthWrite !== depthWrite ) {

      gl.depthMask( depthWrite );
      currentDepthWrite = depthWrite;

    }

  };

  this.setColorWrite = function ( colorWrite ) {

    if ( currentColorWrite !== colorWrite ) {

      gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
      currentColorWrite = colorWrite;

    }

  };

  this.setFlipSided = function ( flipSided ) {

    if ( currentFlipSided !== flipSided ) {

      if ( flipSided ) {

        gl.frontFace( gl.CW );

      } else {

        gl.frontFace( gl.CCW );

      }

      currentFlipSided = flipSided;

    }

  };

  this.setLineWidth = function ( width ) {

    if ( width !== currentLineWidth ) {

      gl.lineWidth( width );

      currentLineWidth = width;

    }

  };

  this.setPolygonOffset = function ( polygonOffset, factor, units ) {

    if ( polygonOffset ) {

      this.enable( gl.POLYGON_OFFSET_FILL );

    } else {

      this.disable( gl.POLYGON_OFFSET_FILL );

    }

    if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

      gl.polygonOffset( factor, units );

      currentPolygonOffsetFactor = factor;
      currentPolygonOffsetUnits = units;

    }

  };

  this.setScissorTest = function ( scissorTest ) {

    if ( scissorTest ) {

      this.enable( gl.SCISSOR_TEST );

    } else {

      this.disable( gl.SCISSOR_TEST );

    }

  };

  // texture

  this.activeTexture = function ( webglSlot ) {

    if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    if ( currentTextureSlot !== webglSlot ) {

      gl.activeTexture( webglSlot );
      currentTextureSlot = webglSlot;

    }

  }

  this.bindTexture = function ( webglType, webglTexture ) {

    if ( currentTextureSlot === undefined ) {

      _this.activeTexture();

    }

    var boundTexture = currentBoundTextures[ currentTextureSlot ];

    if ( boundTexture === undefined ) {

      boundTexture = { type: undefined, texture: undefined };
      currentBoundTextures[ currentTextureSlot ] = boundTexture;

    }

    if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

      gl.bindTexture( webglType, webglTexture );

      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;

    }

  };

  this.compressedTexImage2D = function () {

    try {

      gl.compressedTexImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  this.texImage2D = function () {

    try {

      gl.texImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  //

  this.reset = function () {

    for ( var i = 0; i < enabledAttributes.length; i ++ ) {

      if ( enabledAttributes[ i ] === 1 ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

    capabilities = {};

    compressedTextureFormats = null;

    currentBlending = null;

    currentDepthWrite = null;
    currentColorWrite = null;

    currentFlipSided = null;

  };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

  var gl = renderer.context;
  var state = renderer.state;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var hasVertexTexture;

  var tempTexture, occlusionTexture;

  var init = function () {

    var vertices = new Float32Array( [
      - 1, - 1,  0, 0,
       1, - 1,  1, 0,
       1,  1,  1, 1,
      - 1,  1,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    // buffers

    vertexBuffer     = gl.createBuffer();
    elementBuffer    = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    // textures

    tempTexture      = gl.createTexture();
    occlusionTexture = gl.createTexture();

    state.bindTexture( gl.TEXTURE_2D, tempTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

    var shader;

    if ( hasVertexTexture ) {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "uniform sampler2D occlusionMap;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

              "vVisibility =        visibility.r / 9.0;",
              "vVisibility *= 1.0 - visibility.g / 9.0;",
              "vVisibility *=       visibility.b / 9.0;",
              "vVisibility *= 1.0 - visibility.a / 9.0;",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * vVisibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    } else {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "precision mediump float;",

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform sampler2D occlusionMap;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
              "visibility = ( 1.0 - visibility / 4.0 );",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * visibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    }

    program = createProgram( shader );

    attributes = {
      vertex: gl.getAttribLocation ( program, "position" ),
      uv:     gl.getAttribLocation ( program, "uv" )
    };

    uniforms = {
      renderType:     gl.getUniformLocation( program, "renderType" ),
      map:            gl.getUniformLocation( program, "map" ),
      occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
      opacity:        gl.getUniformLocation( program, "opacity" ),
      color:          gl.getUniformLocation( program, "color" ),
      scale:          gl.getUniformLocation( program, "scale" ),
      rotation:       gl.getUniformLocation( program, "rotation" ),
      screenPosition: gl.getUniformLocation( program, "screenPosition" )
    };

  };

  /*
   * Render lens flares
   * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
   *         reads these back and calculates occlusion.
   */

  this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

    if ( flares.length === 0 ) return;

    var tempPosition = new THREE.Vector3();

    var invAspect = viewportHeight / viewportWidth,
      halfViewportWidth = viewportWidth * 0.5,
      halfViewportHeight = viewportHeight * 0.5;

    var size = 16 / viewportHeight,
      scale = new THREE.Vector2( size * invAspect, size );

    var screenPosition = new THREE.Vector3( 1, 1, 0 ),
      screenPositionPixels = new THREE.Vector2( 1, 1 );

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    state.initAttributes();
    state.enableAttribute( attributes.vertex );
    state.enableAttribute( attributes.uv );
    state.disableUnusedAttributes();

    // loop through all lens flares to update their occlusion and positions
    // setup gl and common used attribs/uniforms

    gl.uniform1i( uniforms.occlusionMap, 0 );
    gl.uniform1i( uniforms.map, 1 );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    state.disable( gl.CULL_FACE );
    gl.depthMask( false );

    for ( var i = 0, l = flares.length; i < l; i ++ ) {

      size = 16 / viewportHeight;
      scale.set( size * invAspect, size );

      // calc object screen position

      var flare = flares[ i ];

      tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

      tempPosition.applyMatrix4( camera.matrixWorldInverse );
      tempPosition.applyProjection( camera.projectionMatrix );

      // setup arrays for gl programs

      screenPosition.copy( tempPosition );

      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

      // screen cull

      if ( hasVertexTexture || (
        screenPositionPixels.x > 0 &&
        screenPositionPixels.x < viewportWidth &&
        screenPositionPixels.y > 0 &&
        screenPositionPixels.y < viewportHeight ) ) {

        // save current RGB to temp texture

        state.activeTexture( gl.TEXTURE0 );
        state.bindTexture( gl.TEXTURE_2D, null );
        state.activeTexture( gl.TEXTURE1 );
        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // render pink quad

        gl.uniform1i( uniforms.renderType, 0 );
        gl.uniform2f( uniforms.scale, scale.x, scale.y );
        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

        state.disable( gl.BLEND );
        state.enable( gl.DEPTH_TEST );

        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // copy result to occlusionMap

        state.activeTexture( gl.TEXTURE0 );
        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // restore graphics

        gl.uniform1i( uniforms.renderType, 1 );
        state.disable( gl.DEPTH_TEST );

        state.activeTexture( gl.TEXTURE1 );
        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // update object positions

        flare.positionScreen.copy( screenPosition );

        if ( flare.customUpdateCallback ) {

          flare.customUpdateCallback( flare );

        } else {

          flare.updateLensFlares();

        }

        // render flares

        gl.uniform1i( uniforms.renderType, 2 );
        state.enable( gl.BLEND );

        for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

          var sprite = flare.lensFlares[ j ];

          if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;

            size = sprite.size * sprite.scale / viewportHeight;

            scale.x = size * invAspect;
            scale.y = size;

            gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
            gl.uniform2f( uniforms.scale, scale.x, scale.y );
            gl.uniform1f( uniforms.rotation, sprite.rotation );

            gl.uniform1f( uniforms.opacity, sprite.opacity );
            gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

            state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
            renderer.setTexture( sprite.texture, 1 );

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

          }

        }

      }

    }

    // restore gl

    state.enable( gl.CULL_FACE );
    state.enable( gl.DEPTH_TEST );
    gl.depthMask( true );

    renderer.resetGLState();

  };

  function createProgram ( shader ) {

    var program = gl.createProgram();

    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    var prefix = "precision " + renderer.getPrecision() + " float;\n";

    gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    gl.compileShader( fragmentShader );
    gl.compileShader( vertexShader );

    gl.attachShader( program, fragmentShader );
    gl.attachShader( program, vertexShader );

    gl.linkProgram( program );

    return program;

  }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

  var gl = renderer.context;
  var state = renderer.state;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;

  var texture;

  // decompose matrixWorld

  var spritePosition = new THREE.Vector3();
  var spriteRotation = new THREE.Quaternion();
  var spriteScale = new THREE.Vector3();

  var init = function () {

    var vertices = new Float32Array( [
      - 0.5, - 0.5,  0, 0,
        0.5, - 0.5,  1, 0,
        0.5,   0.5,  1, 1,
      - 0.5,   0.5,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    vertexBuffer  = gl.createBuffer();
    elementBuffer = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    program = createProgram();

    attributes = {
      position:     gl.getAttribLocation ( program, 'position' ),
      uv:         gl.getAttribLocation ( program, 'uv' )
    };

    uniforms = {
      uvOffset:     gl.getUniformLocation( program, 'uvOffset' ),
      uvScale:      gl.getUniformLocation( program, 'uvScale' ),

      rotation:     gl.getUniformLocation( program, 'rotation' ),
      scale:        gl.getUniformLocation( program, 'scale' ),

      color:        gl.getUniformLocation( program, 'color' ),
      map:        gl.getUniformLocation( program, 'map' ),
      opacity:      gl.getUniformLocation( program, 'opacity' ),

      modelViewMatrix:  gl.getUniformLocation( program, 'modelViewMatrix' ),
      projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

      fogType:      gl.getUniformLocation( program, 'fogType' ),
      fogDensity:     gl.getUniformLocation( program, 'fogDensity' ),
      fogNear:      gl.getUniformLocation( program, 'fogNear' ),
      fogFar:       gl.getUniformLocation( program, 'fogFar' ),
      fogColor:     gl.getUniformLocation( program, 'fogColor' ),

      alphaTest:      gl.getUniformLocation( program, 'alphaTest' )
    };

    var canvas = document.createElement( 'canvas' );
    canvas.width = 8;
    canvas.height = 8;

    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 0, 8, 8 );

    texture = new THREE.Texture( canvas );
    texture.needsUpdate = true;

  };

  this.render = function ( scene, camera ) {

    if ( sprites.length === 0 ) return;

    // setup gl

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    state.initAttributes();
    state.enableAttribute( attributes.position );
    state.enableAttribute( attributes.uv );
    state.disableUnusedAttributes();

    state.disable( gl.CULL_FACE );
    state.enable( gl.BLEND );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    state.activeTexture( gl.TEXTURE0 );
    gl.uniform1i( uniforms.map, 0 );

    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;

    if ( fog ) {

      gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

      if ( fog instanceof THREE.Fog ) {

        gl.uniform1f( uniforms.fogNear, fog.near );
        gl.uniform1f( uniforms.fogFar, fog.far );

        gl.uniform1i( uniforms.fogType, 1 );
        oldFogType = 1;
        sceneFogType = 1;

      } else if ( fog instanceof THREE.FogExp2 ) {

        gl.uniform1f( uniforms.fogDensity, fog.density );

        gl.uniform1i( uniforms.fogType, 2 );
        oldFogType = 2;
        sceneFogType = 2;

      }

    } else {

      gl.uniform1i( uniforms.fogType, 0 );
      oldFogType = 0;
      sceneFogType = 0;

    }


    // update positions and sort

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];

      sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
      sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

    }

    sprites.sort( painterSortStable );

    // render all sprites

    var scale = [];

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];
      var material = sprite.material;

      gl.uniform1f( uniforms.alphaTest, material.alphaTest );
      gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

      sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

      scale[ 0 ] = spriteScale.x;
      scale[ 1 ] = spriteScale.y;

      var fogType = 0;

      if ( scene.fog && material.fog ) {

        fogType = sceneFogType;

      }

      if ( oldFogType !== fogType ) {

        gl.uniform1i( uniforms.fogType, fogType );
        oldFogType = fogType;

      }

      if ( material.map !== null ) {

        gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
        gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

      } else {

        gl.uniform2f( uniforms.uvOffset, 0, 0 );
        gl.uniform2f( uniforms.uvScale, 1, 1 );

      }

      gl.uniform1f( uniforms.opacity, material.opacity );
      gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

      gl.uniform1f( uniforms.rotation, material.rotation );
      gl.uniform2fv( uniforms.scale, scale );

      state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
      state.setDepthTest( material.depthTest );
      state.setDepthWrite( material.depthWrite );

      if ( material.map && material.map.image && material.map.image.width ) {

        renderer.setTexture( material.map, 0 );

      } else {

        renderer.setTexture( texture, 0 );

      }

      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    }

    // restore gl

    state.enable( gl.CULL_FACE );

    renderer.resetGLState();

  };

  function createProgram () {

    var program = gl.createProgram();

    var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    gl.shaderSource( vertexShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',

      'attribute vec2 position;',
      'attribute vec2 uv;',

      'varying vec2 vUV;',

      'void main() {',

        'vUV = uvOffset + uv * uvScale;',

        'vec2 alignedPosition = position * scale;',

        'vec2 rotatedPosition;',
        'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

        'vec4 finalPosition;',

        'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        'finalPosition.xy += rotatedPosition;',
        'finalPosition = projectionMatrix * finalPosition;',

        'gl_Position = finalPosition;',

      '}'

    ].join( '\n' ) );

    gl.shaderSource( fragmentShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',

      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',

      'varying vec2 vUV;',

      'void main() {',

        'vec4 texture = texture2D( map, vUV );',

        'if ( texture.a < alphaTest ) discard;',

        'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

        'if ( fogType > 0 ) {',

          'float depth = gl_FragCoord.z / gl_FragCoord.w;',
          'float fogFactor = 0.0;',

          'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

          '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

          '}',

          'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

        '}',

      '}'

    ].join( '\n' ) );

    gl.compileShader( vertexShader );
    gl.compileShader( fragmentShader );

    gl.attachShader( program, vertexShader );
    gl.attachShader( program, fragmentShader );

    gl.linkProgram( program );

    return program;

  }

  function painterSortStable ( a, b ) {

    if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return b.id - a.id;

    }

  }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

  merge: function ( geometry1, geometry2, materialIndexOffset ) {

    console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    var matrix;

    if ( geometry2 instanceof THREE.Mesh ) {

      geometry2.matrixAutoUpdate && geometry2.updateMatrix();

      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;

    }

    geometry1.merge( geometry2, matrix, materialIndexOffset );

  },

  center: function ( geometry ) {

    console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    return geometry.center();

  }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

  crossOrigin: undefined,

  loadTexture: function ( url, mapping, onLoad, onError ) {

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.Texture( undefined, mapping );

    loader.load( url, function ( image ) {

      texture.image = image;
      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture );

    }, undefined, function ( event ) {

      if ( onError ) onError( event );

    } );

    texture.sourceFile = url;

    return texture;

  },

  loadTextureCube: function ( array, mapping, onLoad, onError ) {

    var images = [];

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.CubeTexture( images, mapping );

    var loaded = 0;

    var loadTexture = function ( i ) {

      loader.load( array[ i ], function ( image ) {

        texture.images[ i ] = image;

        loaded += 1;

        if ( loaded === 6 ) {

          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }

      }, undefined, onError );

    };

    for ( var i = 0, il = array.length; i < il; ++ i ) {

      loadTexture( i );

    }

    return texture;

  },

  loadCompressedTexture: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

  },

  loadCompressedTextureCube: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

  },

  getNormalMap: function ( image, depth ) {

    // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

    var cross = function ( a, b ) {

      return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

    };

    var subtract = function ( a, b ) {

      return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

    };

    var normalize = function ( a ) {

      var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
      return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

    };

    depth = depth | 1;

    var width = image.width;
    var height = image.height;

    var canvas = document.createElement( 'canvas' );
    canvas.width = width;
    canvas.height = height;

    var context = canvas.getContext( '2d' );
    context.drawImage( image, 0, 0 );

    var data = context.getImageData( 0, 0, width, height ).data;
    var imageData = context.createImageData( width, height );
    var output = imageData.data;

    for ( var x = 0; x < width; x ++ ) {

      for ( var y = 0; y < height; y ++ ) {

        var ly = y - 1 < 0 ? 0 : y - 1;
        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
        var lx = x - 1 < 0 ? 0 : x - 1;
        var ux = x + 1 > width - 1 ? width - 1 : x + 1;

        var points = [];
        var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
        points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

        var normals = [];
        var num_points = points.length;

        for ( var i = 0; i < num_points; i ++ ) {

          var v1 = points[ i ];
          var v2 = points[ ( i + 1 ) % num_points ];
          v1 = subtract( v1, origin );
          v2 = subtract( v2, origin );
          normals.push( normalize( cross( v1, v2 ) ) );

        }

        var normal = [ 0, 0, 0 ];

        for ( var i = 0; i < normals.length; i ++ ) {

          normal[ 0 ] += normals[ i ][ 0 ];
          normal[ 1 ] += normals[ i ][ 1 ];
          normal[ 2 ] += normals[ i ][ 2 ];

        }

        normal[ 0 ] /= normals.length;
        normal[ 1 ] /= normals.length;
        normal[ 2 ] /= normals.length;

        var idx = ( y * width + x ) * 4;

        output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
        output[ idx + 3 ] = 255;

      }

    }

    context.putImageData( imageData, 0, 0 );

    return canvas;

  },

  generateDataTexture: function ( width, height, color ) {

    var size = width * height;
    var data = new Uint8Array( 3 * size );

    var r = Math.floor( color.r * 255 );
    var g = Math.floor( color.g * 255 );
    var b = Math.floor( color.b * 255 );

    for ( var i = 0; i < size; i ++ ) {

      data[ i * 3 ]      = r;
      data[ i * 3 + 1 ] = g;
      data[ i * 3 + 2 ] = b;

    }

    var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
    texture.needsUpdate = true;

    return texture;

  }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

  createMultiMaterialObject: function ( geometry, materials ) {

    var group = new THREE.Object3D();

    for ( var i = 0, l = materials.length; i < l; i ++ ) {

      group.add( new THREE.Mesh( geometry, materials[ i ] ) );

    }

    return group;

  },

  detach: function ( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  },

  attach: function ( child, scene, parent ) {

    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse( parent.matrixWorld );
    child.applyMatrix( matrixWorldInverse );

    scene.remove( child );
    parent.add( child );

  }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *  Triangulation ported from AS3
 *    Simple Polygon Triangulation
 *    http://actionsnippet.com/?p=1462
 *
 *  A Method to triangulate shapes with holes
 *    http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

  faces: {},

  // Just for now. face[weight][style]

  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,

  getFace: function () {

    try {

      return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

    } catch ( e ) {

      throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

    }

  },

  loadFace: function ( data ) {

    var family = data.familyName.toLowerCase();

    var ThreeFont = this;

    ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

    ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    return data;

  },

  drawText: function ( text ) {

    // RenderText

    var i,
      face = this.getFace(),
      scale = this.size / face.resolution,
      offset = 0,
      chars = String( text ).split( '' ),
      length = chars.length;

    var fontPaths = [];

    for ( i = 0; i < length; i ++ ) {

      var path = new THREE.Path();

      var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
      offset += ret.offset;

      fontPaths.push( ret.path );

    }

    // get the width

    var width = offset / 2;
    //
    // for ( p = 0; p < allPts.length; p++ ) {
    //
    //  allPts[ p ].x -= width;
    //
    // }

    //var extract = this.extractPoints( allPts, characterPts );
    //extract.contour = allPts;

    //extract.paths = fontPaths;
    //extract.offset = width;

    return { paths: fontPaths, offset: width };

  },




  extractGlyphPoints: function ( c, face, scale, offset, path ) {

    var pts = [];

    var i, i2, divisions,
      outline, action, length,
      scaleX, scaleY,
      x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
      laste,
      glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

    if ( ! glyph ) return;

    if ( glyph.o ) {

      outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
      length = outline.length;

      scaleX = scale;
      scaleY = scale;

      for ( i = 0; i < length; ) {

        action = outline[ i ++ ];

        //console.log( action );

        switch ( action ) {

        case 'm':

          // Move To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;

          path.moveTo( x, y );
          break;

        case 'l':

          // Line To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;
          path.lineTo( x, y );
          break;

        case 'q':

          // QuadraticCurveTo

          cpx  = outline[ i ++ ] * scaleX + offset;
          cpy  = outline[ i ++ ] * scaleY;
          cpx1 = outline[ i ++ ] * scaleX + offset;
          cpy1 = outline[ i ++ ] * scaleY;

          path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
              THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

            }

          }

          break;

        case 'b':

          // Cubic Bezier Curve

          cpx  = outline[ i ++ ] *  scaleX + offset;
          cpy  = outline[ i ++ ] *  scaleY;
          cpx1 = outline[ i ++ ] *  scaleX + offset;
          cpy1 = outline[ i ++ ] *  scaleY;
          cpx2 = outline[ i ++ ] *  scaleX + offset;
          cpy2 = outline[ i ++ ] *  scaleY;

          path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
              THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

            }

          }

          break;

        }

      }

    }



    return { offset: glyph.ha * scale, path: path };

  }

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

  // Parameters

  parameters = parameters || {};

  var size = parameters.size !== undefined ? parameters.size : 100;
  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
  var style = parameters.style !== undefined ? parameters.style : 'normal';

  THREE.FontUtils.size = size;
  THREE.FontUtils.divisions = curveSegments;

  THREE.FontUtils.face = font;
  THREE.FontUtils.weight = weight;
  THREE.FontUtils.style = style;

  // Get a Font data json object

  var data = THREE.FontUtils.drawText( text );

  var paths = data.paths;
  var shapes = [];

  for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  }

  return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

  var EPSILON = 0.0000000001;

  // takes in an contour array and returns

  var process = function ( contour, indices ) {

    var n = contour.length;

    if ( n < 3 ) return null;

    var result = [],
      verts = [],
      vertIndices = [];

    /* we want a counter-clockwise polygon in verts */

    var u, v, w;

    if ( area( contour ) > 0.0 ) {

      for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    } else {

      for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    }

    var nv = n;

    /*  remove nv - 2 vertices, creating 1 triangle every time */

    var count = 2 * nv;   /* error detection */

    for ( v = nv - 1; nv > 2; ) {

      /* if we loop, it is probably a non-simple polygon */

      if ( ( count -- ) <= 0 ) {

        //** Triangulate: ERROR - probable bad polygon!

        //throw ( "Warning, unable to triangulate polygon!" );
        //return null;
        // Sometimes warning is fine, especially polygons are triangulated in reverse.
        console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

        if ( indices ) return vertIndices;
        return result;

      }

      /* three consecutive vertices in current polygon, <u,v,w> */

      u = v;    if ( nv <= u ) u = 0;     /* previous */
      v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
      w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

      if ( snip( contour, u, v, w, nv, verts ) ) {

        var a, b, c, s, t;

        /* true names of the vertices */

        a = verts[ u ];
        b = verts[ v ];
        c = verts[ w ];

        /* output Triangle */

        result.push( [ contour[ a ],
          contour[ b ],
          contour[ c ] ] );


        vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

        /* remove v from the remaining polygon */

        for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

          verts[ s ] = verts[ t ];

        }

        nv --;

        /* reset error detection counter */

        count = 2 * nv;

      }

    }

    if ( indices ) return vertIndices;
    return result;

  };

  // calculate area of the contour polygon

  var area = function ( contour ) {

    var n = contour.length;
    var a = 0.0;

    for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

      a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    }

    return a * 0.5;

  };

  var snip = function ( contour, u, v, w, n, verts ) {

    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;

    ax = contour[ verts[ u ] ].x;
    ay = contour[ verts[ u ] ].y;

    bx = contour[ verts[ v ] ].x;
    by = contour[ verts[ v ] ].y;

    cx = contour[ verts[ w ] ].x;
    cy = contour[ verts[ w ] ].y;

    if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;

    aX = cx - bx;  aY = cy - by;
    bX = ax - cx;  bY = ay - cy;
    cX = bx - ax;  cY = by - ay;

    for ( p = 0; p < n; p ++ ) {

      px = contour[ verts[ p ] ].x;
      py = contour[ verts[ p ] ].y;

      if ( ( ( px === ax ) && ( py === ay ) ) ||
         ( ( px === bx ) && ( py === by ) ) ||
         ( ( px === cx ) && ( py === cy ) ) ) continue;

      apx = px - ax;  apy = py - ay;
      bpx = px - bx;  bpy = py - by;
      cpx = px - cx;  cpy = py - cy;

      // see if p is inside triangle abc

      aCROSSbp = aX * bpy - aY * bpx;
      cCROSSap = cX * apy - cY * apx;
      bCROSScp = bX * cpy - bY * cpx;

      if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

    }

    return true;

  };


  namespace.Triangulate = process;
  namespace.Triangulate.area = area;

  return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API

THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

  THREE.Object3D.call( this );

  this.type = 'Audio';

  this.context = listener.context;
  this.source = this.context.createBufferSource();
  this.source.onended = this.onEnded.bind( this );

  this.gain = this.context.createGain();
  this.gain.connect( this.context.destination );

  this.panner = this.context.createPanner();
  this.panner.connect( this.gain );

  this.autoplay = false;

  this.startTime = 0;
  this.playbackRate = 1;
  this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

  var scope = this;

  var request = new XMLHttpRequest();
  request.open( 'GET', file, true );
  request.responseType = 'arraybuffer';
  request.onload = function ( e ) {

    scope.context.decodeAudioData( this.response, function ( buffer ) {

      scope.source.buffer = buffer;

      if ( scope.autoplay ) scope.play();

    } );

  };
  request.send();

  return this;

};

THREE.Audio.prototype.play = function () {

  if ( this.isPlaying === true ) {

    console.warn( 'THREE.Audio: Audio is already playing.' );
    return;

  }

  var source = this.context.createBufferSource();

  source.buffer = this.source.buffer;
  source.loop = this.source.loop;
  source.onended = this.source.onended;
  source.start( 0, this.startTime );
  source.playbackRate.value = this.playbackRate;

  this.isPlaying = true;

  this.source = source;

  this.connect();

};

THREE.Audio.prototype.pause = function () {

  this.source.stop();
  this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

  this.source.stop();
  this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

  if ( this.filter !== undefined ) {

    this.source.connect( this.filter );
    this.filter.connect( this.panner );

  } else {

    this.source.connect( this.panner );

  }

};

THREE.Audio.prototype.disconnect = function () {

  if ( this.filter !== undefined ) {

    this.source.disconnect( this.filter );
    this.filter.disconnect( this.panner );

  } else {

    this.source.disconnect( this.panner );

  }

};

THREE.Audio.prototype.setFilter = function ( value ) {

  if ( this.isPlaying === true ) {

    this.disconnect();
    this.filter = value;
    this.connect();

  } else {

    this.filter = value;

  }

};

THREE.Audio.prototype.getFilter = function () {

  return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

  this.playbackRate = value;

  if ( this.isPlaying === true ) {

    this.source.playbackRate.value = this.playbackRate;

  }

};

THREE.Audio.prototype.getPlaybackRate = function () {

  return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

  this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

  this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

  return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

  this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function () {

  return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

  this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function () {

  return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function ( value ) {

  this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

  return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();

  return function updateMatrixWorld( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    position.setFromMatrixPosition( this.matrixWorld );

    this.panner.setPosition( position.x, position.y, position.z );

  };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

  THREE.Object3D.call( this );

  this.type = 'AudioListener';

  this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3();

  var orientation = new THREE.Vector3();

  return function updateMatrixWorld( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    var listener = this.context.listener;
    var up = this.up;

    this.matrixWorld.decompose( position, quaternion, scale );

    orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    listener.setPosition( position.x, position.y, position.z );
    listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *  Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//  - t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

  console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
  return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPoint( d / divisions ) );

  }

  return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPointAt( d / divisions ) );

  }

  return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

  var lengths = this.getLengths();
  return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

  if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

  if ( this.cacheArcLengths
    && ( this.cacheArcLengths.length === divisions + 1 )
    && ! this.needsUpdate ) {

    //console.log( "cached", this.cacheArcLengths );
    return this.cacheArcLengths;

  }

  this.needsUpdate = false;

  var cache = [];
  var current, last = this.getPoint( 0 );
  var p, sum = 0;

  cache.push( 0 );

  for ( p = 1; p <= divisions; p ++ ) {

    current = this.getPoint ( p / divisions );
    sum += current.distanceTo( last );
    cache.push( sum );
    last = current;

  }

  this.cacheArcLengths = cache;

  return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {

  this.needsUpdate = true;
  this.getLengths();

};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

  var arcLengths = this.getLengths();

  var i = 0, il = arcLengths.length;

  var targetArcLength; // The targeted u distance value to get

  if ( distance ) {

    targetArcLength = distance;

  } else {

    targetArcLength = u * arcLengths[ il - 1 ];

  }

  //var time = Date.now();

  // binary search for the index with largest value smaller than target u distance

  var low = 0, high = il - 1, comparison;

  while ( low <= high ) {

    i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    comparison = arcLengths[ i ] - targetArcLength;

    if ( comparison < 0 ) {

      low = i + 1;

    } else if ( comparison > 0 ) {

      high = i - 1;

    } else {

      high = i;
      break;

      // DONE

    }

  }

  i = high;

  //console.log('b' , i, low, high, Date.now()- time);

  if ( arcLengths[ i ] === targetArcLength ) {

    var t = i / ( il - 1 );
    return t;

  }

  // we could get finer grain at lengths, or use simple interpolation between two points

  var lengthBefore = arcLengths[ i ];
  var lengthAfter = arcLengths[ i + 1 ];

  var segmentLength = lengthAfter - lengthBefore;

  // determine where we are between the 'before' and 'after' points

  var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  // add that fractional amount to t

  var t = ( i + segmentFraction ) / ( il - 1 );

  return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

  var delta = 0.0001;
  var t1 = t - delta;
  var t2 = t + delta;

  // Capping in case of danger

  if ( t1 < 0 ) t1 = 0;
  if ( t2 > 1 ) t2 = 1;

  var pt1 = this.getPoint( t1 );
  var pt2 = this.getPoint( t2 );

  var vec = pt2.clone().sub( pt1 );
  return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getTangent( t );

};





/**************************************************************
 *  Utils
 **************************************************************/

THREE.Curve.Utils = {

  tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

  },

  // Puay Bing, thanks for helping with this derivative!

  tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

    return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
      3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
      6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
      3 * t * t * p3;

  },

  tangentSpline: function ( t, p0, p1, p2, p3 ) {

    // To check if my formulas are correct

    var h00 = 6 * t * t - 6 * t;  // derived from 2t^3 − 3t^2 + 1
    var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
    var h01 = - 6 * t * t + 6 * t;  // − 2t3 + 3t2
    var h11 = 3 * t * t - 2 * t;  // t3 − t2

    return h00 + h10 + h01 + h11;

  },

  // Catmull-Rom

  interpolate: function( p0, p1, p2, p3, t ) {

    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};


// TODO: Transformation for Curves?

/**************************************************************
 *  3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

  constructor.prototype = Object.create( THREE.Curve.prototype );
  constructor.prototype.constructor = constructor;
  constructor.prototype.getPoint = getPointFunc;

  return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *  Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

  this.curves = [];
  this.bends = [];

  this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

  this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
  // TODO
  // If the ending of curve is not connected to the starting
  // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {

  // TODO Test
  // and verify for vector3 (needs to implement equals)
  // Add a line curve if start and end of lines are not connected
  var startPoint = this.curves[ 0 ].getPoint( 0 );
  var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  if ( ! startPoint.equals( endPoint ) ) {

    this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

  }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0, diff, curve;

  // To think about boundaries points.

  while ( i < curveLengths.length ) {

    if ( curveLengths[ i ] >= d ) {

      diff = curveLengths[ i ] - d;
      curve = this.curves[ i ];

      var u = 1 - diff / curve.getLength();

      return curve.getPointAt( u );

    }

    i ++;

  }

  return null;

  // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

  var lens = this.getCurveLengths();
  return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

  // We use cache values if curves and cache array are same length

  if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    return this.cacheLengths;

  }

  // Get length of sub-curve
  // Push sums into cached array

  var lengths = [], sums = 0;
  var i, il = this.curves.length;

  for ( i = 0; i < il; i ++ ) {

    sums += this.curves[ i ].getLength();
    lengths.push( sums );

  }

  this.cacheLengths = lengths;

  return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

  var points = this.getPoints();

  var maxX, maxY, maxZ;
  var minX, minY, minZ;

  maxX = maxY = Number.NEGATIVE_INFINITY;
  minX = minY = Number.POSITIVE_INFINITY;

  var p, i, il, sum;

  var v3 = points[ 0 ] instanceof THREE.Vector3;

  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

  for ( i = 0, il = points.length; i < il; i ++ ) {

    p = points[ i ];

    if ( p.x > maxX ) maxX = p.x;
    else if ( p.x < minX ) minX = p.x;

    if ( p.y > maxY ) maxY = p.y;
    else if ( p.y < minY ) minY = p.y;

    if ( v3 ) {

      if ( p.z > maxZ ) maxZ = p.z;
      else if ( p.z < minZ ) minZ = p.z;

    }

    sum.add( p );

  }

  var ret = {

    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY

  };

  if ( v3 ) {

    ret.maxZ = maxZ;
    ret.minZ = minZ;

  }

  return ret;

};

/**************************************************************
 *  Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

  var pts = this.getPoints( divisions, true );
  return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

  var pts = this.getSpacedPoints( divisions, true );
  return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < points.length; i ++ ) {

    geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );

  }

  return geometry;

};


/**************************************************************
 *  Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

  this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

  var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

  var oldPts = this.getSpacedPoints( segments );

  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

  var bounds = this.getBoundingBox();

  var i, il, p, oldX, oldY, xNorm;

  for ( i = 0, il = oldPts.length; i < il; i ++ ) {

    p = oldPts[ i ];

    oldX = p.x;
    oldY = p.y;

    xNorm = oldX / bounds.maxX;

    // If using actual distance, for length > path, requires line extrusions
    //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

    xNorm = path.getUtoTmapping( xNorm, oldX );

    // check for out of bounds?

    var pathPt = path.getPoint( xNorm );
    var normal = path.getTangent( xNorm );
    normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

    p.x = pathPt.x + normal.x;
    p.y = pathPt.y + normal.y;

  }

  return oldPts;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

  THREE.CurvePath.call( this );

  this.actions = [];

  if ( points ) {

    this.fromPoints( points );

  }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
  BEZIER_CURVE_TO: 'bezierCurveTo',     // Bezier cubic curve
  CSPLINE_THRU: 'splineThru',       // Catmull-Rom spline
  ARC: 'arc',               // Circle
  ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

  this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

    this.lineTo( vectors[ v ].x, vectors[ v ].y );

  }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );
  this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
                        new THREE.Vector2( aCPx, aCPy ),
                        new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
                         aCP2x, aCP2y,
                         aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
                      new THREE.Vector2( aCP1x, aCP1y ),
                      new THREE.Vector2( aCP2x, aCP2y ),
                      new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

  var args = Array.prototype.slice.call( arguments );
  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];
  //---
  var npts = [ new THREE.Vector2( x0, y0 ) ];
  Array.prototype.push.apply( npts, pts );

  var curve = new THREE.SplineCurve( npts );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absarc( aX + x0, aY + y0, aRadius,
    aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise, aRotation ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absellipse( aX + x0, aY + y0, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise, aRotation );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise, aRotation ) {

  var args = [
    aX, aY,
    xRadius, yRadius,
    aStartAngle, aEndAngle,
    aClockwise,
    aRotation || 0 // aRotation is optional.
  ];
  var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
                  aStartAngle, aEndAngle, aClockwise, aRotation );
  this.curves.push( curve );

  var lastPoint = curve.getPoint( 1 );
  args.push( lastPoint.x );
  args.push( lastPoint.y );

  this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

  if ( ! divisions ) divisions = 40;

  var points = [];

  for ( var i = 0; i < divisions; i ++ ) {

    points.push( this.getPoint( i / divisions ) );

    //if( !this.getPoint( i / divisions ) ) throw "DIE";

  }

  // if ( closedPath ) {
  //
  //  points.push( points[ 0 ] );
  //
  // }

  return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

  if ( this.useSpacedPoints ) {

    return this.getSpacedPoints( divisions, closedPath );

  }

  divisions = divisions || 12;

  var points = [];

  var i, il, item, action, args;
  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
    laste, j,
    t, tx, ty;

  for ( i = 0, il = this.actions.length; i < il; i ++ ) {

    item = this.actions[ i ];

    action = item.action;
    args = item.args;

    switch ( action ) {

    case THREE.PathActions.MOVE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.LINE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.QUADRATIC_CURVE_TO:

      cpx  = args[ 2 ];
      cpy  = args[ 3 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }

      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
        ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.BEZIER_CURVE_TO:

      cpx  = args[ 4 ];
      cpy  = args[ 5 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      cpx2 = args[ 2 ];
      cpy2 = args[ 3 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }


      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
        ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.CSPLINE_THRU:

      laste = this.actions[ i - 1 ].args;

      var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
      var spts = [ last ];

      var n = divisions * args[ 0 ].length;

      spts = spts.concat( args[ 0 ] );

      var spline = new THREE.SplineCurve( spts );

      for ( j = 1; j <= n; j ++ ) {

        points.push( spline.getPointAt( j / n ) );

      }

      break;

    case THREE.PathActions.ARC:

      var aX = args[ 0 ], aY = args[ 1 ],
        aRadius = args[ 2 ],
        aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
        aClockwise = !! args[ 5 ];

      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + aRadius * Math.cos( angle );
        ty = aY + aRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    case THREE.PathActions.ELLIPSE:

      var aX = args[ 0 ], aY = args[ 1 ],
        xRadius = args[ 2 ],
        yRadius = args[ 3 ],
        aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
        aClockwise = !! args[ 6 ],
        aRotation = args[ 7 ];


      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      var cos, sin;
      if ( aRotation !== 0 ) {

        cos = Math.cos( aRotation );
        sin = Math.sin( aRotation );

      }

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + xRadius * Math.cos( angle );
        ty = aY + yRadius * Math.sin( angle );

        if ( aRotation !== 0 ) {

          var x = tx, y = ty;

          // Rotate the point about the center of the ellipse.
          tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
          ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

        }

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    } // end switch

  }



  // Normalize to remove the closing point by default.
  var lastPoint = points[ points.length - 1 ];
  var EPSILON = 0.0000000001;
  if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&
       Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )
    points.splice( points.length - 1, 1 );
  if ( closedPath ) {

    points.push( points[ 0 ] );

  }

  return points;

};

//
// Breaks path into shapes
//
//  Assumptions (if parameter isCCW==true the opposite holds):
//  - solid shapes are defined clockwise (CW)
//  - holes are defined counterclockwise (CCW)
//
//  If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

  function extractSubpaths( inActions ) {

    var i, il, item, action, args;

    var subPaths = [], lastPath = new THREE.Path();

    for ( i = 0, il = inActions.length; i < il; i ++ ) {

      item = inActions[ i ];

      args = item.args;
      action = item.action;

      if ( action === THREE.PathActions.MOVE_TO ) {

        if ( lastPath.actions.length !== 0 ) {

          subPaths.push( lastPath );
          lastPath = new THREE.Path();

        }

      }

      lastPath[ action ].apply( lastPath, args );

    }

    if ( lastPath.actions.length !== 0 ) {

      subPaths.push( lastPath );

    }

    // console.log(subPaths);

    return  subPaths;

  }

  function toShapesNoHoles( inSubpaths ) {

    var shapes = [];

    for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

      var tmpPath = inSubpaths[ i ];

      var tmpShape = new THREE.Shape();
      tmpShape.actions = tmpPath.actions;
      tmpShape.curves = tmpPath.curves;

      shapes.push( tmpShape );

    }

    //console.log("shape", shapes);

    return shapes;

  }

  function isPointInsidePolygon( inPt, inPolygon ) {

    var EPSILON = 0.0000000001;

    var polyLen = inPolygon.length;

    // inPt on polygon contour => immediate success    or
    // toggling of inside/outside at every single! intersection point of an edge
    //  with the horizontal line through inPt, left of inPt
    //  not counting lowerY endpoints of edges and whole edges on that line
    var inside = false;
    for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

      var edgeLowPt  = inPolygon[ p ];
      var edgeHighPt = inPolygon[ q ];

      var edgeDx = edgeHighPt.x - edgeLowPt.x;
      var edgeDy = edgeHighPt.y - edgeLowPt.y;

      if ( Math.abs( edgeDy ) > EPSILON ) {

        // not parallel
        if ( edgeDy < 0 ) {

          edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
          edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

        }
        if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;

        if ( inPt.y === edgeLowPt.y ) {

          if ( inPt.x === edgeLowPt.x )   return  true;   // inPt is on contour ?
          // continue;        // no intersection or edgeLowPt => doesn't count !!!

        } else {

          var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
          if ( perpEdge === 0 )       return  true;   // inPt is on contour ?
          if ( perpEdge < 0 )         continue;
          inside = ! inside;    // true intersection left of inPt

        }

      } else {

        // parallel or collinear
        if ( inPt.y !== edgeLowPt.y )     continue;     // parallel
        // edge lies on the same horizontal line as inPt
        if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
           ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !
        // continue;

      }

    }

    return  inside;

  }


  var subPaths = extractSubpaths( this.actions );
  if ( subPaths.length === 0 ) return [];

  if ( noHoles === true ) return  toShapesNoHoles( subPaths );


  var solid, tmpPath, tmpShape, shapes = [];

  if ( subPaths.length === 1 ) {

    tmpPath = subPaths[ 0 ];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push( tmpShape );
    return shapes;

  }

  var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
  holesFirst = isCCW ? ! holesFirst : holesFirst;

  // console.log("Holes first", holesFirst);

  var betterShapeHoles = [];
  var newShapes = [];
  var newShapeHoles = [];
  var mainIdx = 0;
  var tmpPoints;

  newShapes[ mainIdx ] = undefined;
  newShapeHoles[ mainIdx ] = [];

  var i, il;

  for ( i = 0, il = subPaths.length; i < il; i ++ ) {

    tmpPath = subPaths[ i ];
    tmpPoints = tmpPath.getPoints();
    solid = THREE.Shape.Utils.isClockWise( tmpPoints );
    solid = isCCW ? ! solid : solid;

    if ( solid ) {

      if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx ++;

      newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
      newShapes[ mainIdx ].s.actions = tmpPath.actions;
      newShapes[ mainIdx ].s.curves = tmpPath.curves;

      if ( holesFirst ) mainIdx ++;
      newShapeHoles[ mainIdx ] = [];

      //console.log('cw', i);

    } else {

      newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

      //console.log('ccw', i);

    }

  }

  // only Holes? -> probably all Shapes with wrong orientation
  if ( ! newShapes[ 0 ] ) return  toShapesNoHoles( subPaths );


  if ( newShapes.length > 1 ) {

    var ambiguous = false;
    var toChange = [];

    for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

      betterShapeHoles[ sIdx ] = [];

    }
    for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

      var sho = newShapeHoles[ sIdx ];
      for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

        var ho = sho[ hIdx ];
        var hole_unassigned = true;
        for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

          if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

            if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
            if ( hole_unassigned ) {

              hole_unassigned = false;
              betterShapeHoles[ s2Idx ].push( ho );

            } else {

              ambiguous = true;

            }

          }

        }
        if ( hole_unassigned ) {

          betterShapeHoles[ sIdx ].push( ho );

        }

      }

    }
    // console.log("ambiguous: ", ambiguous);
    if ( toChange.length > 0 ) {

      // console.log("to change: ", toChange);
      if ( ! ambiguous )  newShapeHoles = betterShapeHoles;

    }

  }

  var tmpHoles, j, jl;
  for ( i = 0, il = newShapes.length; i < il; i ++ ) {

    tmpShape = newShapes[ i ].s;
    shapes.push( tmpShape );
    tmpHoles = newShapeHoles[ i ];
    for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

      tmpShape.holes.push( tmpHoles[ j ].h );

    }

  }

  //console.log("shape", shapes);

  return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

  THREE.Path.apply( this, arguments );
  this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

  var extruded = new THREE.ExtrudeGeometry( this, options );
  return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

  var geometry = new THREE.ShapeGeometry( this, options );
  return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

  }

  return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

  }

  return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

  return {

    shape: this.getTransformedPoints( divisions ),
    holes: this.getPointsHoles( divisions )

  };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

  if ( this.useSpacedPoints ) {

    return this.extractAllSpacedPoints( divisions );

  }

  return this.extractAllPoints( divisions );

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
//  return {
//
//    shape: this.transform( bend, divisions ),
//    holes: this.getPointsHoles( divisions, bend )
//
//  };
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

  return {

    shape: this.getTransformedSpacedPoints( divisions ),
    holes: this.getSpacedPointsHoles( divisions )

  };

};

/**************************************************************
 *  Utils
 **************************************************************/

THREE.Shape.Utils = {

  triangulateShape: function ( contour, holes ) {

    function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

      // inOtherPt needs to be collinear to the inSegment
      if ( inSegPt1.x !== inSegPt2.x ) {

        if ( inSegPt1.x < inSegPt2.x ) {

          return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

        } else {

          return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

        }

      } else {

        if ( inSegPt1.y < inSegPt2.y ) {

          return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

        } else {

          return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

        }

      }

    }

    function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

      var EPSILON = 0.0000000001;

      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

      var limit   = seg1dy * seg2dx - seg1dx * seg2dy;
      var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

      if ( Math.abs( limit ) > EPSILON ) {

        // not parallel

        var perpSeg2;
        if ( limit > 0 ) {

          if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];

        } else {

          if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];

        }

        // i.e. to reduce rounding errors
        // intersection at endpoint of segment#1?
        if ( perpSeg2 === 0 ) {

          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt1 ];

        }
        if ( perpSeg2 === limit ) {

          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt2 ];

        }
        // intersection at endpoint of segment#2?
        if ( perpSeg1 === 0 )   return [ inSeg2Pt1 ];
        if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

        // return real intersection point
        var factorSeg1 = perpSeg2 / limit;
        return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

      } else {

        // parallel or collinear
        if ( ( perpSeg1 !== 0 ) ||
           ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) )      return [];

        // they are collinear or degenerate
        var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );  // segment1 is just a point?
        var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );  // segment2 is just a point?
        // both segments are points
        if ( seg1Pt && seg2Pt ) {

          if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
             ( inSeg1Pt1.y !== inSeg2Pt1.y ) )    return [];  // they are distinct  points
          return [ inSeg1Pt1 ];                             // they are the same point

        }
        // segment#1  is a single point
        if ( seg1Pt ) {

          if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )   return [];    // but not in segment#2
          return [ inSeg1Pt1 ];

        }
        // segment#2  is a single point
        if ( seg2Pt ) {

          if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )   return [];    // but not in segment#1
          return [ inSeg2Pt1 ];

        }

        // they are collinear segments, which might overlap
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if ( seg1dx !== 0 ) {

          // the segments are NOT on a vertical line
          if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

          } else {

            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

          }
          if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

          } else {

            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

          }

        } else {

          // the segments are on a vertical line
          if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

          } else {

            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

          }
          if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

          } else {

            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

          }

        }
        if ( seg1minVal <= seg2minVal ) {

          if ( seg1maxVal <  seg2minVal ) return [];
          if ( seg1maxVal === seg2minVal )  {

            if ( inExcludeAdjacentSegs )    return [];
            return [ seg2min ];

          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
          return  [ seg2min, seg2max ];

        } else {

          if ( seg1minVal >  seg2maxVal ) return [];
          if ( seg1minVal === seg2maxVal )  {

            if ( inExcludeAdjacentSegs )    return [];
            return [ seg1min ];

          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
          return  [ seg1min, seg2max ];

        }

      }

    }

    function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

      // The order of legs is important

      var EPSILON = 0.0000000001;

      // translation of all points, so that Vertex is at (0,0)
      var legFromPtX  = inLegFromPt.x - inVertex.x,  legFromPtY = inLegFromPt.y - inVertex.y;
      var legToPtX  = inLegToPt.x - inVertex.x,  legToPtY   = inLegToPt.y - inVertex.y;
      var otherPtX  = inOtherPt.x - inVertex.x,  otherPtY   = inOtherPt.y - inVertex.y;

      // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
      var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;
      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

      if ( Math.abs( from2toAngle ) > EPSILON ) {

        // angle != 180 deg.

        var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;
        // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

        if ( from2toAngle > 0 ) {

          // main angle < 180 deg.
          return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

        } else {

          // main angle > 180 deg.
          return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

        }

      } else {

        // angle == 180 deg.
        // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
        return  ( from2otherAngle > 0 );

      }

    }


    function removeHoles( contour, holes ) {

      var shape = contour.concat(); // work on this shape
      var hole;

      function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

        // Check if hole point lies within angle around shape point
        var lastShapeIdx = shape.length - 1;

        var prevShapeIdx = inShapeIdx - 1;
        if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;

        var nextShapeIdx = inShapeIdx + 1;
        if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;

        var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
        if ( ! insideAngle ) {

          // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
          return  false;

        }

        // Check if shape point lies within angle around hole point
        var lastHoleIdx = hole.length - 1;

        var prevHoleIdx = inHoleIdx - 1;
        if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;

        var nextHoleIdx = inHoleIdx + 1;
        if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;

        insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
        if ( ! insideAngle ) {

          // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
          return  false;

        }

        return  true;

      }

      function intersectsShapeEdge( inShapePt, inHolePt ) {

        // checks for intersections with shape edges
        var sIdx, nextIdx, intersection;
        for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

          nextIdx = sIdx + 1; nextIdx %= shape.length;
          intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
          if ( intersection.length > 0 )    return  true;

        }

        return  false;

      }

      var indepHoles = [];

      function intersectsHoleEdge( inShapePt, inHolePt ) {

        // checks for intersections with hole edges
        var ihIdx, chkHole,
          hIdx, nextIdx, intersection;
        for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

          chkHole = holes[ indepHoles[ ihIdx ]];
          for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

            nextIdx = hIdx + 1; nextIdx %= chkHole.length;
            intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
            if ( intersection.length > 0 )    return  true;

          }

        }
        return  false;

      }

      var holeIndex, shapeIndex,
        shapePt, holePt,
        holeIdx, cutKey, failedCuts = [],
        tmpShape1, tmpShape2,
        tmpHole1, tmpHole2;

      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

        indepHoles.push( h );

      }

      var minShapeIndex = 0;
      var counter = indepHoles.length * 2;
      while ( indepHoles.length > 0 ) {

        counter --;
        if ( counter < 0 ) {

          console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
          break;

        }

        // search for shape-vertex and hole-vertex,
        // which can be connected without intersections
        for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

          shapePt = shape[ shapeIndex ];
          holeIndex = - 1;

          // search for hole which can be reached without intersections
          for ( var h = 0; h < indepHoles.length; h ++ ) {

            holeIdx = indepHoles[ h ];

            // prevent multiple checks
            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
            if ( failedCuts[ cutKey ] !== undefined )     continue;

            hole = holes[ holeIdx ];
            for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

              holePt = hole[ h2 ];
              if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )    continue;
              if ( intersectsShapeEdge( shapePt, holePt ) )   continue;
              if ( intersectsHoleEdge( shapePt, holePt ) )    continue;

              holeIndex = h2;
              indepHoles.splice( h, 1 );

              tmpShape1 = shape.slice( 0, shapeIndex + 1 );
              tmpShape2 = shape.slice( shapeIndex );
              tmpHole1 = hole.slice( holeIndex );
              tmpHole2 = hole.slice( 0, holeIndex + 1 );

              shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

              minShapeIndex = shapeIndex;

              // Debug only, to show the selected cuts
              // glob_CutLines.push( [ shapePt, holePt ] );

              break;

            }
            if ( holeIndex >= 0 ) break;    // hole-vertex found

            failedCuts[ cutKey ] = true;      // remember failure

          }
          if ( holeIndex >= 0 ) break;    // hole-vertex found

        }

      }

      return shape;       /* shape with no holes */

    }


    var i, il, f, face,
      key, index,
      allPointsMap = {};

    // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    var allpoints = contour.concat();

    for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

      Array.prototype.push.apply( allpoints, holes[ h ] );

    }

    //console.log( "allpoints",allpoints, allpoints.length );

    // prepare all points map

    for ( i = 0, il = allpoints.length; i < il; i ++ ) {

      key = allpoints[ i ].x + ":" + allpoints[ i ].y;

      if ( allPointsMap[ key ] !== undefined ) {

        console.warn( "THREE.Shape: Duplicate point", key );

      }

      allPointsMap[ key ] = i;

    }

    // remove holes by cutting paths to holes and adding them to the shape
    var shapeWithoutHoles = removeHoles( contour, holes );

    var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    //console.log( "triangles",triangles, triangles.length );

    // check all face vertices against all points map

    for ( i = 0, il = triangles.length; i < il; i ++ ) {

      face = triangles[ i ];

      for ( f = 0; f < 3; f ++ ) {

        key = face[ f ].x + ":" + face[ f ].y;

        index = allPointsMap[ key ];

        if ( index !== undefined ) {

          face[ f ] = index;

        }

      }

    }

    return triangles.concat();

  },

  isClockWise: function ( pts ) {

    return THREE.FontUtils.Triangulate.area( pts ) < 0;

  },

  // Bezier Curves formulas obtained from
  // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

  // Quad Bezier Functions

  b2p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * p;

  },

  b2p1: function ( t, p ) {

    return 2 * ( 1 - t ) * t * p;

  },

  b2p2: function ( t, p ) {

    return t * t * p;

  },

  b2: function ( t, p0, p1, p2 ) {

    return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

  },

  // Cubic Bezier Functions

  b3p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * k * p;

  },

  b3p1: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * k * t * p;

  },

  b3p2: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * t * t * p;

  },

  b3p3: function ( t, p ) {

    return t * t * t * p;

  },

  b3: function ( t, p0, p1, p2, p3 ) {

    return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

  }

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *  Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

  this.v1 = v1;
  this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

  var point = this.v2.clone().sub( this.v1 );
  point.multiplyScalar( t ).add( this.v1 );

  return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

  return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

  var tangent = this.v2.clone().sub( this.v1 );

  return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *  Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

  return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

  // returns unit vector

  return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *  Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

  var tx, ty;

  tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

  var tx, ty;

  tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  var tangent = new THREE.Vector2( tx, ty );
  tangent.normalize();

  return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *  Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

  this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

  var points = this.points;
  var point = ( points.length - 1 ) * t;

  var intPoint = Math.floor( point );
  var weight = point - intPoint;

  var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  var point1 = points[ intPoint ];
  var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
  vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

  return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *  Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  this.aX = aX;
  this.aY = aY;

  this.xRadius = xRadius;
  this.yRadius = yRadius;

  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;

  this.aClockwise = aClockwise;

  this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

  var deltaAngle = this.aEndAngle - this.aStartAngle;

  if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
  if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

  var angle;

  if ( this.aClockwise === true ) {

    angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

  } else {

    angle = this.aStartAngle + t * deltaAngle;

  }

  var x = this.aX + this.xRadius * Math.cos( angle );
  var y = this.aY + this.yRadius * Math.sin( angle );

  if ( this.aRotation !== 0 ) {

    var cos = Math.cos( this.aRotation );
    var sin = Math.sin( this.aRotation );

    var tx = x, ty = y;

    // Rotate the point about the center of the ellipse.
    x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
    y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

  }

  return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *  Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *  Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

  function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.subVectors( this.v2, this.v1 ); // diff
    vector.multiplyScalar( t );
    vector.add( this.v1 );

    return vector;

  }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *  Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
    vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

    return vector;

  }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *  Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
    vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

    return vector;

  }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *  Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */ ) {

    console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

  var
    tmp = new THREE.Vector3(),
    px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

  }

  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */
  CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    this.c0 = x0;
    this.c1 = t0;
    this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

  };

  CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    // compute tangents when parameterized in [t1,t2]
    var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    // rescale tangents for parametrization in [0,1]
    t1 *= dt1;
    t2 *= dt1;

    // initCubicPoly
    this.init( x1, x2, t1, t2 );

  };

  // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
  CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  };

  CubicPoly.prototype.calc = function( t ) {

    var t2 = t * t;
    var t3 = t2 * t;
    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

  };

  // Subclass Three.js curve
  return THREE.Curve.create(

    function ( p /* array of Vector3 */ ) {

      this.points = p || [];

    },

    function ( t ) {

      var points = this.points,
        point, intPoint, weight, l;

      l = points.length;

      if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

      point = ( l - 1 ) * t;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      if ( weight === 0 && intPoint === l - 1 ) {

        intPoint = l - 2;
        weight = 1;

      }

      var p0, p1, p2, p3;

      if ( intPoint === 0 ) {

        // extrapolate first point
        tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
        p0 = tmp;

      } else {

        p0 = points[ intPoint - 1 ];

      }

      p1 = points[ intPoint ];
      p2 = points[ intPoint + 1 ];

      if ( intPoint + 2 < l ) {

        p3 = points[ intPoint + 2 ]

      } else {

        // extrapolate last point
        tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
        p3 = tmp;

      }

      if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

        // init Centripetal / Chordal Catmull-Rom
        var pow = this.type === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
        var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
        var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

        // safety check for repeated points
        if ( dt1 < 1e-4 ) dt1 = 1.0;
        if ( dt0 < 1e-4 ) dt0 = dt1;
        if ( dt2 < 1e-4 ) dt2 = dt1;

        px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
        py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
        pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

      } else if ( this.type === 'catmullrom' ) {

        var tension = this.tension !== undefined ? this.tension : 0.5;
        px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
        py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
        pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

      }

      var v = new THREE.Vector3(
        px.calc( weight ),
        py.calc( weight ),
        pz.calc( weight )
      );

      return v;

    }

  );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *  Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */ ) {

    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    var point0 = points[ ( intPoint - 1 ) % points.length ];
    var point1 = points[ ( intPoint     ) % points.length ];
    var point2 = points[ ( intPoint + 1 ) % points.length ];
    var point3 = points[ ( intPoint + 2 ) % points.length ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

  LINEAR: 0,
  CATMULLROM: 1,
  CATMULLROM_FORWARD: 2,

  //

  add: function () {

    console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );

  },
  get: function () {

    console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );

  },
  remove: function () {

    console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );

  },

  //

  animations: [],

  init: function ( data ) {

    if ( data.initialized === true ) return data;

    // loop through all keys

    for ( var h = 0; h < data.hierarchy.length; h ++ ) {

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        // remove minus times

        if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

           data.hierarchy[ h ].keys[ k ].time = 0;

        }

        // create quaternions

        if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
          ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

          var quat = data.hierarchy[ h ].keys[ k ].rot;
          data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

        }

      }

      // prepare morph target keys

      if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

        // get all used

        var usedMorphTargets = {};

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

            var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
            usedMorphTargets[ morphTargetName ] = - 1;

          }

        }

        data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


        // set all used on all frames

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          var influences = {};

          for ( var morphTargetName in usedMorphTargets ) {

            for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

              if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                break;

              }

            }

            if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

              influences[ morphTargetName ] = 0;

            }

          }

          data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

        }

      }


      // remove all keys that are on the same time

      for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

        if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

          data.hierarchy[ h ].keys.splice( k, 1 );
          k --;

        }

      }


      // set index

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        data.hierarchy[ h ].keys[ k ].index = k;

      }

    }

    data.initialized = true;

    return data;

  },

  parse: function ( root ) {

    var parseRecurseHierarchy = function ( root, hierarchy ) {

      hierarchy.push( root );

      for ( var c = 0; c < root.children.length; c ++ )
        parseRecurseHierarchy( root.children[ c ], hierarchy );

    };

    // setup hierarchy

    var hierarchy = [];

    if ( root instanceof THREE.SkinnedMesh ) {

      for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

        hierarchy.push( root.skeleton.bones[ b ] );

      }

    } else {

      parseRecurseHierarchy( root, hierarchy );

    }

    return hierarchy;

  },

  play: function ( animation ) {

    if ( this.animations.indexOf( animation ) === - 1 ) {

      this.animations.push( animation );

    }

  },

  stop: function ( animation ) {

    var index = this.animations.indexOf( animation );

    if ( index !== - 1 ) {

      this.animations.splice( index, 1 );

    }

  },

  update: function ( deltaTimeMS ) {

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].resetBlendWeights( );

    }

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].update( deltaTimeMS );

    }

  }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

  this.root = root;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( root );

  this.currentTime = 0;
  this.timeScale = 1;

  this.isPlaying = false;
  this.loop = true;
  this.weight = 0;

  this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype = {

  constructor: THREE.Animation,

  keyTypes:  [ "pos", "rot", "scl" ],

  play: function ( startTime, weight ) {

    this.currentTime = startTime !== undefined ? startTime : 0;
    this.weight = weight !== undefined ? weight : 1;

    this.isPlaying = true;

    this.reset();

    THREE.AnimationHandler.play( this );

  },

  stop: function() {

    this.isPlaying = false;

    THREE.AnimationHandler.stop( this );

  },

  reset: function () {

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];

      if ( object.animationCache === undefined ) {

        object.animationCache = {
          animations: {},
          blending: {
            positionWeight: 0.0,
            quaternionWeight: 0.0,
            scaleWeight: 0.0
          }
        };

      }

      var name = this.data.name;
      var animations = object.animationCache.animations;
      var animationCache = animations[ name ];

      if ( animationCache === undefined ) {

        animationCache = {
          prevKey: { pos: 0, rot: 0, scl: 0 },
          nextKey: { pos: 0, rot: 0, scl: 0 },
          originalMatrix: object.matrix
        };

        animations[ name ] = animationCache;

      }

      // Get keys to match our current time

      for ( var t = 0; t < 3; t ++ ) {

        var type = this.keyTypes[ t ];

        var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
        var nextKey = this.getNextKeyWith( type, h, 1 );

        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

          prevKey = nextKey;
          nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

        }

        animationCache.prevKey[ type ] = prevKey;
        animationCache.nextKey[ type ] = nextKey;

      }

    }

  },

  resetBlendWeights: function () {

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var animationCache = object.animationCache;

      if ( animationCache !== undefined ) {

        var blending = animationCache.blending;

        blending.positionWeight = 0.0;
        blending.quaternionWeight = 0.0;
        blending.scaleWeight = 0.0;

      }

    }

  },

  update: ( function() {

    var points = [];
    var target = new THREE.Vector3();
    var newVector = new THREE.Vector3();
    var newQuat = new THREE.Quaternion();

    // Catmull-Rom spline

    var interpolateCatmullRom = function ( points, scale ) {

      var c = [], v3 = [],
      point, intPoint, weight, w2, w3,
      pa, pb, pc, pd;

      point = ( points.length - 1 ) * scale;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
      c[ 1 ] = intPoint;
      c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
      c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

      pa = points[ c[ 0 ] ];
      pb = points[ c[ 1 ] ];
      pc = points[ c[ 2 ] ];
      pd = points[ c[ 3 ] ];

      w2 = weight * weight;
      w3 = weight * w2;

      v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
      v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
      v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

      return v3;

    };

    var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

      var v0 = ( p2 - p0 ) * 0.5,
        v1 = ( p3 - p1 ) * 0.5;

      return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    };

    return function ( delta ) {

      if ( this.isPlaying === false ) return;

      this.currentTime += delta * this.timeScale;

      if ( this.weight === 0 )
        return;

      //

      var duration = this.data.length;

      if ( this.currentTime > duration || this.currentTime < 0 ) {

        if ( this.loop ) {

          this.currentTime %= duration;

          if ( this.currentTime < 0 )
            this.currentTime += duration;

          this.reset();

        } else {

          this.stop();

        }

      }

      for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

        var object = this.hierarchy[ h ];
        var animationCache = object.animationCache.animations[ this.data.name ];
        var blending = object.animationCache.blending;

        // loop through pos/rot/scl

        for ( var t = 0; t < 3; t ++ ) {

          // get keys

          var type    = this.keyTypes[ t ];
          var prevKey = animationCache.prevKey[ type ];
          var nextKey = animationCache.nextKey[ type ];

          if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
            ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

            prevKey = this.data.hierarchy[ h ].keys[ 0 ];
            nextKey = this.getNextKeyWith( type, h, 1 );

            while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

              prevKey = nextKey;
              nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

            }

            animationCache.prevKey[ type ] = prevKey;
            animationCache.nextKey[ type ] = nextKey;

          }

          var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

          var prevXYZ = prevKey[ type ];
          var nextXYZ = nextKey[ type ];

          if ( scale < 0 ) scale = 0;
          if ( scale > 1 ) scale = 1;

          // interpolate

          if ( type === "pos" ) {

            if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

              newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
              newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
              newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

              // blend
              var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
              object.position.lerp( newVector, proportionalWeight );
              blending.positionWeight += this.weight;

            } else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                  this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

              points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
              points[ 1 ] = prevXYZ;
              points[ 2 ] = nextXYZ;
              points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

              scale = scale * 0.33 + 0.33;

              var currentPoint = interpolateCatmullRom( points, scale );
              var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
              blending.positionWeight += this.weight;

              // blend

              var vector = object.position;

              vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
              vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
              vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

              if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

                target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
                target.sub( vector );
                target.y = 0;
                target.normalize();

                var angle = Math.atan2( target.x, target.z );
                object.rotation.set( 0, angle, 0 );

              }

            }

          } else if ( type === "rot" ) {

            THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

            // Avoid paying the cost of an additional slerp if we don't have to
            if ( blending.quaternionWeight === 0 ) {

              object.quaternion.copy( newQuat );
              blending.quaternionWeight = this.weight;

            } else {

              var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
              THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
              blending.quaternionWeight += this.weight;

            }

          } else if ( type === "scl" ) {

            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

            var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
            object.scale.lerp( newVector, proportionalWeight );
            blending.scaleWeight += this.weight;

          }

        }

      }

      return true;

    };

  } )(),

  getNextKeyWith: function ( type, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;

    if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
       this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

      key = key < keys.length - 1 ? key : keys.length - 1;

    } else {

      key = key % keys.length;

    }

    for ( ; key < keys.length; key ++ ) {

      if ( keys[ key ][ type ] !== undefined ) {

        return keys[ key ];

      }

    }

    return this.data.hierarchy[ h ].keys[ 0 ];

  },

  getPrevKeyWith: function ( type, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;

    if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
      this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

      key = key > 0 ? key : 0;

    } else {

      key = key >= 0 ? key : key + keys.length;

    }


    for ( ; key >= 0; key -- ) {

      if ( keys[ key ][ type ] !== undefined ) {

        return keys[ key ];

      }

    }

    return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

  }

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

  this.root = data.node;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( this.root );
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;

  // initialize to first keyframes

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var keys = this.data.hierarchy[ h ].keys,
      sids = this.data.hierarchy[ h ].sids,
      obj = this.hierarchy[ h ];

    if ( keys.length && sids ) {

      for ( var s = 0; s < sids.length; s ++ ) {

        var sid = sids[ s ],
          next = this.getNextKeyWith( sid, h, 0 );

        if ( next ) {

          next.apply( sid );

        }

      }

      obj.matrixAutoUpdate = false;
      this.data.hierarchy[ h ].node.updateMatrix();
      obj.matrixWorldNeedsUpdate = true;

    }

  }

};

THREE.KeyFrameAnimation.prototype = {

  constructor: THREE.KeyFrameAnimation,

  play: function ( startTime ) {

    this.currentTime = startTime !== undefined ? startTime : 0;

    if ( this.isPlaying === false ) {

      this.isPlaying = true;

      // reset key cache

      var h, hl = this.hierarchy.length,
        object,
        node;

      for ( h = 0; h < hl; h ++ ) {

        object = this.hierarchy[ h ];
        node = this.data.hierarchy[ h ];

        if ( node.animationCache === undefined ) {

          node.animationCache = {};
          node.animationCache.prevKey = null;
          node.animationCache.nextKey = null;
          node.animationCache.originalMatrix = object.matrix;

        }

        var keys = this.data.hierarchy[ h ].keys;

        if ( keys.length ) {

          node.animationCache.prevKey = keys[ 0 ];
          node.animationCache.nextKey = keys[ 1 ];

          this.startTime = Math.min( keys[ 0 ].time, this.startTime );
          this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );

        }

      }

      this.update( 0 );

    }

    this.isPaused = false;

    THREE.AnimationHandler.play( this );

  },

  stop: function () {

    this.isPlaying = false;
    this.isPaused  = false;

    THREE.AnimationHandler.stop( this );

    // reset JIT matrix and remove cache

    for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

      var obj = this.hierarchy[ h ];
      var node = this.data.hierarchy[ h ];

      if ( node.animationCache !== undefined ) {

        var original = node.animationCache.originalMatrix;

        original.copy( obj.matrix );
        obj.matrix = original;

        delete node.animationCache;

      }

    }

  },

  update: function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta * this.timeScale;

    //

    var duration = this.data.length;

    if ( this.loop === true && this.currentTime > duration ) {

      this.currentTime %= duration;

    }

    this.currentTime = Math.min( this.currentTime, duration );

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var node = this.data.hierarchy[ h ];

      var keys = node.keys,
        animationCache = node.animationCache;


      if ( keys.length ) {

        var prevKey = animationCache.prevKey;
        var nextKey = animationCache.nextKey;

        if ( nextKey.time <= this.currentTime ) {

          while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

            prevKey = nextKey;
            nextKey = keys[ prevKey.index + 1 ];

          }

          animationCache.prevKey = prevKey;
          animationCache.nextKey = nextKey;

        }

        if ( nextKey.time >= this.currentTime ) {

          prevKey.interpolate( nextKey, this.currentTime );

        } else {

          prevKey.interpolate( nextKey, nextKey.time );

        }

        this.data.hierarchy[ h ].node.updateMatrix();
        object.matrixWorldNeedsUpdate = true;

      }

    }

  },

  getNextKeyWith: function ( sid, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;
    key = key % keys.length;

    for ( ; key < keys.length; key ++ ) {

      if ( keys[ key ].hasTarget( sid ) ) {

        return keys[ key ];

      }

    }

    return keys[ 0 ];

  },

  getPrevKeyWith: function ( sid, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;
    key = key >= 0 ? key : key + keys.length;

    for ( ; key >= 0; key -- ) {

      if ( keys[ key ].hasTarget( sid ) ) {

        return keys[ key ];

      }

    }

    return keys[ keys.length - 1 ];

  }

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function ( mesh ) {

  this.mesh = mesh;
  this.frames = mesh.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = true;
  this.lastFrame = 0;
  this.currentFrame = 0;

  this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

  constructor: THREE.MorphAnimation,

  play: function () {

    this.isPlaying = true;

  },

  pause: function () {

    this.isPlaying = false;

  },

  update: function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta;

    if ( this.loop === true && this.currentTime > this.duration ) {

      this.currentTime %= this.duration;

    }

    this.currentTime = Math.min( this.currentTime, this.duration );

    var frameTime = this.duration / this.frames;
    var frame = Math.floor( this.currentTime / frameTime );

    var influences = this.mesh.morphTargetInfluences;

    if ( frame !== this.currentFrame ) {

      influences[ this.lastFrame ] = 0;
      influences[ this.currentFrame ] = 1;
      influences[ frame ] = 0;

      this.lastFrame = this.currentFrame;
      this.currentFrame = frame;

    }

    var mix = ( this.currentTime % frameTime ) / frameTime;

    influences[ frame ] = mix;
    influences[ this.lastFrame ] = 1 - mix;

  }

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  THREE.Geometry.call( this );

  this.type = 'BoxGeometry';

  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };

  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;

  var scope = this;

  var width_half = width / 2;
  var height_half = height / 2;
  var depth_half = depth / 2;

  buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
  buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
  buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
  buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
  buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
  buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

  function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

    var w, ix, iy,
    gridX = scope.widthSegments,
    gridY = scope.heightSegments,
    width_half = width / 2,
    height_half = height / 2,
    offset = scope.vertices.length;

    if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

      w = 'z';

    } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

      w = 'y';
      gridY = scope.depthSegments;

    } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

      w = 'x';
      gridX = scope.depthSegments;

    }

    var gridX1 = gridX + 1,
    gridY1 = gridY + 1,
    segment_width = width / gridX,
    segment_height = height / gridY,
    normal = new THREE.Vector3();

    normal[ w ] = depth > 0 ? 1 : - 1;

    for ( iy = 0; iy < gridY1; iy ++ ) {

      for ( ix = 0; ix < gridX1; ix ++ ) {

        var vector = new THREE.Vector3();
        vector[ u ] = ( ix * segment_width - width_half ) * udir;
        vector[ v ] = ( iy * segment_height - height_half ) * vdir;
        vector[ w ] = depth;

        scope.vertices.push( vector );

      }

    }

    for ( iy = 0; iy < gridY; iy ++ ) {

      for ( ix = 0; ix < gridX; ix ++ ) {

        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * ( iy + 1 );
        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
        var d = ( ix + 1 ) + gridX1 * iy;

        var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
        var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
        var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
        var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

        var face = new THREE.Face3( a + offset, b + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
        face.materialIndex = materialIndex;

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

        face = new THREE.Face3( b + offset, c + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
        face.materialIndex = materialIndex;

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

      }

    }

  }

  this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function () {

  var geometry = new THREE.BoxGeometry(
    this.parameters.width,
    this.parameters.height,
    this.parameters.depth,
    this.parameters.widthSegments,
    this.parameters.heightSegments,
    this.parameters.depthSegments
  );

  return geometry;

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CircleGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var i, uvs = [],
  center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

  this.vertices.push( center );
  uvs.push( centerUV );

  for ( i = 0; i <= segments; i ++ ) {

    var vertex = new THREE.Vector3();
    var segment = thetaStart + i / segments * thetaLength;

    vertex.x = radius * Math.cos( segment );
    vertex.y = radius * Math.sin( segment );

    this.vertices.push( vertex );
    uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 1; i <= segments; i ++ ) {

    this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
    this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function () {

  var geometry = new THREE.CircleGeometry(
    this.parameters.radius,
    this.parameters.segments,
    this.parameters.thetaStart,
    this.parameters.thetaLength
  );

  return geometry;

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'CircleBufferGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var vertices = segments + 2;

  var positions = new Float32Array( vertices * 3 );
  var normals = new Float32Array( vertices * 3 );
  var uvs = new Float32Array( vertices * 2 );

  // center data is already zero, but need to set a few extras
  normals[ 3 ] = 1.0;
  uvs[ 0 ] = 0.5;
  uvs[ 1 ] = 0.5;

  for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

    var segment = thetaStart + s / segments * thetaLength;

    positions[ i ] = radius * Math.cos( segment );
    positions[ i + 1 ] = radius * Math.sin( segment );

    normals[ i + 2 ] = 1; // normal z

    uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
    uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

  }

  var indices = [];

  for ( var i = 1; i <= segments; i ++ ) {

    indices.push( i );
    indices.push( i + 1 );
    indices.push( 0 );

  }

  this.addAttribute( 'index', new THREE.IndexBufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function () {

  var geometry = new THREE.CircleBufferGeometry(
    this.parameters.radius,
    this.parameters.segments,
    this.parameters.thetaStart,
    this.parameters.thetaLength
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CylinderGeometry';

  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;

  radialSegments = radialSegments || 8;
  heightSegments = heightSegments || 1;

  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

  var heightHalf = height / 2;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    var v = y / heightSegments;
    var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    for ( x = 0; x <= radialSegments; x ++ ) {

      var u = x / radialSegments;

      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
      vertex.y = - v * height + heightHalf;
      vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  var tanTheta = ( radiusBottom - radiusTop ) / height;
  var na, nb;

  for ( x = 0; x < radialSegments; x ++ ) {

    if ( radiusTop !== 0 ) {

      na = this.vertices[ vertices[ 0 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

    } else {

      na = this.vertices[ vertices[ 1 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

    }

    na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
    nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

    for ( y = 0; y < heightSegments; y ++ ) {

      var v1 = vertices[ y ][ x ];
      var v2 = vertices[ y + 1 ][ x ];
      var v3 = vertices[ y + 1 ][ x + 1 ];
      var v4 = vertices[ y ][ x + 1 ];

      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();

      var uv1 = uvs[ y ][ x ].clone();
      var uv2 = uvs[ y + 1 ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
      var uv4 = uvs[ y ][ x + 1 ].clone();

      this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

      this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

    }

  }

  // top cap

  if ( openEnded === false && radiusTop > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ 0 ][ x ];
      var v2 = vertices[ 0 ][ x + 1 ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, 1, 0 );
      var n2 = new THREE.Vector3( 0, 1, 0 );
      var n3 = new THREE.Vector3( 0, 1, 0 );

      var uv1 = uvs[ 0 ][ x ].clone();
      var uv2 = uvs[ 0 ][ x + 1 ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 0 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  // bottom cap

  if ( openEnded === false && radiusBottom > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ heightSegments ][ x + 1 ];
      var v2 = vertices[ heightSegments ][ x ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, - 1, 0 );
      var n2 = new THREE.Vector3( 0, - 1, 0 );
      var n3 = new THREE.Vector3( 0, - 1, 0 );

      var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
      var uv2 = uvs[ heightSegments ][ x ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 1 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function () {

  var geometry = new THREE.CylinderGeometry(
    this.parameters.radiusTop,
    this.parameters.radiusBottom,
    this.parameters.height,
    this.parameters.radialSegments,
    this.parameters.heightSegments,
    this.parameters.openEnded,
    this.parameters.thetaStart,
    this.parameters.thetaLength
  );

  return geometry;

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

  THREE.BufferGeometry.call( this );

  thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) {

    return a - b;

  };

  var keys = [ 'a', 'b', 'c' ];

  var geometry2;

  if ( geometry instanceof THREE.BufferGeometry ) {

    geometry2 = new THREE.Geometry();
    geometry2.fromBufferGeometry( geometry );

  } else {

    geometry2 = geometry.clone();

  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();

  var vertices = geometry2.vertices;
  var faces = geometry2.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0; j < 3; j ++ ) {

      edge[ 0 ] = face[ keys[ j ] ];
      edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
      edge.sort( sortFunction );

      var key = edge.toString();

      if ( hash[ key ] === undefined ) {

        hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

      } else {

        hash[ key ].face2 = i;

      }

    }

  }

  var coords = [];

  for ( var key in hash ) {

    var h = hash[ key ];

    if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

      var vertex = vertices[ h.vert1 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

      vertex = vertices[ h.vert2 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

    }

  }

  this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

  if ( typeof( shapes ) === "undefined" ) {

    shapes = [];
    return;

  }

  THREE.Geometry.call( this );

  this.type = 'ExtrudeGeometry';

  shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

  // can't really use automatic vertex normals
  // as then front and back sides get smoothed too
  // should do separate smoothing just for sides

  //this.computeVertexNormals();

  //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

  var sl = shapes.length;

  for ( var s = 0; s < sl; s ++ ) {

    var shape = shapes[ s ];
    this.addShape( shape, options );

  }

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

  var amount = options.amount !== undefined ? options.amount : 100;

  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var steps = options.steps !== undefined ? options.steps : 1;

  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;

  // Use default WorldUVGenerator if no UV generators are specified.
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

  var splineTube, binormal, normal, position2;
  if ( extrudePath ) {

    extrudePts = extrudePath.getSpacedPoints( steps );

    extrudeByPath = true;
    bevelEnabled = false; // bevels not supported for path extrusion

    // SETUP TNB variables

    // Reuse TNB from TubeGeomtry for now.
    // TODO1 - have a .isClosed in spline?

    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();

  }

  // Safeguards if bevels are not enabled

  if ( ! bevelEnabled ) {

    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;

  }

  // Variables initialization

  var ahole, h, hl; // looping of holes
  var scope = this;

  var shapesOffset = this.vertices.length;

  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe ...

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

        holes[ h ] = ahole.reverse();

      }

    }

    reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

  }


  var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

  /* Vertices */

  var contour = vertices; // vertices has all points but contour has only points of circumference

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    vertices = vertices.concat( ahole );

  }


  function scalePt2 ( pt, vec, size ) {

    if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    return vec.clone().multiplyScalar( size ).add( pt );

  }

  var b, bs, t, z,
    vert, vlen = vertices.length,
    face, flen = faces.length;


  // Find directions for point movement


  function getBevelVec( inPt, inPrev, inNext ) {

    var EPSILON = 0.0000000001;

    // computes for inPt the corresponding point inPt' on a new contour
    //   shifted by 1 unit (length of normalized vector) to the left
    // if we walk along contour clockwise, this new contour is outside the old one
    //
    // inPt' is the intersection of the two lines parallel to the two
    //  adjacent edges of inPt at a distance of 1 unit on the left side.

    var v_trans_x, v_trans_y, shrink_by = 1;    // resulting translation vector for inPt

    // good reading for geometry algorithms (here: line-line intersection)
    // http://geomalgorithms.com/a05-_intersect-1.html

    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    // check for collinear edges
    var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    if ( Math.abs( collinear0 ) > EPSILON ) {

      // not collinear

      // length of vectors for normalizing

      var v_prev_len = Math.sqrt( v_prev_lensq );
      var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

      // shift adjacent points by unit vectors to the left

      var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
      var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

      var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
      var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

      // scaling factor for v_prev to intersection point

      var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
            ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
            ( v_prev_x * v_next_y - v_prev_y * v_next_x );

      // vector from inPt to intersection point

      v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
      v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

      // Don't normalize!, otherwise sharp corners become ugly
      //  but prevent crazy spikes
      var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
      if ( v_trans_lensq <= 2 ) {

        return  new THREE.Vector2( v_trans_x, v_trans_y );

      } else {

        shrink_by = Math.sqrt( v_trans_lensq / 2 );

      }

    } else {

      // handle special case of collinear edges

      var direction_eq = false;   // assumes: opposite
      if ( v_prev_x > EPSILON ) {

        if ( v_next_x > EPSILON ) {

          direction_eq = true;

        }

      } else {

        if ( v_prev_x < - EPSILON ) {

          if ( v_next_x < - EPSILON ) {

            direction_eq = true;

          }

        } else {

          if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

            direction_eq = true;

          }

        }

      }

      if ( direction_eq ) {

        // console.log("Warning: lines are a straight sequence");
        v_trans_x = - v_prev_y;
        v_trans_y =  v_prev_x;
        shrink_by = Math.sqrt( v_prev_lensq );

      } else {

        // console.log("Warning: lines are a straight spike");
        v_trans_x = v_prev_x;
        v_trans_y = v_prev_y;
        shrink_by = Math.sqrt( v_prev_lensq / 2 );

      }

    }

    return  new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  }


  var contourMovements = [];

  for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    if ( j === il ) j = 0;
    if ( k === il ) k = 0;

    //  (j)---(i)---(k)
    // console.log('i,j,k', i, j , k)

    contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  }

  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    oneHoleMovements = [];

    for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

      if ( j === il ) j = 0;
      if ( k === il ) k = 0;

      //  (j)---(i)---(k)
      oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    }

    holesMovements.push( oneHoleMovements );
    verticesMovements = verticesMovements.concat( oneHoleMovements );

  }


  // Loop bevelSegments, 1 for the front, 1 for the back

  for ( b = 0; b < bevelSegments; b ++ ) {

    //for ( b = bevelSegments; b > 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );

    //z = bevelThickness * t;
    bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
    //bs = bevelSize * t; // linear

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

      v( vert.x, vert.y,  - z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        v( vert.x, vert.y,  - z );

      }

    }

  }

  bs = bevelSize;

  // Back facing vertices

  for ( i = 0; i < vlen; i ++ ) {

    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    if ( ! extrudeByPath ) {

      v( vert.x, vert.y, 0 );

    } else {

      // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

      normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
      binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

      position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

      v( position2.x, position2.y, position2.z );

    }

  }

  // Add stepped vertices...
  // Including front facing vertices

  var s;

  for ( s = 1; s <= steps; s ++ ) {

    for ( i = 0; i < vlen; i ++ ) {

      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

      if ( ! extrudeByPath ) {

        v( vert.x, vert.y, amount / steps * s );

      } else {

        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

        normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
        binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

        position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

        v( position2.x, position2.y, position2.z );

      }

    }

  }


  // Add bevel segments planes

  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for ( b = bevelSegments - 1; b >= 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );
    //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
    bs = bevelSize * Math.sin ( t * Math.PI / 2 );

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
      v( vert.x, vert.y,  amount + z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        if ( ! extrudeByPath ) {

          v( vert.x, vert.y,  amount + z );

        } else {

          v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

        }

      }

    }

  }

  /* Faces */

  // Top and bottom faces

  buildLidFaces();

  // Sides faces

  buildSideFaces();


  /////  Internal functions

  function buildLidFaces() {

    if ( bevelEnabled ) {

      var layer = 0; // steps + 1
      var offset = vlen * layer;

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

      }

      layer = steps + bevelSegments * 2;
      offset = vlen * layer;

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

      }

    } else {

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ], face[ 1 ], face[ 0 ] );

      }

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

      }

    }

  }

  // Create faces for the z-sides of the shape

  function buildSideFaces() {

    var layeroffset = 0;
    sidewalls( contour, layeroffset );
    layeroffset += contour.length;

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      sidewalls( ahole, layeroffset );

      //, true
      layeroffset += ahole.length;

    }

  }

  function sidewalls( contour, layeroffset ) {

    var j, k;
    i = contour.length;

    while ( -- i >= 0 ) {

      j = i;
      k = i - 1;
      if ( k < 0 ) k = contour.length - 1;

      //console.log('b', i,j, i-1, k,vertices.length);

      var s = 0, sl = steps  + bevelSegments * 2;

      for ( s = 0; s < sl; s ++ ) {

        var slen1 = vlen * s;
        var slen2 = vlen * ( s + 1 );

        var a = layeroffset + j + slen1,
          b = layeroffset + k + slen1,
          c = layeroffset + k + slen2,
          d = layeroffset + j + slen2;

        f4( a, b, c, d, contour, s, sl, j, k );

      }

    }

  }


  function v( x, y, z ) {

    scope.vertices.push( new THREE.Vector3( x, y, z ) );

  }

  function f3( a, b, c ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, c ) );

    var uvs = uvgen.generateTopUV( scope, a, b, c );

    scope.faceVertexUvs[ 0 ].push( uvs );

  }

  function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, d ) );
    scope.faces.push( new THREE.Face3( b, c, d ) );

    var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

  }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

  generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];

    return [
      new THREE.Vector2( a.x, a.y ),
      new THREE.Vector2( b.x, b.y ),
      new THREE.Vector2( c.x, c.y )
    ];

  },

  generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];
    var d = vertices[ indexD ];

    if ( Math.abs( a.y - b.y ) < 0.01 ) {

      return [
        new THREE.Vector2( a.x, 1 - a.z ),
        new THREE.Vector2( b.x, 1 - b.z ),
        new THREE.Vector2( c.x, 1 - c.z ),
        new THREE.Vector2( d.x, 1 - d.z )
      ];

    } else {

      return [
        new THREE.Vector2( a.y, 1 - a.z ),
        new THREE.Vector2( b.y, 1 - b.z ),
        new THREE.Vector2( c.y, 1 - c.z ),
        new THREE.Vector2( d.y, 1 - d.z )
      ];

    }

  }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *  material: <int> // material index for front and back faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

  THREE.Geometry.call( this );

  this.type = 'ShapeGeometry';

  if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

  for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    this.addShape( shapes[ i ], options );

  }

  return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

  if ( options === undefined ) options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

  //

  var i, l, hole;

  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe...

    for ( i = 0, l = holes.length; i < l; i ++ ) {

      hole = holes[ i ];

      if ( THREE.Shape.Utils.isClockWise( hole ) ) {

        holes[ i ] = hole.reverse();

      }

    }

    reverse = false;

  }

  var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

  // Vertices

  for ( i = 0, l = holes.length; i < l; i ++ ) {

    hole = holes[ i ];
    vertices = vertices.concat( hole );

  }

  //

  var vert, vlen = vertices.length;
  var face, flen = faces.length;

  for ( i = 0; i < vlen; i ++ ) {

    vert = vertices[ i ];

    this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

  }

  for ( i = 0; i < flen; i ++ ) {

    face = faces[ i ];

    var a = face[ 0 ] + shapesOffset;
    var b = face[ 1 ] + shapesOffset;
    var c = face[ 2 ] + shapesOffset;

    this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
    this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

  }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

  THREE.Geometry.call( this );

  this.type = 'LatheGeometry';

  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };

  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  var inversePointLength = 1.0 / ( points.length - 1 );
  var inverseSegments = 1.0 / segments;

  for ( var i = 0, il = segments; i <= il; i ++ ) {

    var phi = phiStart + i * inverseSegments * phiLength;

    var c = Math.cos( phi ),
      s = Math.sin( phi );

    for ( var j = 0, jl = points.length; j < jl; j ++ ) {

      var pt = points[ j ];

      var vertex = new THREE.Vector3();

      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;

      this.vertices.push( vertex );

    }

  }

  var np = points.length;

  for ( var i = 0, il = segments; i < il; i ++ ) {

    for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;

      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;

      this.faces.push( new THREE.Face3( a, b, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u0, v0 ),
        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u0, v1 )

      ] );

      this.faces.push( new THREE.Face3( b, c, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u1, v1 ),
        new THREE.Vector2( u0, v1 )

      ] );


    }

  }

  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.Geometry.call( this );

  this.type = 'PlaneGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function () {

  var geometry = new THREE.PlaneGeometry(
    this.parameters.width,
    this.parameters.height,
    this.parameters.widthSegments,
    this.parameters.heightSegments
  );

  return geometry;

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.BufferGeometry.call( this );

  this.type = 'PlaneBufferGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  var width_half = width / 2;
  var height_half = height / 2;

  var gridX = Math.floor( widthSegments ) || 1;
  var gridY = Math.floor( heightSegments ) || 1;

  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;

  var segment_width = width / gridX;
  var segment_height = height / gridY;

  var vertices = new Float32Array( gridX1 * gridY1 * 3 );
  var normals = new Float32Array( gridX1 * gridY1 * 3 );
  var uvs = new Float32Array( gridX1 * gridY1 * 2 );

  var offset = 0;
  var offset2 = 0;

  for ( var iy = 0; iy < gridY1; iy ++ ) {

    var y = iy * segment_height - height_half;

    for ( var ix = 0; ix < gridX1; ix ++ ) {

      var x = ix * segment_width - width_half;

      vertices[ offset ] = x;
      vertices[ offset + 1 ] = - y;

      normals[ offset + 2 ] = 1;

      uvs[ offset2 ] = ix / gridX;
      uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

      offset += 3;
      offset2 += 2;

    }

  }

  offset = 0;

  var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

  for ( var iy = 0; iy < gridY; iy ++ ) {

    for ( var ix = 0; ix < gridX; ix ++ ) {

      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * ( iy + 1 );
      var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
      var d = ( ix + 1 ) + gridX1 * iy;

      indices[ offset ] = a;
      indices[ offset + 1 ] = b;
      indices[ offset + 2 ] = d;

      indices[ offset + 3 ] = b;
      indices[ offset + 4 ] = c;
      indices[ offset + 5 ] = d;

      offset += 6;

    }

  }

  this.addAttribute( 'index', new THREE.IndexBufferAttribute( indices, 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function () {

  var geometry = new THREE.PlaneBufferGeometry(
    this.parameters.width,
    this.parameters.height,
    this.parameters.widthSegments,
    this.parameters.heightSegments
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'RingGeometry';

  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

  var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

  for ( i = 0; i < phiSegments + 1; i ++ ) {

    // concentric circles inside ring

    for ( o = 0; o < thetaSegments + 1; o ++ ) {

      // number of segments per circle

      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos( segment );
      vertex.y = radius * Math.sin( segment );

      this.vertices.push( vertex );
      uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

    }

    radius += radiusStep;

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 0; i < phiSegments; i ++ ) {

    // concentric circles inside ring

    var thetaSegment = i * ( thetaSegments + 1 );

    for ( o = 0; o < thetaSegments ; o ++ ) {

      // number of segments per circle

      var segment = o + thetaSegment;

      var v1 = segment;
      var v2 = segment + thetaSegments + 1;
      var v3 = segment + thetaSegments + 2;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

      v1 = segment;
      v2 = segment + thetaSegments + 2;
      v3 = segment + 1;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

    }

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function () {

  var geometry = new THREE.RingGeometry(
    this.parameters.innerRadius,
    this.parameters.outerRadius,
    this.parameters.thetaSegments,
    this.parameters.phiSegments,
    this.parameters.thetaStart,
    this.parameters.thetaLength
  );

  return geometry;

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  console.log( 'THREE.SphereGeometry: Consider using THREE.SphereBufferGeometry for lower memory footprint.' );

  THREE.Geometry.call( this );

  this.type = 'SphereGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    for ( x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;
      var v = y / heightSegments;

      var vertex = new THREE.Vector3();
      vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
      vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  for ( y = 0; y < heightSegments; y ++ ) {

    for ( x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = vertices[ y + 1 ][ x ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      var n1 = this.vertices[ v1 ].clone().normalize();
      var n2 = this.vertices[ v2 ].clone().normalize();
      var n3 = this.vertices[ v3 ].clone().normalize();
      var n4 = this.vertices[ v4 ].clone().normalize();

      var uv1 = uvs[ y ][ x + 1 ].clone();
      var uv2 = uvs[ y ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x ].clone();
      var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

      if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

        uv1.x = ( uv1.x + uv2.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

      } else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

        uv3.x = ( uv3.x + uv4.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

      } else {

        this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

        this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

      }

    }

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function () {

  var geometry = new THREE.SphereGeometry(
    this.parameters.radius,
    this.parameters.widthSegments,
    this.parameters.heightSegments,
    this.parameters.phiStart,
    this.parameters.phiLength,
    this.parameters.thetaStart,
    this.parameters.thetaLength
  );

  return geometry;

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'SphereBufferGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var thetaEnd = thetaStart + thetaLength;

  var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

  var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
  var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
  var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

  var index = 0, vertices = [], normal = new THREE.Vector3();

  for ( var y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];

    var v = y / heightSegments;

    for ( var x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;

      var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      var py = radius * Math.cos( thetaStart + v * thetaLength );
      var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      normal.set( px, py, pz ).normalize();

      positions.setXYZ( index, px, py, pz );
      normals.setXYZ( index, normal.x, normal.y, normal.z );
      uvs.setXY( index, u, 1 - v );

      verticesRow.push( index );

      index ++;

    }

    vertices.push( verticesRow );

  }

  var indices = [];

  for ( var y = 0; y < heightSegments; y ++ ) {

    for ( var x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = vertices[ y + 1 ][ x ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
      if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

    }

  }

  this.addAttribute( 'index', new THREE.IndexBufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', positions );
  this.addAttribute( 'normal', normals );
  this.addAttribute( 'uv', uvs );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

  var geometry = new THREE.SphereBufferGeometry(
    this.parameters.radius,
    this.parameters.widthSegments,
    this.parameters.heightSegments,
    this.parameters.phiStart,
    this.parameters.phiLength,
    this.parameters.thetaStart,
    this.parameters.thetaLength
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size:       <float>,  // size of the text
 *  height:     <float>,  // thickness to extrude text
 *  curveSegments:  <int>,    // number of points on the curves
 *
 *  font:       <string>,   // font name
 *  weight:     <string>,   // font weight (normal, bold)
 *  style:      <string>,   // font style  (normal, italics)
 *
 *  bevelEnabled: <bool>,     // turn on bevel
 *  bevelThickness: <float>,    // how deep into text bevel goes
 *  bevelSize:    <float>,    // how far from text outline is bevel
 *  }
 *
 */

/*  Usage Examples

  // TextGeometry wrapper

  var text3d = new TextGeometry( text, options );

  // Complete manner

  var textShapes = THREE.FontUtils.generateShapes( text, options );
  var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

  parameters = parameters || {};

  var textShapes = THREE.FontUtils.generateShapes( text, parameters );

  // translate parameters to ExtrudeGeometry API

  parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  // defaults

  if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  THREE.ExtrudeGeometry.call( this, textShapes, parameters );

  this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

  THREE.Geometry.call( this );

  this.type = 'TorusGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 8;
  tubularSegments = tubularSegments || 6;
  arc = arc || Math.PI * 2;

  var center = new THREE.Vector3(), uvs = [], normals = [];

  for ( var j = 0; j <= radialSegments; j ++ ) {

    for ( var i = 0; i <= tubularSegments; i ++ ) {

      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;

      center.x = radius * Math.cos( u );
      center.y = radius * Math.sin( u );

      var vertex = new THREE.Vector3();
      vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
      vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
      vertex.z = tube * Math.sin( v );

      this.vertices.push( vertex );

      uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
      normals.push( vertex.clone().sub( center ).normalize() );

    }

  }

  for ( var j = 1; j <= radialSegments; j ++ ) {

    for ( var i = 1; i <= tubularSegments; i ++ ) {

      var a = ( tubularSegments + 1 ) * j + i - 1;
      var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
      var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
      var d = ( tubularSegments + 1 ) * j + i;

      var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

      face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

    }

  }

  this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function () {

  var geometry = new THREE.TorusGeometry(
    this.parameters.radius,
    this.parameters.tube,
    this.parameters.radialSegments,
    this.parameters.tubularSegments,
    this.parameters.arc
  );

  return geometry;

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

  THREE.Geometry.call( this );

  this.type = 'TorusKnotGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    p: p,
    q: q,
    heightScale: heightScale
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 64;
  tubularSegments = tubularSegments || 8;
  p = p || 2;
  q = q || 3;
  heightScale = heightScale || 1;

  var grid = new Array( radialSegments );
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();

  for ( var i = 0; i < radialSegments; ++ i ) {

    grid[ i ] = new Array( tubularSegments );
    var u = i / radialSegments * 2 * p * Math.PI;
    var p1 = getPos( u, q, p, radius, heightScale );
    var p2 = getPos( u + 0.01, q, p, radius, heightScale );
    tang.subVectors( p2, p1 );
    n.addVectors( p2, p1 );

    bitan.crossVectors( tang, n );
    n.crossVectors( bitan, tang );
    bitan.normalize();
    n.normalize();

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var v = j / tubularSegments * 2 * Math.PI;
      var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      var cy = tube * Math.sin( v );

      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;

      grid[ i ][ j ] = this.vertices.push( pos ) - 1;

    }

  }

  for ( var i = 0; i < radialSegments; ++ i ) {

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var ip = ( i + 1 ) % radialSegments;
      var jp = ( j + 1 ) % tubularSegments;

      var a = grid[ i ][ j ];
      var b = grid[ ip ][ j ];
      var c = grid[ ip ][ jp ];
      var d = grid[ i ][ jp ];

      var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
      var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
      var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
      var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  this.computeFaceNormals();
  this.computeVertexNormals();

  function getPos( u, in_q, in_p, radius, heightScale ) {

    var cu = Math.cos( u );
    var su = Math.sin( u );
    var quOverP = in_q / in_p * u;
    var cs = Math.cos( quOverP );

    var tx = radius * ( 2 + cs ) * 0.5 * cu;
    var ty = radius * ( 2 + cs ) * su * 0.5;
    var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

    return new THREE.Vector3( tx, ty, tz );

  }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function () {

  var geometry = new THREE.TorusKnotGeometry(
    this.parameters.radius,
    this.parameters.tube,
    this.parameters.radialSegments,
    this.parameters.tubularSegments,
    this.parameters.p,
    this.parameters.q,
    this.parameters.heightScale
  );

  return geometry;

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

  THREE.Geometry.call( this );

  this.type = 'TubeGeometry';

  this.parameters = {
    path: path,
    segments: segments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };

  segments = segments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  taper = taper || THREE.TubeGeometry.NoTaper;

  var grid = [];

  var scope = this,

    tangent,
    normal,
    binormal,

    numpoints = segments + 1,

    u, v, r,

    cx, cy,
    pos, pos2 = new THREE.Vector3(),
    i, j,
    ip, jp,
    a, b, c, d,
    uva, uvb, uvc, uvd;

  var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
    tangents = frames.tangents,
    normals = frames.normals,
    binormals = frames.binormals;

  // proxy internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  function vert( x, y, z ) {

    return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

  }

  // construct the grid

  for ( i = 0; i < numpoints; i ++ ) {

    grid[ i ] = [];

    u = i / ( numpoints - 1 );

    pos = path.getPointAt( u );

    tangent = tangents[ i ];
    normal = normals[ i ];
    binormal = binormals[ i ];

    r = radius * taper( u );

    for ( j = 0; j < radialSegments; j ++ ) {

      v = j / radialSegments * 2 * Math.PI;

      cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      cy = r * Math.sin( v );

      pos2.copy( pos );
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;

      grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    }

  }


  // construct the mesh

  for ( i = 0; i < segments; i ++ ) {

    for ( j = 0; j < radialSegments; j ++ ) {

      ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
      jp = ( j + 1 ) % radialSegments;

      a = grid[ i ][ j ];   // *** NOT NECESSARILY PLANAR ! ***
      b = grid[ ip ][ j ];
      c = grid[ ip ][ jp ];
      d = grid[ i ][ jp ];

      uva = new THREE.Vector2( i / segments, j / radialSegments );
      uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
      uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
      uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function ( u ) {

  return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

  return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

  var normal = new THREE.Vector3(),

    tangents = [],
    normals = [],
    binormals = [],

    vec = new THREE.Vector3(),
    mat = new THREE.Matrix4(),

    numpoints = segments + 1,
    theta,
    epsilon = 0.0001,
    smallest,

    tx, ty, tz,
    i, u;


  // expose internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  // compute the tangent vectors for each segment on the path

  for ( i = 0; i < numpoints; i ++ ) {

    u = i / ( numpoints - 1 );

    tangents[ i ] = path.getTangentAt( u );
    tangents[ i ].normalize();

  }

  initialNormal3();

  /*
  function initialNormal1(lastBinormal) {
    // fixed start binormal. Has dangers of 0 vectors
    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
  }

  function initialNormal2() {

    // This uses the Frenet-Serret formula for deriving binormal
    var t2 = path.getTangentAt( epsilon );

    normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

  }
  */

  function initialNormal3() {

    // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the smallest tangent xyz component

    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs( tangents[ 0 ].x );
    ty = Math.abs( tangents[ 0 ].y );
    tz = Math.abs( tangents[ 0 ].z );

    if ( tx <= smallest ) {

      smallest = tx;
      normal.set( 1, 0, 0 );

    }

    if ( ty <= smallest ) {

      smallest = ty;
      normal.set( 0, 1, 0 );

    }

    if ( tz <= smallest ) {

      normal.set( 0, 0, 1 );

    }

    vec.crossVectors( tangents[ 0 ], normal ).normalize();

    normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

  }


  // compute the slowly-varying normal and binormal vectors for each segment on the path

  for ( i = 1; i < numpoints; i ++ ) {

    normals[ i ] = normals[ i - 1 ].clone();

    binormals[ i ] = binormals[ i - 1 ].clone();

    vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    if ( vec.length() > epsilon ) {

      vec.normalize();

      theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

      normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    }

    binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  }


  // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  if ( closed ) {

    theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    theta /= ( numpoints - 1 );

    if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

      theta = - theta;

    }

    for ( i = 1; i < numpoints; i ++ ) {

      // twist a little...
      normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
      binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }

  }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

  THREE.Geometry.call( this );

  this.type = 'PolyhedronGeometry';

  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };

  radius = radius || 1;
  detail = detail || 0;

  var that = this;

  for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

  }

  var p = this.vertices;

  var faces = [];

  for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    var v1 = p[ indices[ i ] ];
    var v2 = p[ indices[ i + 1 ] ];
    var v3 = p[ indices[ i + 2 ] ];

    faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

  }

  var centroid = new THREE.Vector3();

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    subdivide( faces[ i ], detail );

  }


  // Handle case when face straddles the seam

  for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    var uvs = this.faceVertexUvs[ 0 ][ i ];

    var x0 = uvs[ 0 ].x;
    var x1 = uvs[ 1 ].x;
    var x2 = uvs[ 2 ].x;

    var max = Math.max( x0, Math.max( x1, x2 ) );
    var min = Math.min( x0, Math.min( x1, x2 ) );

    if ( max > 0.9 && min < 0.1 ) {

      // 0.9 is somewhat arbitrary

      if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
      if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
      if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    }

  }


  // Apply radius

  for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    this.vertices[ i ].multiplyScalar( radius );

  }


  // Merge vertices

  this.mergeVertices();

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


  // Project vector onto sphere's surface

  function prepare( vector ) {

    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push( vertex ) - 1;

    // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    var v = inclination( vector ) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2( u, 1 - v );

    return vertex;

  }


  // Approximate a curved face with recursively sub-divided triangles.

  function make( v1, v2, v3, materialIndex ) {

    var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
    that.faces.push( face );

    centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    var azi = azimuth( centroid );

    that.faceVertexUvs[ 0 ].push( [
      correctUV( v1.uv, v1, azi ),
      correctUV( v2.uv, v2, azi ),
      correctUV( v3.uv, v3, azi )
    ] );

  }


  // Analytically subdivide a face to the required detail level.

  function subdivide( face, detail ) {

    var cols = Math.pow( 2, detail );
    var a = prepare( that.vertices[ face.a ] );
    var b = prepare( that.vertices[ face.b ] );
    var c = prepare( that.vertices[ face.c ] );
    var v = [];

    var materialIndex = face.materialIndex;

    // Construct all of the vertices for this subdivision.

    for ( var i = 0 ; i <= cols; i ++ ) {

      v[ i ] = [];

      var aj = prepare( a.clone().lerp( c, i / cols ) );
      var bj = prepare( b.clone().lerp( c, i / cols ) );
      var rows = cols - i;

      for ( var j = 0; j <= rows; j ++ ) {

        if ( j === 0 && i === cols ) {

          v[ i ][ j ] = aj;

        } else {

          v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

        }

      }

    }

    // Construct all of the faces.

    for ( var i = 0; i < cols ; i ++ ) {

      for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

        var k = Math.floor( j / 2 );

        if ( j % 2 === 0 ) {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1 ][ k ],
            v[ i ][ k ],
            materialIndex
          );

        } else {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1 ][ k + 1 ],
            v[ i + 1 ][ k ],
            materialIndex
          );

        }

      }

    }

  }


  // Angle around the Y axis, counter-clockwise when looking from above.

  function azimuth( vector ) {

    return Math.atan2( vector.z, - vector.x );

  }


  // Angle above the XZ plane.

  function inclination( vector ) {

    return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  }


  // Texture fixing helper. Spheres have some odd behaviours.

  function correctUV( uv, vector, azimuth ) {

    if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
    if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    return uv.clone();

  }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function () {

  var geometry = new THREE.PolyhedronGeometry(
    this.parameters.vertices,
    this.parameters.indices,
    this.parameters.radius,
    this.parameters.detail
  );

  return geometry.copy( this );

};

THREE.PolyhedronGeometry.prototype.copy = function ( source ) {

  THREE.Geometry.prototype.copy.call( this, source );
  return this;

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  var r = 1 / t;

  var vertices = [

    // (±1, ±1, ±1)
    - 1, - 1, - 1,    - 1, - 1,  1,
    - 1,  1, - 1,    - 1,  1,  1,
     1, - 1, - 1,     1, - 1,  1,
     1,  1, - 1,     1,  1,  1,

    // (0, ±1/φ, ±φ)
     0, - r, - t,     0, - r,  t,
     0,  r, - t,     0,  r,  t,

    // (±1/φ, ±φ, 0)
    - r, - t,  0,    - r,  t,  0,
     r, - t,  0,     r,  t,  0,

    // (±φ, 0, ±1/φ)
    - t,  0, - r,     t,  0, - r,
    - t,  0,  r,     t,  0,  r
  ];

  var indices = [
     3, 11,  7,      3,  7, 15,      3, 15, 13,
     7, 19, 17,      7, 17,  6,      7,  6, 15,
    17,  4,  8,     17,  8, 10,     17, 10,  6,
     8,  0, 16,      8, 16,  2,      8,  2, 10,
     0, 12,  1,      0,  1, 18,      0, 18, 16,
     6, 10,  2,      6,  2, 13,      6, 13, 15,
     2, 16, 18,      2, 18,  3,      2,  3, 13,
    18,  1,  9,     18,  9, 11,     18, 11,  3,
     4, 14, 12,      4, 12,  0,      4,  0,  8,
    11,  9,  5,     11,  5, 19,     11, 19,  7,
    19,  5, 14,     19, 14,  4,     19,  4, 17,
     1, 12, 14,      1, 14,  5,      1,  5,  9
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'DodecahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function () {

  var geometry = new THREE.DodecahedronGeometry(
    this.parameters.radius,
    this.parameters.detail
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  var vertices = [
    - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
     0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
     t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  ];

  var indices = [
     0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
     1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
     3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
     4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'IcosahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function () {

  var geometry = new THREE.IcosahedronGeometry(
    this.parameters.radius,
    this.parameters.detail
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

  var vertices = [
    1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
  ];

  var indices = [
    0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'OctahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function () {

  var geometry = new THREE.OctahedronGeometry(
    this.parameters.radius,
    this.parameters.detail
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

  var vertices = [
     1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
  ];

  var indices = [
     2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'TetrahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function () {

  var geometry = new THREE.TetrahedronGeometry(
    this.parameters.radius,
    this.parameters.detail
  );

  geometry.copy( this );

  return geometry;

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

  THREE.Geometry.call( this );

  this.type = 'ParametricGeometry';

  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };

  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[ 0 ];

  var i, j, p;
  var u, v;

  var sliceCount = slices + 1;

  for ( i = 0; i <= stacks; i ++ ) {

    v = i / stacks;

    for ( j = 0; j <= slices; j ++ ) {

      u = j / slices;

      p = func( u, v );
      verts.push( p );

    }

  }

  var a, b, c, d;
  var uva, uvb, uvc, uvd;

  for ( i = 0; i < stacks; i ++ ) {

    for ( j = 0; j < slices; j ++ ) {

      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = ( i + 1 ) * sliceCount + j + 1;
      d = ( i + 1 ) * sliceCount + j;

      uva = new THREE.Vector2( j / slices, i / stacks );
      uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
      uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
      uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

      faces.push( new THREE.Face3( a, b, d ) );
      uvs.push( [ uva, uvb, uvd ] );

      faces.push( new THREE.Face3( b, c, d ) );
      uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  // console.log(this);

  // magic bullet
  // var diff = this.mergeVertices();
  // console.log('removed ', diff, ' vertices by merging');

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

  THREE.BufferGeometry.call( this );

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) {

    return a - b;

  };

  var keys = [ 'a', 'b', 'c' ];

  if ( geometry instanceof THREE.Geometry ) {

    var vertices = geometry.vertices;
    var faces = geometry.faces;
    var numEdges = 0;

    // allocate maximal size
    var edges = new Uint32Array( 6 * faces.length );

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0; j < 3; j ++ ) {

        edge[ 0 ] = face[ keys[ j ] ];
        edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
        edge.sort( sortFunction );

        var key = edge.toString();

        if ( hash[ key ] === undefined ) {

          edges[ 2 * numEdges ] = edge[ 0 ];
          edges[ 2 * numEdges + 1 ] = edge[ 1 ];
          hash[ key ] = true;
          numEdges ++;

        }

      }

    }

    var coords = new Float32Array( numEdges * 2 * 3 );

    for ( var i = 0, l = numEdges; i < l; i ++ ) {

      for ( var j = 0; j < 2; j ++ ) {

        var vertex = vertices[ edges [ 2 * i + j ] ];

        var index = 6 * i + 3 * j;
        coords[ index + 0 ] = vertex.x;
        coords[ index + 1 ] = vertex.y;
        coords[ index + 2 ] = vertex.z;

      }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

  } else if ( geometry instanceof THREE.BufferGeometry ) {

    if ( geometry.attributes.index !== undefined ) {

      // Indexed BufferGeometry

      var vertices = geometry.attributes.position;
      var indices = geometry.attributes.index.array;
      var drawcalls = geometry.drawcalls;
      var numEdges = 0;

      if ( drawcalls.length === 0 ) {

        geometry.addDrawCall( 0, indices.length );

      }

      // allocate maximal size
      var edges = new Uint32Array( 2 * indices.length );

      for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

        var drawcall = drawcalls[ o ];

        var start = drawcall.start;
        var count = drawcall.count;

        for ( var i = start, il = start + count; i < il; i += 3 ) {

          for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = indices[ i + j ];
            edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

              edges[ 2 * numEdges ] = edge[ 0 ];
              edges[ 2 * numEdges + 1 ] = edge[ 1 ];
              hash[ key ] = true;
              numEdges ++;

            }

          }

        }

      }

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numEdges; i < l; i ++ ) {

        for ( var j = 0; j < 2; j ++ ) {

          var index = 6 * i + 3 * j;
          var index2 = edges[ 2 * i + j ];

          coords[ index + 0 ] = vertices.getX( index2 );
          coords[ index + 1 ] = vertices.getY( index2 );
          coords[ index + 2 ] = vertices.getZ( index2 );

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else {

      // non-indexed BufferGeometry

      var vertices = geometry.attributes.position.array;
      var numEdges = vertices.length / 3;
      var numTris = numEdges / 3;

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numTris; i < l; i ++ ) {

        for ( var j = 0; j < 3; j ++ ) {

          var index = 18 * i + 6 * j;

          var index1 = 9 * i + 3 * j;
          coords[ index + 0 ] = vertices[ index1 ];
          coords[ index + 1 ] = vertices[ index1 + 1 ];
          coords[ index + 2 ] = vertices[ index1 + 2 ];

          var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
          coords[ index + 3 ] = vertices[ index2 ];
          coords[ index + 4 ] = vertices[ index2 + 1 ];
          coords[ index + 5 ] = vertices[ index2 + 2 ];

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }

  }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

  size = size || 1;

  var vertices = new Float32Array( [
    0, 0, 0,  size, 0, 0,
    0, 0, 0,  0, size, 0,
    0, 0, 0,  0, 0, size
  ] );

  var colors = new Float32Array( [
    1, 0, 0,  1, 0.6, 0,
    0, 1, 0,  0.6, 1, 0,
    0, 0, 1,  0, 0.6, 1
  ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

  var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
  coneGeometry.translate( 0, - 0.5, 0 );

  return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    // dir is assumed to be normalized

    THREE.Object3D.call( this );

    if ( color === undefined ) color = 0xffff00;
    if ( length === undefined ) length = 1;
    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    this.position.copy( origin );

    this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
    this.line.matrixAutoUpdate = false;
    this.add( this.line );

    this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
    this.cone.matrixAutoUpdate = false;
    this.add( this.cone );

    this.setDirection( dir );
    this.setLength( length, headLength, headWidth );

  }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

  var axis = new THREE.Vector3();
  var radians;

  return function setDirection( dir ) {

    // dir is assumed to be normalized

    if ( dir.y > 0.99999 ) {

      this.quaternion.set( 0, 0, 0, 1 );

    } else if ( dir.y < - 0.99999 ) {

      this.quaternion.set( 1, 0, 0, 0 );

    } else {

      axis.set( dir.z, 0, - dir.x ).normalize();

      radians = Math.acos( dir.y );

      this.quaternion.setFromAxisAngle( axis, radians );

    }

  };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  if ( headLength === undefined ) headLength = 0.2 * length;
  if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  this.line.scale.set( 1, length - headLength, 1 );
  this.line.updateMatrix();

  this.cone.scale.set( headWidth, headLength, headWidth );
  this.cone.position.y = length;
  this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

  this.line.material.color.set( color );
  this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

  if ( object !== undefined ) {

    this.update( object );

  }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

  var box = new THREE.Box3();

  return function ( object ) {

    box.setFromObject( object );

    if ( box.empty() ) return;

    var min = box.min;
    var max = box.max;

    /*
      5____4
    1/___0/|
    | 6__|_7
    2/___3/

    0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    var vertices = this.geometry.attributes.position.array;

    vertices[ 0 ] = max.x; vertices[ 1 ] = max.y; vertices[ 2 ] = max.z;
    vertices[ 3 ] = min.x; vertices[ 4 ] = max.y; vertices[ 5 ] = max.z;

    vertices[ 6 ] = min.x; vertices[ 7 ] = max.y; vertices[ 8 ] = max.z;
    vertices[ 9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

    vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
    vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

    vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
    vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

    //

    vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
    vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

    vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
    vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

    vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
    vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

    vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
    vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

    //

    vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
    vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

    vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
    vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

    vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
    vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

    vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
    vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

    this.geometry.attributes.position.needsUpdate = true;

    this.geometry.computeBoundingSphere();

  }

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0x888888;

  this.object = object;

  this.box = new THREE.Box3();

  THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

  this.box.setFromObject( this.object );

  this.box.size( this.scale );

  this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *  - shows frustum, line of sight and up of the camera
 *  - suitable for fast updates
 *  - based on frustum visualization in lightgl.js shadowmap example
 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

  var pointMap = {};

  // colors

  var hexFrustum = 0xffaa00;
  var hexCone = 0xff0000;
  var hexUp = 0x00aaff;
  var hexTarget = 0xffffff;
  var hexCross = 0x333333;

  // near

  addLine( "n1", "n2", hexFrustum );
  addLine( "n2", "n4", hexFrustum );
  addLine( "n4", "n3", hexFrustum );
  addLine( "n3", "n1", hexFrustum );

  // far

  addLine( "f1", "f2", hexFrustum );
  addLine( "f2", "f4", hexFrustum );
  addLine( "f4", "f3", hexFrustum );
  addLine( "f3", "f1", hexFrustum );

  // sides

  addLine( "n1", "f1", hexFrustum );
  addLine( "n2", "f2", hexFrustum );
  addLine( "n3", "f3", hexFrustum );
  addLine( "n4", "f4", hexFrustum );

  // cone

  addLine( "p", "n1", hexCone );
  addLine( "p", "n2", hexCone );
  addLine( "p", "n3", hexCone );
  addLine( "p", "n4", hexCone );

  // up

  addLine( "u1", "u2", hexUp );
  addLine( "u2", "u3", hexUp );
  addLine( "u3", "u1", hexUp );

  // target

  addLine( "c", "t", hexTarget );
  addLine( "p", "c", hexCross );

  // cross

  addLine( "cn1", "cn2", hexCross );
  addLine( "cn3", "cn4", hexCross );

  addLine( "cf1", "cf2", hexCross );
  addLine( "cf3", "cf4", hexCross );

  function addLine( a, b, hex ) {

    addPoint( a, hex );
    addPoint( b, hex );

  }

  function addPoint( id, hex ) {

    geometry.vertices.push( new THREE.Vector3() );
    geometry.colors.push( new THREE.Color( hex ) );

    if ( pointMap[ id ] === undefined ) {

      pointMap[ id ] = [];

    }

    pointMap[ id ].push( geometry.vertices.length - 1 );

  }

  THREE.LineSegments.call( this, geometry, material );

  this.camera = camera;
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;

  this.pointMap = pointMap;

  this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

  var geometry, pointMap;

  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();

  var setPoint = function ( point, x, y, z ) {

    vector.set( x, y, z ).unproject( camera );

    var points = pointMap[ point ];

    if ( points !== undefined ) {

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        geometry.vertices[ points[ i ] ].copy( vector );

      }

    }

  };

  return function () {

    geometry = this.geometry;
    pointMap = this.pointMap;

    var w = 1, h = 1;

    // we need just camera projection matrix
    // world matrix must be identity

    camera.projectionMatrix.copy( this.camera.projectionMatrix );

    // center / target

    setPoint( "c", 0, 0, - 1 );
    setPoint( "t", 0, 0,  1 );

    // near

    setPoint( "n1", - w, - h, - 1 );
    setPoint( "n2",   w, - h, - 1 );
    setPoint( "n3", - w,   h, - 1 );
    setPoint( "n4",   w,   h, - 1 );

    // far

    setPoint( "f1", - w, - h, 1 );
    setPoint( "f2",   w, - h, 1 );
    setPoint( "f3", - w,   h, 1 );
    setPoint( "f4",   w,   h, 1 );

    // up

    setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    setPoint( "u3",         0, h * 2,   - 1 );

    // cross

    setPoint( "cf1", - w,   0, 1 );
    setPoint( "cf2",   w,   0, 1 );
    setPoint( "cf3",   0, - h, 1 );
    setPoint( "cf4",   0,   h, 1 );

    setPoint( "cn1", - w,   0, - 1 );
    setPoint( "cn2",   w,   0, - 1 );
    setPoint( "cn3",   0, - h, - 1 );
    setPoint( "cn4",   0,   h, - 1 );

    geometry.verticesNeedUpdate = true;

  };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  size = size || 1;

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3( - size,   size, 0 ),
    new THREE.Vector3(   size,   size, 0 ),
    new THREE.Vector3(   size, - size, 0 ),
    new THREE.Vector3( - size, - size, 0 ),
    new THREE.Vector3( - size,   size, 0 )
  );

  var material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.lightPlane = new THREE.Line( geometry, material );
  this.add( this.lightPlane );

  geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(),
    new THREE.Vector3()
  );

  material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.targetLine = new THREE.Line( geometry, material );
  this.add( this.targetLine );

  this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var v3 = new THREE.Vector3();

  return function () {

    v1.setFromMatrixPosition( this.light.matrixWorld );
    v2.setFromMatrixPosition( this.light.target.matrixWorld );
    v3.subVectors( v2, v1 );

    this.lightPlane.lookAt( v3 );
    this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine.geometry.vertices[ 1 ].copy( v3 );
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy( this.lightPlane.material.color );

  };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

  // FaceNormalsHelper only supports THREE.Geometry

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xffff00;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  //

  var nNormals = 0;

  var objGeometry = this.object.geometry;

  if ( objGeometry instanceof THREE.Geometry ) {

    nNormals = objGeometry.faces.length;

  } else {

    console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

  }

  //

  var geometry = new THREE.BufferGeometry();

  var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

  geometry.addAttribute( 'position', positions );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  //

  this.matrixAutoUpdate = false;
  this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var normalMatrix = new THREE.Matrix3();

  return function update() {

    this.object.updateMatrixWorld( true );

    normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var matrixWorld = this.object.matrixWorld;

    var position = this.geometry.attributes.position;

    //

    var objGeometry = this.object.geometry;

    var vertices = objGeometry.vertices;

    var faces = objGeometry.faces;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      var normal = face.normal;

      v1.copy( vertices[ face.a ] )
        .add( vertices[ face.b ] )
        .add( vertices[ face.c ] )
        .divideScalar( 3 )
        .applyMatrix4( matrixWorld );

      v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

      position.setXYZ( idx, v1.x, v1.y, v1.z );

      idx = idx + 1;

      position.setXYZ( idx, v2.x, v2.y, v2.z );

      idx = idx + 1;

    }

    position.needsUpdate = true;

    return this;

  }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  this.color1 = new THREE.Color( 0x444444 );
  this.color2 = new THREE.Color( 0x888888 );

  for ( var i = - size; i <= size; i += step ) {

    geometry.vertices.push(
      new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
      new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
    );

    var color = i === 0 ? this.color1 : this.color2;

    geometry.colors.push( color, color, color, color );

  }

  THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

  this.color1.set( colorCenterLine );
  this.color2.set( colorGrid );

  this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  this.colors = [ new THREE.Color(), new THREE.Color() ];

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  geometry.rotateX( - Math.PI / 2 );

  for ( var i = 0, il = 8; i < il; i ++ ) {

    geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

  }

  var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

  this.lightSphere = new THREE.Mesh( geometry, material );
  this.add( this.lightSphere );

  this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();

  return function () {

    this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    this.lightSphere.geometry.colorsNeedUpdate = true;

  }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

  this.light = light;
  this.light.updateMatrixWorld();

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  THREE.Mesh.call( this, geometry, material );

  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;

  /*
  var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  var d = light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.scale.set( d, d, d );

  }

  this.add( this.lightDistance );
  */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

  this.geometry.dispose();
  this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

  this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  /*
  var d = this.light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.visible = true;
    this.lightDistance.scale.set( d, d, d );

  }
  */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

  this.bones = this.getBoneList( object );

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );
      geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
      geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

    }

  }

  geometry.dynamic = true;

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  THREE.LineSegments.call( this, geometry, material );

  this.root = object;

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

  this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

  var boneList = [];

  if ( object instanceof THREE.Bone ) {

    boneList.push( object );

  }

  for ( var i = 0; i < object.children.length; i ++ ) {

    boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

  }

  return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

  var geometry = this.geometry;

  var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

  var boneMatrix = new THREE.Matrix4();

  var j = 0;

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
      geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
      geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

      j += 2;

    }

  }

  geometry.verticesNeedUpdate = true;

  geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

  geometry.translate( 0, - 0.5, 0 );
  geometry.rotateX( - Math.PI / 2 );

  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

  this.cone = new THREE.Mesh( geometry, material );
  this.add( this.cone );

  this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

  this.cone.geometry.dispose();
  this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();

  return function () {

    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan( this.light.angle );

    this.cone.scale.set( coneWidth, coneWidth, coneLength );

    vector.setFromMatrixPosition( this.light.matrixWorld );
    vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    this.cone.lookAt( vector2.sub( vector ) );

    this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xff0000;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  //

  var nNormals = 0;

  var objGeometry = this.object.geometry;

  if ( objGeometry instanceof THREE.Geometry ) {

    nNormals = objGeometry.faces.length * 3;

  } else if ( objGeometry instanceof THREE.BufferGeometry ) {

    nNormals = objGeometry.attributes.normal.count

  }

  //

  var geometry = new THREE.BufferGeometry();

  var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

  geometry.addAttribute( 'position', positions );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  //

  this.matrixAutoUpdate = false;

  this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var normalMatrix = new THREE.Matrix3();

  return function update() {

    var keys = [ 'a', 'b', 'c' ];

    this.object.updateMatrixWorld( true );

    normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var matrixWorld = this.object.matrixWorld;

    var position = this.geometry.attributes.position;

    //

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

      var vertices = objGeometry.vertices;

      var faces = objGeometry.faces;

      var idx = 0;

      for ( var i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

          var vertex = vertices[ face[ keys[ j ] ] ];

          var normal = face.vertexNormals[ j ];

          v1.copy( vertex ).applyMatrix4( matrixWorld );

          v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

          position.setXYZ( idx, v1.x, v1.y, v1.z );

          idx = idx + 1;

          position.setXYZ( idx, v2.x, v2.y, v2.z );

          idx = idx + 1;

        }

      }

    } else if ( objGeometry instanceof THREE.BufferGeometry ) {

      var objPos = objGeometry.attributes.position;

      var objNorm = objGeometry.attributes.normal;

      var idx = 0;

      // for simplicity, ignore index and drawcalls, and render every normal

      for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

        v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

        v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

        v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

        position.setXYZ( idx, v1.x, v1.y, v1.z );

        idx = idx + 1;

        position.setXYZ( idx, v2.x, v2.y, v2.z );

        idx = idx + 1;

      }

    }

    position.needsUpdate = true;

    return this;

  }

}() );

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0x0000ff;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  //

  var nTangents = 0;

  var objGeometry = this.object.geometry;

  if ( objGeometry instanceof THREE.Geometry ) {

    nTangents = objGeometry.faces.length * 3;

  } else if ( objGeometry instanceof THREE.BufferGeometry ) {

    nTangents = objGeometry.attributes.tangent.count

  }

  //

  var geometry = new THREE.BufferGeometry();

  var positions = new THREE.Float32Attribute( nTangents * 2 * 3, 3 );

  geometry.addAttribute( 'position', positions );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  //

  this.matrixAutoUpdate = false;

  this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function() {

    var keys = [ 'a', 'b', 'c' ];

    this.object.updateMatrixWorld( true );

    var matrixWorld = this.object.matrixWorld;

    var position = this.geometry.attributes.position;

    //

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

      var vertices = objGeometry.vertices;

      var faces = objGeometry.faces;

      var idx = 0;

      for ( var i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

          var vertex = vertices[ face[ keys[ j ] ] ];

          var tangent = face.vertexTangents[ j ];

          v1.copy( vertex ).applyMatrix4( matrixWorld );

          v2.set( tangent.x, tangent.y, tangent.z ); // tangent.w used for bitangents only

          v2.transformDirection( matrixWorld ).multiplyScalar( this.size ).add( v1 );

          position.setXYZ( idx, v1.x, v1.y, v1.z );

          idx = idx + 1;

          position.setXYZ( idx, v2.x, v2.y, v2.z );

          idx = idx + 1;

        }

      }

    } else if ( objGeometry instanceof THREE.BufferGeometry ) {

      var objPos = objGeometry.attributes.position;

      var objTan = objGeometry.attributes.tangent;

      var idx = 0;

      // for simplicity, ignore index and drawcalls, and render every tangent

      for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

        v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

        v2.set( objTan.getX( j ), objTan.getY( j ), objTan.getZ( j ) ); // tangent.w used for bitangents only

        v2.transformDirection( matrixWorld ).multiplyScalar( this.size ).add( v1 );

        position.setXYZ( idx, v1.x, v1.y, v1.z );

        idx = idx + 1;

        position.setXYZ( idx, v2.x, v2.y, v2.z );

        idx = idx + 1;

      }

    }

    position.needsUpdate = true;

    return this;

  }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

  THREE.Object3D.call( this );

  this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.animationsMap = {};
  this.animationsList = [];

  // prepare default animation
  // (all frames played together in 1 second)

  var numFrames = this.geometry.morphTargets.length;

  var name = "__default";

  var startFrame = 0;
  var endFrame = numFrames - 1;

  var fps = numFrames / 1;

  this.createAnimation( name, startFrame, endFrame, fps );
  this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

  var animation = {

    start: start,
    end: end,

    length: end - start + 1,

    fps: fps,
    duration: ( end - start ) / fps,

    lastFrame: 0,
    currentFrame: 0,

    active: false,

    time: 0,
    direction: 1,
    weight: 1,

    directionBackwards: false,
    mirroredLoop: false

  };

  this.animationsMap[ name ] = animation;
  this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

  var pattern = /([a-z]+)_?(\d+)/;

  var firstAnimation, frameRanges = {};

  var geometry = this.geometry;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var chunks = morph.name.match( pattern );

    if ( chunks && chunks.length > 1 ) {

      var name = chunks[ 1 ];

      if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

      var range = frameRanges[ name ];

      if ( i < range.start ) range.start = i;
      if ( i > range.end ) range.end = i;

      if ( ! firstAnimation ) firstAnimation = name;

    }

  }

  for ( var name in frameRanges ) {

    var range = frameRanges[ name ];
    this.createAnimation( name, range.start, range.end, fps );

  }

  this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = 1;
    animation.directionBackwards = false;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = - 1;
    animation.directionBackwards = true;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.fps = fps;
    animation.duration = ( animation.end - animation.start ) / animation.fps;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.duration = duration;
    animation.fps = ( animation.end - animation.start ) / animation.duration;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.weight = weight;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = time;

  }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

  var time = 0;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    time = animation.time;

  }

  return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

  var duration = - 1;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    duration = animation.duration;

  }

  return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = 0;
    animation.active = true;

  } else {

    console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

  }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.active = false;

  }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

  for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    var animation = this.animationsList[ i ];

    if ( ! animation.active ) continue;

    var frameTime = animation.duration / animation.length;

    animation.time += animation.direction * delta;

    if ( animation.mirroredLoop ) {

      if ( animation.time > animation.duration || animation.time < 0 ) {

        animation.direction *= - 1;

        if ( animation.time > animation.duration ) {

          animation.time = animation.duration;
          animation.directionBackwards = true;

        }

        if ( animation.time < 0 ) {

          animation.time = 0;
          animation.directionBackwards = false;

        }

      }

    } else {

      animation.time = animation.time % animation.duration;

      if ( animation.time < 0 ) animation.time += animation.duration;

    }

    var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    var weight = animation.weight;

    if ( keyframe !== animation.currentFrame ) {

      this.morphTargetInfluences[ animation.lastFrame ] = 0;
      this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

      this.morphTargetInfluences[ keyframe ] = 0;

      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;

    }

    var mix = ( animation.time % frameTime ) / frameTime;

    if ( animation.directionBackwards ) mix = 1 - mix;

    if ( animation.currentFrame !== animation.lastFrame ) {

      this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
      this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

    } else {

      this.morphTargetInfluences[ animation.currentFrame ] = weight;

    }

  }

};


},{}],25:[function(require,module,exports){
/*! (C) WebReflection Mit Style License */
(function(e,t,n,r){"use strict";function rt(e,t){for(var n=0,r=e.length;n<r;n++)dt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(dt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute("is"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is="'+t+'"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.prevValue,i=e.newValue;Q&&t.attributeChangedCallback&&e.attrName!=="style"&&t.attributeChangedCallback(e.attrName,n===e[a]?null:r,n===e[l]?null:i)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(F.splice(t,1),dt(e,o))}function dt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+"Callback"])&&n.call(e))}if(r in t)return;var i="__"+r+(Math.random()*1e5>>0),s="attached",o="detached",u="extends",a="ADDITION",f="MODIFICATION",l="REMOVAL",c="DOMAttrModified",h="DOMContentLoaded",p="DOMSubtreeModified",d="<",v="=",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=["ANNOTATION-XML","COLOR-PROFILE","FONT-FACE","FONT-FACE-SRC","FONT-FACE-URI","FONT-FACE-FORMAT","FONT-FACE-NAME","MISSING-GLYPH"],y=[],b=[],w="",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function vt(e){return e?(vt.prototype=e,new vt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,"addEventListener"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:"class",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,"propertychange",s)),t.call(this,e,o,u)},C(H,"addEventListener",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!=="setAttribute"&&(r[n]=t.value);return r})),t[r]=function(n,r){p=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o=0,u=r.length;o<u;o++)i=r[o],i.type==="childList"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!=="style"&&s.attributeChangedCallback(i.attributeName,i.oldValue,s.getAttribute(i.attributeName)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener("DOMNodeInserted",ft(s)),t.addEventListener("DOMNodeRemoved",ft(o))),t.addEventListener(h,lt),t.addEventListener("readystatechange",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=""+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute("is",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t});if(-2<S.call(y,v+p)+S.call(y,d+p))throw new Error("A "+n+" type is already registered");if(!m.test(p)||-1<S.call(g,p))throw new Error("The type "+n+" is invalid");var i=function(){return f?t.createElement(l,p):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():p,c=y.push((f?v:d)+p)-1,p;return w=w.concat(w.length?",":"",f?l+'[is="'+n.toLowerCase()+'"]':l),i.prototype=b[c]=T.call(a,"prototype")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,"registerElement");
},{}],26:[function(require,module,exports){
/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/sole/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/sole/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

// performance.now polyfill
( function ( root ) {

	if ( 'performance' in root === false ) {
		root.performance = {};
	}

	// IE 8
	Date.now = ( Date.now || function () {
		return new Date().getTime();
	} );

	if ( 'now' in root.performance === false ) {
		var offset = root.performance.timing && root.performance.timing.navigationStart ? performance.timing.navigationStart
		                                                                                : Date.now();

		root.performance.now = function () {
			return Date.now() - offset;
		};
	}

} )( this );

var TWEEN = TWEEN || ( function () {

	var _tweens = [];

	return {

		REVISION: '14',

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		add: function ( tween ) {

			_tweens.push( tween );

		},

		remove: function ( tween ) {

			var i = _tweens.indexOf( tween );

			if ( i !== -1 ) {

				_tweens.splice( i, 1 );

			}

		},

		update: function ( time ) {

			if ( _tweens.length === 0 ) return false;

			var i = 0;

			time = time !== undefined ? time : window.performance.now();

			while ( i < _tweens.length ) {

				if ( _tweens[ i ].update( time ) ) {

					i++;

				} else {

					_tweens.splice( i, 1 );

				}

			}

			return true;

		}
	};

} )();

TWEEN.Tween = function ( object ) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	// Set all starting values present on the target object
	for ( var field in object ) {

		_valuesStart[ field ] = parseFloat(object[field], 10);

	}

	this.to = function ( properties, duration ) {

		if ( duration !== undefined ) {

			_duration = duration;

		}

		_valuesEnd = properties;

		return this;

	};

	this.start = function ( time ) {

		TWEEN.add( this );

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : window.performance.now();
		_startTime += _delayTime;

		for ( var property in _valuesEnd ) {

			// check if an Array was provided as property value
			if ( _valuesEnd[ property ] instanceof Array ) {

				if ( _valuesEnd[ property ].length === 0 ) {

					continue;

				}

				// create a local copy of the Array with the start value at the front
				_valuesEnd[ property ] = [ _object[ property ] ].concat( _valuesEnd[ property ] );

			}

			_valuesStart[ property ] = _object[ property ];

			if( ( _valuesStart[ property ] instanceof Array ) === false ) {
				_valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;

		}

		return this;

	};

	this.stop = function () {

		if ( !_isPlaying ) {
			return this;
		}

		TWEEN.remove( this );
		_isPlaying = false;

		if ( _onStopCallback !== null ) {

			_onStopCallback.call( _object );

		}

		this.stopChainedTweens();
		return this;

	};

	this.stopChainedTweens = function () {

		for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

			_chainedTweens[ i ].stop();

		}

	};

	this.delay = function ( amount ) {

		_delayTime = amount;
		return this;

	};

	this.repeat = function ( times ) {

		_repeat = times;
		return this;

	};

	this.yoyo = function( yoyo ) {

		_yoyo = yoyo;
		return this;

	};


	this.easing = function ( easing ) {

		_easingFunction = easing;
		return this;

	};

	this.interpolation = function ( interpolation ) {

		_interpolationFunction = interpolation;
		return this;

	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;

	};

	this.onStart = function ( callback ) {

		_onStartCallback = callback;
		return this;

	};

	this.onUpdate = function ( callback ) {

		_onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function ( callback ) {

		_onCompleteCallback = callback;
		return this;

	};

	this.onStop = function ( callback ) {

		_onStopCallback = callback;
		return this;

	};

	this.update = function ( time ) {

		var property;

		if ( time < _startTime ) {

			return true;

		}

		if ( _onStartCallbackFired === false ) {

			if ( _onStartCallback !== null ) {

				_onStartCallback.call( _object );

			}

			_onStartCallbackFired = true;

		}

		var elapsed = ( time - _startTime ) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		var value = _easingFunction( elapsed );

		for ( property in _valuesEnd ) {

			var start = _valuesStart[ property ] || 0;
			var end = _valuesEnd[ property ];

			if ( end instanceof Array ) {

				_object[ property ] = _interpolationFunction( end, value );

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if ( typeof(end) === "string" ) {
					end = start + parseFloat(end, 10);
				}

				// protect against non numeric properties.
				if ( typeof(end) === "number" ) {
					_object[ property ] = start + ( end - start ) * value;
				}

			}

		}

		if ( _onUpdateCallback !== null ) {

			_onUpdateCallback.call( _object, value );

		}

		if ( elapsed == 1 ) {

			if ( _repeat > 0 ) {

				if( isFinite( _repeat ) ) {
					_repeat--;
				}

				// reassign starting values, restart by making startTime = now
				for( property in _valuesStartRepeat ) {

					if ( typeof( _valuesEnd[ property ] ) === "string" ) {
						_valuesStartRepeat[ property ] = _valuesStartRepeat[ property ] + parseFloat(_valuesEnd[ property ], 10);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[ property ];
						_valuesStartRepeat[ property ] = _valuesEnd[ property ];
						_valuesEnd[ property ] = tmp;
					}

					_valuesStart[ property ] = _valuesStartRepeat[ property ];

				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				_startTime = time + _delayTime;

				return true;

			} else {

				if ( _onCompleteCallback !== null ) {

					_onCompleteCallback.call( _object );

				}

				for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

					_chainedTweens[ i ].start( time );

				}

				return false;

			}

		}

		return true;

	};

};


TWEEN.Easing = {

	Linear: {

		None: function ( k ) {

			return k;

		}

	},

	Quadratic: {

		In: function ( k ) {

			return k * k;

		},

		Out: function ( k ) {

			return k * ( 2 - k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
			return - 0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic: {

		In: function ( k ) {

			return k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic: {

		In: function ( k ) {

			return k * k * k * k;

		},

		Out: function ( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
			return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic: {

		In: function ( k ) {

			return k * k * k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal: {

		In: function ( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out: function ( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut: function ( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential: {

		In: function ( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out: function ( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

		},

		InOut: function ( k ) {

			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
			return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular: {

		In: function ( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out: function ( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

		}

	},

	Back: {

		In: function ( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out: function ( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut: function ( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce: {

		In: function ( k ) {

			return 1 - TWEEN.Easing.Bounce.Out( 1 - k );

		},

		Out: function ( k ) {

			if ( k < ( 1 / 2.75 ) ) {

				return 7.5625 * k * k;

			} else if ( k < ( 2 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			} else if ( k < ( 2.5 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			} else {

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut: function ( k ) {

			if ( k < 0.5 ) return TWEEN.Easing.Bounce.In( k * 2 ) * 0.5;
			return TWEEN.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.Linear;

		if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
		if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

		return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

	},

	Bezier: function ( v, k ) {

		var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;

		for ( i = 0; i <= n; i++ ) {
			b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
		}

		return b;

	},

	CatmullRom: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.CatmullRom;

		if ( v[ 0 ] === v[ m ] ) {

			if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

			return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

		} else {

			if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
			if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

			return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

		}

	},

	Utils: {

		Linear: function ( p0, p1, t ) {

			return ( p1 - p0 ) * t + p0;

		},

		Bernstein: function ( n , i ) {

			var fc = TWEEN.Interpolation.Utils.Factorial;
			return fc( n ) / fc( i ) / fc( n - i );

		},

		Factorial: ( function () {

			var a = [ 1 ];

			return function ( n ) {

				var s = 1, i;
				if ( a[ n ] ) return a[ n ];
				for ( i = n; i > 1; i-- ) s *= i;
				return a[ n ] = s;

			};

		} )(),

		CatmullRom: function ( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	}

};

// UMD (Universal Module Definition)
( function ( root ) {

	if ( typeof define === 'function' && define.amd ) {

		// AMD
		define( [], function () {
			return TWEEN;
		} );

	} else if ( typeof exports === 'object' ) {

		// Node.js
		module.exports = TWEEN;

	} else {

		// Global variable
		root.TWEEN = TWEEN;

	}

} )( this );

},{}],27:[function(require,module,exports){
/* global Event, HTMLElement */

require('../vr-register-element');

module.exports = document.registerElement(
  'vr-assets',
  {
    prototype: Object.create(
      HTMLElement.prototype,
      {
        createdCallback: {
          value: function () {
            this.attachEventListeners();
          }
        },

        attachEventListeners: {
          value: function () {
            var self = this;
            var assetLoaded = this.assetLoaded.bind(this);
            this.assetsPending = 0;
            traverseDOM(this);
            function traverseDOM (node) {
              var tagName = node.tagName;
              if (node !== self && tagName && tagName.indexOf('VR-') === 0) {
                attachEventListener(node);
                self.assetsPending++;
              }
              node = node.firstChild;
              while (node) {
                traverseDOM(node);
                node = node.nextSibling;
              }
            }
            function attachEventListener (node) {
              node.addEventListener('loaded', assetLoaded);
            }
          }
        },

        assetLoaded: {
          value: function () {
            this.assetsPending--;
            if (this.assetsPending === 0) {
              this.load();
            }
          }
        },

        load: {
          value: function () {
            // To prevent emmitting the loaded event more than once
            if (this.hasLoaded) { return; }
            var event = new Event('loaded');
            this.hasLoaded = true;
            this.dispatchEvent(event);
          }
        }
      }
    )
  }
);

},{"../vr-register-element":42}],28:[function(require,module,exports){
require('../vr-register-element');

var THREE = require('../../lib/three');
var VRObject = require('./vr-object');

module.exports = document.registerElement(
  'vr-camera',
  {
    prototype: Object.create(
      VRObject.prototype,
      {
        createdCallback: {
          value: function () {
            var camera = this.object3D = new THREE.PerspectiveCamera();
            // This should probably managed within vr-scene
            this.sceneEl.camera = camera;
            this.saveInitialValues();
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            // Camera parameters
            var fov = parseFloat(this.getAttribute('fov')) || 45;
            var near = parseFloat(this.getAttribute('near')) || 1;
            var far = parseFloat(this.getAttribute('far')) || 10000;
            var aspect = parseFloat(this.getAttribute('aspect')) ||
                         window.innerWidth / window.innerHeight;

            // Setting three.js camera parameters
            this.object3D.fov = fov;
            this.object3D.near = near;
            this.object3D.far = far;
            this.object3D.aspect = aspect;
            this.object3D.updateProjectionMatrix();
          }
        },

        saveInitialValues: {
          value: function () {
            if (this.initValues) { return; }
            this.initValues = {
              x: parseFloat(this.getAttribute('x')) || 0,
              y: parseFloat(this.getAttribute('y')) || 0,
              z: parseFloat(this.getAttribute('z')) || 0,
              rotX: parseFloat(this.getAttribute('rotX')) || 0,
              rotY: parseFloat(this.getAttribute('rotY')) || 0,
              rotZ: parseFloat(this.getAttribute('rotZ')) || 0,
              fov: parseFloat(this.getAttribute('fov')) || 45,
              near: parseFloat(this.getAttribute('nar')) || 1,
              far: parseFloat(this.getAttribute('far')) || 10000,
              aspect: parseFloat(this.getAttribute('aspect')) ||
                      window.innerWidth / window.innerHeight
            };
          }
        },

        restoreInitialValues: {
          value: function () {
            if (!this.initValues) { return; }
            this.setAttribute('x', this.initValues.x);
            this.setAttribute('y', this.initValues.y);
            this.setAttribute('z', this.initValues.z);
            this.setAttribute('rotX', this.initValues.rotX);
            this.setAttribute('rotY', this.initValues.rotY);
            this.setAttribute('rotZ', this.initValues.rotZ);
            this.setAttribute('fov', this.initValues.fov);
            this.setAttribute('near', this.initValues.far);
            this.setAttribute('far', this.initValues.far);
            this.setAttribute('aspect', this.initValues.aspect);
          }
        },

        reset: {
          value: function () {
            this.restoreInitialValues();
          }
        }
      }
    )
  }
);

},{"../../lib/three":20,"../vr-register-element":42,"./vr-object":30}],29:[function(require,module,exports){
/* global Event, HTMLElement */

require('../vr-register-element');

/**
 *
 * VRNode is the base class for all the VR markup
 * It manages loading of objects.
 *
 */

module.exports = document.registerElement(
  'vr-node',
  {
    prototype: Object.create(
      HTMLElement.prototype,
      {

        //  ----------------------------------  //
        //   Native custom elements callbacks   //
        //  ----------------------------------  //

        createdCallback: {
          value: function () {
            var sceneEl = document.querySelector('vr-scene');
            this.sceneEl = sceneEl;
          },
          writable: window.debug
        },

        attachedCallback: {
          value: function () { /* no-op */ },
          writable: window.debug
        },

        detachedCallback: {
          value: function () { /* no-op */ },
          writable: window.debug
        },

        attributeChangedCallback: {
          value: function () { /* no-op */ },
          writable: window.debug
        },

        load: {
          value: function () {
            // To prevent emmitting the loaded event more than once
            if (this.hasLoaded) { return; }
            var attributeChangedCallback = this.attributeChangedCallback;
            var event = new Event('loaded');
            this.hasLoaded = true;
            this.dispatchEvent(event);
            if (attributeChangedCallback) { attributeChangedCallback.apply(this); }
          },
          writable: window.debug
        }
      })
  }
);

},{"../vr-register-element":42}],30:[function(require,module,exports){
/* global HTMLElement */

require('../vr-register-element');

var THREE = require('../../lib/three');
var VRNode = require('./vr-node');
var VRUtils = require('../vr-utils');

/**
 *
 * VROBject represents all elements that are part of the 3D scene.
 * They all have a position, rotation and a scale.
 *
 */
var VRObject = module.exports = document.registerElement(
  'vr-object',
  {
    prototype: Object.create(
      VRNode.prototype,
      {

        //  ----------------------------------  //
        //   Native custom elements callbacks   //
        //  ----------------------------------  //

        createdCallback: {
          value: function () {
            this.object3D = new THREE.Object3D();
            this.load();
          },
          writable: window.debug
        },

        attributeChangedCallback: {
          value: function () {
            this.object3D = this.object3D || new THREE.Object3D();
            // Position
            var position = this.getAttribute('position');

            // Rotation
            var rotation = this.getAttribute('rotation');
            var rotationX = THREE.Math.degToRad(rotation.x);
            var rotationY = THREE.Math.degToRad(rotation.y);
            var rotationZ = THREE.Math.degToRad(rotation.z);

            // Scale
            var scale = this.getAttribute('scale');

            // Setting three.js parameters
            this.object3D.position.set(position.x, position.y, position.z);
            this.object3D.rotation.order = 'YXZ';
            this.object3D.rotation.set(rotationX, rotationY, rotationZ);
            this.object3D.scale.set(scale.x, scale.y, scale.z);
          },
          writable: window.debug
        },

        attachedCallback: {
          value: function () {
            // When creating an element from JS is not guaranteed to have
            // a parent after initialization. It's up to the arbitrary
            // JS to attach the element to the DOM. We cover this
            // case here.
            if (!this.hasLoaded) { return; }
            this.addToParent();
          },
          writable: window.debug
        },

        detachedCallback: {
          value: function () {
            this.parentEl.remove(this);
          },
          writable: window.debug
        },

        add: {
          value: function (el) {
            if (!el.object3D) {
              VRUtils.error("Trying to add an object3D that doesn't exist");
            }
            this.object3D.add(el.object3D);
          },
          writable: window.debug
        },

        addToParent: {
          value: function () {
            var parent = this.parentEl = this.parentNode;
            var attachedToParent = this.attachedToParent;
            if (!parent || attachedToParent) { return; }
            // To prevent an object to attach itself multiple times to the parent
            this.attachedToParent = true;
            parent.add(this);
          },
          writable: window.debug
        },

        load: {
          value: function () {
            // To prevent calling load more than once
            if (this.hasLoaded) { return; }
            // Handle to the associated DOM element
            this.object3D.el = this;
            // It attaches itself to the threejs parent object3D
            this.addToParent();
            // It sets default values on the attributes if they're not defined
            this.initAttributes();
            // Setup animations if there's any
            this.addAnimations();
            VRNode.prototype.load.call(this);
          },
          writable: window.debug
        },

        setAttribute: {
          value: function (attr, val) {
            if (typeof val === 'object' &&
              (attr === 'position' ||
               attr === 'rotation' ||
               attr === 'scale')) {
              val = [val.x, val.y, val.z].join(' ');
            }
            HTMLElement.prototype.setAttribute.call(this, attr, val);
          },
          writable: window.debug
        },

        remove: {
          value: function (el) {
            this.object3D.remove(el.object3D);
          },
          writable: window.debug
        },

        initAttributes: {
          value: function (el) {
            var position = this.getAttribute('position');
            var rotation = this.getAttribute('rotation');
            var scale = this.getAttribute('scale');
            if (!position) { this.setAttribute('position', '0 0 0'); }
            if (!rotation) { this.setAttribute('rotation', '0 0 0'); }
            if (!scale) { this.setAttribute('scale', '1 1 1'); }
            // We force an attribute update if all the attributes are defined.
            // It syncs the attributes with the object3D.
            if (scale && rotation && scale) {
              VRObject.prototype.attributeChangedCallback.call(this);
            }
          },
          writable: window.debug
        },

        addAnimations: {
          value: function () {
            var self = this;
            var animations = this.getAttribute('animation');
            if (!animations) { return; }
            animations = animations.split(' ');
            animations.forEach(attachObject);
            function attachObject (animationName) {
              var el = document.getElementById(animationName);
              if (!el) { return; }
              el.add(self);
            }
          },
          writable: window.debug
        },

        getAttribute: {
          value: function (attribute) {
            var value = HTMLElement.prototype.getAttribute.call(this, attribute);
            return VRUtils.parseAttributeString(attribute, value);
          },
          writable: window.debug
        }
      })
  }
);

},{"../../lib/three":20,"../vr-register-element":42,"../vr-utils":43,"./vr-node":29}],31:[function(require,module,exports){
/* global MessageChannel, performance, Promise */

require('../vr-register-element');

var TWEEN = require('tween.js');

var THREE = require('../../lib/three');
var VRNode = require('./vr-node');

var VRScene = module.exports = document.registerElement(
  'vr-scene',
  {
    prototype: Object.create(
      VRNode.prototype, {
        createdCallback: {
          value: function () {
            this.attachEventListeners();
            this.attachFullscreenListeners();
            this.setupScene();
          }
        },

        detachedCallback: {
          value: function () {
            this.shutdown();
          }
        },

        shutdown: {
          value: function () {
            window.cancelAnimationFrame(this.animationFrameID);
          }
        },

        attachEventListeners: {
          value: function () {
            var self = this;
            var elementLoaded = this.elementLoaded.bind(this);
            this.pendingElements = 0;
            var assets = document.querySelector('vr-assets');
            if (assets && !assets.hasLoaded) {
              this.pendingElements++;
              assets.addEventListener('loaded', elementLoaded);
            }
            traverseDOM(this);
            function traverseDOM (node) {
              // We have to wait for the element
              // If the node it's not the scene itself
              // and it's a VR element
              // and the node has not loaded yet
              if (node !== self && self.isVRNode(node) && !node.hasLoaded) {
                attachEventListener(node);
                self.pendingElements++;
              }
              node = node.firstChild;
              while (node) {
                traverseDOM(node);
                node = node.nextSibling;
              }
            }
            function attachEventListener (node) {
              node.addEventListener('loaded', elementLoaded);
            }
          }
        },

        isVRNode: {
          value: function (node) {
            // To check if a DOM elemnt is a VR element
            // We should be checking for the prototype like this
            // if (VRNode.prototype.isPrototypeOf(node))
            // Safari and Chrome doesn't seem to have the proper
            // prototype attached to the node before the createdCallback
            // function is called. To determine that an element is a VR
            // related node we check if the tag name starts with VR-
            // This is fragile. We have to understand why the behaviour between
            // firefox and the other browsers
            // is not consistent. Firefox is the only one that behaves as one
            // expects: The nodes have the proper prototype attached to them at
            // any time during their lifecycle.
            return node.tagName && node.tagName.indexOf('VR-') === 0;
          }
        },

        attachMessageListeners: {
          value: function () {
            var self = this;
            window.addEventListener('message', function (e) {
              if (e.data && e.data.type === 'fullscreen') {
                switch (e.data.data) {
                  // set renderer with fullscreen VR enter and exit.
                  case 'enter':
                    self.setStereoRenderer();
                    break;
                  case 'exit':
                    self.setMonoRenderer();
                    break;
                }
              }
            });
          }
        },

        attachFullscreenListeners: {
          value: function () {
            // handle fullscreen changes
            document.addEventListener('mozfullscreenchange', this.fullscreenChange.bind(this));
            document.addEventListener('webkitfullscreenchange', this.fullscreenChange.bind(this));
          }
        },

        fullscreenChange: {
          value: function (e) {
            // switch back to the mono renderer if we have dropped out of fullscreen VR mode.
            var fsElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
            if (!fsElement) {
              this.renderer = this.monoRenderer;
            }
          }
        },

        elementLoaded: {
          value: function () {
            this.pendingElements--;
            // If we still need to wait for more elements
            if (this.pendingElements > 0) { return; }
            // If the render loop is already running
            if (this.renderLoopStarted) { return; }
            this.setupLoader();
            this.resizeCanvas();
            // It kicks off the render loop
            this.render(performance.now());
            this.renderLoopStarted = true;
            this.load();
          }
        },

        createEnterVrButton: {
          value: function () {
            var vrButton = document.createElement('button');
            vrButton.textContent = 'Enter VR';
            vrButton.className = 'vr-button';
            document.body.appendChild(vrButton);
            vrButton.addEventListener('click', this.enterVR.bind(this));
          }
        },

        // returns a promise that resolves to true if loader is in VR mode.
        vrLoaderMode: {
          value: function () {
            return new Promise(function (resolve) {
              var channel = new MessageChannel();
              window.top.postMessage({type: 'checkVr'}, '*', [channel.port2]);
              channel.port1.onmessage = function (message) {
                resolve(!!message.data.data.isVr);
              };
            });
          }
        },

        setupLoader: {
          value: function () {
            var self = this;
            // inside loader, check for vr mode before kicking off render loop.
            if (window.top !== window.self) {
              self.attachMessageListeners();
              self.vrLoaderMode().then(function (isVr) {
                if (isVr) {
                  self.setStereoRenderer();
                } else {
                  self.setMonoRenderer();
                }
                window.top.postMessage({type: 'ready'}, '*');
              });
            } else {
              self.createEnterVrButton();
            }
          }
        },

        setStereoRenderer: {
          value: function () {
            this.renderer = this.stereoRenderer;
            this.resizeCanvas();
          }
        },

        setMonoRenderer: {
          value: function () {
            this.renderer = this.monoRenderer;
            this.resizeCanvas();
          }
        },

        setupScene: {
          value: function () {
            this.behaviors = this.querySelectorAll('vr-controls');
            // querySelectorAll returns a NodeList that it's not a normal array
            // We need to convert
            this.behaviors = Array.prototype.slice.call(this.behaviors);
            // The canvas where the WebGL context will be painted
            this.setupCanvas();
            // The three.js renderer setup
            this.setupRenderer();
            // three.js camera setup
            this.setupCamera();
            // cursor camera setup
            this.setupCursor();
          }
        },

        setupCanvas: {
          value: function () {
            var canvas = this.canvas = document.createElement('canvas');
            canvas.classList.add('vr-canvas');
            document.body.appendChild(canvas);
            window.addEventListener('resize', this.resizeCanvas.bind(this), false);
          }
        },

        setupCamera: {
          value: function () {
            var cameraEl = this.querySelector('vr-camera');
            // If there's not a user-defined camera, we create one.
            if (!cameraEl) {
              cameraEl = document.createElement('vr-camera');
              cameraEl.setAttribute('fov', 45);
              cameraEl.setAttribute('near', 1);
              cameraEl.setAttribute('far', 10000);
              this.appendChild(cameraEl);
            }
          }
        },

        setupCursor: {
          value: function () {
            var cursor = this.querySelector('vr-cursor');
            if (cursor) {
              this.cursor = cursor;
            }
          }
        },

        enterVR: {
          value: function () {
            this.renderer = this.stereoRenderer;
            this.stereoRenderer.setFullScreen(true);
          }
        },

        setupRenderer: {
          value: function () {
            var canvas = this.canvas;
            var renderer = this.renderer = this.monoRenderer =
              (VRScene && VRScene.renderer) || // To prevent creating multiple rendering contexts
              new THREE.WebGLRenderer({canvas: canvas, antialias: true, alpha: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.sortObjects = false;
            VRScene.renderer = renderer;

            this.stereoRenderer = new THREE.VREffect(renderer);

            this.object3D = (VRScene && VRScene.scene) || new THREE.Scene();
            VRScene.scene = this.object3D;
          }
        },

        resizeCanvas: {
          value: function () {
            var canvas = this.canvas;
            var camera = this.camera;
            // Make it visually fill the positioned parent
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            // Set the internal size to match
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            // Updates camera
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            // Notify the renderer of the size change
            this.renderer.setSize(canvas.width, canvas.height);
          }
        },

        add: {
          value: function (el) {
            if (!el.object3D) { return; }
            this.object3D.add(el.object3D);
          }
        },

        addBehavior: {
          value: function (behavior) {
            this.behaviors.push(behavior);
          }
        },

        remove: {
          value: function (el) {
            if (!el.object3D) { return; }
            this.object3D.remove(el.object3D);
          }
        },

        render: {
          value: function (t) {
            TWEEN.update(t);
            // Updates behaviors
            this.behaviors.forEach(function (behavior) {
              behavior.update(t);
            });
            this.renderer.render(this.object3D, this.camera);
            this.animationFrameID = window.requestAnimationFrame(this.render.bind(this));
          }
        }
      }
    )
  }
);

},{"../../lib/three":20,"../vr-register-element":42,"./vr-node":29,"tween.js":26}],32:[function(require,module,exports){
/**
 * http://www.alexandre-pestana.com/webgl/PBRViewer.html
*/

module.exports = function (THREE) {

	return {

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uvScale;",

			"varying vec2 vUv;",
			"varying mat3 tbn;",
			"varying vec3 vLightVector;",
			"varying vec3 vTestNormal;",
			"varying vec3 vPosition;",

			"void main()",
			"{",
			"vUv = uvScale * uv;",

			"vec3 vNormal = normalize(normalMatrix * normal);",
			"vec3 vTangent = normalize(normalMatrix * tangent.xyz);",
			"vec3 vBinormal = normalize(cross(vNormal, vTangent) * tangent.w);",

			"tbn = mat3(vTangent, vBinormal, vNormal);",

			"vLightVector = normalize(vec3(0.4, 0.2 ,0.2));",

			"vPosition = position;",
			"vTestNormal = normal;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",

			"}"
		].join("\n"),

		fragmentShader: [

			"#define PI 3.14159265359",

	    "uniform samplerCube envMap0;",
	    "uniform samplerCube envMap1;",
	    "uniform samplerCube envMap2;",
	    "uniform samplerCube envMap3;",
	    "uniform samplerCube envMap4;",
	    "uniform samplerCube envMap5;",
	    "uniform vec3 baseColor;",

	    "uniform float roughness;",
	    "uniform float metallic;",
	    "uniform float lightIntensity;",

	    "varying vec2 vUv;",
	    "varying mat3 tbn;",
	    "varying vec3 vLightVector;",
	    "varying vec3 vTestNormal;",
	    "varying vec3 vPosition;",

		  "vec3 Diffuse(vec3 pAlbedo)",
			"{",
			  "return pAlbedo/PI;",
			"}",

		  "//---------- Normal distribution functions ------------//",
			"float NormalDistribution_GGX(float a, float NdH)",
			"{",
			    "// Isotropic ggx.",
			    "float a2 = a*a;",
			    "float NdH2 = NdH * NdH;",

			    "float denominator = NdH2 * (a2 - 1.0) + 1.0;",
			    "denominator *= denominator;",
			    "denominator *= PI;",

			    "return a2 / denominator;",
			"}",

			"//---------- Geometric shadowing ------------//",
			"float Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)",
			"{",
			    "// Smith schlick-GGX.",
			    "float k = a * 0.5;",
			    "float GV = NdV / (NdV * (1.0 - k) + k);",
			    "float GL = NdL / (NdL * (1.0 - k) + k);",

			    "return GV * GL;",
			"}",

			"//---------- Fresnel ------------//",
			"vec3 Fresnel_Schlick(vec3 specularColor, vec3 h, vec3 v)",
			"{",
			  "return (specularColor + (1.0 - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));",
			"}",

			"//---------- BRDF terms ------------//",
			"float Specular_D(float a, float NdH)",
			"{",
				"return NormalDistribution_GGX(a, NdH);",
			"}",

			"vec3 Specular_F(vec3 specularColor, vec3 h, vec3 v)",
			"{",
				"return Fresnel_Schlick(specularColor, h, v);",
			"}",

			"vec3 Specular_F_Roughness(vec3 specularColor, float a, vec3 h, vec3 v)",
			"{",
				"return (specularColor + (max(vec3(1.0 - a), specularColor) - specularColor) * pow((1.0 - clamp(dot(v, h), 0.0, 1.0)), 5.0));",
			"}",

			"float Specular_G(float a, float NdV, float NdL, float NdH, float VdH, float LdV)",
			"{",
				"return Geometric_Smith_Schlick_GGX(a, NdV, NdL);",
			"}",

			"vec3 Specular(vec3 specularColor, vec3 h, vec3 v, vec3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)",
			"{",
			   "return ((Specular_D(a, NdH) * Specular_G(a, NdV, NdL, NdH, VdH, LdV)) * Specular_F(specularColor, v, h) ) / (4.0 * NdL * NdV + 0.0001);",
			"}",

			"vec3 ComputeLight(vec3 albedoColor,vec3 specularColor, vec3 normal, vec3 lightPosition, vec3 lightColor, vec3 lightDir, vec3 viewDir)",
			"{",
		    "// Compute some useful values.",
		    "float NdL = clamp(dot(normal, lightDir), 0.0, 1.0);",
		    "float NdV = clamp(dot(normal, viewDir), 0.0, 1.0);",
		    "vec3 h = normalize(lightDir + viewDir);",
		    "float NdH = clamp(dot(normal, h), 0.0, 1.0);",
		    "float VdH = clamp(dot(viewDir, h), 0.0, 1.0);",
		    "float LdV = clamp(dot(lightDir, viewDir), 0.0, 1.0);",
		    "float a = max(0.001, roughness * roughness);",

		    "vec3 cDiff = Diffuse(albedoColor);",
		    "vec3 cSpec = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);",

		    "return lightColor * NdL * (cDiff * (1.0 - cSpec) + cSpec);",
			"}",

			"// Ok, this is ugly, but there is an explanation ...",
			"// WebGL need the extension EXT_shader_texture_lod in order to use textureCubeLod, and it's not yet implemented.",
			"// With textureCube the mipmap is automatically applied, and you can only add a bias.",
			"// To avoid that I saved each mip level in a separate cubemap.",
			"// If there is a less awfull way to do this I'd be happy to know !",
			"vec3 ComputeEnvColor(float roughness, vec3 reflectionVector)",
			"{",
				"float a = roughness * roughness * 6.0;",
				"if ( a < 1.0)",
				"{",
					"return mix(textureCube(envMap0, reflectionVector).rgb, textureCube(envMap1, reflectionVector).rgb, a);",
				"}",

				"if ( a < 2.0)",
				"{",
					"return mix(textureCube(envMap1, reflectionVector).rgb, textureCube(envMap2, reflectionVector).rgb, a - 1.0);",
				"}",

				"if ( a < 3.0)",
				"{",
					"return mix(textureCube(envMap2, reflectionVector).rgb, textureCube(envMap3, reflectionVector).rgb, a - 2.0);",
				"}",

				"if ( a < 4.0)",
				"{",
					"return mix(textureCube(envMap3, reflectionVector).rgb, textureCube(envMap4, reflectionVector).rgb, a - 3.0);",
				"}",

				"if ( a < 5.0)",
				"{",
					"return mix(textureCube(envMap4, reflectionVector).rgb, textureCube(envMap5, reflectionVector).rgb, a - 4.0);",
				"}",

				"return textureCube(envMap5, reflectionVector).rgb;",
			"}",

	    "void main()",
	    "{",
	      "vec3 normal = vTestNormal;",

	      "vec3 viewDir = normalize(cameraPosition - vPosition);",
	      "vec3 albedoCorrected = pow(abs(baseColor.rgb), vec3(2.2));",

	      "vec3 realAlbedo = baseColor - baseColor * metallic;",
	      "vec3 realSpecularColor = mix(vec3(0.03, 0.03, 0.03), baseColor, metallic);",

	      "vec3 light1 = ComputeLight( realAlbedo, realSpecularColor, normal, vLightVector, vec3(0.4, 0.42, 0.37), vLightVector, viewDir);",

	      "vec3 reflectVector = reflect(-viewDir, normal);",
	  		"vec3 envColor = ComputeEnvColor(roughness, reflectVector);",

	  		"vec3 envFresnel = Specular_F_Roughness(realSpecularColor, roughness * roughness, normal, viewDir);",

	  		"gl_FragColor = vec4(vec3(lightIntensity) * light1 + 1.0 * envFresnel * envColor + realAlbedo * 0.01, 1.0);",
	    "}"

		].join("\n")

	};

};

},{}],33:[function(require,module,exports){
require('./vr-register-element');

var VRUtils = require('./vr-utils');
var VRNode = require('./core/vr-node');

var TWEEN = require('tween.js');

module.exports = document.registerElement(
  'vr-animation', {
    prototype: Object.create(
      VRNode.prototype, {
        createdCallback: {
          value: function () {
            this.delay = parseFloat(this.getAttribute('delay')) || 0;
            this.duration = parseFloat(this.getAttribute('duration')) || 1000;
            this.loop = this.hasAttribute('loop');
            this.attribute = this.getAttribute('attribute');
            this.to = VRUtils.parseAttributeString(this.attribute, this.getAttribute('to'));
            this.load();
          }
        },

        add: {
          value: function (obj) {
            var attribute = this.attribute;
            var from = obj.getAttribute(attribute);
            new TWEEN.Tween(from)
              .to(this.to, this.duration)
              .delay(this.delay)
              .onUpdate(function () {
                obj.setAttribute(attribute, this);
              })
              .start();
          }
        }
      })
  });

},{"./core/vr-node":29,"./vr-register-element":42,"./vr-utils":43,"tween.js":26}],34:[function(require,module,exports){
require('./vr-register-element');

var VRNode = require('./core/vr-node');

module.exports = document.registerElement(
  'vr-behavior',
  {
    prototype: Object.create(
      VRNode.prototype,
      {
        createdCallback: {
          value: function () {
            this.sceneEl.addBehavior(this);
          }
        },

        // Tags that inherit from VRBehavior should define their own update
        // function.
        update: {
          value: function () { /* no op */ }
        }
      })
  }
);

},{"./core/vr-node":29,"./vr-register-element":42}],35:[function(require,module,exports){
var THREE = require('../lib/three');

var VRObject = require('./core/vr-object');
// To avoid recalculation at every mouse movement tick
var PI_2 = Math.PI / 2;

module.exports = document.registerElement(
  'vr-controls',
  {
    prototype: Object.create(
      VRObject.prototype,
      {
        createdCallback: {
          value: function () {
            this.object3D = new THREE.Object3D();
            this.prevTime = Date.now();
            // The canvas where the scene is painted
            this.canvasEl = document.querySelector('vr-scene').canvas;

            // To keep track of the pressed keys
            this.keys = {};
            this.mouseDown = false;

            this.acceleration = 65;
            this.velocity = new THREE.Vector3();

            this.pitchObject = new THREE.Object3D();
            this.yawObject = new THREE.Object3D();
            this.yawObject.position.y = 10;
            this.yawObject.add(this.pitchObject);

            this.setAttribute('locomotion', true);
            this.setAttribute('mouse-look', true);

            this.attachMouseKeyboardListeners();
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var locomotion = this.getAttribute('locomotion');
            var mouseLook = this.getAttribute('mouse-look');
            this.locomotion = locomotion === 'true';
            this.mouseLook = mouseLook === 'true';
          }
        },

        update: {
          value: function () {
            var velocity = this.velocity;
            var pitchObject = this.pitchObject;
            var yawObject = this.yawObject;
            var time = window.performance.now();
            var delta = (time - this.prevTime) / 1000;
            var keys = this.keys;
            var acceleration = this.acceleration;
            this.prevTime = time;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            var position = this.getAttribute('position');
            var x = position.x || 0;
            var y = position.y || 0;
            var z = position.z || 0;

            var rotation = this.getAttribute('rotation');
            var rotZ = rotation.z || 0;

            if (this.locomotion) {
              if (keys[65]) { // Left
                velocity.x -= acceleration * delta;
              }
              if (keys[87]) { // Up
                velocity.z -= acceleration * delta;
              }
              if (keys[68]) { // Right
                velocity.x += acceleration * delta;
              }
              if (keys[83]) { // Down
                velocity.z += acceleration * delta;
              }
            }

            if (keys[90]) { // Z
              x = 0;
              y = 0;
              z = 0;

              this.reset();
              // scene.resetSensor();

              position = this.getAttribute('position');
              x = position.x || 0;
              y = position.y || 0;
              z = position.z || 0;

              rotation = this.getAttribute('rotation');
              rotZ = rotation.z || 0;
            }

            this.setAttribute('rotation', {
              x: THREE.Math.radToDeg(pitchObject.rotation.x),
              y: THREE.Math.radToDeg(yawObject.rotation.y),
              z: rotZ
            });

            var movementVector = this.getMovementVector(delta);
            this.setAttribute('position', {
              x: x + movementVector.x,
              y: y,
              z: z + movementVector.z
            });
          }
        },

        attachMouseKeyboardListeners: {
          value: function () {
            var canvasEl = this.canvasEl;

            // Keyboard events
            window.addEventListener('keydown', this.onKeyDown.bind(this), false);
            window.addEventListener('keyup', this.onKeyUp.bind(this), false);

            // Mouse Events
            canvasEl.addEventListener('mousedown', this.onMouseDown.bind(this), true);
            canvasEl.addEventListener('mouseup', this.onMouseUp.bind(this), true);
            canvasEl.addEventListener('mousemove', this.onMouseMove.bind(this), true);
          }
        },

        onMouseMove: {
          value: function (event) {
            var pitchObject = this.pitchObject;
            var yawObject = this.yawObject;
            var mouseDown = this.mouseDown;

            if (!mouseDown || !this.mouseLook) { return; }

            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            yawObject.rotation.y -= movementX * 0.002;
            pitchObject.rotation.x -= movementY * 0.002;
            pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
          }
        },

        onMouseDown: {
          value: function (event) {
            this.mouseDown = true;
            this.lastMouseX = event.clientX;
            this.lastMouseY = event.clientY;
          }
        },

        onMouseUp: {
          value: function () {
            this.mouseDown = false;
          }
        },

        onKeyDown: {
          value: function (event) {
            this.keys[event.keyCode] = true;
          }
        },

        onKeyUp: {
          value: function (event) {
            this.keys[event.keyCode] = false;
          }
        },

        getMovementVector: {
          value: function (delta) {
            var velocity = this.velocity;
            var direction = new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta);
            var rotation = new THREE.Euler(0, 0, 0, 'YXZ');
            var pitchObject = this.pitchObject;
            var yawObject = this.yawObject;
            rotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0);
            return direction.applyEuler(rotation);
          }
        }
      })
  }
);

},{"../lib/three":20,"./core/vr-object":30}],36:[function(require,module,exports){
require('./vr-register-element');

var THREE = require('../lib/three');

var VRObject = require('./core/vr-object');

module.exports = document.registerElement(
  'vr-cursor',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D = new THREE.Mesh(geometry, material);
            this.raycaster = new THREE.Raycaster();
            this.attachEventListeners();
            this.load();
          }
        },

        attachEventListeners: {
          value: function () {
            document.addEventListener('mousedown', this.onMouseDown.bind(this), false);
            this.addEventListener('click', this.handleClick.bind(this));
          }
        },

        onMouseDown: {
          value: function () {
            this.click();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            var geometry = this.getGeometry();
            this.object3D.geometry = geometry;
            this.object3D.material = material;
          }
        },

        getGeometry: {
          value: function () {
            var radius = parseFloat(this.getAttribute('radius')) || 10;
            var geometryId = this.getAttribute('geometry');
            var geometryEl = geometryId ? document.querySelector('#' + geometryId) : undefined;
            return (geometryEl && geometryEl.geometry) || new THREE.SphereGeometry(radius, 64, 40);
          }
        },

        getMaterial: {
          value: function () {
            var materialId = this.getAttribute('material');
            var materialEl = materialId ? document.querySelector('#' + materialId) : undefined;
            return (materialEl && materialEl.material) || new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});
          }
        },

        intersect: {
          value: function (objects) {
            var raycaster = this.raycaster;
            var cursor = this.object3D;
            var cursorPosition = cursor.position.clone();
            cursor.localToWorld(cursorPosition);
            var parent = this.parentNode.object3D;
            var parentPosition = parent.position.clone();
            parent.localToWorld(parentPosition);
            var direction = cursorPosition.sub(parentPosition).normalize();
            raycaster.set(parentPosition, direction);
            return raycaster.intersectObjects(objects, true);
          }
        },

        handleClick: {
          value: function () {
            var scene = this.sceneEl.object3D;
            var intersectedObjects = this.intersect(scene.children);
            intersectedObjects.forEach(function (obj) {
              obj.object.el.click();
            });
          }
        }
      })
  }
);

},{"../lib/three":20,"./core/vr-object":30,"./vr-register-element":42}],37:[function(require,module,exports){
require('./vr-register-element');

var THREE = require('../lib/three');
var VRNode = require('./core/vr-node');

module.exports = document.registerElement(
  'vr-fog',
  {
    prototype: Object.create(
      VRNode.prototype, {
        createdCallback: {
          value: function () {
            var color = this.getAttribute('color') || 0xFFFFFF;
            var near = parseFloat(this.getAttribute('near') || 1);
            var far = parseFloat(this.getAttribute('far') || 1000);
            this.fog = this.sceneEl.object3D.fog = new THREE.Fog(color, near, far);
            this.load();
          }
        }
      })
  }
);

},{"../lib/three":20,"./core/vr-node":29,"./vr-register-element":42}],38:[function(require,module,exports){
require('./vr-register-element');

var THREE = require('../lib/three');
var VRNode = require('./core/vr-node');
var VRUtils = require('./vr-utils');

module.exports = document.registerElement(
  'vr-geometry',
  {
    prototype: Object.create(
      VRNode.prototype, {
        createdCallback: {
          value: function () {
            this.setupGeometry();
            this.load();
          }
        },

        setupGeometry: {
          value: function () {
            var primitive = this.primitive = this.getAttribute('primitive') || 'Box';
            var geometry;
            var radius;
            switch (primitive) {
              case 'Box':
                var width = parseFloat(this.getAttribute('width')) || 200;
                var height = parseFloat(this.getAttribute('height')) || 200;
                var depth = parseFloat(this.getAttribute('depth')) || 200;
                geometry = new THREE.BoxGeometry(width, height, depth);
                break;
              case 'Sphere':
                radius = parseFloat(this.getAttribute('radius')) || 100;
                geometry = new THREE.SphereGeometry(radius, 32, 32);
                break;
              case 'Torus':
                radius = parseFloat(this.getAttribute('radius')) || 200;
                var tube = parseFloat(this.getAttribute('tube')) || 10;
                geometry = new THREE.TorusGeometry(radius, tube);
                break;
              default:
                VRUtils.warn('Primitive type not supported');
                break;
            }
            this.geometry = geometry;
            return geometry;
          }
        }
      }
    )
  }
);

},{"../lib/three":20,"./core/vr-node":29,"./vr-register-element":42,"./vr-utils":43}],39:[function(require,module,exports){
require('./vr-register-element');

var VRObject = require('./core/vr-object');
var VRNode = require('./core/vr-node');
var THREE = require('../lib/three');
var VRUtils = require('./vr-utils');

require('./core/vr-camera');
require('./core/vr-scene');
require('./core/vr-assets');

require('./vr-animation');
require('./vr-behavior');
require('./vr-controls');
require('./vr-cursor');
require('./vr-fog');
require('./vr-geometry');
require('./vr-material');
require('./vr-mesh');

module.exports = {
  THREE: THREE,
  VRObject: VRObject,
  VRNode: VRNode,
  utils: VRUtils
};

},{"../lib/three":20,"./core/vr-assets":27,"./core/vr-camera":28,"./core/vr-node":29,"./core/vr-object":30,"./core/vr-scene":31,"./vr-animation":33,"./vr-behavior":34,"./vr-controls":35,"./vr-cursor":36,"./vr-fog":37,"./vr-geometry":38,"./vr-material":40,"./vr-mesh":41,"./vr-register-element":42,"./vr-utils":43}],40:[function(require,module,exports){
require('./vr-register-element');

var THREE = require('../lib/three');
var VRNode = require('./core/vr-node');

module.exports = document.registerElement(
  'vr-material',
  {
    prototype: Object.create(
      VRNode.prototype, {
        createdCallback: {
          value: function () {
            this.material = this.setupMaterial();
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var color = this.getAttribute('color') || Math.random() * 0xffffff;
            var roughness = this.getAttribute('roughness') || '1.0';
            var metallic = this.getAttribute('metallic') || '0.5';

            this.roughness = parseFloat(roughness);
            this.metallic = parseFloat(metallic);
            this.lightIntensity = 7.001;
            color = new THREE.Color(color);
            this.color = new THREE.Vector3(color.r, color.g, color.b);
            this.updateMaterial();
          }
        },

        updateMaterial: {
          value: function () {
            var material = this.material;
            material.uniforms.baseColor.value = this.color;
            material.uniforms.roughness.value = this.roughness;
            material.uniforms.metallic.value = this.metallic;
            material.uniforms.lightIntensity.value = this.lightIntensity;
          }
        },

        setupMaterial: {
          value: function () {
            // Shader parameters
            var baseColor = new THREE.Vector3(0.5, 0.5, 0.5);
            var roughness = 1.0;
            var metallic = 0.5;
            var lightIntensity = 7.001;

            // See comments of the function ComputeEnvColor for the explanations on this hug number of cubemaps.
            // Cube Map mip 0
            var path = 'images/pbr/maskonaive_m00_c0';
            var format = '.png';
            var urls = [
              path + '0' + format, path + '1' + format,
              path + '2' + format, path + '3' + format,
              path + '4' + format, path + '5' + format
            ];
            var cubeMapMip0 = THREE.ImageUtils.loadTextureCube(urls);
            cubeMapMip0.format = THREE.RGBFormat;

            // Cube Map mip 1
            path = 'images/pbr/maskonaive_m01_c0';
            format = '.png';
            urls = [
              path + '0' + format, path + '1' + format,
              path + '2' + format, path + '3' + format,
              path + '4' + format, path + '5' + format
            ];
            var cubeMapMip1 = THREE.ImageUtils.loadTextureCube(urls);
            cubeMapMip1.format = THREE.RGBFormat;

            // Cube Map mip 2
            path = 'images/pbr/maskonaive_m02_c0';
            format = '.png';
            urls = [
              path + '0' + format, path + '1' + format,
              path + '2' + format, path + '3' + format,
              path + '4' + format, path + '5' + format
            ];
            var cubeMapMip2 = THREE.ImageUtils.loadTextureCube(urls);
            cubeMapMip2.format = THREE.RGBFormat;

            // Cube Map mip 3
            path = 'images/pbr/maskonaive_m03_c0';
            format = '.png';
            urls = [
              path + '0' + format, path + '1' + format,
              path + '2' + format, path + '3' + format,
              path + '4' + format, path + '5' + format
            ];
            var cubeMapMip3 = THREE.ImageUtils.loadTextureCube(urls);
            cubeMapMip3.format = THREE.RGBFormat;

            // Cube Map mip 4
            path = 'images/pbr/maskonaive_m04_c0';
            format = '.png';
            urls = [
              path + '0' + format, path + '1' + format,
              path + '2' + format, path + '3' + format,
              path + '4' + format, path + '5' + format
            ];
            var cubeMapMip4 = THREE.ImageUtils.loadTextureCube(urls);
            cubeMapMip4.format = THREE.RGBFormat;

            // Cube Map mip 5
            path = 'images/pbr/maskonaive_m05_c0';
            format = '.png';
            urls = [
              path + '0' + format, path + '1' + format,
              path + '2' + format, path + '3' + format,
              path + '4' + format, path + '5' + format
            ];
            var cubeMapMip5 = THREE.ImageUtils.loadTextureCube(urls);
            cubeMapMip5.format = THREE.RGBFormat;

            var shaderPBR = THREE.ShaderLib.pbr;

            var material = new THREE.ShaderMaterial({
              uniforms: {
                baseColor: {
                  type: 'v3',
                  value: baseColor
                },

                envMap0: {
                  type: 't',
                  value: cubeMapMip0
                },

                envMap1: {
                  type: 't',
                  value: cubeMapMip1
                },

                envMap2: {
                  type: 't',
                  value: cubeMapMip2
                },

                envMap3: {
                  type: 't',
                  value: cubeMapMip3
                },

                envMap4: {
                  type: 't',
                  value: cubeMapMip4
                },

                envMap5: {
                  type: 't',
                  value: cubeMapMip5
                },

                roughness: {
                  type: 'f',
                  value: roughness
                },

                metallic: {
                  type: 'f',
                  value: metallic
                },

                lightIntensity: {
                  type: 'f',
                  value: lightIntensity
                },

                uvScale: {
                  type: 'v2',
                  value: new THREE.Vector2(1.0, 1.0)
                }
              },
              vertexShader: shaderPBR.vertexShader,
              fragmentShader: shaderPBR.fragmentShader
            });

            return material;
          }
        }
      }
    )
  }
);

},{"../lib/three":20,"./core/vr-node":29,"./vr-register-element":42}],41:[function(require,module,exports){
require('./vr-register-element');

var THREE = require('../lib/three');
var VRObject = require('./core/vr-object');

module.exports = document.registerElement(
  'vr-mesh',
  {
    prototype: Object.create(
      VRObject.prototype, {
        createdCallback: {
          value: function () {
            var geometry = this.getGeometry();
            var material = this.getMaterial();
            this.object3D = new THREE.Mesh(geometry, material);
            this.load();
          }
        },

        attributeChangedCallback: {
          value: function () {
            var material = this.getMaterial();
            if (material) {
              this.object3D.material = material;
            }
            this.object3D.geometry = this.getGeometry();
          }
        },

        getGeometry: {
          value: function () {
            var geometryId = this.getAttribute('geometry');
            var geometryEl = geometryId ? document.querySelector('#' + geometryId) : undefined;
            return (geometryEl && geometryEl.geometry) || new THREE.BoxGeometry(200, 200, 200);
          }
        },

        getMaterial: {
          value: function () {
            var materialId = this.getAttribute('material');
            var materialEl = materialId ? document.querySelector('#' + materialId) : undefined;
            return materialEl && materialEl.material;
          }
        }
      }
    )
  }
);

},{"../lib/three":20,"./core/vr-object":30,"./vr-register-element":42}],42:[function(require,module,exports){
// Polyfill `document.registerElement`.
require('document-register-element');

/*
 ------------------------------------------------------------
 ------------- WARNING WARNING WARNING WARNING --------------
 ------------------------------------------------------------

 This module wraps registerElement to deal with
 components that inherit from VRNode and VRObject.
 It's a pass through in any other case.

 It wraps some of the prototype methods
 of the created element to make sure that the corresponding
 functions in the base classes (VRObject and VRNode) are also
 invoked. The method in the base class is always call before the
 one in the derived object.

*/
var registerElement = document.registerElement;

/**
 * @param  {string} tagName The name of the tag to register
 * @param  {object} obj The prototype of the new element
 * @return {object} The prototype of the new element
 */
module.exports = document.registerElement = function (tagName, obj) {
  var proto = Object.getPrototypeOf(obj.prototype);
  var newObj = obj;

  // Does the element inherit from VRNode?
  if (VRNode && proto === VRNode.prototype) {
    newObj = wrapVRNodeMethods(obj.prototype);
    newObj = {prototype: Object.create(proto, newObj)};
  }

  // Does the element inherit from VRObject?
  if (VRObject && proto === VRObject.prototype) {
    newObj = wrapVRObjectMethods(obj.prototype);
    newObj = {prototype: Object.create(proto, newObj)};
  }

  return registerElement.call(document, tagName, newObj);
};

/**
 * This wrapps some of the obj methods to call those on VRNode base clase
 * @param  {object} obj The objects that contains the methods that will be wrapped
 * @return {object} An object with the same properties as the input parameter but
 * with some of methods wrapped.
 */
function wrapVRNodeMethods (obj) {
  var newObj = {};
  wrapMethods(newObj, ['createdCallback'], obj, VRNode.prototype);
  copyProperties(obj, newObj);
  return newObj;
}

/**
 * This wrapps some of the obj methods to call those on VRObject base clase
 * @param  {object} obj The objects that contains the methods that will be wrapped
 * @return {object} An object with the same properties as the input parameter but
 * with some of methods wrapped.
 */
function wrapVRObjectMethods (obj) {
  var newObj = {};
  var vrNodeMethods = ['createdCallback'];
  var vrObjectMethods = [
    'attributeChangedCallback',
    'attachedCallback',
    'dettachedCallback'
  ];
  wrapMethods(newObj, vrNodeMethods, obj, VRNode.prototype);
  wrapMethods(newObj, vrObjectMethods, obj, VRObject.prototype);
  // Copies the remaining properties into the new object
  copyProperties(obj, newObj);
  return newObj;
}

/**
 * Wraps a list a methods to ensure that those in the base class are called through the derived one
 * @param  {object} targetObj Object that will contain the wrapped methods
 * @param  {array} methodList List of methods from the derivedObj that will be wrapped
 * @param  {object} derivedObject Object that inherits from the baseObj
 * @param  {object} baseObj Object that derivedObj inherits from
 * @return {undefined}
 */
function wrapMethods (targetObj, methodList, derivedObj, baseObj) {
  methodList.forEach(function (methodName) {
    wrapMethod(targetObj, methodName, derivedObj, baseObj);
  });
}

/**
 * Wraps one method to ensure that the one in the base class is called before the one
 * in the derived one
 * @param  {object} obj Object that will contain the wrapped method
 * @param  {string} methodName The name of the method that will be wrapped
 * @param  {object} derivedObject Object that inherits from the baseObj
 * @param  {object} baseObj Object that derivedObj inherits from
 * @return {undefined}
 */
function wrapMethod (obj, methodName, derivedObj, baseObj) {
  var derivedMethod = derivedObj[methodName];
  var baseMethod = baseObj[methodName];
  if (!derivedMethod || !baseMethod) { return; }
  // Wrapper
  // The base method is called before the one in the derived class
  var wrapperMethod = function () {
    baseMethod.apply(this, arguments);
    return derivedMethod.apply(this, arguments);
  };
  obj[methodName] = {value: wrapperMethod, writable: window.debug};
}

/**
 * It copies the properties from source to destination object
 * if they don't exist already
 * @param  {object} source The object where properties are copied from
 * @param  {[type]} destination The object where properties are copied to
 * @return {undefined}
 */
function copyProperties (source, destination) {
  var props = Object.getOwnPropertyNames(source);
  props.forEach(function (prop) {
    if (!destination[prop]) {
      destination[prop] = {value: source[prop], writable: window.debug};
    }
  });
}

var VRNode = require('./core/vr-node');
var VRObject = require('./core/vr-object');

},{"./core/vr-node":29,"./core/vr-object":30,"document-register-element":25}],43:[function(require,module,exports){
var error = module.exports.error = function (msg) {
  throw new Error(msg);
};

module.exports.warn = function (msg) {
  console.warn(msg);
};

module.exports.parseAttributeString = function (attribute, str) {
  var values;
  var value = str;
  if (attribute === 'position' ||
      attribute === 'rotation' ||
      attribute === 'scale') {
    if (!str) {
      return null;
    }
    values = value.split(' ');
    if (values.length !== 3) {
      error('attr string should be len 3, ex:  (0 1 2)');
    }
    value = {
      x: parseFloat(values[0]),
      y: parseFloat(values[1]),
      z: parseFloat(values[2])
    };
  }
  return value;
};

},{}],44:[function(require,module,exports){
'use strict';
// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

module.exports = {
    // Create a <link> tag with optional data attributes
    createLink: function(href, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var link = document.createElement('link');

        link.href = href;
        link.rel = 'stylesheet';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            link.setAttribute('data-' + key, value);
        }

        head.appendChild(link);
    },
    // Create a <style> tag with optional data attributes
    createStyle: function(cssText, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0],
            style = document.createElement('style');

        style.type = 'text/css';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            style.setAttribute('data-' + key, value);
        }
        
        if (style.sheet) { // for jsdom and IE9+
            style.innerHTML = cssText;
            style.sheet.cssText = cssText;
            head.appendChild(style);
        } else if (style.styleSheet) { // for IE8 and below
            head.appendChild(style);
            style.styleSheet.cssText = cssText;
        } else { // for Chrome, Firefox, and Safari
            style.appendChild(document.createTextNode(cssText));
            head.appendChild(style);
        }
    }
};

},{}],45:[function(require,module,exports){
var css = "body,html{height:100%;overflow:hidden}.vr-canvas{height:100%;left:0;position:absolute;top:0;width:100%}button{background-color:#303030;border:1px solid #fff;color:#fff;cursor:pointer;left:0;padding:5px;position:absolute;top:0;width:90px;z-index:999999}button:hover{background-color:gray;color:#fff}.vr-button{top:20px;left:30px}"; (require("browserify-css").createStyle(css, { "href": "style/index.css"})); module.exports = css;
},{"browserify-css":44}]},{},[18])(18)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb3JlL2luZGV4LmpzIiwiY29yZS92ci1hdWRpby5qcyIsImNvcmUvdnItY3ViZS5qcyIsImNvcmUvdnItY3VydmVkUGxhbmUxLmpzIiwiY29yZS92ci1jdXJ2ZWRQbGFuZTIuanMiLCJjb3JlL3ZyLWN5bGluZGVyLmpzIiwiY29yZS92ci1ncmlkLmpzIiwiY29yZS92ci1oZW1pc3BoZXJlbGlnaHQuanMiLCJjb3JlL3ZyLWltYWdlLmpzIiwiY29yZS92ci1tb2RlbC5qcyIsImNvcmUvdnItb2JqLWxvYWRlci5qcyIsImNvcmUvdnItcGxhbmUuanMiLCJjb3JlL3ZyLXNreWJveC5qcyIsImNvcmUvdnItc2t5c3BoZXJlLmpzIiwiY29yZS92ci1zcGhlcmUuanMiLCJjb3JlL3ZyLXZpZGVvLmpzIiwiY29yZS92ci12aWRlbzM2MC5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvbGliL2N1cnNvcjNELmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvbGliL3RocmVlLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvbGliL3ZlbmRvci9SYXljYXN0ZXIuanMiLCJub2RlX21vZHVsZXMvQG1venZyL3ZyLW1hcmt1cC9saWIvdmVuZG9yL1ZSQ29udHJvbHMuanMiLCJub2RlX21vZHVsZXMvQG1venZyL3ZyLW1hcmt1cC9saWIvdmVuZG9yL1ZSRWZmZWN0LmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvbGliL3ZlbmRvci90aHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL25vZGVfbW9kdWxlcy9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50L2J1aWxkL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvQG1venZyL3ZyLW1hcmt1cC9ub2RlX21vZHVsZXMvdHdlZW4uanMvc3JjL1R3ZWVuLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL2NvcmUvdnItYXNzZXRzLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL2NvcmUvdnItY2FtZXJhLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL2NvcmUvdnItbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy9jb3JlL3ZyLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy9jb3JlL3ZyLXNjZW5lLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL3NoYWRlcnMvcGJyLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL3ZyLWFuaW1hdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy92ci1iZWhhdmlvci5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy92ci1jb250cm9scy5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy92ci1jdXJzb3IuanMiLCJub2RlX21vZHVsZXMvQG1venZyL3ZyLW1hcmt1cC9zcmMvdnItZm9nLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL3ZyLWdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL3ZyLW1hcmt1cC5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy92ci1tYXRlcmlhbC5qcyIsIm5vZGVfbW9kdWxlcy9AbW96dnIvdnItbWFya3VwL3NyYy92ci1tZXNoLmpzIiwibm9kZV9tb2R1bGVzL0Btb3p2ci92ci1tYXJrdXAvc3JjL3ZyLXJlZ2lzdGVyLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvQG1venZyL3ZyLW1hcmt1cC9zcmMvdnItdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jc3MvYnJvd3Nlci5qcyIsInN0eWxlL2luZGV4LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzeW1DQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICd2ci1hdWRpbyc6IHJlcXVpcmUoJy4vdnItYXVkaW8nKSxcbiAgJ3ZyLWN1YmUnOiByZXF1aXJlKCcuL3ZyLWN1YmUnKSxcbiAgJ3ZyLWN1cnZlZFBsYW5lMSc6IHJlcXVpcmUoJy4vdnItY3VydmVkUGxhbmUxJyksXG4gICd2ci1jdXJ2ZWRQbGFuZTInOiByZXF1aXJlKCcuL3ZyLWN1cnZlZFBsYW5lMicpLFxuICAndnItY3lsaW5kZXInOiByZXF1aXJlKCcuL3ZyLWN5bGluZGVyJyksXG4gICd2ci1ncmlkJzogcmVxdWlyZSgnLi92ci1ncmlkJyksXG4gICd2ci1oZW1pc3BoZXJlbGlnaHQnOiByZXF1aXJlKCcuL3ZyLWhlbWlzcGhlcmVsaWdodCcpLFxuICAndnItaW1hZ2UnOiByZXF1aXJlKCcuL3ZyLWltYWdlJyksXG4gICd2ci1tb2RlbCc6IHJlcXVpcmUoJy4vdnItbW9kZWwnKSxcbiAgJ3ZyLW9iai1sb2FkZXInOiByZXF1aXJlKCcuL3ZyLW9iai1sb2FkZXInKSxcbiAgJ3ZyLXBsYW5lJzogcmVxdWlyZSgnLi92ci1wbGFuZScpLFxuICAndnItc2t5Ym94JzogcmVxdWlyZSgnLi92ci1za3lib3gnKSxcbiAgJ3ZyLXNreXNwaGVyZSc6IHJlcXVpcmUoJy4vdnItc2t5c3BoZXJlJyksXG4gICd2ci1zcGhlcmUnOiByZXF1aXJlKCcuL3ZyLXNwaGVyZScpLFxuICAndnItdmlkZW8nOiByZXF1aXJlKCcuL3ZyLXZpZGVvJyksXG4gICd2ci12aWRlbzM2MCc6IHJlcXVpcmUoJy4vdnItdmlkZW8zNjAnKVxufTtcbiIsInZhciBWUk1hcmt1cCA9IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKTtcblxudmFyIFRIUkVFID0gVlJNYXJrdXAuVEhSRUU7XG52YXIgVlJPYmplY3QgPSBWUk1hcmt1cC5WUk9iamVjdDtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItYXVkaW8nLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBuZXcgVEhSRUUuQXVkaW9MaXN0ZW5lcigpO1xuXG4gICAgICAgICAgICB2YXIgc3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgdmFyIHZvbHVtZSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZvbCcpKSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBsb29wID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xvb3AnKSB8fCB0cnVlO1xuICAgICAgICAgICAgdmFyIHNvdW5kID0gbmV3IFRIUkVFLkF1ZGlvKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHZvbHVtZSA9IHZvbHVtZSAqIDEwOyAvLyBXZSBtdWx0aXBsZSBieSB0ZW4gc28gdGhlIHVzZXIgY2FuIGRlZmluZSB2b2x1bWUgaW4gbW9yZSBpbnR1aXRpdmUgc2NhbGU6IDAtMTAuXG4gICAgICAgICAgICBzb3VuZC5zb3VyY2Uuc3RhcnQoMCwgMCk7XG5cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgc291bmQubG9hZChzcmMpO1xuICAgICAgICAgICAgICBzb3VuZC5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICAgICAgICAgICAgc291bmQuc2V0TG9vcChsb29wKTtcbiAgICAgICAgICAgICAgc291bmQuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gc291bmQ7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLWN1YmUnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSB8fCA1O1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKSB8fCA1O1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnZGVwdGgnKSkgfHwgNTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuQm94R2VvbWV0cnkod2lkdGgsIGhlaWdodCwgZGVwdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNYXRlcmlhbDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJyk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxFbDtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbDtcblxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsSWQpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWxFbCA9IG1hdGVyaWFsSWQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIG1hdGVyaWFsSWQpIDoge307XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbWF0ZXJpYWxFbC5tYXRlcmlhbDtcbiAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoY29sb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogY29sb3J9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG4pO1xuIiwidmFyIFZSTWFya3VwID0gcmVxdWlyZSgnQG1venZyL3ZyLW1hcmt1cCcpO1xuXG52YXIgVEhSRUUgPSBWUk1hcmt1cC5USFJFRTtcbnZhciBWUk9iamVjdCA9IFZSTWFya3VwLlZST2JqZWN0O1xuXG5kb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXG4gICd2ci1jdXJ2ZWRQbGFuZTEnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgncmFkaXVzJykpIHx8IDEwO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkgfHwgNDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkgfHwgMTtcblxuICAgICAgICAgICAgdmFyIGNpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHJhZGl1cztcbiAgICAgICAgICAgIHZhciB0aGV0YUxlbmd0aCA9IChNYXRoLlBJICogMikgKiAod2lkdGggLyBjaXJjdW1mZXJlbmNlKTtcblxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgICAgICAgIHJhZGl1cywgLy8gcmFkaXVzIHRvcFxuICAgICAgICAgICAgICByYWRpdXMsIC8vIHJhZGl1cyBib3R0b21cbiAgICAgICAgICAgICAgaGVpZ2h0LCAvLyBoZWlnaHRcbiAgICAgICAgICAgICAgMzAsIC8vIHkgc2VnbWVudHNcbiAgICAgICAgICAgICAgMTAsIC8vIHggc2VnbWVudHNcbiAgICAgICAgICAgICAgdHJ1ZSwgLy8gb3BlbmVuZGVkXG4gICAgICAgICAgICAgIDAsICAvLyB0aGV0YSBzdGFydFxuICAgICAgICAgICAgICB0aGV0YUxlbmd0aFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkuYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlU2NhbGUoMSwgMSwgLTEpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNYXRlcmlhbDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXRlcmlhbCcpO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsRWwgPSBtYXRlcmlhbElkID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBtYXRlcmlhbElkKSA6IHt9O1xuICAgICAgICAgICAgcmV0dXJuIChtYXRlcmlhbEVsICYmIG1hdGVyaWFsRWwubWF0ZXJpYWwpIHx8IG5ldyBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwoe2NvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYsIG9wYWNpdHk6IDEuMH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInZhciBWUk1hcmt1cCA9IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKTtcblxudmFyIFRIUkVFID0gVlJNYXJrdXAuVEhSRUU7XG52YXIgVlJPYmplY3QgPSBWUk1hcmt1cC5WUk9iamVjdDtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItY3VydmVkUGxhbmUyJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R2VvbWV0cnk6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JhZGl1cycpKSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkgfHwgNTtcbiAgICAgICAgICAgIHZhciB0aGV0YVN0YXJ0ID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgndGhldGFTdGFydCcpKSB8fCBNYXRoLlBJO1xuICAgICAgICAgICAgdmFyIHRoZXRhTGVuZ3RoID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgndGhldGFMZW5ndGgnKSkgfHwgOTA7XG4gICAgICAgICAgICB2YXIgZmxpcE5vcm1hbHMgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdmbGlwJykpIHx8IHRydWU7XG5cbiAgICAgICAgICAgIHZhciByYWRpdXNTZWdtZW50cyA9IHRoZXRhTGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHRTZWdtZW50cyA9IDE7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhldGFMZW5ndGggKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0O1xuXG4gICAgICAgICAgICBpZiAoZmxpcE5vcm1hbHMpIHtcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3RpbmcgbGVuZ3RoIGZyb20gc3RhcnQgaGFzIGVmZmVjdCBvZiBlbmFibGluZyBkZXNpZ25lclxuICAgICAgICAgICAgICAvLyB0byBzcGVjaWZ5IGxlZnQgZWRnZSBwb3NpdGlvbiBvZiB0aGUgYmFuZCAoc3RhcnQpLCBhbmRcbiAgICAgICAgICAgICAgLy8gZXh0ZW5kaW5nIGJhbmQgcmlnaHR3YXJkcy5cbiAgICAgICAgICAgICAgc3RhcnQgPSAodGhldGFTdGFydCArIDE4MCkgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSAodGhldGFTdGFydCAtIHRoZXRhTGVuZ3RoKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KHJhZGl1cywgcmFkaXVzLCBoZWlnaHQsIHJhZGl1c1NlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgdHJ1ZSwgc3RhcnQsIGxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChmbGlwTm9ybWFscykge1xuICAgICAgICAgICAgICBnZW9tZXRyeS5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VTY2FsZSgtMSwgMSwgMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXRzIHBpdm90IHRvIHRvcCBvZiBiYW5kLlxuICAgICAgICAgICAgZ2VvbWV0cnkuYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oMCwgMCAtIGhlaWdodCAvIDIsIDApKTtcblxuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNYXRlcmlhbDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW1nU3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RleCcpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ29wYWNpdHknKSkgfHwgMTtcblxuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHt0cmFuc3BhcmVudDogdHJ1ZSwgc2lkZTogVEhSRUUuRG91YmxlU2lkZX0pO1xuXG4gICAgICAgICAgICBpZiAoaW1nU3JjKSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsLm1hcCA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoaW1nU3JjKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoY29sb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoJyNDQ0NDQ0MnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0ZXJpYWwub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLWN5bGluZGVyJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R2VvbWV0cnk6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JhZGl1cycpIHx8IDUpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IDEpO1xuICAgICAgICAgICAgdmFyIHJhZGl1c1NlZ21lbnRzID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgncmFkaXVzU2VnbWVudHMnKSB8fCAzNik7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0U2VnbWVudHMgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHRTZWdtZW50cycpIHx8IDEwKTtcbiAgICAgICAgICAgIHZhciBvcGVuRW5kZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnb3BlbmVuZGVkJyk7XG5cbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgICAgICAgICAgICByYWRpdXMsIC8vIHJhZGl1cyB0b3BcbiAgICAgICAgICAgICAgcmFkaXVzLCAvLyByYWRpdXMgYm90dG9tXG4gICAgICAgICAgICAgIGhlaWdodCwgLy8gaGVpZ2h0XG4gICAgICAgICAgICAgIHJhZGl1c1NlZ21lbnRzLCAvLyB5IHNlZ21lbnRzXG4gICAgICAgICAgICAgIGhlaWdodFNlZ21lbnRzLCAvLyB4IHNlZ21lbnRzXG4gICAgICAgICAgICAgIG9wZW5FbmRlZCAvLyBvcGVuZW5kZWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWF0ZXJpYWw6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnY29sb3InKSkgfHwgMHhDQzAwMDA7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXRlcmlhbCcpO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsRWwgPSBtYXRlcmlhbElkID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBtYXRlcmlhbElkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiAobWF0ZXJpYWxFbCAmJiBtYXRlcmlhbEVsLm1hdGVyaWFsKSB8fCBuZXcgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInZhciBWUk1hcmt1cCA9IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKTtcblxudmFyIFRIUkVFID0gVlJNYXJrdXAuVEhSRUU7XG52YXIgVlJPYmplY3QgPSBWUk1hcmt1cC5WUk9iamVjdDtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItZ3JpZCcsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBWUk9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xvcicpIHx8ICcjNjY2JztcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6IGNvbG9yfSk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlbmVyYXRlR2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QgPSBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZ2VvbWV0cnkgPSB0aGlzLmdlbmVyYXRlR2VvbWV0cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2VuZXJhdGVHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NpemUnKSB8fCAxNCk7XG4gICAgICAgICAgICB2YXIgZGVuc2l0eSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2RlbnNpdHknKSB8fCAxKTtcblxuICAgICAgICAgICAgLy8gR3JpZFxuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IC1zaXplOyBpIDw9IHNpemU7IGkgKz0gZGVuc2l0eSkge1xuICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKC1zaXplLCAtMC4wNCwgaSkpO1xuICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHNpemUsIC0wLjA0LCBpKSk7XG5cbiAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhpLCAtMC4wNCwgLXNpemUpKTtcbiAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhpLCAtMC4wNCwgc2l6ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4pO1xuIiwidmFyIFZSTWFya3VwID0gcmVxdWlyZSgnQG1venZyL3ZyLW1hcmt1cCcpO1xuXG52YXIgVEhSRUUgPSBWUk1hcmt1cC5USFJFRTtcbnZhciBWUk9iamVjdCA9IFZSTWFya3VwLlZST2JqZWN0O1xuXG5kb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXG4gICd2ci1oZW1pc3BoZXJlbGlnaHQnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2t5Q29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc2t5Q29sb3InKSB8fCAnI0ZGRkZGRic7XG4gICAgICAgICAgICB2YXIgZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JvdW5kQ29sb3InKSB8fCAnI0ZGRkZGRic7XG4gICAgICAgICAgICB2YXIgaW50ZW5zaXR5ID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnaW50ZW5zaXR5JykgfHwgMSk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodChza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLWltYWdlJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R2VvbWV0cnk6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAxMCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KHdpZHRoLCBoZWlnaHQsIDEsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNYXRlcmlhbDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW1nU3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICAgIG1hcDogVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZShpbWdTcmMpLFxuICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLW1vZGVsJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSwge1xuXG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBUSFJFRS5Db2xsYWRhTG9hZGVyIHNjYWxlIG9mIDAuMDEgZW5zdXJlcyBzY2FsZXMgbWF0Y2ggYWNyb3NzIERBRSBhbmQgVEhSRUUgc2NlbmUgKGVnIDFtIC0gMW0pXG4gICAgICAgICAgICB2YXIgc2NhbGVCYXNlID0gMC4wMTtcbiAgICAgICAgICAgIHZhciBzY2FsZVVzZXIgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdzY2FsZScpKSB8fCAxO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVCYXNlICogc2NhbGVVc2VyO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBlbmFibGUgdXNlciB0byBwYXNzIGluIG1hdGVyaWFsLCBhbmQgaGF2ZSB0aGF0IG1hdGVyaWFsIGFwcGx5IHRvIGFsbCBub2RlcyBpbiB0aGUgbG9hZGVkIG9iamVjdC5cbiAgICAgICAgICAgIC8vIFRPRE86IGxvYWQgYW5kIHBsYXliYWNrIGFuaW1hdGlvbnMgZnJvbSBsb2FkZWQgbW9kZWxzLlxuXG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkNvbGxhZGFMb2FkZXIoKTtcbiAgICAgICAgICAgIGxvYWRlci5vcHRpb25zLmNvbnZlcnRVcEF4aXMgPSB0cnVlOyAvLyBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRoaXMuIERvZXNuJ3QgYXBwZWFyIHRvIGJlIHRoZSBjYXNlLiBCdXQgaXQgd2FzIGluIFRocmVlLmpzIGV4YW1wbGVzLlxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoc3JjLCBmdW5jdGlvbiAoY29sbGFkYSkge1xuICAgICAgICAgICAgICB2YXIgZGFlID0gY29sbGFkYS5zY2VuZTtcbiAgICAgICAgICAgICAgZGFlLnNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgICAgICAgc2VsZi5vYmplY3QzRCA9IGRhZTtcbiAgICAgICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLW9iai1sb2FkZXInLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG5cbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzcmMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG5cbiAgICAgICAgICAgIC8vIE9CSlxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoKTtcbiAgICAgICAgICAgIG1hbmFnZXIub25Qcm9ncmVzcyA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0sIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5PQkpMb2FkZXIobWFuYWdlcik7XG4gICAgICAgICAgICBsb2FkZXIubG9hZChzcmMsIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xuICAgICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvYmplY3QucG9zaXRpb24ueSA9IC0xNTtcbiAgICAgICAgICAgICAgc2VsZi5vYmplY3QzRCA9IG9iamVjdDtcbiAgICAgICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWF0ZXJpYWw6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWF0ZXJpYWwnKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbEVsID0gbWF0ZXJpYWxJZCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgbWF0ZXJpYWxJZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gbWF0ZXJpYWxFbCAmJiBtYXRlcmlhbEVsLm1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KVxuICB9XG4pO1xuIiwidmFyIFZSTWFya3VwID0gcmVxdWlyZSgnQG1venZyL3ZyLW1hcmt1cCcpO1xuXG52YXIgVEhSRUUgPSBWUk1hcmt1cC5USFJFRTtcbnZhciBWUk9iamVjdCA9IFZSTWFya3VwLlZST2JqZWN0O1xuXG5kb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXG4gICd2ci1wbGFuZScsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBWUk9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdlb21ldHJ5OiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpIHx8IDEwO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKSB8fCAxMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSh3aWR0aCwgaGVpZ2h0LCAxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWF0ZXJpYWw6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXRlcmlhbCcpO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsRWw7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbElkKSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsRWwgPSBtYXRlcmlhbElkID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBtYXRlcmlhbElkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBtYXRlcmlhbEVsLm1hdGVyaWFsO1xuICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcihjb2xvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe2NvbG9yOiBjb2xvcn0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLXNreWJveCcsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBWUk9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdlb21ldHJ5OiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnc2l6ZScpKSB8fCAxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuQm94R2VvbWV0cnkoc2l6ZSwgc2l6ZSwgc2l6ZSwgMSwgMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHVybFByZWZpeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgIHZhciB1cmxzID0gW1xuICAgICAgICAgICAgICB1cmxQcmVmaXggKyAncmlnaHQuanBnJyxcbiAgICAgICAgICAgICAgdXJsUHJlZml4ICsgJ2xlZnQuanBnJyxcbiAgICAgICAgICAgICAgdXJsUHJlZml4ICsgJ3RvcC5qcGcnLFxuICAgICAgICAgICAgICB1cmxQcmVmaXggKyAnYm90dG9tLmpwZycsXG4gICAgICAgICAgICAgIHVybFByZWZpeCArICdmcm9udC5qcGcnLFxuICAgICAgICAgICAgICB1cmxQcmVmaXggKyAnYmFjay5qcGcnXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICB2YXIgdGV4dHVyZUN1YmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSh1cmxzLCBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRleHR1cmVDdWJlLmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdDtcblxuICAgICAgICAgICAgdmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYi5jdWJlO1xuXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICAgIHVuaWZvcm1zOiBzaGFkZXIudW5pZm9ybXMsXG4gICAgICAgICAgICAgIHNpZGU6IFRIUkVFLkJhY2tTaWRlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXMudEN1YmUudmFsdWUgPSB0ZXh0dXJlQ3ViZTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInZhciBWUk1hcmt1cCA9IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKTtcblxudmFyIFRIUkVFID0gVlJNYXJrdXAuVEhSRUU7XG52YXIgVlJPYmplY3QgPSBWUk1hcmt1cC5WUk9iamVjdDtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItc2t5c3BoZXJlJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R2VvbWV0cnk6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JhZGl1cycpKSB8fCA1MDAwO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShyYWRpdXMsIDY0LCA0MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbWdTcmMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7c2lkZTogVEhSRUUuQmFja1NpZGUsIGZvZzogZmFsc2V9KTtcblxuICAgICAgICAgICAgaWYgKGltZ1NyYykge1xuICAgICAgICAgICAgICBtYXRlcmlhbC5tYXAgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKGltZ1NyYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCcjQ0NDQ0NDJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJ2YXIgVlJNYXJrdXAgPSByZXF1aXJlKCdAbW96dnIvdnItbWFya3VwJyk7XG5cbnZhciBUSFJFRSA9IFZSTWFya3VwLlRIUkVFO1xudmFyIFZST2JqZWN0ID0gVlJNYXJrdXAuVlJPYmplY3Q7XG5cbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLXNwaGVyZScsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBWUk9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdlb21ldHJ5OiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdyYWRpdXMnKSkgfHwgNTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkocmFkaXVzLCAyMCwgMjApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNYXRlcmlhbDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJyk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxFbDtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbDtcblxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsSWQpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWxFbCA9IG1hdGVyaWFsSWQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIG1hdGVyaWFsSWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBtYXRlcmlhbCA9IG1hdGVyaWFsRWwubWF0ZXJpYWw7XG4gICAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7Y29sb3I6IGNvbG9yfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInZhciBWUk1hcmt1cCA9IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKTtcblxudmFyIFRIUkVFID0gVlJNYXJrdXAuVEhSRUU7XG52YXIgVlJPYmplY3QgPSBWUk1hcmt1cC5WUk9iamVjdDtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItdmlkZW8nLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiBubyBgdXBkYXRlYCBmdW5jdGlvbiBuZWVkZWQgKi9cblxuICAgICAgICBnZXRHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8IDUwKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCA1MCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkod2lkdGgsIGhlaWdodCwgMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgdmlkZW8uc3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgdmlkZW8uYXV0b3BsYXkgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIHZpZGVvLmxvb3AgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnbG9vcCcpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5WaWRlb1RleHR1cmUodmlkZW8pO1xuICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdDtcbiAgICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICBtYXA6IHRleHR1cmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgfVxuKTtcbiIsInZhciBWUk1hcmt1cCA9IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKTtcblxudmFyIFRIUkVFID0gVlJNYXJrdXAuVEhSRUU7XG52YXIgVlJPYmplY3QgPSBWUk1hcmt1cC5WUk9iamVjdDtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItdmlkZW8zNjAnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiBubyBgdXBkYXRlYCBmdW5jdGlvbiBuZWVkZWQgKi9cblxuICAgICAgICBnZXRHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgncmFkaXVzJykgfHwgMTAwMDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShyYWRpdXMsIDY0LCA0MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgdmlkZW8uc3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgdmlkZW8uYXV0b3BsYXkgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIHZpZGVvLmxvb3AgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnbG9vcCcpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5WaWRlb1RleHR1cmUodmlkZW8pO1xuICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdDtcblxuICAgICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICAgIG1hcDogdGV4dHVyZSxcbiAgICAgICAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIE1haW4gbGlicmFyeS5cbiAgVlJNYXJrdXA6IHJlcXVpcmUoJ0Btb3p2ci92ci1tYXJrdXAnKSxcblxuICAvLyBDb3JlIGNvbXBvbmVudHMuXG4gIGNvcmU6IHJlcXVpcmUoJy4vY29yZS8nKSxcblxuICAvLyBCb2lsZXJwbGF0ZSBzdHlsZXMuXG4gIGNzczogcmVxdWlyZSgnLi9zdHlsZS9pbmRleC5jc3MnKVxufTtcbiIsIi8qKlxuICogQGF1dGhvciBkbWFyY29zIC0gZGllZ28ubWFyY29zQGdtYWlsLmNvbVxuICpcbiAqIFJldXNhYmxlIGN1cnNvciBmb3IgM0Qgc2NlbmVzXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRIUkVFKSB7XG5cblx0dmFyIEN1cnNvciA9IGZ1bmN0aW9uICggb2JqZWN0LCByZW5kZXJlciApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgdG9wID0gTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIG9iamVjdC5mb3YgKiAwLjUgKSApICogb2JqZWN0Lm5lYXI7XG5cdFx0dmFyIGJvdHRvbSA9IC0gdG9wO1xuXHRcdHZhciBsZWZ0ID0gb2JqZWN0LmFzcGVjdCAqIGJvdHRvbTtcblx0XHR2YXIgcmlnaHQgPSBvYmplY3QuYXNwZWN0ICogdG9wO1xuXHRcdHZhciBuZWFyID0gb2JqZWN0Lm5lYXI7XG5cdFx0dmFyIGZhciA9IG9iamVjdC5mYXI7XG5cblx0XHR2YXIgY3Vyc29yUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBwaXhlbHNUb0RlZ3JlZXNGYWN0b3IgPSAwLjAwMDMwO1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy5sb2NrID0gZmFsc2U7XG5cdFx0dGhpcy5tYXhGT1YgPSAzMDtcblx0XHR0aGlzLmRlbHRhRXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoKTtcblx0XHR0aGlzLm1vdXNlRGVsdGFYID0gMDtcblx0XHR0aGlzLm1vdXNlRGVsdGFZID0gMDtcblxuXHRcdHRoaXMucG9pbnRlckxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApO1xuXHRcdHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSAoIHJlbmRlcmVyICE9PSB1bmRlZmluZWQgKSA/IHJlbmRlcmVyLmRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ25vbmUnO1xuXG5cdFx0dGhpcy5wb2ludGVyID0gbmV3IFRIUkVFLk1lc2goXG5cdFx0XHRuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIDAuMDA4LCAwLjAwOCwgMC4wMDggKSxcblx0XHRcdG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZjAwMDAsIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUgfSApXG5cdFx0KTtcblx0XHR0aGlzLnBvaW50ZXIucG9zaXRpb24ueiA9IC03NTtcblx0XHR0aGlzLmFkZCggdGhpcy5wb2ludGVyICk7XG5cdFx0dGhpcy5zY2VuZS5hZGQoIHRoaXMgKTtcblxuXHRcdC8vIEluaXRpYWxpemF0aW9uIG9mIGxvY2FsIHZhcmlhYmxlc1xuXHRcdC8vIFRvIGF2b2lkIGFsbG9jYXRpb25zIGluIGV2ZXJ5IGZyYW1lXG5cdFx0dGhpcy5tb3VzZVZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuXHRcdHRoaXMuZGVsdGFRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHR0aGlzLmRlbHRhTW91c2VRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdC8vIHVwZGF0ZVxuXHRcdC8vIEl0IHN0b3JlcyB0aGUgY2FtZXJhIG9yaWVudGF0aW9uIGNoYW5nZSBiZXR3ZWVuIGZyYW1lc1xuXHRcdHRoaXMuY2FtZXJhRGVsdGFRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHQvLyBJdCBzdG9yZXMgdGhlIGludmVyc2Ugb2YgdGhlIGNhbWVyYSBvcmllbnRhdGlvblxuXHRcdHRoaXMuY2FtZXJhSW52ZXJzZSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHQvLyB1cGRhdGVNb3VzZVF1YXRlcm5pb25cblx0XHR0aGlzLnhEZWx0YVF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHRcdHRoaXMueURlbHRhUXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cdFx0dGhpcy5tb3VzZU1vdmVRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHR0aGlzLnhBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCk7XG5cdFx0dGhpcy55QXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuXHRcdHRoaXMubW91c2VRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVsdGFBbmdsZTtcblx0XHRcdHZhciBjYW1lcmFJbnZlcnNlID0gc2NvcGUuY2FtZXJhSW52ZXJzZTtcblx0XHRcdC8vIElmIHRoZSBwb2ludGVyIGlzIGxvY2tlZCB3ZSBtb3ZlIHRoZSBjdXJzb3IgcmFkaWFsbHlcblx0XHRcdGlmICggc2NvcGUucG9pbnRlckxvY2tlZCApIHtcblx0XHRcdFx0Ly8gRmlyc3QgZnJhbWUgd2UgaW5pdGlhbGl6ZSB2YXJpYWJsZXNcblx0XHRcdFx0aWYgKCAhc2NvcGUucHJldmlvdXNDYW1lcmFRdWF0ICkge1xuXHRcdFx0XHRcdHNjb3BlLmRlbHRhTW91c2VRdWF0LmNvcHkoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0XHRcdFx0c2NvcGUucHJldmlvdXNDYW1lcmFRdWF0ID0gc2NvcGUub2JqZWN0LnF1YXRlcm5pb24uY2xvbmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBbmdsZSBiZXR3ZWVuIGNhbWVyYSBhbmQgY3Vyc29yXG5cdFx0XHRcdGRlbHRhQW5nbGUgPSBxdWF0ZXJuaW9uc0FuZ2xlKCBzY29wZS5vYmplY3QucXVhdGVybmlvbiwgc2NvcGUucXVhdGVybmlvbiApICogKCAxODAgLyBNYXRoLlBJICkgO1xuXG5cdFx0XHRcdC8vIEl0IGNhbGN1bGF0ZXMgaG93IG11Y2ggdGhlIGNhbWVyYSBvcmllbnRhdGlvbiBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGZyYW1lXG5cdFx0XHRcdC8vIGRpZmYgKiBxMSA9IHEyICAtLS0+ICBkaWZmID0gcTIgKiBpbnZlcnNlKHExKVxuXHRcdFx0XHQvLyB3aGVyZTogIGludmVyc2UocTEpID0gY29uanVnYXRlKHExKSAvIGFicyhxMSlcblx0XHRcdFx0Ly8gYW5kOiAgY29uanVnYXRlKCBxdWF0ZXJuaW9uKHJlLCBpLCBqLCBrKSApID0gcXVhdGVybmlvbihyZSwgLWksIC1qLCAtaylcblx0XHRcdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMjE1NzQzNS9kaWZmZXJlbmNlLWJldHdlZW4tdGhlLXR3by1xdWF0ZXJuaW9uc1xuXHRcdFx0XHRjYW1lcmFJbnZlcnNlLmNvcHkoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICkuaW52ZXJzZSgpO1xuXHRcdFx0XHRzY29wZS5jYW1lcmFEZWx0YVF1YXRlcm5pb24uY29weSggc2NvcGUucHJldmlvdXNDYW1lcmFRdWF0ICkubXVsdGlwbHkoIGNhbWVyYUludmVyc2UgKTtcblxuXHRcdFx0XHQvKioqKioqKioqKi9cblx0XHRcdFx0Ly8gUElORyBQT05HXG5cdFx0XHRcdC8vIElmIHRoZSBjdXJzb3IgZ29lcyBvdXQgb2YgRk9WIGl0IHN5bmNzIGNhbWVyYSBhbmQgY3Vyc29yIG9yaXRlbnRhdGlvblxuXHRcdFx0XHRpZiAoIGRlbHRhQW5nbGUgPj0gc2NvcGUubWF4Rk9WICkge1xuXHRcdFx0XHRcdHNjb3BlLmRlbHRhUXVhdGVybmlvbi5tdWx0aXBseSggc2NvcGUuY2FtZXJhRGVsdGFRdWF0ZXJuaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUElORyBQT05HXG5cblx0XHRcdFx0Ly8gLy8gU1RJQ0tZXG5cdFx0XHRcdC8vIGlmICggZGVsdGFBbmdsZSA+PSB0aGlzLm1heEZPViApIHtcblx0XHRcdFx0Ly8gXHRzY29wZS5sb2NrID0gdHJ1ZTtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0XHQvLyBpZiAoIHNjb3BlLmxvY2sgKSB7XG5cdFx0XHRcdC8vXHRzY29wZS5kZWx0YVF1YXRlcm5pb24ubXVsdGlwbHkoIHNjb3BlLmNhbWVyYURlbHRhUXVhdGVybmlvbiApO1xuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdC8vIC8vIFNUSUNLWVxuXHRcdFx0XHQvKioqKioqKioqKi9cblxuXHRcdFx0XHRzY29wZS51cGRhdGVNb3VzZVF1YXRlcm5pb24oKTtcblxuXHRcdFx0XHQvLyBOZXcgY3Vyc29yIHF1YXRlcm5pb25cblx0XHRcdFx0c2NvcGUucXVhdGVybmlvbi5jb3B5KCBzY29wZS5kZWx0YVF1YXRlcm5pb24gKS5pbnZlcnNlKCk7XG5cdFx0XHRcdHNjb3BlLnF1YXRlcm5pb24ubXVsdGlwbHkoIHNjb3BlLmRlbHRhTW91c2VRdWF0ICk7XG5cblx0XHRcdFx0Ly8gV2UgY29weSBjdXJyZW50IHF1YXRlcm5pb24gaW4gcHJldmlvdXMgZm9yIHRoZSBuZXh0IGZyYW1lXG5cdFx0XHRcdHNjb3BlLnByZXZpb3VzQ2FtZXJhUXVhdC5jb3B5KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApO1xuXHRcdFx0XHRzY29wZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBJZiB0aGUgcG9pbnRlciBpcyBub3QgbG9ja2VkIHdlIG1vdmUgdGhlIHBvaW50ZXIgb24gYSAyZCBwbGFuZVxuXG5cdFx0XHRcdHNjb3BlLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRzY29wZS5wb2ludGVyLnBvc2l0aW9uLnggPSBzY29wZS5tb3VzZVZlY3Rvci54O1xuXHRcdFx0XHRzY29wZS5wb2ludGVyLnBvc2l0aW9uLnkgPSAtc2NvcGUubW91c2VWZWN0b3IueTtcblx0XHRcdFx0c2NvcGUucmVuZGVyKCk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLnVwZGF0ZU1vdXNlUXVhdGVybmlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1vdXNlUXVhdCA9IHNjb3BlLm1vdXNlUXVhdDtcblx0XHRcdHZhciBkZWx0YUFuZ2xlO1xuXHRcdFx0dmFyIHhEZWx0YVF1YXRlcm5pb24gPSBzY29wZS54RGVsdGFRdWF0ZXJuaW9uO1xuXHRcdFx0dmFyIHlEZWx0YVF1YXRlcm5pb24gPSBzY29wZS55RGVsdGFRdWF0ZXJuaW9uO1xuXHRcdFx0dmFyIG1vdXNlTW92ZVF1YXQgPSBzY29wZS5tb3VzZU1vdmVRdWF0O1xuXHRcdFx0dmFyIHhBeGlzID0gc2NvcGUueEF4aXMuc2V0KCAxLCAwLCAwICk7XG5cdFx0XHR2YXIgeUF4aXMgPSBzY29wZS55QXhpcy5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdHZhciB4SW5jID0gc2NvcGUubW91c2VEZWx0YVg7XG5cdFx0XHR2YXIgeUluYyA9IHNjb3BlLm1vdXNlRGVsdGFZO1xuXHRcdFx0dmFyIGluY1NpZ247XG5cblx0XHRcdGlmICggeEluYyAhPT0gMCB8fCB5SW5jICE9PTAgKSB7XG5cblx0XHRcdFx0c2NvcGUub2JqZWN0LmxvY2FsVG9Xb3JsZCggeEF4aXMgKTtcblx0XHRcdFx0eERlbHRhUXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCB4QXhpcywgeEluYyAqIDIgKiBNYXRoLlBJICk7XG5cblx0XHRcdFx0c2NvcGUub2JqZWN0LmxvY2FsVG9Xb3JsZCggeUF4aXMgKTtcblx0XHRcdFx0eURlbHRhUXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCB5QXhpcywgeUluYyAqIDIgKiBNYXRoLlBJICk7XG5cblx0XHRcdFx0Ly8gTW92ZSB0aGUgY3Vyc29yIGluIHRoZSB0d28gZGlmZmVyZW50IGF4aXMgb2YgdGhlIHBvbGFyIGNvb3JkaW5hdGVzOiDOuCBhbmQgz4Zcblx0XHRcdFx0bW91c2VNb3ZlUXVhdC5jb3B5KCB4RGVsdGFRdWF0ZXJuaW9uICkubXVsdGlwbHkoIHlEZWx0YVF1YXRlcm5pb24gKTtcblx0XHRcdFx0Ly8gVGVzdCBpZiB0aGUgbW91c2UgZGVsdGEgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgRk9WXG5cdFx0XHRcdG1vdXNlUXVhdC5jb3B5KCBtb3VzZU1vdmVRdWF0ICkubXVsdGlwbHkoIHNjb3BlLnF1YXRlcm5pb24gKTtcblx0XHRcdFx0Ly8gQW5nbGUgYmV0d2VlbiBjYW1lcmEgb3JpZW50YXRpb24gYW5kIG5ldyBjdXJzb3Igb3JpZW50YXRpb25cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IHF1YXRlcm5pb25zQW5nbGUoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uLCBtb3VzZVF1YXQgKSAqICggMTgwIC8gTWF0aC5QSSApO1xuXHRcdFx0XHQvLyBJZiB0aGUgY3Vyc29yIHN0YXlzIGluIEZPViB3ZSBhcHBseSB0aGUgZGVsdGFcblx0XHRcdFx0aWYgKGRlbHRhQW5nbGUgPCBzY29wZS5tYXhGT1YpIHtcblx0XHRcdFx0XHRzY29wZS5kZWx0YU1vdXNlUXVhdC5jb3B5KCBtb3VzZU1vdmVRdWF0ICkubXVsdGlwbHkoIHNjb3BlLnF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHRzY29wZS5kZWx0YVF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHRcdFx0XHRcdC8vIC8vIFNUSUNLWVxuXHRcdFx0XHRcdC8vIHRoaXMubG9jayA9IGZhbHNlO1xuXHRcdFx0XHRcdC8vIC8vIFNUSUNLWVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubW91c2VEZWx0YVggPSAwO1xuXHRcdFx0XHRzY29wZS5tb3VzZURlbHRhWSA9IDA7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHNjb3BlLnBvaW50ZXJMb2NrZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBhdXRvQ2xlYXIgPSBzY29wZS5yZW5kZXJlci5hdXRvQ2xlYXI7XG5cdFx0XHRpZiAoIHNjb3BlLnBhcmVudCAhPT0gc2NvcGUuc2NlbmUgKSB7XG5cdFx0XHRcdHN0b3JlUGFyZW50U2NlbmUoKTtcblx0XHRcdFx0c2NvcGUucGFyZW50LnJlbW92ZSggc2NvcGUgKTtcblx0XHRcdFx0c2NvcGUuc2NlbmUuYWRkKCBzY29wZSApO1xuXHRcdFx0fVxuXHRcdFx0c2NvcGUucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG5cdFx0XHRzY29wZS5yZW5kZXJlci5yZW5kZXIoIHNjb3BlLnNjZW5lLCBzY29wZS5jYW1lcmEgKTtcblx0XHRcdHNjb3BlLnJlbmRlcmVyLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlU2NyZWVuUG9zaXRpb24oIGUgKSB7XG5cdFx0XHQvLyBJdCBjb252ZXJ0cyBmcm9tIHNjcmVlbiB0byBjYW1lcmEgY29vcmRpbmF0ZXNcblx0XHRcdHZhciBtb3VzZVggPSAoIGUuY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoICkgKiAyIC0gMTtcblx0XHRcdHZhciBtb3VzZVkgPSAoIGUuY2xpZW50WSAvIHdpbmRvdy5pbm5lckhlaWdodCApICogMiAtIDE7XG5cblx0XHRcdC8vIGN1cnNvciBwb3NpdGlvbiBpbiBjYW1lcmEgY29vcmRpbmF0ZXNcblx0XHRcdGN1cnNvclBvc2l0aW9uLmNvcHkoIHNjb3BlLnBvaW50ZXIucG9zaXRpb24gKTtcblx0XHRcdGN1cnNvclBvc2l0aW9uLnByb2plY3QoIHNjb3BlLmNhbWVyYSApO1xuXG5cdFx0XHRzY29wZS5tb3VzZVZlY3Rvci5zZXQoIG1vdXNlWCwgbW91c2VZLCBjdXJzb3JQb3NpdGlvbi56ICk7XG5cdFx0XHRzY29wZS5tb3VzZVZlY3Rvci51bnByb2plY3QoIHNjb3BlLmNhbWVyYSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVJhZGlhbFBvc2l0aW9uKCBlICkge1xuXHRcdFx0dmFyIG1vdmVtZW50WCA9IGUubW92ZW1lbnRYIHx8XG5cdFx0XHRcdFx0ZS5tb3pNb3ZlbWVudFggfHxcblx0XHRcdFx0XHRlLndlYmtpdE1vdmVtZW50WCB8fCAwO1xuXG5cdFx0XHR2YXIgbW92ZW1lbnRZID0gZS5tb3ZlbWVudFkgfHxcblx0XHRcdFx0XHRlLm1vek1vdmVtZW50WSB8fFxuXHRcdFx0XHRcdGUud2Via2l0TW92ZW1lbnRZIHx8IDA7XG5cblx0XHRcdHNjb3BlLm1vdXNlRGVsdGFYIC09IG1vdmVtZW50WSAqIHBpeGVsc1RvRGVncmVlc0ZhY3Rvcjtcblx0XHRcdHNjb3BlLm1vdXNlRGVsdGFZIC09IG1vdmVtZW50WCAqIHBpeGVsc1RvRGVncmVlc0ZhY3Rvcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBxdWF0ZXJuaW9uc0FuZ2xlKHExLCBxMikge1xuXHRcdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0xICk7XG5cdFx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLTEgKTtcblx0XHRcdHYxLmFwcGx5UXVhdGVybmlvbihxMSk7XG5cdFx0XHR2Mi5hcHBseVF1YXRlcm5pb24ocTIpO1xuXHRcdFx0cmV0dXJuIHYxLmFuZ2xlVG8odjIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBlICkge1xuXHRcdFx0aWYgKCBzY29wZS5wb2ludGVyTG9ja2VkICkge1xuXHRcdFx0XHRpZiAoIHNjb3BlLm1vdXNlRG93biA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVGhlIGN1cnNvciBtb3ZlcyByYWRpYWxseSBhcm91bmQgdGhlIHVzZXJcblx0XHRcdFx0dXBkYXRlUmFkaWFsUG9zaXRpb24gKCBlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBUaGUgY3Vyc29yIG1vdmVzIG9uIHRoZSBmbGF0IHNjcmVlblxuXHRcdFx0XHR1cGRhdGVTY3JlZW5Qb3NpdGlvbiAoIGUgKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0UGl2b3QoIG9iamVjdCApIHtcblx0XHRcdHNjb3BlLnBvc2l0aW9uLmNvcHkoIG9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0c2NvcGUucXVhdGVybmlvbi5jb3B5KCBvYmplY3QucXVhdGVybmlvbiApO1xuXHRcdFx0c2NvcGUuZGVsdGFRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwb2ludGVyTG9ja0NoYW5nZWQoKSB7XG5cdFx0XHRzY29wZS5wb2ludGVyTG9ja2VkID1cblx0XHRcdFx0ZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ID09PSBzY29wZS5kb21FbGVtZW50IHx8XG5cdFx0XHRcdGRvY3VtZW50Lm1velBvaW50ZXJMb2NrRWxlbWVudCA9PT0gc2NvcGUuZG9tRWxlbWVudCB8fFxuXHRcdFx0XHRkb2N1bWVudC53ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQgPT09IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRcdHN0b3JlUGFyZW50U2NlbmUoKTtcblxuXHRcdFx0aWYgKCBzY29wZS5wb2ludGVyTG9ja2VkID09PSB0cnVlICkge1xuXHRcdFx0XHRyZXNldFBpdm90KCBzY29wZS5vYmplY3QgKTtcblx0XHRcdFx0c2NvcGUuc2NlbmUucmVtb3ZlKCBzY29wZSApO1xuXHRcdFx0XHRzY29wZS5wYXJlbnRTY2VuZS5hZGQoIHNjb3BlICk7XG5cdFx0XHRcdHNjb3BlLnBvaW50ZXIuc2NhbGUuc2V0KCA1MCwgNTAsIDUwICk7XG5cdFx0XHRcdHNjb3BlLnByZXZpb3VzQ2FtZXJhUXVhdCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzZXRQaXZvdCggc2NvcGUuY2FtZXJhICk7XG5cdFx0XHRcdHNjb3BlLnBhcmVudFNjZW5lLnJlbW92ZSggc2NvcGUgKTtcblx0XHRcdFx0c2NvcGUuc2NlbmUuYWRkKCBzY29wZSApO1xuXHRcdFx0XHRzY29wZS5wb2ludGVyLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXHRcdFx0XHRzY29wZS5wb2ludGVyTG9ja2VkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHRcdFx0c2NvcGUubW91c2VEb3duID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuXHRcdFx0c2NvcGUubW91c2VEb3duID0gdHJ1ZTtcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2NsaWNrJywgZGF0YTogZSB9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RvcmVQYXJlbnRTY2VuZSgpIHtcblx0XHRcdGlmICggIXNjb3BlLnBhcmVudFNjZW5lICYmIHNjb3BlLnBhcmVudCAhPT0gc2NvcGUuc2NlbmUgKSB7XG5cdFx0XHRcdHNjb3BlLnBhcmVudFNjZW5lID0gc2NvcGUucGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybG9ja2NoYW5nZScsIHBvaW50ZXJMb2NrQ2hhbmdlZCwgZmFsc2UgKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW96cG9pbnRlcmxvY2tjaGFuZ2UnLCBwb2ludGVyTG9ja0NoYW5nZWQsIGZhbHNlICk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmtpdHBvaW50ZXJsb2NrY2hhbmdlJywgcG9pbnRlckxvY2tDaGFuZ2VkLCBmYWxzZSApO1xuXG5cdH07XG5cblx0Q3Vyc29yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5cdHJldHVybiBDdXJzb3I7XG5cbn07XG4iLCJ2YXIgVEhSRUUgPSByZXF1aXJlKCcuL3ZlbmRvci90aHJlZScpO1xuXG4vLyBUT0RPOiBFdmVudHVhbGx5IGluY2x1ZGUgdGhlc2Ugb25seSBpZiB0aGV5IGFyZSBuZWVkZWQgYnkgYSBjb21wb25lbnQuXG5USFJFRS5DdXJzb3IgPSByZXF1aXJlKCcuLi9saWIvY3Vyc29yM0QnKShUSFJFRSk7XG5USFJFRS5SYXljYXN0ZXIgPSByZXF1aXJlKCcuLi9saWIvdmVuZG9yL1JheWNhc3RlcicpKFRIUkVFKTtcblRIUkVFLlNoYWRlckxpYi5wYnIgPSByZXF1aXJlKCcuLi9zcmMvc2hhZGVycy9wYnInKShUSFJFRSk7XG5USFJFRS5WUkNvbnRyb2xzID0gcmVxdWlyZSgnLi4vbGliL3ZlbmRvci9WUkNvbnRyb2xzJyk7XG5USFJFRS5WUkVmZmVjdCA9IHJlcXVpcmUoJy4uL2xpYi92ZW5kb3IvVlJFZmZlY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcbiIsIi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbS9cbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRIUkVFKSB7XG5cblx0dmFyIFJheWNhc3RlciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xuXG5cdFx0dGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cblx0XHR0aGlzLnBhcmFtcyA9IHtcblx0XHRcdFNwcml0ZToge30sXG5cdFx0XHRNZXNoOiB7fSxcblx0XHRcdFBvaW50Q2xvdWQ6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0XHRMT0Q6IHt9LFxuXHRcdFx0TGluZToge31cblx0XHR9O1xuXG5cdH07XG5cblx0dmFyIGRlc2NTb3J0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG5cdH07XG5cblx0dmFyIGludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHRSYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFJheWNhc3RlcixcblxuXHRcdHByZWNpc2lvbjogMC4wMDAxLFxuXHRcdGxpbmVQcmVjaXNpb246IDEsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG5cdFx0XHQvLyBjYW1lcmEgaXMgYXNzdW1lZCBfbm90XyB0byBiZSBhIGNoaWxkIG9mIGEgdHJhbnNmb3JtZWQgb2JqZWN0XG5cblx0XHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0dGhpcy5yYXkub3JpZ2luLmNvcHkoIGNhbWVyYS5wb3NpdGlvbiApO1xuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCBjYW1lcmEucG9zaXRpb24gKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcblxuXHRcdFx0aWYgKCBvYmplY3RzIGluc3RhbmNlb2YgQXJyYXkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0cmV0dXJuIFJheWNhc3RlcjtcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBkbWFyY29zIC8gaHR0cHM6Ly9naXRodWIuY29tL2RtYXJjb3NcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqL1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCcuL3RocmVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBvYmplY3QsIG9uRXJyb3IgKSB7XG5cbiAgdmFyIHNjb3BlID0gdGhpcztcblxuICB2YXIgdnJJbnB1dHMgPSBbXTtcblxuICBmdW5jdGlvbiBmaWx0ZXJJbnZhbGlkRGV2aWNlcyggZGV2aWNlcyApIHtcblxuICAgIC8vIEV4Y2x1ZGUgQ2FyZGJvYXJkIHBvc2l0aW9uIHNlbnNvciBpZiBPY3VsdXMgZXhpc3RzLlxuXG4gICAgdmFyIG9jdWx1c0RldmljZXMgPSBkZXZpY2VzLmZpbHRlciggZnVuY3Rpb24gKCBkZXZpY2UgKSB7XG5cbiAgICAgIHJldHVybiBkZXZpY2UuZGV2aWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ29jdWx1cycpICE9PSAtMTtcblxuICAgIH0gKTtcblxuICAgIGlmICggb2N1bHVzRGV2aWNlcy5sZW5ndGggPj0gMSApIHtcblxuICAgICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKCBmdW5jdGlvbiAoIGRldmljZSApIHtcblxuICAgICAgICByZXR1cm4gZGV2aWNlLmRldmljZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjYXJkYm9hcmQnKSA9PT0gLTE7XG5cbiAgICAgIH0gKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBkZXZpY2VzO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnb3RWUkRldmljZXMoIGRldmljZXMgKSB7XG5cbiAgICBkZXZpY2VzID0gZmlsdGVySW52YWxpZERldmljZXMoIGRldmljZXMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRldmljZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICBpZiAoIGRldmljZXNbIGkgXSBpbnN0YW5jZW9mIFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgKSB7XG5cbiAgICAgICAgdnJJbnB1dHMucHVzaCggZGV2aWNlc1sgaSBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggb25FcnJvciApIG9uRXJyb3IoICdITUQgbm90IGF2YWlsYWJsZScgKTtcblxuICB9XG5cbiAgaWYgKCBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzICkge1xuXG4gICAgbmF2aWdhdG9yLmdldFZSRGV2aWNlcygpLnRoZW4oIGdvdFZSRGV2aWNlcyApO1xuXG4gIH1cblxuICAvLyB0aGUgUmlmdCBTREsgcmV0dXJucyB0aGUgcG9zaXRpb24gaW4gbWV0ZXJzXG4gIC8vIHRoaXMgc2NhbGUgZmFjdG9yIGFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgaG93IG1ldGVyc1xuICAvLyBhcmUgY29udmVydGVkIHRvIHNjZW5lIHVuaXRzLlxuXG4gIHRoaXMuc2NhbGUgPSAxO1xuXG4gIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdnJJbnB1dHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgdnJJbnB1dCA9IHZySW5wdXRzWyBpIF07XG5cbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUgPSB2cklucHV0LmdldFN0YXRlKCk7XG5cbiAgICAgIGlmICggc3RhdGUub3JpZW50YXRpb24gIT09IG51bGwgKSB7XG5cbiAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uY29weSggc3RhdGUub3JpZW50YXRpb24gKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHN0YXRlLnBvc2l0aW9uICE9PSBudWxsICkge1xuXG4gICAgICAgIG9iamVjdC5wb3NpdGlvbi5jb3B5KCBzdGF0ZS5wb3NpdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5zY2FsZSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnJlc2V0U2Vuc29yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdnJJbnB1dHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgdnJJbnB1dCA9IHZySW5wdXRzWyBpIF07XG5cbiAgICAgIGlmICggdnJJbnB1dC5yZXNldFNlbnNvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZySW5wdXQucmVzZXRTZW5zb3IoKTtcblxuICAgICAgfSBlbHNlIGlmICggdnJJbnB1dC56ZXJvU2Vuc29yICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdnJJbnB1dC56ZXJvU2Vuc29yKCk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuemVyb1NlbnNvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZSQ29udHJvbHM6IC56ZXJvU2Vuc29yKCkgaXMgbm93IC5yZXNldFNlbnNvcigpLicgKTtcbiAgICB0aGlzLnJlc2V0U2Vuc29yKCk7XG5cbiAgfTtcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBkbWFyY29zIC8gaHR0cHM6Ly9naXRodWIuY29tL2RtYXJjb3NcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqXG4gKiBXZWJWUiBTcGVjOiBodHRwOi8vbW96dnIuZ2l0aHViLmlvL3dlYnZyLXNwZWMvd2VidnIuaHRtbFxuICpcbiAqIEZpcmVmb3g6IGh0dHA6Ly9tb3p2ci5jb20vZG93bmxvYWRzL1xuICogQ2hyb21pdW06IGh0dHBzOi8vZHJpdmUuZ29vZ2xlLmNvbS9mb2xkZXJ2aWV3P2lkPTBCenVkTHQyMkJxR1JiVzlXVEhNdE9XTXpOalEmdXNwPXNoYXJpbmcjbGlzdFxuICpcbiAqL1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCcuL3RocmVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCByZW5kZXJlciwgb25FcnJvciApIHtcblxuICB2YXIgdnJITUQ7XG4gIHZhciBleWVUcmFuc2xhdGlvbkwsIGV5ZUZPVkw7XG4gIHZhciBleWVUcmFuc2xhdGlvblIsIGV5ZUZPVlI7XG5cbiAgZnVuY3Rpb24gZ290VlJEZXZpY2VzKCBkZXZpY2VzICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGV2aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIGlmICggZGV2aWNlc1sgaSBdIGluc3RhbmNlb2YgSE1EVlJEZXZpY2UgKSB7XG5cbiAgICAgICAgdnJITUQgPSBkZXZpY2VzWyBpIF07XG5cbiAgICAgICAgaWYgKCB2ckhNRC5nZXRFeWVQYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICB2YXIgZXllUGFyYW1zTCA9IHZySE1ELmdldEV5ZVBhcmFtZXRlcnMoICdsZWZ0JyApO1xuICAgICAgICAgIHZhciBleWVQYXJhbXNSID0gdnJITUQuZ2V0RXllUGFyYW1ldGVycyggJ3JpZ2h0JyApO1xuXG4gICAgICAgICAgZXllVHJhbnNsYXRpb25MID0gZXllUGFyYW1zTC5leWVUcmFuc2xhdGlvbjtcbiAgICAgICAgICBleWVUcmFuc2xhdGlvblIgPSBleWVQYXJhbXNSLmV5ZVRyYW5zbGF0aW9uO1xuICAgICAgICAgIGV5ZUZPVkwgPSBleWVQYXJhbXNMLnJlY29tbWVuZGVkRmllbGRPZlZpZXc7XG4gICAgICAgICAgZXllRk9WUiA9IGV5ZVBhcmFtc1IucmVjb21tZW5kZWRGaWVsZE9mVmlldztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhbiBvbGRlciBjb2RlIHBhdGggYW5kIG5vdCBzcGVjIGNvbXBsaWFudC5cbiAgICAgICAgICAvLyBJdCBzaG91bGQgYmUgcmVtb3ZlZCBhdCBzb21lIHBvaW50IGluIHRoZSBuZWFyIGZ1dHVyZS5cbiAgICAgICAgICBleWVUcmFuc2xhdGlvbkwgPSB2ckhNRC5nZXRFeWVUcmFuc2xhdGlvbiggJ2xlZnQnICk7XG4gICAgICAgICAgZXllVHJhbnNsYXRpb25SID0gdnJITUQuZ2V0RXllVHJhbnNsYXRpb24oICdyaWdodCcgKTtcbiAgICAgICAgICBleWVGT1ZMID0gdnJITUQuZ2V0UmVjb21tZW5kZWRFeWVGaWVsZE9mVmlldyggJ2xlZnQnICk7XG4gICAgICAgICAgZXllRk9WUiA9IHZySE1ELmdldFJlY29tbWVuZGVkRXllRmllbGRPZlZpZXcoICdyaWdodCcgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7IC8vIFdlIGtlZXAgdGhlIGZpcnN0IHdlIGVuY291bnRlclxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIHZySE1EID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGlmICggb25FcnJvciApIG9uRXJyb3IoICdITUQgbm90IGF2YWlsYWJsZScgKTtcblxuICAgIH1cblxuICB9XG5cbiAgaWYgKCBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzICkge1xuXG4gICAgbmF2aWdhdG9yLmdldFZSRGV2aWNlcygpLnRoZW4oIGdvdFZSRGV2aWNlcyApO1xuXG4gIH1cblxuICAvL1xuXG4gIHRoaXMuc2NhbGUgPSAxO1xuXG4gIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSggd2lkdGgsIGhlaWdodCApO1xuXG4gIH07XG5cbiAgLy8gZnVsbHNjcmVlblxuXG4gIHZhciBpc0Z1bGxzY3JlZW4gPSBmYWxzZTtcblxuICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZG9tRWxlbWVudDtcbiAgdmFyIGZ1bGxzY3JlZW5jaGFuZ2UgPSBjYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4gPyAnbW96ZnVsbHNjcmVlbmNoYW5nZScgOiAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSc7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggZnVsbHNjcmVlbmNoYW5nZSwgZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgIGlzRnVsbHNjcmVlbiA9IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xuXG4gIH0sIGZhbHNlICk7XG5cbiAgdGhpcy5zZXRGdWxsU2NyZWVuID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xuXG4gICAgaWYgKCB2ckhNRCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuICAgIGlmICggaXNGdWxsc2NyZWVuID09PSBib29sZWFuICkgcmV0dXJuO1xuXG4gICAgaWYgKCBjYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4gKSB7XG5cbiAgICAgIGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbiggeyB2ckRpc3BsYXk6IHZySE1EIH0gKTtcblxuICAgIH0gZWxzZSBpZiAoIGNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiApIHtcblxuICAgICAgY2FudmFzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCB7IHZyRGlzcGxheTogdnJITUQgfSApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gcmVuZGVyXG5cbiAgdmFyIGNhbWVyYUwgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcbiAgdmFyIGNhbWVyYVIgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcblxuICAgIGlmICggdnJITUQgKSB7XG5cbiAgICAgIHZhciBzY2VuZUwsIHNjZW5lUjtcblxuICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBzY2VuZSApICkge1xuXG4gICAgICAgIHNjZW5lTCA9IHNjZW5lWyAwIF07XG4gICAgICAgIHNjZW5lUiA9IHNjZW5lWyAxIF07XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgc2NlbmVMID0gc2NlbmU7XG4gICAgICAgIHNjZW5lUiA9IHNjZW5lO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplID0gcmVuZGVyZXIuZ2V0U2l6ZSgpO1xuICAgICAgc2l6ZS53aWR0aCAvPSAyO1xuXG4gICAgICByZW5kZXJlci5lbmFibGVTY2lzc29yVGVzdCggdHJ1ZSApO1xuICAgICAgcmVuZGVyZXIuY2xlYXIoKTtcblxuICAgICAgaWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgIGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WTCwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcbiAgICAgIGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WUiwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcblxuICAgICAgY2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggY2FtZXJhTC5wb3NpdGlvbiwgY2FtZXJhTC5xdWF0ZXJuaW9uLCBjYW1lcmFMLnNjYWxlICk7XG4gICAgICBjYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKCBjYW1lcmFSLnBvc2l0aW9uLCBjYW1lcmFSLnF1YXRlcm5pb24sIGNhbWVyYVIuc2NhbGUgKTtcblxuICAgICAgY2FtZXJhTC50cmFuc2xhdGVYKCBleWVUcmFuc2xhdGlvbkwueCAqIHRoaXMuc2NhbGUgKTtcbiAgICAgIGNhbWVyYVIudHJhbnNsYXRlWCggZXllVHJhbnNsYXRpb25SLnggKiB0aGlzLnNjYWxlICk7XG5cbiAgICAgIC8vIHJlbmRlciBsZWZ0IGV5ZVxuICAgICAgcmVuZGVyZXIuc2V0Vmlld3BvcnQoIDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG4gICAgICByZW5kZXJlci5zZXRTY2lzc29yKCAwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZUwsIGNhbWVyYUwgKTtcblxuICAgICAgLy8gcmVuZGVyIHJpZ2h0IGV5ZVxuICAgICAgcmVuZGVyZXIuc2V0Vmlld3BvcnQoIHNpemUud2lkdGgsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG4gICAgICByZW5kZXJlci5zZXRTY2lzc29yKCBzaXplLndpZHRoLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZVIsIGNhbWVyYVIgKTtcblxuICAgICAgcmVuZGVyZXIuZW5hYmxlU2Npc3NvclRlc3QoIGZhbHNlICk7XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIC8vIFJlZ3VsYXIgcmVuZGVyIG1vZGUgaWYgbm90IEhNRFxuXG4gICAgaWYgKCBBcnJheS5pc0FycmF5KCBzY2VuZSApICkgc2NlbmUgPSBzY2VuZVsgMCBdO1xuXG4gICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cbiAgfTtcblxuICAvL1xuXG4gIGZ1bmN0aW9uIGZvdlRvTkRDU2NhbGVPZmZzZXQoIGZvdiApIHtcblxuICAgIHZhciBweHNjYWxlID0gMi4wIC8gKCBmb3YubGVmdFRhbiArIGZvdi5yaWdodFRhbiApO1xuICAgIHZhciBweG9mZnNldCA9ICggZm92LmxlZnRUYW4gLSBmb3YucmlnaHRUYW4gKSAqIHB4c2NhbGUgKiAwLjU7XG4gICAgdmFyIHB5c2NhbGUgPSAyLjAgLyAoIGZvdi51cFRhbiArIGZvdi5kb3duVGFuICk7XG4gICAgdmFyIHB5b2Zmc2V0ID0gKCBmb3YudXBUYW4gLSBmb3YuZG93blRhbiApICogcHlzY2FsZSAqIDAuNTtcbiAgICByZXR1cm4geyBzY2FsZTogWyBweHNjYWxlLCBweXNjYWxlIF0sIG9mZnNldDogWyBweG9mZnNldCwgcHlvZmZzZXQgXSB9O1xuXG4gIH1cblxuICBmdW5jdGlvbiBmb3ZQb3J0VG9Qcm9qZWN0aW9uKCBmb3YsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApIHtcblxuICAgIHJpZ2h0SGFuZGVkID0gcmlnaHRIYW5kZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiByaWdodEhhbmRlZDtcbiAgICB6TmVhciA9IHpOZWFyID09PSB1bmRlZmluZWQgPyAwLjAxIDogek5lYXI7XG4gICAgekZhciA9IHpGYXIgPT09IHVuZGVmaW5lZCA/IDEwMDAwLjAgOiB6RmFyO1xuXG4gICAgdmFyIGhhbmRlZG5lc3NTY2FsZSA9IHJpZ2h0SGFuZGVkID8gLSAxLjAgOiAxLjA7XG5cbiAgICAvLyBzdGFydCB3aXRoIGFuIGlkZW50aXR5IG1hdHJpeFxuICAgIHZhciBtb2JqID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB2YXIgbSA9IG1vYmouZWxlbWVudHM7XG5cbiAgICAvLyBhbmQgd2l0aCBzY2FsZS9vZmZzZXQgaW5mbyBmb3Igbm9ybWFsaXplZCBkZXZpY2UgY29vcmRzXG4gICAgdmFyIHNjYWxlQW5kT2Zmc2V0ID0gZm92VG9ORENTY2FsZU9mZnNldCggZm92ICk7XG5cbiAgICAvLyBYIHJlc3VsdCwgbWFwIGNsaXAgZWRnZXMgdG8gWy13LCt3XVxuICAgIG1bIDAgKiA0ICsgMCBdID0gc2NhbGVBbmRPZmZzZXQuc2NhbGVbIDAgXTtcbiAgICBtWyAwICogNCArIDEgXSA9IDAuMDtcbiAgICBtWyAwICogNCArIDIgXSA9IHNjYWxlQW5kT2Zmc2V0Lm9mZnNldFsgMCBdICogaGFuZGVkbmVzc1NjYWxlO1xuICAgIG1bIDAgKiA0ICsgMyBdID0gMC4wO1xuXG4gICAgLy8gWSByZXN1bHQsIG1hcCBjbGlwIGVkZ2VzIHRvIFstdywrd11cbiAgICAvLyBZIG9mZnNldCBpcyBuZWdhdGVkIGJlY2F1c2UgdGhpcyBwcm9qIG1hdHJpeCB0cmFuc2Zvcm1zIGZyb20gd29ybGQgY29vcmRzIHdpdGggWT11cCxcbiAgICAvLyBidXQgdGhlIE5EQyBzY2FsaW5nIGhhcyBZPWRvd24gKHRoYW5rcyBEM0Q/KVxuICAgIG1bIDEgKiA0ICsgMCBdID0gMC4wO1xuICAgIG1bIDEgKiA0ICsgMSBdID0gc2NhbGVBbmRPZmZzZXQuc2NhbGVbIDEgXTtcbiAgICBtWyAxICogNCArIDIgXSA9IC0gc2NhbGVBbmRPZmZzZXQub2Zmc2V0WyAxIF0gKiBoYW5kZWRuZXNzU2NhbGU7XG4gICAgbVsgMSAqIDQgKyAzIF0gPSAwLjA7XG5cbiAgICAvLyBaIHJlc3VsdCAodXAgdG8gdGhlIGFwcClcbiAgICBtWyAyICogNCArIDAgXSA9IDAuMDtcbiAgICBtWyAyICogNCArIDEgXSA9IDAuMDtcbiAgICBtWyAyICogNCArIDIgXSA9IHpGYXIgLyAoIHpOZWFyIC0gekZhciApICogLSBoYW5kZWRuZXNzU2NhbGU7XG4gICAgbVsgMiAqIDQgKyAzIF0gPSAoIHpGYXIgKiB6TmVhciApIC8gKCB6TmVhciAtIHpGYXIgKTtcblxuICAgIC8vIFcgcmVzdWx0ICg9IFogaW4pXG4gICAgbVsgMyAqIDQgKyAwIF0gPSAwLjA7XG4gICAgbVsgMyAqIDQgKyAxIF0gPSAwLjA7XG4gICAgbVsgMyAqIDQgKyAyIF0gPSBoYW5kZWRuZXNzU2NhbGU7XG4gICAgbVsgMyAqIDQgKyAzIF0gPSAwLjA7XG5cbiAgICBtb2JqLnRyYW5zcG9zZSgpO1xuXG4gICAgcmV0dXJuIG1vYmo7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvdlRvUHJvamVjdGlvbiggZm92LCByaWdodEhhbmRlZCwgek5lYXIsIHpGYXIgKSB7XG5cbiAgICB2YXIgREVHMlJBRCA9IE1hdGguUEkgLyAxODAuMDtcblxuICAgIHZhciBmb3ZQb3J0ID0ge1xuICAgICAgdXBUYW46IE1hdGgudGFuKCBmb3YudXBEZWdyZWVzICogREVHMlJBRCApLFxuICAgICAgZG93blRhbjogTWF0aC50YW4oIGZvdi5kb3duRGVncmVlcyAqIERFRzJSQUQgKSxcbiAgICAgIGxlZnRUYW46IE1hdGgudGFuKCBmb3YubGVmdERlZ3JlZXMgKiBERUcyUkFEICksXG4gICAgICByaWdodFRhbjogTWF0aC50YW4oIGZvdi5yaWdodERlZ3JlZXMgKiBERUcyUkFEIClcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvdlBvcnRUb1Byb2plY3Rpb24oIGZvdlBvcnQsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApO1xuXG4gIH1cblxufTtcbiIsIi8vIEZpbGU6c3JjL1RocmVlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG52YXIgVEhSRUUgPSB7IFJFVklTSU9OOiAnNzJkZXYnIH07XG5cbi8vXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXG4gICAgZGVmaW5lKCAndGhyZWUnLCBUSFJFRSApO1xuXG59IGVsc2UgaWYgKCAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGV4cG9ydHMgJiYgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUgKSB7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xuXG59XG5cblxuLy8gcG9seWZpbGxzXG5cbmlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCB8fCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgKSB7XG5cbiAgLy8gTWlzc2luZyBpbiBBbmRyb2lkIHN0b2NrIGJyb3dzZXIuXG5cbiAgKCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xuXG4gICAgZm9yICggdmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgISBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKysgeCApIHtcblxuICAgICAgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuICAgICAgc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fCBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXG4gICAgfVxuXG4gICAgaWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuc2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgdmFyIGN1cnJUaW1lID0gRGF0ZS5ub3coKSwgdGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XG4gICAgICAgIHZhciBpZCA9IHNlbGYuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgY2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXG4gICAgICAgIH0sIHRpbWVUb0NhbGwgKTtcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgIHJldHVybiBpZDtcblxuICAgICAgfTtcblxuICAgIH1cblxuICAgIGlmICggc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuY2xlYXJUaW1lb3V0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoIGlkICkge1xuXG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApO1xuXG4gICAgICB9O1xuXG4gICAgfVxuXG4gIH0oKSApO1xuXG59XG5cbmlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXG5cbiAgTWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgcmV0dXJuICggeCA8IDAgKSA/IC0gMSA6ICggeCA+IDAgKSA/IDEgOiArIHg7XG5cbiAgfTtcblxufVxuXG5pZiAoIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgLy8gTWlzc2luZyBpbiBJRTktMTEuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWVcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5tYXRjaCggL15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC8gKVsgMSBdO1xuXG4gICAgfVxuXG4gIH0gKTtcblxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cblxuVEhSRUUuTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIgfTtcblxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXG5cblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XG5cblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cbi8vIFNIQURPV0lORyBUWVBFU1xuXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XG5cbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xuXG4vLyBzaWRlXG5cblRIUkVFLkZyb250U2lkZSA9IDA7XG5USFJFRS5CYWNrU2lkZSA9IDE7XG5USFJFRS5Eb3VibGVTaWRlID0gMjtcblxuLy8gc2hhZGluZ1xuXG5USFJFRS5Ob1NoYWRpbmcgPSAwO1xuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XG5cbi8vIGNvbG9yc1xuXG5USFJFRS5Ob0NvbG9ycyA9IDA7XG5USFJFRS5GYWNlQ29sb3JzID0gMTtcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XG5cbi8vIGJsZW5kaW5nIG1vZGVzXG5cblRIUkVFLk5vQmxlbmRpbmcgPSAwO1xuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5USFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxuLy8gIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxuXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5USFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcblRIUkVFLk1pbkVxdWF0aW9uID0gMTAzO1xuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBkZXN0aW5hdGlvbiBmYWN0b3JzXG5cblRIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG5USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcblRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcblRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBzb3VyY2UgZmFjdG9yc1xuXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG4vL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcbi8vVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG4vL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuLy9USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcblxuLy8gZGVwdGggbW9kZXNcblxuVEhSRUUuTmV2ZXJEZXB0aCA9IDA7XG5USFJFRS5BbHdheXNEZXB0aCA9IDE7XG5USFJFRS5MZXNzRGVwdGggPSAyO1xuVEhSRUUuTGVzc0VxdWFsRGVwdGggPSAzO1xuVEhSRUUuRXF1YWxEZXB0aCA9IDQ7XG5USFJFRS5HcmVhdGVyRXF1YWxEZXB0aCA9IDU7XG5USFJFRS5HcmVhdGVyRGVwdGggPSA2O1xuVEhSRUUuTm90RXF1YWxEZXB0aCA9IDc7XG5cblxuLy8gVEVYVFVSRSBDT05TVEFOVFNcblxuVEhSRUUuTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xuVEhSRUUuTWl4T3BlcmF0aW9uID0gMTtcblRIUkVFLkFkZE9wZXJhdGlvbiA9IDI7XG5cbi8vIE1hcHBpbmcgbW9kZXNcblxuVEhSRUUuVVZNYXBwaW5nID0gMzAwO1xuXG5USFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG5cblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5cblRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xuXG4vLyBXcmFwcGluZyBtb2Rlc1xuXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XG5USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcblRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuXG4vLyBGaWx0ZXJzXG5cblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xuVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xuVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5USFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuXG4vLyBEYXRhIHR5cGVzXG5cblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuVEhSRUUuQnl0ZVR5cGUgPSAxMDEwO1xuVEhSRUUuU2hvcnRUeXBlID0gMTAxMTtcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcblRIUkVFLkludFR5cGUgPSAxMDEzO1xuVEhSRUUuVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XG5USFJFRS5IYWxmRmxvYXRUeXBlID0gMTAyNTtcblxuLy8gUGl4ZWwgdHlwZXNcblxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XG5USFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE3O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xuXG4vLyBQaXhlbCBmb3JtYXRzXG5cblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcblRIUkVFLlJHQkZvcm1hdCA9IDEwMjA7XG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XG5USFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjM7XG4vLyBUSFJFRS5SR0JFRm9ybWF0IGhhbmRsZWQgYXMgVEhSRUUuUkdCQUZvcm1hdCBpbiBzaGFkZXJzXG5USFJFRS5SR0JFRm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDsgLy8xMDI0O1xuXG4vLyBERFMgLyBTVDNDIENvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXG5cblRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcblRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XG5USFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcblxuXG4vLyBQVlJUQyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xuXG5USFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XG5USFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDE7XG5USFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xuVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcblxuXG4vLyBERVBSRUNBVEVEXG5cblRIUkVFLlByb2plY3RvciA9IGZ1bmN0aW9uICgpIHtcblxuICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcblxuICB0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IucHJvamVjdCgpLicgKTtcbiAgICB2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XG5cbiAgfTtcblxuICB0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcbiAgICB2ZWN0b3IudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICB9O1xuXG4gIHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcblxuICB9O1xuXG59O1xuXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblxuICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQ2FudmFzUmVuZGVyZXIgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9DYW52YXNSZW5kZXJlci5qcycgKTtcblxuICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge307XG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XG4gIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7fTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9Db2xvci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgIHJldHVybiB0aGlzLnNldFJHQiggYXJndW1lbnRzWyAwIF0sIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApO1xuXG4gIH1cblxuICByZXR1cm4gdGhpcy5zZXQoIGNvbG9yICk7XG5cbn07XG5cblRIUkVFLkNvbG9yLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXG5cbiAgcjogMSwgZzogMSwgYjogMSxcblxuICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cbiAgICAgIHRoaXMuY29weSggdmFsdWUgKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cbiAgICAgIHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuICAgICAgdGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuICAgIGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xuXG4gICAgdGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcbiAgICB0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG4gICAgdGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XG5cbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0SFNMOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBodWUycmdiICggcCwgcSwgdCApIHtcblxuICAgICAgaWYgKCB0IDwgMCApIHQgKz0gMTtcbiAgICAgIGlmICggdCA+IDEgKSB0IC09IDE7XG4gICAgICBpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG4gICAgICBpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuICAgICAgaWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xuICAgICAgcmV0dXJuIHA7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xuXG4gICAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuICAgICAgaCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XG4gICAgICBzID0gVEhSRUUuTWF0aC5jbGFtcCggcywgMCwgMSApO1xuICAgICAgbCA9IFRIUkVFLk1hdGguY2xhbXAoIGwsIDAsIDEgKTtcblxuICAgICAgaWYgKCBzID09PSAwICkge1xuXG4gICAgICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcbiAgICAgICAgdmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG4gICAgICAgIHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xuICAgICAgICB0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XG4gICAgICAgIHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XG5cbiAgICB2YXIgcGFyc2VBbHBoYSA9IGZ1bmN0aW9uICggc3RyQWxwaGEgKSB7XG5cbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQoIHN0ckFscGhhICk7XG5cbiAgICAgIGlmICggYWxwaGEgPCAxICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgY29sb3IgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbHBoYTtcblxuICAgIH1cblxuXG4gICAgdmFyIG07XG5cbiAgICBpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKFxccyooW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cbiAgICAgIC8vIHJnYiAvIGhzbFxuXG4gICAgICB2YXIgY29sb3I7XG4gICAgICB2YXIgbmFtZSA9IG1bIDEgXTtcbiAgICAgIHZhciBjb21wb25lbnRzID0gbVsgMiBdO1xuXG4gICAgICBzd2l0Y2ggKCBuYW1lICkge1xuXG4gICAgICAgIGNhc2UgJ3JnYic6XG5cbiAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAvLyByZ2IoMjU1LDAsMClcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqJC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgICAgICAgICAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZ2JhJzpcblxuICAgICAgICAgIGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgIC8vIHJnYmEoMjU1LDAsMCwwLjUpXG4gICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG4gICAgICAgICAgICBwYXJzZUFscGhhKCBjb2xvclsgNCBdICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgLy8gcmdiYSgxMDAlLDAlLDAlLDAuNSlcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgICAgICAgIHBhcnNlQWxwaGEoIGNvbG9yWyA0IF0gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoc2wnOlxuXG4gICAgICAgICAgaWYgKCBjb2xvciA9IC9eKFswLTldKlxcLj9bMC05XSspXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKiQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgICAgICAgICAgLy8gaHNsKDEyMCw1MCUsNTAlKVxuICAgICAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICk7XG4gICAgICAgICAgICB2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xuICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoc2xhJzpcblxuICAgICAgICAgIGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyokLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cbiAgICAgICAgICAgIC8vIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuICAgICAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICk7XG4gICAgICAgICAgICB2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xuICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcbiAgICAgICAgICAgIHBhcnNlQWxwaGEoIGNvbG9yWyA0IF0gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggbSA9IC9eXFwjKFtBLUZhLWYwLTldKykkLy5leGVjKCBzdHlsZSApICkge1xuXG4gICAgICAvLyBoZXggY29sb3JcblxuICAgICAgdmFyIGhleCA9IG1bIDEgXTtcbiAgICAgIHZhciBzaXplID0gaGV4Lmxlbmd0aDtcblxuICAgICAgaWYgKCBzaXplID09PSAzICkge1xuXG4gICAgICAgIC8vICNmZjBcbiAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcbiAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgfSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcblxuICAgICAgICAvLyAjZmYwMDAwXG4gICAgICAgIHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XG4gICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCA0ICkgKyBoZXguY2hhckF0KCA1ICksIDE2ICkgLyAyNTU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoID4gMCApIHtcblxuICAgICAgLy8gY29sb3Iga2V5d29yZHNcbiAgICAgIHZhciBoZXggPSBUSFJFRS5Db2xvcktleXdvcmRzWyBzdHlsZSBdO1xuXG4gICAgICBpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIC8vIHJlZFxuICAgICAgICB0aGlzLnNldEhleCggaGV4ICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdW5rbm93biBjb2xvclxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG4gICAgdGhpcy5yID0gY29sb3IucjtcbiAgICB0aGlzLmcgPSBjb2xvci5nO1xuICAgIHRoaXMuYiA9IGNvbG9yLmI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuICAgIGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG4gICAgdGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIGdhbW1hRmFjdG9yICk7XG4gICAgdGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XG4gICAgdGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuICAgIGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG4gICAgdmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcblxuICAgIHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xuICAgIHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xuICAgIHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cbiAgICB0aGlzLnIgPSByICogcjtcbiAgICB0aGlzLmcgPSBnICogZztcbiAgICB0aGlzLmIgPSBiICogYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XG4gICAgdGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcbiAgICB0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRIZXg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xuXG4gIH0sXG5cbiAgZ2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XG5cbiAgfSxcblxuICBnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG4gICAgdmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG4gICAgdmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuICAgIHZhciBodWUsIHNhdHVyYXRpb247XG4gICAgdmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XG5cbiAgICBpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG4gICAgICBodWUgPSAwO1xuICAgICAgc2F0dXJhdGlvbiA9IDA7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cbiAgICAgIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcblxuICAgICAgc3dpdGNoICggbWF4ICkge1xuXG4gICAgICAgIGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcbiAgICAgICAgY2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICAgIGh1ZSAvPSA2O1xuXG4gICAgfVxuXG4gICAgaHNsLmggPSBodWU7XG4gICAgaHNsLnMgPSBzYXR1cmF0aW9uO1xuICAgIGhzbC5sID0gbGlnaHRuZXNzO1xuXG4gICAgcmV0dXJuIGhzbDtcblxuICB9LFxuXG4gIGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xuXG4gIH0sXG5cbiAgb2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cbiAgICB2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcblxuICAgIGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XG5cbiAgICB0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgICB0aGlzLnIgKz0gY29sb3IucjtcbiAgICB0aGlzLmcgKz0gY29sb3IuZztcbiAgICB0aGlzLmIgKz0gY29sb3IuYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xuXG4gICAgdGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcbiAgICB0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuICAgIHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy5yICs9IHM7XG4gICAgdGhpcy5nICs9IHM7XG4gICAgdGhpcy5iICs9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG4gICAgdGhpcy5yICo9IGNvbG9yLnI7XG4gICAgdGhpcy5nICo9IGNvbG9yLmc7XG4gICAgdGhpcy5iICo9IGNvbG9yLmI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnIgKj0gcztcbiAgICB0aGlzLmcgKj0gcztcbiAgICB0aGlzLmIgKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cbiAgICB0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcbiAgICB0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcbiAgICB0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XG5cbiAgICByZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cbiAgICB0aGlzLnIgPSBhcnJheVsgMCBdO1xuICAgIHRoaXMuZyA9IGFycmF5WyAxIF07XG4gICAgdGhpcy5iID0gYXJyYXlbIDIgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5nO1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Db2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXG4nYmVpZ2UnOiAweEY1RjVEQywgJ2Jpc3F1ZSc6IDB4RkZFNEM0LCAnYmxhY2snOiAweDAwMDAwMCwgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsICdibHVlJzogMHgwMDAwRkYsICdibHVldmlvbGV0JzogMHg4QTJCRTIsXG4nYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXG4nY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4QixcbidkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsICdkYXJrZ3JheSc6IDB4QTlBOUE5LCAnZGFya2dyZWVuJzogMHgwMDY0MDAsICdkYXJrZ3JleSc6IDB4QTlBOUE5LCAnZGFya2toYWtpJzogMHhCREI3NkIsICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxuJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcbidkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG4nZGVlcHBpbmsnOiAweEZGMTQ5MywgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsICdkaW1ncmF5JzogMHg2OTY5NjksICdkaW1ncmV5JzogMHg2OTY5NjksICdkb2RnZXJibHVlJzogMHgxRTkwRkYsICdmaXJlYnJpY2snOiAweEIyMjIyMixcbidmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxuJ2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxuJ2luZGlhbnJlZCc6IDB4Q0Q1QzVDLCAnaW5kaWdvJzogMHg0QjAwODIsICdpdm9yeSc6IDB4RkZGRkYwLCAna2hha2knOiAweEYwRTY4QywgJ2xhdmVuZGVyJzogMHhFNkU2RkEsICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcbidsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXG4nbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcbidsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LCAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSwgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLCAnbGltZSc6IDB4MDBGRjAwLCAnbGltZWdyZWVuJzogMHgzMkNEMzIsXG4nbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXG4nbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG4nbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCwgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLCAnbWlzdHlyb3NlJzogMHhGRkU0RTEsICdtb2NjYXNpbic6IDB4RkZFNEI1LCAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcbiduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXG4ncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcbidwZXJ1JzogMHhDRDg1M0YsICdwaW5rJzogMHhGRkMwQ0IsICdwbHVtJzogMHhEREEwREQsICdwb3dkZXJibHVlJzogMHhCMEUwRTYsICdwdXJwbGUnOiAweDgwMDA4MCwgJ3JlZCc6IDB4RkYwMDAwLCAncm9zeWJyb3duJzogMHhCQzhGOEYsXG4ncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcbidzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxuJ3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsICdzdGVlbGJsdWUnOiAweDQ2ODJCNCwgJ3Rhbic6IDB4RDJCNDhDLCAndGVhbCc6IDB4MDA4MDgwLCAndGhpc3RsZSc6IDB4RDhCRkQ4LCAndG9tYXRvJzogMHhGRjYzNDcsICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcbid2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XG5cbi8vIEZpbGU6c3JjL21hdGgvUXVhdGVybmlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gIHRoaXMuX3ggPSB4IHx8IDA7XG4gIHRoaXMuX3kgPSB5IHx8IDA7XG4gIHRoaXMuX3ogPSB6IHx8IDA7XG4gIHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxuXG4gIGdldCB4ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl94O1xuXG4gIH0sXG5cbiAgc2V0IHggKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB5ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl95O1xuXG4gIH0sXG5cbiAgc2V0IHkgKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB6ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl96O1xuXG4gIH0sXG5cbiAgc2V0IHogKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3ogPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB3ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl93O1xuXG4gIH0sXG5cbiAgc2V0IHcgKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3cgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5fdyA9IHc7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG4gICAgdGhpcy5feCA9IHF1YXRlcm5pb24ueDtcbiAgICB0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuICAgIHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG4gICAgdGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgfVxuXG4gICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgIC8vICAyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cbiAgICAvLyAgY29udGVudC9TcGluQ2FsYy5tXG5cbiAgICB2YXIgYzEgPSBNYXRoLmNvcyggZXVsZXIuX3ggLyAyICk7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbiggZXVsZXIuX3ggLyAyICk7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcblxuICAgIGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfVxuXG4gICAgaWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cbiAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG4gICAgdmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuICAgIHRoaXMuX3ggPSBheGlzLnggKiBzO1xuICAgIHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuICAgIHRoaXMuX3ogPSBheGlzLnogKiBzO1xuICAgIHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cbiAgICAgIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG4gICAgICBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuICAgICAgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cbiAgICAgIHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuICAgICAgcztcblxuICAgIGlmICggdHJhY2UgPiAwICkge1xuXG4gICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG4gICAgICB0aGlzLl93ID0gMC4yNSAvIHM7XG4gICAgICB0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG4gICAgICB0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG4gICAgICB0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cbiAgICB9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG4gICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuICAgICAgdGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuICAgICAgdGhpcy5feCA9IDAuMjUgKiBzO1xuICAgICAgdGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgICAgdGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG4gICAgfSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG4gICAgICBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuICAgICAgdGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuICAgICAgdGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgICAgdGhpcy5feSA9IDAuMjUgKiBzO1xuICAgICAgdGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cbiAgICAgIHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICAgIHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcbiAgICAgIHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcbiAgICAgIHRoaXMuX3ogPSAwLjI1ICogcztcblxuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuICAgIC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG4gICAgdmFyIHYxLCByO1xuXG4gICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cbiAgICAgIGlmICggciA8IEVQUyApIHtcblxuICAgICAgICByID0gMDtcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG4gICAgICAgICAgdjEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdjEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdjEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5feCA9IHYxLng7XG4gICAgICB0aGlzLl95ID0gdjEueTtcbiAgICAgIHRoaXMuX3ogPSB2MS56O1xuICAgICAgdGhpcy5fdyA9IHI7XG5cbiAgICAgIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0oKSxcblxuICBpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX3ggKj0gLSAxO1xuICAgIHRoaXMuX3kgKj0gLSAxO1xuICAgIHRoaXMuX3ogKj0gLSAxO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG4gIH0sXG5cbiAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgaWYgKCBsID09PSAwICkge1xuXG4gICAgICB0aGlzLl94ID0gMDtcbiAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgdGhpcy5feiA9IDA7XG4gICAgICB0aGlzLl93ID0gMTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGwgPSAxIC8gbDtcblxuICAgICAgdGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuICAgICAgdGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuICAgICAgdGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuICAgICAgdGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cbiAgICBpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cbiAgICB2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcbiAgICB2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuICAgIHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG4gICAgdGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcbiAgICB0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuICAgIHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuXG4gIH0sXG5cbiAgc2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XG5cbiAgICBpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgdmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuICAgIHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cbiAgICBpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cbiAgICAgIHRoaXMuX3cgPSAtIHFiLl93O1xuICAgICAgdGhpcy5feCA9IC0gcWIuX3g7XG4gICAgICB0aGlzLl95ID0gLSBxYi5feTtcbiAgICAgIHRoaXMuX3ogPSAtIHFiLl96O1xuXG4gICAgICBjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMuY29weSggcWIgKTtcblxuICAgIH1cblxuICAgIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5feiA9IHo7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgdmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XG4gICAgdmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cbiAgICBpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG4gICAgICB0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xuICAgICAgdGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcbiAgICAgIHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG4gICAgICB0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG4gICAgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICAgIHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG4gICAgdGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcbiAgICB0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuICAgIHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cbiAgICByZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICB0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICB0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cbiAgcmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuXG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuXG59O1xuXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMixcblxuICBzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54ICs9IHM7XG4gICAgdGhpcy55ICs9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG4gICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgdGhpcy55ICs9IHYueSAqIHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54IC09IHM7XG4gICAgdGhpcy55IC09IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB0aGlzLnggKj0gdi54O1xuICAgIHRoaXMueSAqPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggKj0gcztcbiAgICB0aGlzLnkgKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB0aGlzLnggLz0gdi54O1xuICAgIHRoaXMueSAvPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPiB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55ID4gdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWluLCBtYXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIH1cblxuICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwgKTtcbiAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgZmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjZWlsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IC0gdGhpcy54O1xuICAgIHRoaXMueSA9IC0gdGhpcy55O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cbiAgfSxcblxuICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblxuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XG5cbiAgfSxcblxuICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICB9LFxuXG4gIHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cbiAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG4gICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcblxuICB9LFxuXG4gIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICB0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgdGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuICB0aGlzLnogPSB6IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuICAgIHRoaXMueCA9IHg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuICAgIHRoaXMueiA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgY2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgICBjYXNlIDI6IHJldHVybiB0aGlzLno7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICB0aGlzLnogPSB2Lno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgdGhpcy56ICs9IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggKz0gcztcbiAgICB0aGlzLnkgKz0gcztcbiAgICB0aGlzLnogKz0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgIHRoaXMueSA9IGEueSArIGIueTtcbiAgICB0aGlzLnogPSBhLnogKyBiLno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG4gICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgdGhpcy55ICs9IHYueSAqIHM7XG4gICAgdGhpcy56ICs9IHYueiAqIHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgdGhpcy56IC09IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggLT0gcztcbiAgICB0aGlzLnkgLT0gcztcbiAgICB0aGlzLnogLT0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdGhpcy54ID0gYS54IC0gYi54O1xuICAgIHRoaXMueSA9IGEueSAtIGIueTtcbiAgICB0aGlzLnogPSBhLnogLSBiLno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCAqPSB2Lng7XG4gICAgdGhpcy55ICo9IHYueTtcbiAgICB0aGlzLnogKj0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgdGhpcy56ICo9IHNjYWxhcjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB0aGlzLnggPSBhLnggKiBiLng7XG4gICAgdGhpcy55ID0gYS55ICogYi55O1xuICAgIHRoaXMueiA9IGEueiAqIGIuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHF1YXRlcm5pb247XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XG5cbiAgICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHF1YXRlcm5pb247XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcbiAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG4gICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblxuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XG4gICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF07XG4gICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcblxuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgIHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXG5cbiAgICB0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xuICAgIHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF0gKSAqIGQ7XG4gICAgdGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBxeCA9IHEueDtcbiAgICB2YXIgcXkgPSBxLnk7XG4gICAgdmFyIHF6ID0gcS56O1xuICAgIHZhciBxdyA9IHEudztcblxuICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cbiAgICB2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgIHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgdmFyIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgICB2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG4gICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcbiAgICB0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWF0cml4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcblxuICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgIG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWF0cml4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVucHJvamVjdCggY2FtZXJhICkge1xuXG4gICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcbiAgICAvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogejtcbiAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6O1xuICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cbiAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHRoaXMueCAvPSB2Lng7XG4gICAgdGhpcy55IC89IHYueTtcbiAgICB0aGlzLnogLz0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgaWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cbiAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICB0aGlzLnggKj0gaW52U2NhbGFyO1xuICAgICAgdGhpcy55ICo9IGludlNjYWxhcjtcbiAgICAgIHRoaXMueiAqPSBpbnZTY2FsYXI7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMueiA9IDA7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPiB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55ID4gdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueiA+IHYueiApIHtcblxuICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGlmICggdGhpcy54IDwgdi54ICkge1xuXG4gICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA8IHYueSApIHtcblxuICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnogPCB2LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IHYuejtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy56IDwgbWluLnogKSB7XG5cbiAgICAgIHRoaXMueiA9IG1pbi56O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IG1heC56O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1pbiwgbWF4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICB9XG5cbiAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcbiAgICAgIG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICByb3VuZDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSAtIHRoaXMueDtcbiAgICB0aGlzLnkgPSAtIHRoaXMueTtcbiAgICB0aGlzLnogPSAtIHRoaXMuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG4gIH0sXG5cbiAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG4gIH0sXG5cbiAgbGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICB9LFxuXG4gIHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggICkge1xuXG4gICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cbiAgICB0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgIHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG4gICAgdGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuICAgIHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xuICAgIHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xuICAgIHRoaXMueiA9IHggKiB2LnkgLSB5ICogdi54O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuICAgIHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG4gICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxLCBkb3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdjEuY29weSggdmVjdG9yICkubm9ybWFsaXplKCk7XG5cbiAgICAgIGRvdCA9IHRoaXMuZG90KCB2MSApO1xuXG4gICAgICByZXR1cm4gdGhpcy5jb3B5KCB2MSApLm11bHRpcGx5U2NhbGFyKCBkb3QgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHByb2plY3RPblBsYW5lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cbiAgICAgIHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuICAgIH1cblxuICB9KCksXG5cbiAgcmVmbGVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG4gICAgLy8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICByZXR1cm4gdGhpcy5zdWIoIHYxLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuICAgIH1cblxuICB9KCksXG5cbiAgYW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggdGhpcy5sZW5ndGgoKSAqIHYubGVuZ3RoKCkgKTtcblxuICAgIC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cbiAgICByZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHZhciBkeCA9IHRoaXMueCAtIHYueDtcbiAgICB2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XG4gICAgdmFyIGR6ID0gdGhpcy56IC0gdi56O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuICB9LFxuXG4gIHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcblxuICB9LFxuXG4gIHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSwgb3JkZXIgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcblxuICB9LFxuXG4gIGdldFBvc2l0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcblxuICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xuXG4gIH0sXG5cbiAgZ2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuJyApO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XG5cbiAgfSxcblxuICBnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cbiAgfSxcblxuICBzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XG4gICAgdGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcbiAgICB0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgMiBdICkubGVuZ3RoKCk7XG4gICAgdmFyIHN5ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDQgXSwgbS5lbGVtZW50c1sgNSBdLCBtLmVsZW1lbnRzWyA2IF0gKS5sZW5ndGgoKTtcbiAgICB2YXIgc3ogPSB0aGlzLnNldCggbS5lbGVtZW50c1sgOCBdLCBtLmVsZW1lbnRzWyA5IF0sIG0uZWxlbWVudHNbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgIHRoaXMueCA9IHN4O1xuICAgIHRoaXMueSA9IHN5O1xuICAgIHRoaXMueiA9IHN6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cbiAgICB2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuXG4gICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgdGhpcy54ID0gbWVbIG9mZnNldCBdO1xuICAgIHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XG4gICAgdGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcbiAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjQuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xuICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3I0LFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG4gICAgdGhpcy56ID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0VzogZnVuY3Rpb24gKCB3ICkge1xuXG4gICAgdGhpcy53ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgY2FzZSAwOiByZXR1cm4gdGhpcy54O1xuICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy55O1xuICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy56O1xuICAgICAgY2FzZSAzOiByZXR1cm4gdGhpcy53O1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICB0aGlzLnogPSB2Lno7XG4gICAgdGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCArPSB2Lng7XG4gICAgdGhpcy55ICs9IHYueTtcbiAgICB0aGlzLnogKz0gdi56O1xuICAgIHRoaXMudyArPSB2Lnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54ICs9IHM7XG4gICAgdGhpcy55ICs9IHM7XG4gICAgdGhpcy56ICs9IHM7XG4gICAgdGhpcy53ICs9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgdGhpcy56ID0gYS56ICsgYi56O1xuICAgIHRoaXMudyA9IGEudyArIGIudztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cbiAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICB0aGlzLnkgKz0gdi55ICogcztcbiAgICB0aGlzLnogKz0gdi56ICogcztcbiAgICB0aGlzLncgKz0gdi53ICogcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcbiAgICB0aGlzLnogLT0gdi56O1xuICAgIHRoaXMudyAtPSB2Lnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54IC09IHM7XG4gICAgdGhpcy55IC09IHM7XG4gICAgdGhpcy56IC09IHM7XG4gICAgdGhpcy53IC09IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgdGhpcy56ID0gYS56IC0gYi56O1xuICAgIHRoaXMudyA9IGEudyAtIGIudztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgdGhpcy53ICo9IHNjYWxhcjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcbiAgICB2YXIgdyA9IHRoaXMudztcblxuICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xuICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xuICAgIHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcbiAgICB0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuICAgICAgdGhpcy56ICo9IGludlNjYWxhcjtcbiAgICAgIHRoaXMudyAqPSBpbnZTY2FsYXI7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMueiA9IDA7XG4gICAgICB0aGlzLncgPSAxO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgLy8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xuXG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcblxuICAgIGlmICggcyA8IDAuMDAwMSApIHtcblxuICAgICAgIHRoaXMueCA9IDE7XG4gICAgICAgdGhpcy55ID0gMDtcbiAgICAgICB0aGlzLnogPSAwO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgIHRoaXMueCA9IHEueCAvIHM7XG4gICAgICAgdGhpcy55ID0gcS55IC8gcztcbiAgICAgICB0aGlzLnogPSBxLnogLyBzO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIHZhciBhbmdsZSwgeCwgeSwgeiwgICAvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuICAgICAgZXBzaWxvbiA9IDAuMDEsICAgLy8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcbiAgICAgIGVwc2lsb24yID0gMC4xLCAgIC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cbiAgICAgIHRlID0gbS5lbGVtZW50cyxcblxuICAgICAgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcbiAgICAgIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG4gICAgICBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuICAgIGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uIClcbiAgICAgICAmJiAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKVxuICAgICAgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xuXG4gICAgICAvLyBzaW5ndWxhcml0eSBmb3VuZFxuICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuICAgICAgLy8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xuXG4gICAgICBpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxuICAgICAgICAgJiYgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApXG4gICAgICAgICAmJiAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yIClcbiAgICAgICAgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XG5cbiAgICAgICAgLy8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cbiAgICAgICAgdGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcblxuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG4gICAgICBhbmdsZSA9IE1hdGguUEk7XG5cbiAgICAgIHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcbiAgICAgIHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcbiAgICAgIHZhciB6eiA9ICggbTMzICsgMSApIC8gMjtcbiAgICAgIHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuICAgICAgdmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XG4gICAgICB2YXIgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcblxuICAgICAgaWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcblxuICAgICAgICAvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG4gICAgICAgIGlmICggeHggPCBlcHNpbG9uICkge1xuXG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgeSA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgIHogPSAwLjcwNzEwNjc4MTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgeCA9IE1hdGguc3FydCggeHggKTtcbiAgICAgICAgICB5ID0geHkgLyB4O1xuICAgICAgICAgIHogPSB4eiAvIHg7XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKCB5eSA+IHp6ICkge1xuXG4gICAgICAgIC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cbiAgICAgICAgaWYgKCB5eSA8IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB5ID0gTWF0aC5zcXJ0KCB5eSApO1xuICAgICAgICAgIHggPSB4eSAvIHk7XG4gICAgICAgICAgeiA9IHl6IC8geTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuXG4gICAgICAgIGlmICggenogPCBlcHNpbG9uICkge1xuXG4gICAgICAgICAgeCA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICB6ID0gMDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgeiA9IE1hdGguc3FydCggenogKTtcbiAgICAgICAgICB4ID0geHogLyB6O1xuICAgICAgICAgIHkgPSB5eiAvIHo7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cblxuICAgIH1cblxuICAgIC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuICAgIHZhciBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKVxuICAgICAgICAgICAgICArICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApXG4gICAgICAgICAgICAgICsgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuICAgIGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XG5cbiAgICAvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG4gICAgLy8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXG5cbiAgICB0aGlzLnggPSAoIG0zMiAtIG0yMyApIC8gcztcbiAgICB0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICB0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcbiAgICB0aGlzLncgPSBNYXRoLmFjb3MoICggbTExICsgbTIyICsgbTMzIC0gMSApIC8gMiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGlmICggdGhpcy54ID4gdi54ICkge1xuXG4gICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA+IHYueSApIHtcblxuICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnogPiB2LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IHYuejtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy53ID4gdi53ICkge1xuXG4gICAgICB0aGlzLncgPSB2Lnc7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueiA8IHYueiApIHtcblxuICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLncgPCB2LncgKSB7XG5cbiAgICAgIHRoaXMudyA9IHYudztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG4gICAgaWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuICAgICAgdGhpcy54ID0gbWluLng7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuICAgICAgdGhpcy54ID0gbWF4Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtaW4ueTtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG4gICAgICB0aGlzLnkgPSBtYXgueTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy56IDwgbWluLnogKSB7XG5cbiAgICAgIHRoaXMueiA9IG1pbi56O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IG1heC56O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLncgPCBtaW4udyApIHtcblxuICAgICAgdGhpcy53ID0gbWluLnc7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLncgPiBtYXgudyApIHtcblxuICAgICAgdGhpcy53ID0gbWF4Lnc7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWluLCBtYXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG4gICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cbiAgICAgIH1cblxuICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgdGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuICAgIHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcbiAgICB0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgIHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IC0gdGhpcy54O1xuICAgIHRoaXMueSA9IC0gdGhpcy55O1xuICAgIHRoaXMueiA9IC0gdGhpcy56O1xuICAgIHRoaXMudyA9IC0gdGhpcy53O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cbiAgfSxcblxuICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblxuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XG5cbiAgfSxcblxuICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XG5cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gIH0sXG5cbiAgc2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XG5cbiAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG4gICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG4gICAgdGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgdGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG4gICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcbiAgICB0aGlzLncgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMyBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG4gIHRoaXMuX3ggPSB4IHx8IDA7XG4gIHRoaXMuX3kgPSB5IHx8IDA7XG4gIHRoaXMuX3ogPSB6IHx8IDA7XG4gIHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xuXG59O1xuXG5USFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcblxuVEhSRUUuRXVsZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcblxuICBnZXQgeCAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5feDtcblxuICB9LFxuXG4gIHNldCB4ICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgfSxcblxuICBnZXQgeSAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5feTtcblxuICB9LFxuXG4gIHNldCB5ICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgfSxcblxuICBnZXQgeiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fejtcblxuICB9LFxuXG4gIHNldCB6ICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLl96ID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgfSxcblxuICBnZXQgb3JkZXIgKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX29yZGVyO1xuXG4gIH0sXG5cbiAgc2V0IG9yZGVyICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLl9vcmRlciA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlcik7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgdGhpcy5feCA9IGV1bGVyLl94O1xuICAgIHRoaXMuX3kgPSBldWxlci5feTtcbiAgICB0aGlzLl96ID0gZXVsZXIuX3o7XG4gICAgdGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XG5cbiAgICB2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xuXG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIHZhciB0ZSA9IG0uZWxlbWVudHM7XG4gICAgdmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG4gICAgdmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG4gICAgdmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG4gICAgb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuICAgIGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICB0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcbiAgICAgICAgdGhpcy5feiA9IDA7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgdGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG4gICAgICAgIHRoaXMuX3ogPSAwO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcblxuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICB0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OSApIHtcblxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuICAgICAgdGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuICAgICAgICB0aGlzLl95ID0gMDtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyIClcblxuICAgIH1cblxuICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XG5cbiAgICBpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtYXRyaXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG4gICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgIG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuICAgICAgdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xuXG4gIH0sXG5cbiAgcmVvcmRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG4gICAgdmFyIHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbmV3T3JkZXIgKSB7XG5cbiAgICAgIHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XG4gICAgICB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgcmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5feCA9IGFycmF5WyAwIF07XG4gICAgdGhpcy5feSA9IGFycmF5WyAxIF07XG4gICAgdGhpcy5feiA9IGFycmF5WyAyIF07XG4gICAgaWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgdG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG4gICAgaWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuICAgICAgcmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0xpbmUzLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuTGluZTMgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cbiAgdGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB0aGlzLmVuZCA9ICggZW5kICE9PSB1bmRlZmluZWQgKSA/IGVuZCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLkxpbmUzLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTGluZTMsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cbiAgICB0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XG4gICAgdGhpcy5lbmQuY29weSggZW5kICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cbiAgICB0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcbiAgICB0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gIH0sXG5cbiAgZGVsdGE6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xuXG4gIH0sXG5cbiAgYXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gIH0sXG5cbiAgY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHN0YXJ0UCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHN0YXJ0RW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcblxuICAgICAgc3RhcnRQLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLnN0YXJ0ICk7XG4gICAgICBzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG4gICAgICB2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xuICAgICAgdmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XG5cbiAgICAgIHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG4gICAgICBpZiAoIGNsYW1wVG9MaW5lICkge1xuXG4gICAgICAgIHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICB0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcblxuICAgIHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gIHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xuICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IyKCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxuXG4gIHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cbiAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG4gICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgICB0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgdGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuICAgIHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cbiAgICByZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcblxuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gIH0sXG5cbiAgc2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cbiAgfSxcblxuICBleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgdGhpcy5taW4ubWluKCBwb2ludCApO1xuICAgIHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgdGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcbiAgICB0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG4gICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuICAgICAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSApIHtcblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgfSxcblxuICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnNldChcbiAgICAgICggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcbiAgICAgICggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxuICAgICk7XG5cbiAgfSxcblxuICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICAvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuICAgIGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgKSB7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0sXG5cbiAgY2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICAgIHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcbiAgICAgIHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuICAgIHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICB0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcbiAgICB0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG4gICAgdGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgdGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDMucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxuXG4gIHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xuXG4gICAgICB2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgICB0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgc2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcbiAgICAvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgIG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgICBvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XG5cbiAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXS5hcnJheTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgIHYxLnNldCggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICk7XG5cbiAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcbiAgICB0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cbiAgICByZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICB9LFxuXG4gIHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG4gIH0sXG5cbiAgZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHRoaXMubWluLm1pbiggcG9pbnQgKTtcbiAgICB0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIHRoaXMubWluLnN1YiggdmVjdG9yICk7XG4gICAgdGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgdGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuICAgIHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuICAgICAgICAgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogKSB7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0sXG5cbiAgY29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgaWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG4gICAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSAmJlxuICAgICAgICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIH0sXG5cbiAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG4gICAgLy8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5zZXQoXG4gICAgICAoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG4gICAgICAoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXG4gICAgICAoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcbiAgICApO1xuXG4gIH0sXG5cbiAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgLy8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cbiAgICBpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XG4gICAgICAgICBib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogKSB7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0sXG5cbiAgY2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICAgIHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcbiAgICAgIHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgZ2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgICAgcmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XG4gICAgICByZXN1bHQucmFkaXVzID0gdGhpcy5zaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuICAgIHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICB0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcbiAgICB0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICBdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgICAvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuICAgICAgcG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXG4gICAgICBwb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcbiAgICAgIHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxuICAgICAgcG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXG4gICAgICBwb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcbiAgICAgIHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxuICAgICAgcG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXG4gICAgICBwb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAgLy8gMTExXG5cbiAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG4gICAgICB0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICB0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuICAgIHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICByZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5NYXRyaXgzID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICAxLCAwLCAwLFxuICAgIDAsIDEsIDAsXG4gICAgMCwgMCwgMVxuXG4gIF0gKTtcblxuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTWF0cml4My5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcbiAgICB0ZVsgMSBdID0gbjIxOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNyBdID0gbjIzO1xuICAgIHRlWyAyIF0gPSBuMzE7IHRlWyA1IF0gPSBuMzI7IHRlWyA4IF0gPSBuMzM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIG1lWyAwIF0sIG1lWyAzIF0sIG1lWyA2IF0sXG4gICAgICBtZVsgMSBdLCBtZVsgNCBdLCBtZVsgNyBdLFxuICAgICAgbWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuICB9LFxuXG4gIG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuXG4gIH0sXG5cbiAgYXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cbiAgICAgICAgdjEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuICAgICAgICB2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcbiAgICAgICAgdjEudG9BcnJheSggYXJyYXksIGogKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG4gICAgICAgIHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuICAgICAgICB2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcbiAgICAgICAgdjEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cbiAgICAgICAgdjEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cbiAgICAgICAgYnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG4gICAgdGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcbiAgICB0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuICAgICAgZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcbiAgICAgIGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XG5cbiAgICByZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG4gIH0sXG5cbiAgZ2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25JbnZlcnRpYmxlICkge1xuXG4gICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcbiAgICAvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcblxuICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdGVbIDAgXSA9ICAgbWVbIDEwIF0gKiBtZVsgNSBdIC0gbWVbIDYgXSAqIG1lWyA5IF07XG4gICAgdGVbIDEgXSA9IC0gbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XG4gICAgdGVbIDIgXSA9ICAgbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcbiAgICB0ZVsgMyBdID0gLSBtZVsgMTAgXSAqIG1lWyA0IF0gKyBtZVsgNiBdICogbWVbIDggXTtcbiAgICB0ZVsgNCBdID0gICBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcbiAgICB0ZVsgNSBdID0gLSBtZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xuICAgIHRlWyA2IF0gPSAgIG1lWyA5IF0gKiBtZVsgNCBdIC0gbWVbIDUgXSAqIG1lWyA4IF07XG4gICAgdGVbIDcgXSA9IC0gbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcbiAgICB0ZVsgOCBdID0gICBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xuXG4gICAgdmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcblxuICAgIC8vIG5vIGludmVyc2VcblxuICAgIGlmICggZGV0ID09PSAwICkge1xuXG4gICAgICB2YXIgbXNnID0gXCJNYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgICBpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCBtc2cgKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLmlkZW50aXR5KCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgdGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xuICAgIHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XG4gICAgdG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cbiAgICBhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfSxcblxuICBnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG5cbiAgICB0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cbiAgICB2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICByWyAwIF0gPSBtWyAwIF07XG4gICAgclsgMSBdID0gbVsgMyBdO1xuICAgIHJbIDIgXSA9IG1bIDYgXTtcbiAgICByWyAzIF0gPSBtWyAxIF07XG4gICAgclsgNCBdID0gbVsgNCBdO1xuICAgIHJbIDUgXSA9IG1bIDcgXTtcbiAgICByWyA2IF0gPSBtWyAyIF07XG4gICAgclsgNyBdID0gbVsgNSBdO1xuICAgIHJbIDggXSA9IG1bIDggXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcbiAgICAgIHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXG4gICAgICB0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG4gICAgXTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5cbiAgXSApO1xuXG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcblxuICBzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuICAgIHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuICAgIHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcbiAgICB0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xuICAgIHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuXG4gIH0sXG5cbiAgY29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuICAgIHRlWyAxMyBdID0gbWVbIDEzIF07XG4gICAgdGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgeEF4aXMuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XG4gICAgeUF4aXMuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG4gICAgekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuICAgIHRoaXMuc2V0KFxuICAgICAgeEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcbiAgICAgIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG4gICAgICB4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuICAgICAgMCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbSApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgICAgdmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcbiAgICAgIHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0KCBtZVsgNCBdLCBtZVsgNSBdLCBtZVsgNiBdICkubGVuZ3RoKCk7XG4gICAgICB2YXIgc2NhbGVaID0gMSAvIHYxLnNldCggbWVbIDggXSwgbWVbIDkgXSwgbWVbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgICAgdGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG4gICAgICB0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcbiAgICAgIHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXG4gICAgICB0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcbiAgICAgIHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuICAgICAgdGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cbiAgICAgIHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuICAgICAgdGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG4gICAgICB0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgfVxuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHZhciB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuICAgIHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XG4gICAgdmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcbiAgICB2YXIgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG4gICAgaWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgIHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG4gICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICB0ZVsgNCBdID0gLSBjICogZjtcbiAgICAgIHRlWyA4IF0gPSBkO1xuXG4gICAgICB0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XG4gICAgICB0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XG4gICAgICB0ZVsgOSBdID0gLSBiICogYztcblxuICAgICAgdGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xuICAgICAgdGVbIDYgXSA9IGJlICsgYWYgKiBkO1xuICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgdmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cbiAgICAgIHRlWyAwIF0gPSBjZSArIGRmICogYjtcbiAgICAgIHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcbiAgICAgIHRlWyA4IF0gPSBhICogZDtcblxuICAgICAgdGVbIDEgXSA9IGEgKiBmO1xuICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgdGVbIDkgXSA9IC0gYjtcblxuICAgICAgdGVbIDIgXSA9IGNmICogYiAtIGRlO1xuICAgICAgdGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgdmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cbiAgICAgIHRlWyAwIF0gPSBjZSAtIGRmICogYjtcbiAgICAgIHRlWyA0IF0gPSAtIGEgKiBmO1xuICAgICAgdGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG4gICAgICB0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG4gICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICB0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cbiAgICAgIHRlWyAyIF0gPSAtIGEgKiBkO1xuICAgICAgdGVbIDYgXSA9IGI7XG4gICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgICB2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgdGVbIDQgXSA9IGJlICogZCAtIGFmO1xuICAgICAgdGVbIDggXSA9IGFlICogZCArIGJmO1xuXG4gICAgICB0ZVsgMSBdID0gYyAqIGY7XG4gICAgICB0ZVsgNSBdID0gYmYgKiBkICsgYWU7XG4gICAgICB0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XG5cbiAgICAgIHRlWyAyIF0gPSAtIGQ7XG4gICAgICB0ZVsgNiBdID0gYiAqIGM7XG4gICAgICB0ZVsgMTAgXSA9IGEgKiBjO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICB2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgdGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuICAgICAgdGVbIDggXSA9IGJjICogZiArIGFkO1xuXG4gICAgICB0ZVsgMSBdID0gZjtcbiAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgIHRlWyA5IF0gPSAtIGIgKiBlO1xuXG4gICAgICB0ZVsgMiBdID0gLSBkICogZTtcbiAgICAgIHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcbiAgICAgIHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cbiAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICAgIHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG4gICAgICB0ZVsgMCBdID0gYyAqIGU7XG4gICAgICB0ZVsgNCBdID0gLSBmO1xuICAgICAgdGVbIDggXSA9IGQgKiBlO1xuXG4gICAgICB0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG4gICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICB0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cbiAgICAgIHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcbiAgICAgIHRlWyA2IF0gPSBiICogZTtcbiAgICAgIHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cbiAgICB9XG5cbiAgICAvLyBsYXN0IGNvbHVtblxuICAgIHRlWyAzIF0gPSAwO1xuICAgIHRlWyA3IF0gPSAwO1xuICAgIHRlWyAxMSBdID0gMDtcblxuICAgIC8vIGJvdHRvbSByb3dcbiAgICB0ZVsgMTIgXSA9IDA7XG4gICAgdGVbIDEzIF0gPSAwO1xuICAgIHRlWyAxNCBdID0gMDtcbiAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKS4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG4gIH0sXG5cbiAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcbiAgICB2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcbiAgICB2YXIgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6MjtcbiAgICB2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcbiAgICB2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuICAgIHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XG4gICAgdGVbIDQgXSA9IHh5IC0gd3o7XG4gICAgdGVbIDggXSA9IHh6ICsgd3k7XG5cbiAgICB0ZVsgMSBdID0geHkgKyB3ejtcbiAgICB0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xuICAgIHRlWyA5IF0gPSB5eiAtIHd4O1xuXG4gICAgdGVbIDIgXSA9IHh6IC0gd3k7XG4gICAgdGVbIDYgXSA9IHl6ICsgd3g7XG4gICAgdGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XG5cbiAgICAvLyBsYXN0IGNvbHVtblxuICAgIHRlWyAzIF0gPSAwO1xuICAgIHRlWyA3IF0gPSAwO1xuICAgIHRlWyAxMSBdID0gMDtcblxuICAgIC8vIGJvdHRvbSByb3dcbiAgICB0ZVsgMTIgXSA9IDA7XG4gICAgdGVbIDEzIF0gPSAwO1xuICAgIHRlWyAxNCBdID0gMDtcbiAgICB0ZVsgMTUgXSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHgsIHksIHo7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBleWUsIHRhcmdldCwgdXAgKSB7XG5cbiAgICAgIGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIHkgPT09IHVuZGVmaW5lZCApIHkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCB6ID09PSB1bmRlZmluZWQgKSB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBpZiAoIHoubGVuZ3RoKCkgPT09IDAgKSB7XG5cbiAgICAgICAgei56ID0gMTtcblxuICAgICAgfVxuXG4gICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgaWYgKCB4Lmxlbmd0aCgpID09PSAwICkge1xuXG4gICAgICAgIHoueCArPSAwLjAwMDE7XG4gICAgICAgIHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICB9XG5cbiAgICAgIHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XG5cblxuICAgICAgdGVbIDAgXSA9IHgueDsgdGVbIDQgXSA9IHkueDsgdGVbIDggXSA9IHoueDtcbiAgICAgIHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XG4gICAgICB0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtdWx0aXBseTogZnVuY3Rpb24gKCBtLCBuICkge1xuXG4gICAgaWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuICB9LFxuXG4gIG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHZhciBhZSA9IGEuZWxlbWVudHM7XG4gICAgdmFyIGJlID0gYi5lbGVtZW50cztcbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuICAgIHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcbiAgICB2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuICAgIHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cbiAgICB2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XG4gICAgdmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuICAgIHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG4gICAgdmFyIGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcblxuICAgIHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG4gICAgdGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcbiAgICB0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuICAgIHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG4gICAgdGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcbiAgICB0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuICAgIHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG4gICAgdGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cbiAgICB0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuICAgIHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG4gICAgdGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG4gICAgdGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cbiAgICB0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuICAgIHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG4gICAgdGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG4gICAgdGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCBhLCBiLCByICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApO1xuXG4gICAgclsgMCBdID0gdGVbIDAgXTsgclsgMSBdID0gdGVbIDEgXTsgclsgMiBdID0gdGVbIDIgXTsgclsgMyBdID0gdGVbIDMgXTtcbiAgICByWyA0IF0gPSB0ZVsgNCBdOyByWyA1IF0gPSB0ZVsgNSBdOyByWyA2IF0gPSB0ZVsgNiBdOyByWyA3IF0gPSB0ZVsgNyBdO1xuICAgIHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XG4gICAgclsgMTIgXSA9IHRlWyAxMiBdOyByWyAxMyBdID0gdGVbIDEzIF07IHJbIDE0IF0gPSB0ZVsgMTQgXTsgclsgMTUgXSA9IHRlWyAxNSBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG4gICAgdGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcbiAgICB0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcbiAgICB0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcblxuICB9LFxuXG4gIG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cbiAgfSxcblxuICBtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcblxuICB9LFxuXG4gIGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG4gICAgICAgIHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcbiAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG4gICAgICAgIHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcblxuICAgICAgICB2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcbiAgICAgICAgdjEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XG4gICAgICAgIHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xuXG4gICAgICAgIHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gICAgICAgIGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgcm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG4gICAgdi50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcblxuICB9LFxuXG4gIGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gIH0sXG5cbiAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG4gICAgdmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuICAgIHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XG4gICAgdmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuICAgIC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG4gICAgLy8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cbiAgICByZXR1cm4gKFxuICAgICAgbjQxICogKFxuICAgICAgICArIG4xNCAqIG4yMyAqIG4zMlxuICAgICAgICAgLSBuMTMgKiBuMjQgKiBuMzJcbiAgICAgICAgIC0gbjE0ICogbjIyICogbjMzXG4gICAgICAgICArIG4xMiAqIG4yNCAqIG4zM1xuICAgICAgICAgKyBuMTMgKiBuMjIgKiBuMzRcbiAgICAgICAgIC0gbjEyICogbjIzICogbjM0XG4gICAgICApICtcbiAgICAgIG40MiAqIChcbiAgICAgICAgKyBuMTEgKiBuMjMgKiBuMzRcbiAgICAgICAgIC0gbjExICogbjI0ICogbjMzXG4gICAgICAgICArIG4xNCAqIG4yMSAqIG4zM1xuICAgICAgICAgLSBuMTMgKiBuMjEgKiBuMzRcbiAgICAgICAgICsgbjEzICogbjI0ICogbjMxXG4gICAgICAgICAtIG4xNCAqIG4yMyAqIG4zMVxuICAgICAgKSArXG4gICAgICBuNDMgKiAoXG4gICAgICAgICsgbjExICogbjI0ICogbjMyXG4gICAgICAgICAtIG4xMSAqIG4yMiAqIG4zNFxuICAgICAgICAgLSBuMTQgKiBuMjEgKiBuMzJcbiAgICAgICAgICsgbjEyICogbjIxICogbjM0XG4gICAgICAgICArIG4xNCAqIG4yMiAqIG4zMVxuICAgICAgICAgLSBuMTIgKiBuMjQgKiBuMzFcbiAgICAgICkgK1xuICAgICAgbjQ0ICogKFxuICAgICAgICAtIG4xMyAqIG4yMiAqIG4zMVxuICAgICAgICAgLSBuMTEgKiBuMjMgKiBuMzJcbiAgICAgICAgICsgbjExICogbjIyICogbjMzXG4gICAgICAgICArIG4xMyAqIG4yMSAqIG4zMlxuICAgICAgICAgLSBuMTIgKiBuMjEgKiBuMzNcbiAgICAgICAgICsgbjEyICogbjIzICogbjMxXG4gICAgICApXG5cbiAgICApO1xuXG4gIH0sXG5cbiAgdHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciB0bXA7XG5cbiAgICB0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuICAgIHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuICAgIGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyA5IF0gID0gdGVbIDkgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cbiAgICBhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICByZXR1cm4gdjEuc2V0KCB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAxMiBdID0gdi54O1xuICAgIHRlWyAxMyBdID0gdi55O1xuICAgIHRlWyAxNCBdID0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0sIHRocm93T25JbnZlcnRpYmxlICkge1xuXG4gICAgLy8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdmFyIG4xMSA9IG1lWyAwIF0sIG4xMiA9IG1lWyA0IF0sIG4xMyA9IG1lWyA4IF0sIG4xNCA9IG1lWyAxMiBdO1xuICAgIHZhciBuMjEgPSBtZVsgMSBdLCBuMjIgPSBtZVsgNSBdLCBuMjMgPSBtZVsgOSBdLCBuMjQgPSBtZVsgMTMgXTtcbiAgICB2YXIgbjMxID0gbWVbIDIgXSwgbjMyID0gbWVbIDYgXSwgbjMzID0gbWVbIDEwIF0sIG4zNCA9IG1lWyAxNCBdO1xuICAgIHZhciBuNDEgPSBtZVsgMyBdLCBuNDIgPSBtZVsgNyBdLCBuNDMgPSBtZVsgMTEgXSwgbjQ0ID0gbWVbIDE1IF07XG5cbiAgICB0ZVsgMCBdID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0O1xuICAgIHRlWyA0IF0gPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQ7XG4gICAgdGVbIDggXSA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NDtcbiAgICB0ZVsgMTIgXSA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcbiAgICB0ZVsgMSBdID0gbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0O1xuICAgIHRlWyA1IF0gPSBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQ7XG4gICAgdGVbIDkgXSA9IG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NDtcbiAgICB0ZVsgMTMgXSA9IG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNDtcbiAgICB0ZVsgMiBdID0gbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0O1xuICAgIHRlWyA2IF0gPSBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQ7XG4gICAgdGVbIDEwIF0gPSBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQ7XG4gICAgdGVbIDE0IF0gPSBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQ7XG4gICAgdGVbIDMgXSA9IG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MztcbiAgICB0ZVsgNyBdID0gbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzO1xuICAgIHRlWyAxMSBdID0gbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzO1xuICAgIHRlWyAxNSBdID0gbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzO1xuXG4gICAgdmFyIGRldCA9IG4xMSAqIHRlWyAwIF0gKyBuMjEgKiB0ZVsgNCBdICsgbjMxICogdGVbIDggXSArIG40MSAqIHRlWyAxMiBdO1xuXG4gICAgaWYgKCBkZXQgPT09IDAgKSB7XG5cbiAgICAgIHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cbiAgICAgIGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oIG1zZyApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWRlbnRpdHkoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9LFxuXG4gIHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9LFxuXG4gIHJvdGF0ZVk6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9LFxuXG4gIHJvdGF0ZVo6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9LFxuXG4gIHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfSxcblxuICBzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuICAgIHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG4gICAgdGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcbiAgICB0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcbiAgICB0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZ2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG4gICAgdmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuICAgIHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBNYXRoLm1heCggc2NhbGVZU3EsIHNjYWxlWlNxICkgKSApO1xuXG4gIH0sXG5cbiAgbWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgMSwgMCwgMCwgeCxcbiAgICAgIDAsIDEsIDAsIHksXG4gICAgICAwLCAwLCAxLCB6LFxuICAgICAgMCwgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICAxLCAwLCAgMCwgMCxcbiAgICAgIDAsIGMsIC0gcywgMCxcbiAgICAgIDAsIHMsICBjLCAwLFxuICAgICAgMCwgMCwgIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cbiAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgIGMsIDAsIHMsIDAsXG4gICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIC0gcywgMCwgYywgMCxcbiAgICAgICAwLCAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIGMsIC0gcywgMCwgMCxcbiAgICAgIHMsICBjLCAwLCAwLFxuICAgICAgMCwgIDAsIDEsIDAsXG4gICAgICAwLCAgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuICAgIC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICB2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuICAgIHZhciB0ID0gMSAtIGM7XG4gICAgdmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG4gICAgdmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgdHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuICAgICAgdHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuICAgICAgdHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIHgsIDAsIDAsIDAsXG4gICAgICAwLCB5LCAwLCAwLFxuICAgICAgMCwgMCwgeiwgMCxcbiAgICAgIDAsIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG4gICAgdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuICAgIHRoaXMuc2NhbGUoIHNjYWxlICk7XG4gICAgdGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdmVjdG9yLCBtYXRyaXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cbiAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgIHZhciBzeCA9IHZlY3Rvci5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcbiAgICAgIHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcbiAgICAgIHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgICB2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuICAgICAgaWYgKCBkZXQgPCAwICkge1xuXG4gICAgICAgIHN4ID0gLSBzeDtcblxuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbi54ID0gdGVbIDEyIF07XG4gICAgICBwb3NpdGlvbi55ID0gdGVbIDEzIF07XG4gICAgICBwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cbiAgICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cbiAgICAgIG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxuXG4gICAgICB2YXIgaW52U1ggPSAxIC8gc3g7XG4gICAgICB2YXIgaW52U1kgPSAxIC8gc3k7XG4gICAgICB2YXIgaW52U1ogPSAxIC8gc3o7XG5cbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG4gICAgICBtYXRyaXguZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuICAgICAgbWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG4gICAgICBtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG4gICAgICBtYXRyaXguZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG4gICAgICBxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgIHNjYWxlLnggPSBzeDtcbiAgICAgIHNjYWxlLnkgPSBzeTtcbiAgICAgIHNjYWxlLnogPSBzejtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgdmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cbiAgICB2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuICAgIHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG4gICAgdmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG4gICAgdmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XG5cbiAgICB0ZVsgMCBdID0geDsgIHRlWyA0IF0gPSAwOyAgdGVbIDggXSA9IGE7ICB0ZVsgMTIgXSA9IDA7XG4gICAgdGVbIDEgXSA9IDA7ICB0ZVsgNSBdID0geTsgIHRlWyA5IF0gPSBiOyAgdGVbIDEzIF0gPSAwO1xuICAgIHRlWyAyIF0gPSAwOyAgdGVbIDYgXSA9IDA7ICB0ZVsgMTAgXSA9IGM7IHRlWyAxNCBdID0gZDtcbiAgICB0ZVsgMyBdID0gMDsgIHRlWyA3IF0gPSAwOyAgdGVbIDExIF0gPSAtIDE7IHRlWyAxNSBdID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cbiAgICB2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKTtcbiAgICB2YXIgeW1pbiA9IC0geW1heDtcbiAgICB2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XG4gICAgdmFyIHhtYXggPSB5bWF4ICogYXNwZWN0O1xuXG4gICAgcmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xuXG4gIH0sXG5cbiAgbWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIHcgPSByaWdodCAtIGxlZnQ7XG4gICAgdmFyIGggPSB0b3AgLSBib3R0b207XG4gICAgdmFyIHAgPSBmYXIgLSBuZWFyO1xuXG4gICAgdmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcbiAgICB2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xuICAgIHZhciB6ID0gKCBmYXIgKyBuZWFyICkgLyBwO1xuXG4gICAgdGVbIDAgXSA9IDIgLyB3OyAgdGVbIDQgXSA9IDA7ICB0ZVsgOCBdID0gMDsgIHRlWyAxMiBdID0gLSB4O1xuICAgIHRlWyAxIF0gPSAwOyAgdGVbIDUgXSA9IDIgLyBoOyAgdGVbIDkgXSA9IDA7ICB0ZVsgMTMgXSA9IC0geTtcbiAgICB0ZVsgMiBdID0gMDsgIHRlWyA2IF0gPSAwOyAgdGVbIDEwIF0gPSAtIDIgLyBwOyB0ZVsgMTQgXSA9IC0gejtcbiAgICB0ZVsgMyBdID0gMDsgIHRlWyA3IF0gPSAwOyAgdGVbIDExIF0gPSAwOyB0ZVsgMTUgXSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG4gICAgICBpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuICAgIHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sIHRlWyAzIF0sXG4gICAgICB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdLCB0ZVsgNyBdLFxuICAgICAgdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0sIHRlWyAxMSBdLFxuICAgICAgdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSwgdGVbIDE1IF1cbiAgICBdO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9SYXkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG4gIHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5SYXkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5SYXksXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG4gICAgdGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XG4gICAgdGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcblxuICAgIHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcbiAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgfSxcblxuICByZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgICB0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG4gICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgICAgdmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICAvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG4gICAgICBpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICAgIH1cblxuICAgICAgdjEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgIHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXG4gICAgICAvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuICAgICAgLy8gZGVmaW5lZCBieSB2MCBhbmQgdjFcbiAgICAgIC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG4gICAgICAvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcbiAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuICAgICAgc2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcbiAgICAgIHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcbiAgICAgIGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xuXG4gICAgICB2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcbiAgICAgIHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XG4gICAgICB2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcbiAgICAgIHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xuICAgICAgdmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XG4gICAgICB2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcbiAgICAgIHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuICAgICAgaWYgKCBkZXQgPiAwICkge1xuXG4gICAgICAgIC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuICAgICAgICBzMCA9IGEwMSAqIGIxIC0gYjA7XG4gICAgICAgIHMxID0gYTAxICogYjAgLSBiMTtcbiAgICAgICAgZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG4gICAgICAgIGlmICggczAgPj0gMCApIHtcblxuICAgICAgICAgIGlmICggczEgPj0gLSBleHREZXQgKSB7XG5cbiAgICAgICAgICAgIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAgIC8vIHJlZ2lvbiAwXG4gICAgICAgICAgICAgIC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cblxuICAgICAgICAgICAgICB2YXIgaW52RGV0ID0gMSAvIGRldDtcbiAgICAgICAgICAgICAgczAgKj0gaW52RGV0O1xuICAgICAgICAgICAgICBzMSAqPSBpbnZEZXQ7XG4gICAgICAgICAgICAgIHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgLy8gcmVnaW9uIDFcblxuICAgICAgICAgICAgICBzMSA9IHNlZ0V4dGVudDtcbiAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyByZWdpb24gNVxuXG4gICAgICAgICAgICBzMSA9IC0gc2VnRXh0ZW50O1xuICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCBzMSA8PSAtIGV4dERldCApIHtcblxuICAgICAgICAgICAgLy8gcmVnaW9uIDRcblxuICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuICAgICAgICAgICAgczEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuICAgICAgICAgICAgLy8gcmVnaW9uIDNcblxuICAgICAgICAgICAgczAgPSAwO1xuICAgICAgICAgICAgczEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHJlZ2lvbiAyXG5cbiAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgICAgICAgICBzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblxuICAgICAgICBzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG4gICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuICAgICAgICBvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgICAgIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3FyRGlzdDtcblxuICAgIH07XG5cbiAgfSgpLFxuXG5cbiAgaXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcblxuICB9LFxuXG4gIGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktc3BoZXJlLWludGVyc2VjdGlvbi9cblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICB2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICB2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XG5cbiAgICAgIHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cbiAgICAgIGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG4gICAgICAvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuICAgICAgdmFyIHQwID0gdGNhIC0gdGhjO1xuXG4gICAgICAvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG4gICAgICB2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cbiAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuICAgICAgaWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuICAgICAgLy8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuICAgICAgLy8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuICAgICAgaWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICAgIC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXG4gICAgICByZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIGlzSW50ZXJzZWN0aW9uUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XG5cbiAgICB2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cbiAgICBpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICBpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG4gICAgaWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgICAgaWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgIH1cblxuICAgICAgLy8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIH1cblxuICAgIHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICAvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxuXG4gICAgcmV0dXJuIHQgPj0gMCA/IHQgOiAgbnVsbDtcblxuICB9LFxuXG4gIGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XG5cbiAgICBpZiAoIHQgPT09IG51bGwgKSB7XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgfSxcblxuICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktYm94LWludGVyc2VjdGlvbi9cblxuICAgIHZhciB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblxuICAgIHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXG4gICAgICBpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG4gICAgICBpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XG5cbiAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cbiAgICBpZiAoIGludmRpcnggPj0gMCApIHtcblxuICAgICAgdG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG4gICAgICB0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuICAgICAgdG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cbiAgICB9XG5cbiAgICBpZiAoIGludmRpcnkgPj0gMCApIHtcblxuICAgICAgdHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgICAgdHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgICAgdHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgfVxuXG4gICAgaWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cbiAgICAvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXG5cbiAgICBpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xuXG4gICAgaWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuICAgIGlmICggaW52ZGlyeiA+PSAwICkge1xuXG4gICAgICB0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgICB0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgICB0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cbiAgICB9XG5cbiAgICBpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG4gICAgaWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuICAgIGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XG5cbiAgICAvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cbiAgICBpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgfSxcblxuICBpbnRlcnNlY3RUcmlhbmdsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXG4gICAgdmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBlZGdlMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGVkZ2UyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgIC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvSW50ZXJzZWN0aW9uL1dtNUludHJSYXkzVHJpYW5nbGUzLmNwcFxuXG4gICAgICBlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XG4gICAgICBlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG4gICAgICBub3JtYWwuY3Jvc3NWZWN0b3JzKCBlZGdlMSwgZWRnZTIgKTtcblxuICAgICAgLy8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXG4gICAgICAvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG4gICAgICAvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcbiAgICAgIC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxuICAgICAgLy8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcbiAgICAgIHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xuICAgICAgdmFyIHNpZ247XG5cbiAgICAgIGlmICggRGROID4gMCApIHtcblxuICAgICAgICBpZiAoIGJhY2tmYWNlQ3VsbGluZyApIHJldHVybiBudWxsO1xuICAgICAgICBzaWduID0gMTtcblxuICAgICAgfSBlbHNlIGlmICggRGROIDwgMCApIHtcblxuICAgICAgICBzaWduID0gLSAxO1xuICAgICAgICBEZE4gPSAtIERkTjtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgfVxuXG4gICAgICBkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG4gICAgICB2YXIgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTIuY3Jvc3NWZWN0b3JzKCBkaWZmLCBlZGdlMiApICk7XG5cbiAgICAgIC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICBpZiAoIERkUXhFMiA8IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcblxuICAgICAgLy8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgIGlmICggRGRFMXhRIDwgMCApIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgfVxuXG4gICAgICAvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxuICAgICAgaWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIH1cblxuICAgICAgLy8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cbiAgICAgIHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XG5cbiAgICAgIC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgIGlmICggUWROIDwgMCApIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgfVxuXG4gICAgICAvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cbiAgICAgIHJldHVybiB0aGlzLmF0KCBRZE4gLyBEZE4sIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcblxuICAgIHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcbiAgICB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcbiAgICB0aGlzLmRpcmVjdGlvbi5zdWIoIHRoaXMub3JpZ2luICk7XG4gICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XG5cbiAgICByZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwaGVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG4gIHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG59O1xuXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG4gICAgdGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG4gICAgICBpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYm94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgdGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuICAgIHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcblxuICB9LFxuXG4gIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgcmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cbiAgfSxcblxuICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cbiAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG4gIH0sXG5cbiAgY2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmVzdWx0LmNvcHkoIHBvaW50ICk7XG5cbiAgICBpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuICAgICAgcmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcbiAgICAgIHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIH0sXG5cbiAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgYm94ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuICAgIGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuICAgIHJldHVybiBib3g7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgdGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICB0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICB0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgcmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvRnJ1c3R1bS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuICB0aGlzLnBsYW5lcyA9IFtcblxuICAgICggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgVEhSRUUuUGxhbmUoKSxcbiAgICAoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXG4gICAgKCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuICAgICggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgVEhSRUUuUGxhbmUoKSxcbiAgICAoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXG4gICAgKCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXG5cbiAgXTtcblxufTtcblxuVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkZydXN0dW0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cbiAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuICAgIHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG4gICAgcGxhbmVzWyAyIF0uY29weSggcDIgKTtcbiAgICBwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuICAgIHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG4gICAgcGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggZnJ1c3R1bSApIHtcblxuICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgIHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG4gICAgdmFyIG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XG4gICAgdmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XG4gICAgdmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xuICAgIHZhciBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XG5cbiAgICBwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcbiAgICBwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcbiAgICBwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcbiAgICBwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcbiAgICBwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcbiAgICB2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcbiAgICB2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgICAgdmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuICAgICAgaWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0sXG5cbiAgaW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHAxID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2IDsgaSArKyApIHtcblxuICAgICAgICB2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcblxuICAgICAgICBwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xuICAgICAgICBwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuICAgICAgICBwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xuICAgICAgICBwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xuICAgICAgICBwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xuICAgICAgICBwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG4gICAgICAgIHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcbiAgICAgICAgdmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xuXG4gICAgICAgIC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXG5cbiAgICAgICAgaWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG5cbiAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgIGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9QbGFuZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlBsYW5lID0gZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG4gIHRoaXMubm9ybWFsID0gKCBub3JtYWwgIT09IHVuZGVmaW5lZCApID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcbiAgdGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xuXG59O1xuXG5USFJFRS5QbGFuZS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlBsYW5lLFxuXG4gIHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG4gICAgdGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgdGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cbiAgICB0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcbiAgICB0aGlzLmNvbnN0YW50ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcblxuICAgIHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgIHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTsgLy8gbXVzdCBiZSB0aGlzLm5vcm1hbCwgbm90IG5vcm1hbCwgYXMgdGhpcy5ub3JtYWwgaXMgbm9ybWFsaXplZFxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cbiAgICAgIHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG4gICAgICB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuICAgIHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuICAgIHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG4gICAgdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcbiAgICB0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5jb25zdGFudCAqPSAtIDE7XG4gICAgdGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cbiAgfSxcblxuICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgcmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xuXG4gIH0sXG5cbiAgb3J0aG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XG5cbiAgfSxcblxuICBpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcblxuICAgIC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG4gICAgdmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG4gICAgdmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcblxuICAgIHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcblxuICB9LFxuXG4gIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG4gICAgICB2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG4gICAgICBpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG4gICAgICAgIC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cbiAgICAgICAgaWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICAgIGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuXG4gIGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5jb25zdGFudCApO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cbiAgICAgIC8vIGNvbXB1dGUgbmV3IG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcbiAgICAgIC8vIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9ub3JtYWx0cmFuc2Zvcm0uaHRtbFxuICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG4gICAgICB2YXIgbmV3Tm9ybWFsID0gdjEuY29weSggdGhpcy5ub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApO1xuXG4gICAgICB2YXIgbmV3Q29wbGFuYXJQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjIgKTtcbiAgICAgIG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgdGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbmV3Tm9ybWFsLCBuZXdDb3BsYW5hclBvaW50ICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgcmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9NYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWF0aCA9IHtcblxuICBnZW5lcmF0ZVVVSUQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXG5cbiAgICB2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCAnJyApO1xuICAgIHZhciB1dWlkID0gbmV3IEFycmF5KCAzNiApO1xuICAgIHZhciBybmQgPSAwLCByO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgMzY7IGkgKysgKSB7XG5cbiAgICAgICAgaWYgKCBpID09PSA4IHx8IGkgPT09IDEzIHx8IGkgPT09IDE4IHx8IGkgPT09IDIzICkge1xuXG4gICAgICAgICAgdXVpZFsgaSBdID0gJy0nO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIGkgPT09IDE0ICkge1xuXG4gICAgICAgICAgdXVpZFsgaSBdID0gJzQnO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoIHJuZCA8PSAweDAyICkgcm5kID0gMHgyMDAwMDAwICsgKCBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwICkgfCAwO1xuICAgICAgICAgIHIgPSBybmQgJiAweGY7XG4gICAgICAgICAgcm5kID0gcm5kID4+IDQ7XG4gICAgICAgICAgdXVpZFsgaSBdID0gY2hhcnNbICggaSA9PT0gMTkgKSA/ICggciAmIDB4MyApIHwgMHg4IDogciBdO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXVpZC5qb2luKCAnJyApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgLy8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XG5cbiAgY2xhbXA6IGZ1bmN0aW9uICggeCwgYSwgYiApIHtcblxuICAgIHJldHVybiAoIHggPCBhICkgPyBhIDogKCAoIHggPiBiICkgPyBiIDogeCApO1xuXG4gIH0sXG5cbiAgLy8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGluZilcblxuICBjbGFtcEJvdHRvbTogZnVuY3Rpb24gKCB4LCBhICkge1xuXG4gICAgcmV0dXJuIHggPCBhID8gYSA6IHg7XG5cbiAgfSxcblxuICAvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG4gIGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xuXG4gICAgcmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuICB9LFxuXG4gIC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuICBtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cbiAgICByZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuICB9LFxuXG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG4gIHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cbiAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuICAgIHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cbiAgfSxcblxuICBzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cbiAgICBpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgaWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG4gICAgeCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuICAgIHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cbiAgfSxcblxuICAvLyBSYW5kb20gZmxvYXQgZnJvbSA8MCwgMT4gd2l0aCAxNiBiaXRzIG9mIHJhbmRvbW5lc3NcbiAgLy8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcblxuICByYW5kb20xNjogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XG5cbiAgfSxcblxuICAvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cbiAgcmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cbiAgICByZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG4gIH0sXG5cbiAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuICByYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG4gICAgcmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuICB9LFxuXG4gIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuICByYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cbiAgICByZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuICB9LFxuXG4gIGRlZ1RvUmFkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGVncmVlVG9SYWRpYW5zRmFjdG9yID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cbiAgICAgIHJldHVybiBkZWdyZWVzICogZGVncmVlVG9SYWRpYW5zRmFjdG9yO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgcmFkVG9EZWc6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByYWRpYW5Ub0RlZ3JlZXNGYWN0b3IgPSAxODAgLyBNYXRoLlBJO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcmFkaWFucyApIHtcblxuICAgICAgcmV0dXJuIHJhZGlhbnMgKiByYWRpYW5Ub0RlZ3JlZXNGYWN0b3I7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICByZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxuICB9LFxuXG4gIG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdmFsdWUgLS07XG4gICAgdmFsdWUgfD0gdmFsdWUgPj4gMTtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xuICAgIHZhbHVlIHw9IHZhbHVlID4+IDQ7XG4gICAgdmFsdWUgfD0gdmFsdWUgPj4gODtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcbiAgICB2YWx1ZSArKztcblxuICAgIHJldHVybiB2YWx1ZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvU3BsaW5lLmpzXG5cbi8qKlxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXG4gKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXG4gKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BsaW5lID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cbiAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgdmFyIGMgPSBbXSwgdjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcbiAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcbiAgcGEsIHBiLCBwYywgcGQ7XG5cbiAgdGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24gKCBhICkge1xuXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xuXG4gICAgcG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGs7XG4gICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuICAgIGNbIDEgXSA9IGludFBvaW50O1xuICAgIGNbIDIgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xuICAgIGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xuXG4gICAgcGEgPSB0aGlzLnBvaW50c1sgY1sgMCBdIF07XG4gICAgcGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XG4gICAgcGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XG4gICAgcGQgPSB0aGlzLnBvaW50c1sgY1sgMyBdIF07XG5cbiAgICB3MiA9IHdlaWdodCAqIHdlaWdodDtcbiAgICB3MyA9IHdlaWdodCAqIHcyO1xuXG4gICAgdjMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgIHYzLnkgPSBpbnRlcnBvbGF0ZSggcGEueSwgcGIueSwgcGMueSwgcGQueSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICB2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XG5cbiAgICByZXR1cm4gdjM7XG5cbiAgfTtcblxuICB0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBpLCBwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgICAgY29vcmRzID0gW107XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHAgPSB0aGlzLnBvaW50c1sgaSBdO1xuICAgICAgY29vcmRzWyBpIF0gPSBbIHAueCwgcC55LCBwLnogXTtcblxuICAgIH1cblxuICAgIHJldHVybiBjb29yZHM7XG5cbiAgfTtcblxuICAvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcblxuICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcblxuICAgIHZhciBpLCBpbmRleCwgblNhbXBsZXMsIHBvc2l0aW9uLFxuICAgICAgcG9pbnQgPSAwLCBpbnRQb2ludCA9IDAsIG9sZEludFBvaW50ID0gMCxcbiAgICAgIG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBjaHVua0xlbmd0aHMgPSBbXSxcbiAgICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgIC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxuXG4gICAgY2h1bmtMZW5ndGhzWyAwIF0gPSAwO1xuXG4gICAgaWYgKCAhIG5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xuXG4gICAgblNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xuXG4gICAgb2xkUG9zaXRpb24uY29weSggdGhpcy5wb2ludHNbIDAgXSApO1xuXG4gICAgZm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSArKyApIHtcblxuICAgICAgaW5kZXggPSBpIC8gblNhbXBsZXM7XG5cbiAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcbiAgICAgIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgICB0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcblxuICAgICAgb2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcblxuICAgICAgcG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xuICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXG4gICAgICBpZiAoIGludFBvaW50ICE9PSBvbGRJbnRQb2ludCApIHtcblxuICAgICAgICBjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcbiAgICAgICAgb2xkSW50UG9pbnQgPSBpbnRQb2ludDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXG5cbiAgICBjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xuXG4gICAgcmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xuXG4gIH07XG5cbiAgdGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcblxuICAgIHZhciBpLCBqLFxuICAgICAgaW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxuICAgICAgcmVhbERpc3RhbmNlLFxuICAgICAgc2FtcGxpbmcsIHBvc2l0aW9uLFxuICAgICAgbmV3cG9pbnRzID0gW10sXG4gICAgICB0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgc2wgPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xuXG4gICAgZm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XG4gICAgICAvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcblxuICAgICAgcmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XG5cbiAgICAgIHNhbXBsaW5nID0gTWF0aC5jZWlsKCBzYW1wbGluZ0NvZWYgKiByZWFsRGlzdGFuY2UgLyBzbC50b3RhbCApO1xuXG4gICAgICBpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgICAgIGluZGV4TmV4dCA9IGkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcblxuICAgICAgZm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGogKysgKSB7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuICAgICAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xuXG4gICAgICB9XG5cbiAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgXSApLmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xuXG4gIH07XG5cbiAgLy8gQ2F0bXVsbC1Sb21cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuICAgIHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxuICAgICAgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgIHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9UcmlhbmdsZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICB0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcbiAgICB2MC5zdWJWZWN0b3JzKCBhLCBiICk7XG4gICAgcmVzdWx0LmNyb3NzKCB2MCApO1xuXG4gICAgdmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XG4gICAgaWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XG5cbiAgICAgIHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XG5cbiAgfTtcblxufSgpO1xuXG4vLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcbiAgICB2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG4gICAgdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuICAgIHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcbiAgICB2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG4gICAgdmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuICAgIHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcbiAgICB2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cbiAgICB2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuICAgIGlmICggZGVub20gPT09IDAgKSB7XG5cbiAgICAgIC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xuICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcblxuICAgIH1cblxuICAgIHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcbiAgICB2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuICAgIHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XG5cbiAgICAvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxuICAgIHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcblxuICB9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYyApIHtcblxuICAgIHZhciByZXN1bHQgPSBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG4gICAgcmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xuXG4gIH07XG5cbn0oKTtcblxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5UcmlhbmdsZSxcblxuICBzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICAgIHRoaXMuYS5jb3B5KCBhICk7XG4gICAgdGhpcy5iLmNvcHkoIGIgKTtcbiAgICB0aGlzLmMuY29weSggYyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cbiAgICB0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG4gICAgdGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuICAgIHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cbiAgICB0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuICAgIHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG4gICAgdGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXJlYTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgdjAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcbiAgICAgIHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cbiAgICAgIHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cbiAgfSxcblxuICBub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICByZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG4gIH0sXG5cbiAgcGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG4gIH0sXG5cbiAgYmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG4gIH0sXG5cbiAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9DbG9jay5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ2xvY2sgPSBmdW5jdGlvbiAoIGF1dG9TdGFydCApIHtcblxuICB0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XG5cbiAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICB0aGlzLm9sZFRpbWUgPSAwO1xuICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ2xvY2sucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcblxuICBzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICA/IHNlbGYucGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICAgOiBEYXRlLm5vdygpO1xuXG4gICAgdGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICB9LFxuXG4gIGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmdldERlbHRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cbiAgfSxcblxuICBnZXREZWx0YTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRpZmYgPSAwO1xuXG4gICAgaWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcblxuICAgICAgdGhpcy5zdGFydCgpO1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cbiAgICAgIHZhciBuZXdUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgPyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgICAgIDogRGF0ZS5ub3coKTtcblxuICAgICAgZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XG4gICAgICB0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG4gICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZjtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge307XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkV2ZW50RGlzcGF0Y2hlcixcblxuICBhcHBseTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICBvYmplY3QuaGFzRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzRXZlbnRMaXN0ZW5lcjtcbiAgICBvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblxuICB9LFxuXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG4gICAgfVxuXG4gICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG5cbiAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG4gICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgICAgIGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuICAgIGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIGFycmF5WyBpIF0gPSBsaXN0ZW5lckFycmF5WyBpIF07XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9SYXljYXN0ZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tL1xuICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXG4gKi9cblxuKCBmdW5jdGlvbiAoIFRIUkVFICkge1xuXG4gIFRIUkVFLlJheWNhc3RlciA9IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcblxuICAgIHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcbiAgICAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG4gICAgdGhpcy5uZWFyID0gbmVhciB8fCAwO1xuICAgIHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xuXG4gICAgdGhpcy5wYXJhbXMgPSB7XG4gICAgICBTcHJpdGU6IHt9LFxuICAgICAgTWVzaDoge30sXG4gICAgICBQb2ludENsb3VkOiB7IHRocmVzaG9sZDogMSB9LFxuICAgICAgTE9EOiB7fSxcbiAgICAgIExpbmU6IHt9XG4gICAgfTtcblxuICB9O1xuXG4gIHZhciBkZXNjU29ydCA9IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcblxuICB9O1xuXG4gIHZhciBpbnRlcnNlY3RPYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKSB7XG5cbiAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICAgIGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgLy9cblxuICBUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuICAgIGxpbmVQcmVjaXNpb246IDEsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cbiAgICAgIHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG4gICAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG4gICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgICB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuICAgICAgfSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG4gICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcbiAgICAgICAgdGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cbiAgICAgIHZhciBpbnRlcnNlY3RzID0gW107XG5cbiAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcblxuICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cbiAgICAgIH1cblxuICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgIH1cblxuICB9O1xuXG59KCBUSFJFRSApICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcbiAqL1xuXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICB0aGlzLnVwID0gVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XG5cbiAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHJvdGF0aW9uID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcblxuICB2YXIgb25Sb3RhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuICB9O1xuXG4gIHZhciBvblF1YXRlcm5pb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG4gIH07XG5cbiAgcm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcbiAgcXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBwb3NpdGlvblxuICAgIH0sXG4gICAgcm90YXRpb246IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcm90YXRpb25cbiAgICB9LFxuICAgIHF1YXRlcm5pb246IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcXVhdGVybmlvblxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogc2NhbGVcbiAgICB9LFxuICAgIG1vZGVsVmlld01hdHJpeDoge1xuICAgICAgdmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcbiAgICB9LFxuICAgIG5vcm1hbE1hdHJpeDoge1xuICAgICAgdmFsdWU6IG5ldyBUSFJFRS5NYXRyaXgzKClcbiAgICB9XG4gIH0gKTtcblxuICB0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XG5cbiAgdGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcbiAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgdGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG5cbiAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcbiAgdGhpcy5yZW5kZXJPcmRlciA9IDA7XG5cbiAgdGhpcy51c2VyRGF0YSA9IHt9O1xuXG59O1xuXG5USFJFRS5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5USFJFRS5PYmplY3QzRC5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk9iamVjdDNELFxuXG4gIGdldCBldWxlck9yZGVyICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byAucm90YXRpb24ub3JkZXIuJyApO1xuXG4gICAgcmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XG5cbiAgfSxcblxuICBzZXQgZXVsZXJPcmRlciAoIHZhbHVlICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGhhcyBiZWVuIG1vdmVkIHRvIC5yb3RhdGlvbi5vcmRlci4nICk7XG5cbiAgICB0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XG5cbiAgfSxcblxuICBnZXQgdXNlUXVhdGVybmlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cbiAgfSxcblxuICBzZXQgdXNlUXVhdGVybmlvbiAoIHZhbHVlICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG4gIH0sXG5cbiAgc2V0IHJlbmRlckRlcHRoICggdmFsdWUgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyApO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgdGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xuXG4gICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICB9LFxuXG4gIHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuICAgIC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuICB9LFxuXG4gIHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcblxuICB9LFxuXG4gIHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcblxuICB9LFxuXG4gIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXG5cbiAgICB0aGlzLnF1YXRlcm5pb24uY29weSggcSApO1xuXG4gIH0sXG5cbiAgcm90YXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG4gICAgLy8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuICAgICAgcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYXhpcywgZGlzdGFuY2UgKSB7XG5cbiAgICAgIHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG4gICAgICB0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKTtcblxuICB9LFxuXG4gIHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gIH0sXG5cbiAgd29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgICAgbTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcblxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgaWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xuXG4gICAgICBpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cbiAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG4gICAgICB9XG5cbiAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG4gICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcblxuICAgICAgb2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcblxuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcblxuICB9LFxuXG4gIGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG4gIH0sXG5cbiAgZ2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuICB9LFxuXG4gIGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cbiAgICBpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuICAgICAgdmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cbiAgICAgIGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB9LFxuXG4gIGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgfSxcblxuICBnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XG5cbiAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBnZXRXb3JsZFNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHJlc3VsdCApO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgZ2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgY2FsbGJhY2soIHRoaXMgKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgaWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgY2FsbGJhY2soIHRoaXMgKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuICAgIH1cblxuICB9LFxuXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgaWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cbiAgICAgIGNhbGxiYWNrKCBwYXJlbnQgKTtcblxuICAgICAgcGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgfSxcblxuICB1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuICAgIGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgIGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xuXG4gICAgICBpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBmb3JjZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2hpbGRyZW5cblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICB2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgKTtcblxuICAgIHZhciBkYXRhID0ge307XG5cbiAgICAvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuICAgIC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG4gICAgLy8gYmVpbmcgc2VyaWFsaXplZC5cbiAgICBpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuICAgICAgLy8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuICAgICAgbWV0YSA9IHtcbiAgICAgICAgZ2VvbWV0cmllczoge30sXG4gICAgICAgIG1hdGVyaWFsczoge30sXG4gICAgICAgIHRleHR1cmVzOiB7fSxcbiAgICAgICAgaW1hZ2VzOiB7fVxuICAgICAgfTtcblxuICAgICAgZGF0YS5tZXRhZGF0YSA9IHtcbiAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICB0eXBlOiAnT2JqZWN0JyxcbiAgICAgICAgZ2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuICAgICAgfTtcblxuICAgIH1cblxuICAgIC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgaWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG4gICAgaWYgKCB0aGlzLnZpc2libGUgIT09IHRydWUgKSBkYXRhLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cbiAgICBkYXRhLm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblxuICAgIGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG4gICAgICBkYXRhLmNoaWxkcmVuID0gW107XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIGRhdGEuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0ge307XG5cbiAgICBpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuICAgICAgdmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcbiAgICAgIHZhciBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xuICAgICAgdmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuICAgICAgdmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cbiAgICAgIGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuICAgICAgaWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG4gICAgICBpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgICAgIGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXG4gICAgfVxuXG4gICAgb3V0cHV0Lm9iamVjdCA9IGRhdGE7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgLy8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcbiAgICAvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXG4gICAgLy8gYW5kIHJldHVybiBhcyBhcnJheVxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUgKCBjYWNoZSApIHtcblxuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcblxuICAgICAgICB2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcbiAgICAgICAgZGVsZXRlIGRhdGEubWV0YWRhdGE7XG4gICAgICAgIHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cbiAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcblxuICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG4gICAgdGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcblxuICAgIHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XG4gICAgdGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuICAgIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gc291cmNlLnJvdGF0aW9uQXV0b1VwZGF0ZTtcblxuICAgIHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG4gICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cbiAgICB0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG4gICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuICAgIHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuICAgIGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuICAgICAgICB0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgdGhpcy5hID0gYTtcbiAgdGhpcy5iID0gYjtcbiAgdGhpcy5jID0gYztcblxuICB0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xuXG4gIHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcblxuICB0aGlzLnZlcnRleFRhbmdlbnRzID0gW107XG5cbiAgdGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbn07XG5cblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgdGhpcy5hID0gc291cmNlLmE7XG4gICAgdGhpcy5iID0gc291cmNlLmI7XG4gICAgdGhpcy5jID0gc291cmNlLmM7XG5cbiAgICB0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XG4gICAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLnZlcnRleFRhbmdlbnRzWyBpIF0gPSBzb3VyY2UudmVydGV4VGFuZ2VudHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2U0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcbiAgcmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuICB0aGlzLnZlcnNpb24gPSAwO1xuXG59O1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUsXG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xuICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICB9LFxuXG4gIGdldCBjb3VudCgpIHtcblxuICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCAvIHRoaXMuaXRlbVNpemU7XG5cbiAgfSxcblxuICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuICB9LFxuXG4gIGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgaW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG4gICAgaW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XG5cbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xuXG4gICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IucjtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiAoIGluZGljZXMgKSB7XG5cbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XG5cbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmE7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuICAgICAgfVxuXG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cbiAgfSxcblxuICBzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG4gICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcblxuICB9LFxuXG4gIHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuICB9LFxuXG4gIHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cbiAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSApLCB0aGlzLml0ZW1TaXplICk7XG5cbiAgfVxuXG59O1xuXG4vL1xuXG5USFJFRS5JbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuSW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQ2NEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0R5bmFtaWNCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcblxuICB0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblxufTtcblxuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5kZXhCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSwgbWVzaFBlckF0dHJpYnV0ZSwgZHluYW1pYyApIHtcblxuICBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG4gIHRoaXMuZHluYW1pYyA9IGR5bmFtaWMgfHwgZmFsc2U7XG4gIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSApLCB0aGlzLml0ZW1TaXplLCB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUsIHRoaXMuZHluYW1pYyApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUsIGR5bmFtaWMgKSB7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXG4gIHRoaXMudmVyc2lvbiA9IDA7XG5cbiAgdGhpcy5keW5hbWljID0gZHluYW1pYyB8fCBmYWxzZTtcbiAgdGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XG5cbn07XG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIsXG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgfSxcblxuICBnZXQgY291bnQgKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XG5cbiAgfSxcblxuICBzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuICB9LFxuXG4gIGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgaW5kZXgxICo9IHRoaXMuc3RyaWRlO1xuICAgIGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5ICksIHRoaXMuc3RyaWRlLCB0aGlzLmR5bmFtaWMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uICggYXJyYXksIHN0cmlkZSwgZHluYW1pYywgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlLCBkeW5hbWljICk7XG5cbiAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKTtcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSApLCB0aGlzLnN0cmlkZSwgdGhpcy5keW5hbWljLCB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApIHtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xuICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXG59O1xuXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXG5cbiAgZ2V0IGxlbmd0aCgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gIH0sXG5cbiAgZ2V0IGNvdW50KCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheS5sZW5ndGggLyB0aGlzLmRhdGEuc3RyaWRlO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcblxuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXSA9IHg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXSA9IHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xuXG4gIH0sXG5cbiAgZ2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xuXG4gIH0sXG5cbiAgZ2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG4gIH0sXG5cbiAgZ2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xuXG4gIH0sXG5cbiAgc2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XG5cbiAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuICB0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG4gIHRoaXMudmVydGljZXMgPSBbXTtcbiAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgdGhpcy5mYWNlcyA9IFtdO1xuICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG5cbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcbiAgdGhpcy5tb3JwaENvbG9ycyA9IFtdO1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xuXG4gIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcbiAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICB0aGlzLmhhc1RhbmdlbnRzID0gZmFsc2U7XG5cbiAgLy8gdXBkYXRlIGZsYWdzXG5cbiAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5HZW9tZXRyeSxcblxuICBhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICB2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcbiAgICAgIGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gIH0sXG5cbiAgcm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuICAgIHZhciBtMTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICBtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cbiAgICB2YXIgbTE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cbiAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgbTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICByb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG4gICAgdmFyIG0xO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG4gICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgIG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cbiAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuICAgIHZhciBtMTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cbiAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgbTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cbiAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgc2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHNjYWxlIGdlb21ldHJ5XG5cbiAgICB2YXIgbTE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cbiAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgbTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cbiAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgbG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgb2JqO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG4gICAgICBpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cbiAgICAgIG9iai5sb29rQXQoIHZlY3RvciApO1xuXG4gICAgICBvYmoudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICB2YXIgdmVydGljZXMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgIHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdXZzMiA9IGF0dHJpYnV0ZXMudXYyICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2Mi5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdGFuZ2VudHMgPSBhdHRyaWJ1dGVzLnRhbmdlbnQgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudGFuZ2VudC5hcnJheSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcbiAgICBpZiAoIHRhbmdlbnRzICE9PSB1bmRlZmluZWQgKSB0aGlzLmhhc1RhbmdlbnRzID0gdHJ1ZTtcblxuICAgIHZhciB0ZW1wTm9ybWFscyA9IFtdO1xuICAgIHZhciB0ZW1wVVZzID0gW107XG4gICAgdmFyIHRlbXBVVnMyID0gW107XG4gICAgdmFyIHRlbXBUYW5nZW50cyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMywgaiArPSAyLCBrICs9IDQgKSB7XG5cbiAgICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG4gICAgICBpZiAoIG5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0ZW1wVVZzMi5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHRhbmdlbnRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGVtcFRhbmdlbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB0YW5nZW50c1sgayBdLCB0YW5nZW50c1sgayArIDEgXSwgdGFuZ2VudHNbIGsgKyAyIF0sIHRhbmdlbnRzWyBrICsgMyBdICkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGFkZEZhY2UgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cbiAgICAgIHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcbiAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cbiAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKTtcblxuICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXG4gICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggdGFuZ2VudHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBmYWNlLnZlcnRleFRhbmdlbnRzLnB1c2goIHRlbXBUYW5nZW50c1sgYSBdLmNsb25lKCksIHRlbXBUYW5nZW50c1sgYiBdLmNsb25lKCksIHRlbXBUYW5nZW50c1sgYyBdLmNsb25lKCkgKTtcblxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgICBpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuICAgICAgICAgIHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgICAgICAgZm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcblxuICAgICAgICAgICAgYWRkRmFjZSggaW5kaWNlc1sgaiBdLCBpbmRpY2VzWyBqICsgMSBdLCBpbmRpY2VzWyBqICsgMiBdICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICBhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgKz0gMyApIHtcblxuICAgICAgICBhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG4gICAgdGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG5cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICB2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXG4gICAgdmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xuXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgbWF0cml4LnNldChcbiAgICAgIHMsIDAsIDAsIC0gcyAqIGNlbnRlci54LFxuICAgICAgMCwgcywgMCwgLSBzICogY2VudGVyLnksXG4gICAgICAwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcbiAgICAgIDAsIDAsIDAsIDFcbiAgICApO1xuXG4gICAgdGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICB2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICAgIHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgdmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgICAgYWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG4gICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgY2Iubm9ybWFsaXplKCk7XG5cbiAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cbiAgICB2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcblxuICAgIHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xuXG4gICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuICAgICAgdmVydGljZXNbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGFyZWFXZWlnaHRlZCApIHtcblxuICAgICAgLy8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcbiAgICAgIC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cblxuICAgICAgdmFyIHZBLCB2QiwgdkM7XG4gICAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgICB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgICB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgICAgICBhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgdmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcbiAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcbiAgICAgICAgdmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgIHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgICAgIHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgICAgIHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cbiAgICAgIHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgaWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcbiAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcbiAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cbiAgICAvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcbiAgICAvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcbiAgICAvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cbiAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XG5cbiAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xuXG4gICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXG5cbiAgICB2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cbiAgICAgIGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xuXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgICAgICB2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xuICAgICAgICB2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuICAgICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICAgICAgZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgdmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xuXG4gICAgICAgICAgZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xuICAgICAgICAgIGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuICAgICAgLy8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxuXG4gICAgICB0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG4gICAgICAvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuICAgICAgdG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgdG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICAgIC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuICAgICAgdmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cbiAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICBmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XG4gICAgICAgIHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xuXG4gICAgICAgIGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcbiAgICAgICAgdmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XG4gICAgICAgIHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcbiAgICAgIGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG4gICAgLy8gdGFuZ2VudHMgZ28gdG8gdmVydGljZXNcblxuICAgIHZhciBmLCBmbCwgdiwgdmwsIGksIHZlcnRleEluZGV4LFxuICAgICAgZmFjZSwgdXYsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMsXG4gICAgICB4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxuICAgICAgczEsIHMyLCB0MSwgdDIsIHIsIHQsIHRlc3QsXG4gICAgICB0YW4xID0gW10sIHRhbjIgPSBbXSxcbiAgICAgIHNkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0ZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRtcDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHc7XG5cbiAgICBmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG4gICAgICB0YW4xWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdGFuMlsgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBjb250ZXh0LCBhLCBiLCBjLCB1YSwgdWIsIHVjICkge1xuXG4gICAgICB2QSA9IGNvbnRleHQudmVydGljZXNbIGEgXTtcbiAgICAgIHZCID0gY29udGV4dC52ZXJ0aWNlc1sgYiBdO1xuICAgICAgdkMgPSBjb250ZXh0LnZlcnRpY2VzWyBjIF07XG5cbiAgICAgIHV2QSA9IHV2WyB1YSBdO1xuICAgICAgdXZCID0gdXZbIHViIF07XG4gICAgICB1dkMgPSB1dlsgdWMgXTtcblxuICAgICAgeDEgPSB2Qi54IC0gdkEueDtcbiAgICAgIHgyID0gdkMueCAtIHZBLng7XG4gICAgICB5MSA9IHZCLnkgLSB2QS55O1xuICAgICAgeTIgPSB2Qy55IC0gdkEueTtcbiAgICAgIHoxID0gdkIueiAtIHZBLno7XG4gICAgICB6MiA9IHZDLnogLSB2QS56O1xuXG4gICAgICBzMSA9IHV2Qi54IC0gdXZBLng7XG4gICAgICBzMiA9IHV2Qy54IC0gdXZBLng7XG4gICAgICB0MSA9IHV2Qi55IC0gdXZBLnk7XG4gICAgICB0MiA9IHV2Qy55IC0gdXZBLnk7XG5cbiAgICAgIHIgPSAxLjAgLyAoIHMxICogdDIgLSBzMiAqIHQxICk7XG4gICAgICBzZGlyLnNldCggKCB0MiAqIHgxIC0gdDEgKiB4MiApICogcixcbiAgICAgICAgICAgICggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXG4gICAgICAgICAgICAoIHQyICogejEgLSB0MSAqIHoyICkgKiByICk7XG4gICAgICB0ZGlyLnNldCggKCBzMSAqIHgyIC0gczIgKiB4MSApICogcixcbiAgICAgICAgICAgICggczEgKiB5MiAtIHMyICogeTEgKSAqIHIsXG4gICAgICAgICAgICAoIHMxICogejIgLSBzMiAqIHoxICkgKiByICk7XG5cbiAgICAgIHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcbiAgICAgIHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcbiAgICAgIHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuICAgICAgdGFuMlsgYSBdLmFkZCggdGRpciApO1xuICAgICAgdGFuMlsgYiBdLmFkZCggdGRpciApO1xuICAgICAgdGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG4gICAgfVxuXG4gICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcbiAgICAgIHV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGYgXTsgLy8gdXNlIFVWIGxheWVyIDAgZm9yIHRhbmdlbnRzXG5cbiAgICAgIGhhbmRsZVRyaWFuZ2xlKCB0aGlzLCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jLCAwLCAxLCAyICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZmFjZUluZGV4ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcblxuICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgTWF0aC5taW4oIGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGgsIDMgKTsgaSArKyApIHtcblxuICAgICAgICBuLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cbiAgICAgICAgdmVydGV4SW5kZXggPSBmYWNlWyBmYWNlSW5kZXhbIGkgXSBdO1xuXG4gICAgICAgIHQgPSB0YW4xWyB2ZXJ0ZXhJbmRleCBdO1xuXG4gICAgICAgIC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cbiAgICAgICAgdG1wLmNvcHkoIHQgKTtcbiAgICAgICAgdG1wLnN1Yiggbi5tdWx0aXBseVNjYWxhciggbi5kb3QoIHQgKSApICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuICAgICAgICB0bXAyLmNyb3NzVmVjdG9ycyggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0sIHQgKTtcbiAgICAgICAgdGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2ZXJ0ZXhJbmRleCBdICk7XG4gICAgICAgIHcgPSAoIHRlc3QgPCAwLjAgKSA/IC0gMS4wIDogMS4wO1xuXG4gICAgICAgIGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IG5ldyBUSFJFRS5WZWN0b3I0KCB0bXAueCwgdG1wLnksIHRtcC56LCB3ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuaGFzVGFuZ2VudHMgPSB0cnVlO1xuXG4gIH0sXG5cbiAgY29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBpZiAoIGkgPiAwICkge1xuXG4gICAgICAgIGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG4gIH0sXG5cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcblxuICB9LFxuXG4gIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XG5cbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsTWF0cml4LFxuICAgIHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgIHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXG4gICAgdmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXG4gICAgZmFjZXMxID0gdGhpcy5mYWNlcyxcbiAgICBmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcbiAgICB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXG4gICAgdXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblxuICAgIGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XG5cbiAgICBpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICB9XG5cbiAgICAvLyB2ZXJ0aWNlc1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xuXG4gICAgICB2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xuXG4gICAgICBpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG4gICAgICB2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xuXG4gICAgfVxuXG4gICAgLy8gZmFjZXNcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXG4gICAgICBmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcbiAgICAgIGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgICAgZmFjZUNvcHkgPSBuZXcgVEhSRUUuRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcbiAgICAgIGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgICBpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICBub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgICB9XG5cbiAgICAgIGZhY2VDb3B5LmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgY29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XG4gICAgICAgIGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XG5cbiAgICAgIH1cblxuICAgICAgZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XG5cbiAgICAgIGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xuXG4gICAgfVxuXG4gICAgLy8gdXZzXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xuXG4gICAgICBpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcblxuICAgICAgfVxuXG4gICAgICB1dnMxLnB1c2goIHV2Q29weSApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgbWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cbiAgICBpZiAoIG1lc2ggaW5zdGFuY2VvZiBUSFJFRS5NZXNoID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgdGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcblxuICB9LFxuXG4gIC8qXG4gICAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cbiAgICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuICAgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuICAgKi9cblxuICBtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICB2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcblxuICAgIHZhciB2LCBrZXk7XG4gICAgdmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xuICAgIHZhciBpLCBpbCwgZmFjZTtcbiAgICB2YXIgaW5kaWNlcywgaiwgamw7XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgICAga2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xuXG4gICAgICBpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG4gICAgICAgIHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcbiAgICAgICAgY2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcbiAgICAgICAgY2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLy8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxuICAgIC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXG4gICAgdmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cbiAgICAgIGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xuICAgICAgZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XG4gICAgICBmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcblxuICAgICAgaW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xuXG4gICAgICB2YXIgZHVwSW5kZXggPSAtIDE7XG5cbiAgICAgIC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcbiAgICAgIC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXG4gICAgICBmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuICsrICkge1xuXG4gICAgICAgIGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XG5cbiAgICAgICAgICBkdXBJbmRleCA9IG47XG4gICAgICAgICAgZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XG5cbiAgICAgIHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XG5cbiAgICAgIHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuICAgICAgZm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXG5cbiAgICB2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcbiAgICB0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuICAgIHJldHVybiBkaWZmO1xuXG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgdHlwZTogJ0dlb21ldHJ5JyxcbiAgICAgICAgZ2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cbiAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgIGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgICBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcblxuICAgIH1cblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZmFjZXMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgIHZhciBub3JtYWxzSGFzaCA9IHt9O1xuICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICB2YXIgY29sb3JzSGFzaCA9IHt9O1xuICAgIHZhciB1dnMgPSBbXTtcbiAgICB2YXIgdXZzSGFzaCA9IHt9O1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG4gICAgICB2YXIgaGFzTWF0ZXJpYWwgPSBmYWxzZTsgLy8gZmFjZS5tYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcbiAgICAgIHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcbiAgICAgIHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XG4gICAgICB2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XG4gICAgICB2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcblxuICAgICAgdmFyIGZhY2VUeXBlID0gMDtcblxuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcblxuICAgICAgZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcbiAgICAgIGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcblxuICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgICAgIGZhY2VzLnB1c2goXG4gICAgICAgICAgZ2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXG4gICAgICAgICAgZ2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXG4gICAgICAgICAgZ2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcbiAgICAgICAgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cbiAgICAgICAgZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgICAgZmFjZXMucHVzaChcbiAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXG4gICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxuICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxuICAgICAgICApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgICAgIGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgICAgICBmYWNlcy5wdXNoKFxuICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXG4gICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcbiAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXG4gICAgICAgICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xuXG4gICAgICByZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcblxuICAgICAgdmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgICB9XG5cbiAgICAgIG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XG4gICAgICBub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuICAgICAgcmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcblxuICAgICAgdmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuICAgICAgfVxuXG4gICAgICBjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgY29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XG5cbiAgICAgIHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcblxuICAgICAgdmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuICAgICAgfVxuXG4gICAgICB1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcbiAgICAgIHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cbiAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cbiAgICB9XG5cbiAgICBkYXRhLmRhdGEgPSB7fTtcblxuICAgIGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgIGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcbiAgICBpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcbiAgICBpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMuZmFjZXMgPSBbXTtcbiAgICB0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG5cbiAgICB2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZmFjZXMgPSBzb3VyY2UuZmFjZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcblxuICAgICAgaWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XG5cbiAgICAgICAgICB2YXIgdXYgPSB1dnNbIGsgXTtcblxuICAgICAgICAgIHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXS5wdXNoKCB1dnNDb3B5ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgfSxcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gIHNldCBncm91cHNOZWVkVXBkYXRlICggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy5kaXNwb3NlKCk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuRGlyZWN0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy5uYW1lID0gJyc7XG4gIHRoaXMudHlwZSA9ICdEaXJlY3RHZW9tZXRyeSc7XG5cbiAgdGhpcy5pbmRpY2VzID0gW107XG4gIHRoaXMudmVydGljZXMgPSBbXTtcbiAgdGhpcy5ub3JtYWxzID0gW107XG4gIHRoaXMuY29sb3JzID0gW107XG4gIHRoaXMudXZzID0gW107XG4gIHRoaXMudXZzMiA9IFtdO1xuICB0aGlzLnRhbmdlbnRzID0gW107XG5cbiAgdGhpcy5ncm91cHMgPSBbXTtcblxuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gIHRoaXMuc2tpbldlaWdodHMgPSBbXTtcbiAgdGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gIC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG4gIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAvLyB1cGRhdGUgZmxhZ3NcblxuICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5EaXJlY3RHZW9tZXRyeSxcblxuICBjb21wdXRlQm91bmRpbmdCb3g6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3gsXG4gIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSxcblxuICBjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVUYW5nZW50cygpIGlzIG5vdCBhIG1ldGhvZCBvZiB0aGlzIHR5cGUgb2YgZ2VvbWV0cnkuJyApO1xuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuXG4gICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcbiAgICB2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcblxuICAgIHZhciBoYXNUYW5nZW50cyA9IGdlb21ldHJ5Lmhhc1RhbmdlbnRzO1xuXG4gICAgdmFyIGdyb3VwO1xuICAgIHZhciBtYXRlcmlhbEluZGV4O1xuXG4gICAgLy8gbW9ycGhzXG5cbiAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuICAgIHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xuXG4gICAgaWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb24gPSBbXTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBpIF0gPSBbXTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG4gICAgfVxuXG4gICAgdmFyIG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcbiAgICB2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcblxuICAgIGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIG1vcnBoVGFyZ2V0c05vcm1hbCA9IFtdO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgbW9ycGhUYXJnZXRzTm9ybWFsWyBpIF0gPSBbXTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XG5cbiAgICB9XG5cbiAgICAvLyBza2luc1xuXG4gICAgdmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XG4gICAgdmFyIHNraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHM7XG5cbiAgICB2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcbiAgICB2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgIC8vXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGkzID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKywgaTMgKz0gMyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgIGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cbiAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgIGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG4gICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICB0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xuXG4gICAgICAgICAgdGhpcy51dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xuXG4gICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICB0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XG5cbiAgICAgICAgICB0aGlzLnV2czIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBtYXRlcmlhbHNcblxuICAgICAgaWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuICAgICAgICBpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBncm91cC5jb3VudCA9IGkzIC0gZ3JvdXAuc3RhcnQ7XG4gICAgICAgICAgdGhpcy5ncm91cHMucHVzaCggZ3JvdXAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXAgPSB7XG4gICAgICAgICAgc3RhcnQ6IGkzLFxuICAgICAgICAgIG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcbiAgICAgICAgfTtcblxuICAgICAgfVxuXG4gICAgICAvLyB0YW5nZW50c1xuXG4gICAgICBpZiAoIGhhc1RhbmdlbnRzID09PSB0cnVlICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhUYW5nZW50cyA9IGZhY2UudmVydGV4VGFuZ2VudHM7XG5cbiAgICAgICAgaWYgKCB2ZXJ0ZXhUYW5nZW50cy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgICB0aGlzLnRhbmdlbnRzLnB1c2goIHZlcnRleFRhbmdlbnRzWyAwIF0sIHZlcnRleFRhbmdlbnRzWyAxIF0sIHZlcnRleFRhbmdlbnRzWyAyIF0gKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB0YW5nZW50cyAnLCBpICk7XG5cbiAgICAgICAgICB0aGlzLnRhbmdlbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gbW9ycGhzXG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcblxuICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcblxuICAgICAgICBtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcblxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xuXG4gICAgICAgIG1vcnBoVGFyZ2V0c05vcm1hbFsgaiBdLnB1c2goIG1vcnBoTm9ybWFsLmEsIG1vcnBoTm9ybWFsLmIsIG1vcnBoTm9ybWFsLmMgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBza2luc1xuXG4gICAgICBpZiAoIGhhc1NraW5JbmRpY2VzICkge1xuXG4gICAgICAgIHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzU2tpbldlaWdodHMgKSB7XG5cbiAgICAgICAgdGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vXG5cbiAgICBpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGdyb3VwLmNvdW50ID0gaTMgLSBncm91cC5zdGFydDtcbiAgICAgIHRoaXMuZ3JvdXBzLnB1c2goIGdyb3VwICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcbiAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG4gICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuICAgIHRoaXMudGFuZ2VudHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy5uYW1lID0gJyc7XG4gIHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cbiAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgdGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblxuICB0aGlzLmdyb3VwcyA9IFtdO1xuXG4gIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcblxuICBhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xuXG4gICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICYmIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSB7IGFycmF5OiBhcmd1bWVudHNbIDEgXSwgaXRlbVNpemU6IGFyZ3VtZW50c1sgMiBdIH07XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIGlmICggbmFtZSA9PT0gJ2luZGV4JyAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIFRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xuICAgICAgYXR0cmlidXRlID0gbmV3IFRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUuYXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XG5cbiAgfSxcblxuICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICB9LFxuXG4gIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gIH0sXG5cbiAgZ2V0IGRyYXdjYWxscygpIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuICAgIHJldHVybiB0aGlzLmdyb3VwcztcblxuICB9LFxuXG4gIGdldCBvZmZzZXRzKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5vZmZzZXRzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG4gIH0sXG5cbiAgYWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcblxuICAgIGlmICggaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIG5vIGxvbmdlciBzdXBwb3J0cyBpbmRleE9mZnNldC4nICk7XG5cbiAgICB9XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcbiAgICB0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcblxuICB9LFxuXG4gIGNsZWFyRHJhd0NhbGxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcbiAgICB0aGlzLmNsZWFyR3JvdXBzKCk7XG5cbiAgfSxcblxuICBhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICB0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgIG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cbiAgICB9ICk7XG5cbiAgfSxcblxuICBjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5ncm91cHMgPSBbXTtcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XG4gICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgIGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgIG5vcm1hbE1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBub3JtYWwuYXJyYXkgKTtcbiAgICAgIG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICB9XG5cbiAgfSxcblxuICByb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXG4gICAgdmFyIG0xO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG4gICAgICBpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgIG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cbiAgICAgIHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgcm90YXRlWTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuICAgIHZhciBtMTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcblxuICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICBtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cbiAgICB2YXIgbTE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cbiAgICAgIGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXG4gICAgdmFyIG0xO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICBtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBzY2FsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gc2NhbGUgZ2VvbWV0cnlcblxuICAgIHZhciBtMTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcblxuICAgICAgaWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICBtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuICAgICAgdGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBvYmo7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cbiAgICAgIGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgICAgb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cbiAgICAgIG9iai51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgdGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XG5cbiAgICB0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcblxuICB9LFxuXG4gIHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG4gICAgICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcbiAgICAgIHZhciBjb2xvcnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcblxuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucy5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cbiAgICAgIGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG4gICAgICAgIHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCAgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICAgIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICB2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcblxuICAgICAgaWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICAgIH1cblxuICAgICAgZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcbiAgICAgIGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuICAgICAgZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuICAgICAgZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuICAgICAgZGlyZWN0LnRhbmdlbnRzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZTtcblxuICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGdlb21ldHJ5ID0gZGlyZWN0O1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICAgIGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIH1cblxuICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5jb2xvcjtcblxuICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBhdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy50YW5nZW50O1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkudGFuZ2VudHMgKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkRpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgcmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XG5cbiAgfSxcblxuICBmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuXG4gICAgaWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkudXZzMi5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgdXZzMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2czIubGVuZ3RoICogMiApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS50YW5nZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgdGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS50YW5nZW50cy5sZW5ndGggKiA0ICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3RhbmdlbnQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0YW5nZW50cywgNCApLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS50YW5nZW50cyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIFR5cGVBcnJheSA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICAgIHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XG5cbiAgICB9XG5cbiAgICAvLyBncm91cHNcblxuICAgIHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgLy8gbW9ycGhzXG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICB2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG1vcnBoVGFyZ2V0Lmxlbmd0aCAqIDMsIDMgKTtcblxuICAgICAgICBhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XG5cbiAgICB9XG5cbiAgICAvLyBza2lubmluZ1xuXG4gICAgaWYgKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgc2tpbkluZGljZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgc2tpbldlaWdodHMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdza2luV2VpZ2h0Jywgc2tpbldlaWdodHMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5XZWlnaHRzICkgKTtcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgIGlmICggcG9zaXRpb25zICkge1xuXG4gICAgICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3g7XG4gICAgICAgIGJiLm1ha2VFbXB0eSgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgIGJiLmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5taW4uc2V0KCAwLCAwLCAwICk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubWF4LnNldCggMCwgMCwgMCApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgaWYgKCBwb3NpdGlvbnMgKSB7XG5cbiAgICAgICAgYm94Lm1ha2VFbXB0eSgpO1xuXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICB2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICBib3guZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGJveC5jZW50ZXIoIGNlbnRlciApO1xuXG4gICAgICAgIC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG4gICAgICAgIC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuICAgICAgICB2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG4gICAgICAgIGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gIH0sXG5cbiAgY29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgIGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9ucy5sZW5ndGggKSwgMyApICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cbiAgICAgICAgdmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIG5vcm1hbHNbIGkgXSA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICAgIHZhciB2QSwgdkIsIHZDLFxuXG4gICAgICBwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBwQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBwQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgLy8gaW5kZXhlZCBlbGVtZW50c1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMuaW5kZXggKSB7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuXG4gICAgICAgIGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgIHRoaXMuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cbiAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGogXTtcblxuICAgICAgICAgIHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgdkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcbiAgICAgICAgICAgIHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XG4gICAgICAgICAgICB2QyA9IGluZGljZXNbIGkgKyAyIF0gKiAzO1xuXG4gICAgICAgICAgICBwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcbiAgICAgICAgICAgIHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xuICAgICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XG5cbiAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgICAgICAgICAgYWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG4gICAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgICAgbm9ybWFsc1sgdkEgXSArPSBjYi54O1xuICAgICAgICAgICAgbm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcbiAgICAgICAgICAgIG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XG5cbiAgICAgICAgICAgIG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcbiAgICAgICAgICAgIG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XG4gICAgICAgICAgICBub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xuXG4gICAgICAgICAgICBub3JtYWxzWyB2QyBdICs9IGNiLng7XG4gICAgICAgICAgICBub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xuICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xuXG4gICAgICAgICAgcEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcbiAgICAgICAgICBwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcbiAgICAgICAgICBwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcblxuICAgICAgICAgIGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgICAgICAgIGNiLmNyb3NzKCBhYiApO1xuXG4gICAgICAgICAgbm9ybWFsc1sgaSBdID0gY2IueDtcbiAgICAgICAgICBub3JtYWxzWyBpICsgMSBdID0gY2IueTtcbiAgICAgICAgICBub3JtYWxzWyBpICsgMiBdID0gY2IuejtcblxuICAgICAgICAgIG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xuICAgICAgICAgIG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xuICAgICAgICAgIG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xuXG4gICAgICAgICAgbm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XG4gICAgICAgICAgbm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XG4gICAgICAgICAgbm9ybWFsc1sgaSArIDggXSA9IGNiLno7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG4gICAgICBhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG4gICAgLy8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXG5cbiAgICBpZiAoIHRoaXMuYXR0cmlidXRlcy5pbmRleCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcbiAgICAgICB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICB0aGlzLmF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIGluIEJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpJyApO1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICB2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG4gICAgdmFyIHV2cyA9IHRoaXMuYXR0cmlidXRlcy51di5hcnJheTtcblxuICAgIHZhciBuVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuICAgIGlmICggdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICd0YW5nZW50JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggNCAqIG5WZXJ0aWNlcyApLCA0ICkgKTtcblxuICAgIH1cblxuICAgIHZhciB0YW5nZW50cyA9IHRoaXMuYXR0cmlidXRlcy50YW5nZW50LmFycmF5O1xuXG4gICAgdmFyIHRhbjEgPSBbXSwgdGFuMiA9IFtdO1xuXG4gICAgZm9yICggdmFyIGsgPSAwOyBrIDwgblZlcnRpY2VzOyBrICsrICkge1xuXG4gICAgICB0YW4xWyBrIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdGFuMlsgayBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgICAgIHV2QSA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgICB1dkIgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgICAgdXZDID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblxuICAgICAgeDEsIHgyLCB5MSwgeTIsIHoxLCB6MixcbiAgICAgIHMxLCBzMiwgdDEsIHQyLCByO1xuXG4gICAgdmFyIHNkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0ZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBhLCBiLCBjICkge1xuXG4gICAgICB2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcbiAgICAgIHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuICAgICAgdkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGMgKiAzICk7XG5cbiAgICAgIHV2QS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKTtcbiAgICAgIHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcbiAgICAgIHV2Qy5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKTtcblxuICAgICAgeDEgPSB2Qi54IC0gdkEueDtcbiAgICAgIHgyID0gdkMueCAtIHZBLng7XG5cbiAgICAgIHkxID0gdkIueSAtIHZBLnk7XG4gICAgICB5MiA9IHZDLnkgLSB2QS55O1xuXG4gICAgICB6MSA9IHZCLnogLSB2QS56O1xuICAgICAgejIgPSB2Qy56IC0gdkEuejtcblxuICAgICAgczEgPSB1dkIueCAtIHV2QS54O1xuICAgICAgczIgPSB1dkMueCAtIHV2QS54O1xuXG4gICAgICB0MSA9IHV2Qi55IC0gdXZBLnk7XG4gICAgICB0MiA9IHV2Qy55IC0gdXZBLnk7XG5cbiAgICAgIHIgPSAxLjAgLyAoIHMxICogdDIgLSBzMiAqIHQxICk7XG5cbiAgICAgIHNkaXIuc2V0KFxuICAgICAgICAoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxuICAgICAgICAoIHQyICogeTEgLSB0MSAqIHkyICkgKiByLFxuICAgICAgICAoIHQyICogejEgLSB0MSAqIHoyICkgKiByXG4gICAgICApO1xuXG4gICAgICB0ZGlyLnNldChcbiAgICAgICAgKCBzMSAqIHgyIC0gczIgKiB4MSApICogcixcbiAgICAgICAgKCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcbiAgICAgICAgKCBzMSAqIHoyIC0gczIgKiB6MSApICogclxuICAgICAgKTtcblxuICAgICAgdGFuMVsgYSBdLmFkZCggc2RpciApO1xuICAgICAgdGFuMVsgYiBdLmFkZCggc2RpciApO1xuICAgICAgdGFuMVsgYyBdLmFkZCggc2RpciApO1xuXG4gICAgICB0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XG4gICAgICB0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XG4gICAgICB0YW4yWyBjIF0uYWRkKCB0ZGlyICk7XG5cbiAgICB9XG5cbiAgICB2YXIgaSwgaWw7XG4gICAgdmFyIGosIGpsO1xuICAgIHZhciBpQSwgaUIsIGlDO1xuXG4gICAgaWYgKCB0aGlzLmdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgIHRoaXMuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cbiAgICBmb3IgKCBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cbiAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xuXG4gICAgICB2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcbiAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgICBmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgaUEgPSBpbmRpY2VzWyBpICsgMCBdO1xuICAgICAgICBpQiA9IGluZGljZXNbIGkgKyAxIF07XG4gICAgICAgIGlDID0gaW5kaWNlc1sgaSArIDIgXTtcblxuICAgICAgICBoYW5kbGVUcmlhbmdsZSggaUEsIGlCLCBpQyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdG1wMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHcsIHQsIHRlc3Q7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVWZXJ0ZXgoIHYgKSB7XG5cbiAgICAgIG4uZnJvbUFycmF5KCBub3JtYWxzLCB2ICogMyApO1xuICAgICAgbjIuY29weSggbiApO1xuXG4gICAgICB0ID0gdGFuMVsgdiBdO1xuXG4gICAgICAvLyBHcmFtLVNjaG1pZHQgb3J0aG9nb25hbGl6ZVxuXG4gICAgICB0bXAuY29weSggdCApO1xuICAgICAgdG1wLnN1Yiggbi5tdWx0aXBseVNjYWxhciggbi5kb3QoIHQgKSApICkubm9ybWFsaXplKCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBoYW5kZWRuZXNzXG5cbiAgICAgIHRtcDIuY3Jvc3NWZWN0b3JzKCBuMiwgdCApO1xuICAgICAgdGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2IF0gKTtcbiAgICAgIHcgPSAoIHRlc3QgPCAwLjAgKSA/IC0gMS4wIDogMS4wO1xuXG4gICAgICB0YW5nZW50c1sgdiAqIDQgXSA9IHRtcC54O1xuICAgICAgdGFuZ2VudHNbIHYgKiA0ICsgMSBdID0gdG1wLnk7XG4gICAgICB0YW5nZW50c1sgdiAqIDQgKyAyIF0gPSB0bXAuejtcbiAgICAgIHRhbmdlbnRzWyB2ICogNCArIDMgXSA9IHc7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cbiAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xuXG4gICAgICB2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcbiAgICAgIHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG4gICAgICBmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgaUEgPSBpbmRpY2VzWyBpICsgMCBdO1xuICAgICAgICBpQiA9IGluZGljZXNbIGkgKyAxIF07XG4gICAgICAgIGlDID0gaW5kaWNlc1sgaSArIDIgXTtcblxuICAgICAgICBoYW5kbGVWZXJ0ZXgoIGlBICk7XG4gICAgICAgIGhhbmRsZVZlcnRleCggaUIgKTtcbiAgICAgICAgaGFuZGxlVmVydGV4KCBpQyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb21wdXRlT2Zmc2V0czogZnVuY3Rpb24gKCBzaXplICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJylcblxuICB9LFxuXG4gIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICBpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xuXG4gICAgICB2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xuICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkgKyssIGogKysgKSB7XG5cbiAgICAgICAgYXR0cmlidXRlQXJyYXkxWyBqIF0gPSBhdHRyaWJ1dGVBcnJheTJbIGkgXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICB2YXIgeCwgeSwgeiwgbjtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgIHggPSBub3JtYWxzWyBpIF07XG4gICAgICB5ID0gbm9ybWFsc1sgaSArIDEgXTtcbiAgICAgIHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG4gICAgICBuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuICAgICAgbm9ybWFsc1sgaSBdICo9IG47XG4gICAgICBub3JtYWxzWyBpICsgMSBdICo9IG47XG4gICAgICBub3JtYWxzWyBpICsgMiBdICo9IG47XG5cbiAgICB9XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICB0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxuICAgICAgICBnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgaWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICAgIGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfVxuXG4gICAgZGF0YS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG4gICAgdmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuICAgIGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG4gICAgICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXR0cmlidXRlLmFycmF5ICk7XG5cbiAgICAgIGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcbiAgICAgICAgaXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcbiAgICAgICAgdHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgIGFycmF5OiBhcnJheVxuICAgICAgfTtcblxuICAgIH1cblxuICAgIGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgIGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcbiAgICAgICAgY2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuICAgICAgICByYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuICAgICAgfTtcblxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcbiAgICB2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuICAgICAgdGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcbiAgdGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHVuZGVmaW5lZDtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZERyYXdDYWxsID0gZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluc3RhbmNlcyApIHtcblxuICB0aGlzLmRyYXdjYWxscy5wdXNoKCB7XG5cbiAgICBzdGFydDogc3RhcnQsXG4gICAgY291bnQ6IGNvdW50LFxuICAgIGluc3RhbmNlczogaW5zdGFuY2VzXG5cbiAgfSApO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIGZvciAoIHZhciBhdHRyIGluIHNvdXJjZS5hdHRyaWJ1dGVzICkge1xuXG4gICAgdmFyIHNvdXJjZUF0dHIgPSBzb3VyY2UuYXR0cmlidXRlc1sgYXR0ciBdO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCBhdHRyLCBzb3VyY2VBdHRyLmNsb25lKCkgKTtcblxuICB9XG5cbiAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5kcmF3Y2FsbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICB2YXIgb2Zmc2V0ID0gc291cmNlLmRyYXdjYWxsc1sgaSBdO1xuICAgIHRoaXMuYWRkRHJhd0NhbGwoIG9mZnNldC5zdGFydCwgb2Zmc2V0LmNvdW50LCBvZmZzZXQuaW5zdGFuY2VzICk7XG5cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuZ2V0V29ybGREaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gIH07XG5cbn0oKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgY2FtZXJhcyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cbiAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xuXG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuICB9O1xuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XG4gIHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanNcblxuLyoqXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcbiAqICAtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xuXG4gIHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcblxuICB2YXIgY2FtZXJhUFggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgY2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgY2FtZXJhUFgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApICk7XG4gIHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG4gIHZhciBjYW1lcmFOWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICBjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuICBjYW1lcmFOWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xuICB0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuICB2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgY2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG4gIGNhbWVyYVBZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuICB0aGlzLmFkZCggY2FtZXJhUFkgKTtcblxuICB2YXIgY2FtZXJhTlkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgY2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcbiAgY2FtZXJhTlkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICkgKTtcbiAgdGhpcy5hZGQoIGNhbWVyYU5ZICk7XG5cbiAgdmFyIGNhbWVyYVBaID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gIGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XG4gIGNhbWVyYVBaLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSApO1xuICB0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuICB2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgY2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgY2FtZXJhTloubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLSAxICkgKTtcbiAgdGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cbiAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIHsgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciB9ICk7XG5cbiAgdGhpcy51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XG5cbiAgICBpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG4gICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXG4gIH07XG5cbn07XG5cblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVDYW1lcmE7XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgPSBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG4gIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cbiAgdGhpcy56b29tID0gMTtcblxuICB0aGlzLmxlZnQgPSBsZWZ0O1xuICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIHRoaXMudG9wID0gdG9wO1xuICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuICB0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcbiAgdGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xuXG4gIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG4gIHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG4gIHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcbiAgdmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG4gIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcbiAgdGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcbiAgdGhpcy50b3AgPSBzb3VyY2UudG9wO1xuICB0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG4gIHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuICB0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cbiAgdGhpcy56b29tID0gc291cmNlLnpvb207XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcbiAgZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcbiAgZGF0YS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xuICBkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcbiAgZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG4gIGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG4gIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG4gIFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcblxuICB0aGlzLnpvb20gPSAxO1xuXG4gIHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcbiAgdGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XG4gIHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG4gIHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXG4gIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtcblxuXG4vKipcbiAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1ZcbiAqIDM1bW0gKGZ1bGwtZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xuXG4gIGlmICggZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCApIGZyYW1lSGVpZ2h0ID0gMjQ7XG5cbiAgdGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xuICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG4vKipcbiAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcbiAqXG4gKiAgICstLS0rLS0tKy0tLStcbiAqICAgfCBBIHwgQiB8IEMgfFxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgRCB8IEUgfCBGIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICpcbiAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcbiAqXG4gKiAgIHZhciB3ID0gMTkyMDtcbiAqICAgdmFyIGggPSAxMDgwO1xuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XG4gKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XG4gKlxuICogICAtLUEtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuICogICAtLUItLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuICogICAtLUMtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuICogICAtLUQtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuICogICAtLUUtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuICogICAtLUYtLVxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuICpcbiAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0Vmlld09mZnNldCA9IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gIHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuICB0aGlzLmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmb3YgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKCAyICogTWF0aC5hdGFuKCBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5mb3YgKSAqIDAuNSApIC8gdGhpcy56b29tICkgKTtcblxuICBpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xuXG4gICAgdmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xuICAgIHZhciB0b3AgPSBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKSAqIHRoaXMubmVhcjtcbiAgICB2YXIgYm90dG9tID0gLSB0b3A7XG4gICAgdmFyIGxlZnQgPSBhc3BlY3QgKiBib3R0b207XG4gICAgdmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xuICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKCByaWdodCAtIGxlZnQgKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcCAtIGJvdHRvbSApO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxuICAgICAgbGVmdCArIHRoaXMueCAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXG4gICAgICBsZWZ0ICsgKCB0aGlzLnggKyB0aGlzLndpZHRoICkgKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuICAgICAgdG9wIC0gKCB0aGlzLnkgKyB0aGlzLmhlaWdodCApICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuICAgICAgdG9wIC0gdGhpcy55ICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuICAgICAgdGhpcy5uZWFyLFxuICAgICAgdGhpcy5mYXJcbiAgICApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBmb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG4gIHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcbiAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG4gIHRoaXMuZmFyID0gc291cmNlLmZhcjtcblxuICB0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG4gIGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuICBkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcbiAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpZ2h0JztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpZ2h0O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG4vLyBGaWxlOnNyYy9saWdodHMvQW1iaWVudExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BbWJpZW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG4gIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgdGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XG5cbn07XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BbWJpZW50TGlnaHQ7XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvQXJlYUxpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBNUGFua25pbiAvIGh0dHA6Ly93d3cucmVkcGxhbnQuZGUvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBwcmFmdWxsaXRcbiAqL1xuXG5USFJFRS5BcmVhTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnQXJlYUxpZ2h0JztcblxuICB0aGlzLm5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcbiAgdGhpcy5yaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG4gIHRoaXMud2lkdGggPSAxLjA7XG4gIHRoaXMuaGVpZ2h0ID0gMS4wO1xuXG4gIHRoaXMuY29uc3RhbnRBdHRlbnVhdGlvbiA9IDEuNTtcbiAgdGhpcy5saW5lYXJBdHRlbnVhdGlvbiA9IDAuNTtcbiAgdGhpcy5xdWFkcmF0aWNBdHRlbnVhdGlvbiA9IDAuMTtcblxufTtcblxuVEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFyZWFMaWdodDtcblxuVEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuICB0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XG4gIHRoaXMucmlnaHQuY29weSggc291cmNlLnJpZ2h0ICk7XG4gIHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcbiAgdGhpcy5jb25zdGFudEF0dGVudWF0aW9uID0gc291cmNlLmNvbnN0YW50QXR0ZW51YXRpb247XG4gIHRoaXMubGluZWFyQXR0ZW51YXRpb24gPSBzb3VyY2UubGluZWFyQXR0ZW51YXRpb247XG4gIHRoaXMucXVhZHJhdGljQXR0ZW51YXRpb24gPSBzb3VyY2UucXVhZHJhdGljQXR0ZW51YXRpb247XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkFyZWFMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gIFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cbiAgdGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG4gIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG4gIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbiAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gIHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDUwO1xuICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IDUwMDA7XG5cbiAgdGhpcy5zaGFkb3dDYW1lcmFMZWZ0ID0gLSA1MDA7XG4gIHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQgPSA1MDA7XG4gIHRoaXMuc2hhZG93Q2FtZXJhVG9wID0gNTAwO1xuICB0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbSA9IC0gNTAwO1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuc2hhZG93QmlhcyA9IDA7XG4gIHRoaXMuc2hhZG93RGFya25lc3MgPSAwLjU7XG5cbiAgdGhpcy5zaGFkb3dNYXBXaWR0aCA9IDUxMjtcbiAgdGhpcy5zaGFkb3dNYXBIZWlnaHQgPSA1MTI7XG5cbiAgdGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuICB0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuICB0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG4gIHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcbiAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cbiAgdGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG4gIHRoaXMub25seVNoYWRvdyA9IHNvdXJjZS5vbmx5U2hhZG93O1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFOZWFyO1xuICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFGYXI7XG5cbiAgdGhpcy5zaGFkb3dDYW1lcmFMZWZ0ID0gc291cmNlLnNoYWRvd0NhbWVyYUxlZnQ7XG4gIHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhUmlnaHQ7XG4gIHRoaXMuc2hhZG93Q2FtZXJhVG9wID0gc291cmNlLnNoYWRvd0NhbWVyYVRvcDtcbiAgdGhpcy5zaGFkb3dDYW1lcmFCb3R0b20gPSBzb3VyY2Uuc2hhZG93Q2FtZXJhQm90dG9tO1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHNvdXJjZS5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG4gIHRoaXMuc2hhZG93QmlhcyA9IHNvdXJjZS5zaGFkb3dCaWFzO1xuICB0aGlzLnNoYWRvd0RhcmtuZXNzID0gc291cmNlLnNoYWRvd0RhcmtuZXNzO1xuXG4gIHRoaXMuc2hhZG93TWFwV2lkdGggPSBzb3VyY2Uuc2hhZG93TWFwV2lkdGg7XG4gIHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gc291cmNlLnNoYWRvd01hcEhlaWdodDtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24gKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xuXG4gIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxMDAsIDAgKTtcbiAgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICB0aGlzLmdyb3VuZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBncm91bmRDb2xvciApO1xuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHQ7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gIHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XG4gIHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcbiAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9Qb2ludExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cbiAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuICB0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG4gIHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuICB0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuICB0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL1Nwb3RMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXG4gIHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG4gIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG4gIHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcbiAgdGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcbiAgdGhpcy5leHBvbmVudCA9ICggZXhwb25lbnQgIT09IHVuZGVmaW5lZCApID8gZXhwb25lbnQgOiAxMDtcbiAgdGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxOyAvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cbiAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gIHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDUwO1xuICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IDUwMDA7XG4gIHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gNTA7XG5cbiAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5zaGFkb3dCaWFzID0gMDtcbiAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuICB0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuICB0aGlzLnNoYWRvd01hcCA9IG51bGw7XG4gIHRoaXMuc2hhZG93TWFwU2l6ZSA9IG51bGw7XG4gIHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcbiAgdGhpcy5zaGFkb3dNYXRyaXggPSBudWxsO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG4gIHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG4gIHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG4gIHRoaXMuZXhwb25lbnQgPSBzb3VyY2UuZXhwb25lbnQ7XG4gIHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cbiAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cbiAgdGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG4gIHRoaXMub25seVNoYWRvdyA9IHNvdXJjZS5vbmx5U2hhZG93O1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFOZWFyO1xuICB0aGlzLnNoYWRvd0NhbWVyYUZhciA9IHNvdXJjZS5zaGFkb3dDYW1lcmFGYXI7XG4gIHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gc291cmNlLnNoYWRvd0NhbWVyYUZvdjtcblxuICB0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBzb3VyY2Uuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuICB0aGlzLnNoYWRvd0JpYXMgPSBzb3VyY2Uuc2hhZG93QmlhcztcbiAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IHNvdXJjZS5zaGFkb3dEYXJrbmVzcztcblxuICB0aGlzLnNoYWRvd01hcFdpZHRoID0gc291cmNlLnNoYWRvd01hcFdpZHRoO1xuICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IHNvdXJjZS5zaGFkb3dNYXBIZWlnaHQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcbiAgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuICBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XG4gIGRhdGEub2JqZWN0LmV4cG9uZW50ID0gdGhpcy5leHBvbmVudDtcbiAgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NhY2hlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DYWNoZSA9IHtcblxuICBlbmFibGVkOiBmYWxzZSxcblxuICBmaWxlczoge30sXG5cbiAgYWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcblxuICAgIGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcblxuICAgIHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcblxuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cbiAgICBpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuICAgIHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcblxuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XG5cbiAgICBkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XG5cbiAgfSxcblxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XG4gIHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG59O1xuXG5USFJFRS5Mb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Mb2FkZXIsXG5cbiAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuICBleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xuXG4gICAgaWYgKCBwYXJ0cy5sZW5ndGggPT09IDEgKSByZXR1cm4gJy4vJztcblxuICAgIHBhcnRzLnBvcCgpO1xuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xuXG4gIH0sXG5cbiAgaW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcblxuICAgICAgYXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcblxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIG5lZWRzVGFuZ2VudHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIG0gPSBtYXRlcmlhbHNbIGkgXTtcblxuICAgICAgaWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIGNyZWF0ZU1hdGVyaWFsOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBpbWFnZUxvYWRlcjtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXRlcmlhbCggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG4gICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICBpZiAoIGNyb3NzT3JpZ2luID09PSB1bmRlZmluZWQgJiYgc2NvcGUuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGNyb3NzT3JpZ2luID0gc2NvcGUuY3Jvc3NPcmlnaW47XG5cbiAgICAgIGlmICggaW1hZ2VMb2FkZXIgPT09IHVuZGVmaW5lZCApIGltYWdlTG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cbiAgICAgIGZ1bmN0aW9uIG5lYXJlc3RfcG93MiggbiApIHtcblxuICAgICAgICB2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLnJvdW5kKCAgbCApICk7XG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlX3RleHR1cmUoIHdoZXJlLCBuYW1lLCBzb3VyY2VGaWxlLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcblxuICAgICAgICB2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHNvdXJjZUZpbGU7XG5cbiAgICAgICAgdmFyIHRleHR1cmU7XG5cbiAgICAgICAgdmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XG5cbiAgICAgICAgaWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xuXG4gICAgICAgICAgbG9hZGVyID0gaW1hZ2VMb2FkZXI7XG4gICAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xuICAgICAgICAgIGxvYWRlci5sb2FkKCBmdWxsUGF0aCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgaWYgKCBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICB2YXIgd2lkdGggPSBuZWFyZXN0X3BvdzIoIGltYWdlLndpZHRoICk7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBuZWFyZXN0X3BvdzIoIGltYWdlLmhlaWdodCApO1xuXG4gICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBjYW52YXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgfSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLnNvdXJjZUZpbGUgPSBzb3VyY2VGaWxlO1xuXG4gICAgICAgIGlmICggcmVwZWF0ICkge1xuXG4gICAgICAgICAgdGV4dHVyZS5yZXBlYXQuc2V0KCByZXBlYXRbIDAgXSwgcmVwZWF0WyAxIF0gKTtcblxuICAgICAgICAgIGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgICAgaWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvZmZzZXQgKSB7XG5cbiAgICAgICAgICB0ZXh0dXJlLm9mZnNldC5zZXQoIG9mZnNldFsgMCBdLCBvZmZzZXRbIDEgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHdyYXAgKSB7XG5cbiAgICAgICAgICB2YXIgd3JhcE1hcCA9IHtcbiAgICAgICAgICAgICdyZXBlYXQnOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcbiAgICAgICAgICAgICdtaXJyb3InOiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICggd3JhcE1hcFsgd3JhcFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHRleHR1cmUud3JhcFMgPSB3cmFwTWFwWyB3cmFwWyAwIF0gXTtcbiAgICAgICAgICBpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYW5pc290cm9weSApIHtcblxuICAgICAgICAgIHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHdoZXJlWyBuYW1lIF0gPSB0ZXh0dXJlO1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJnYjJoZXgoIHJnYiApIHtcblxuICAgICAgICByZXR1cm4gKCByZ2JbIDAgXSAqIDI1NSA8PCAxNiApICsgKCByZ2JbIDEgXSAqIDI1NSA8PCA4ICkgKyByZ2JbIDIgXSAqIDI1NTtcblxuICAgICAgfVxuXG4gICAgICAvLyBkZWZhdWx0c1xuXG4gICAgICB2YXIgbXR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG4gICAgICB2YXIgbXBhcnMgPSB7IGNvbG9yOiAweGVlZWVlZSwgb3BhY2l0eTogMS4wLCBtYXA6IG51bGwsIGxpZ2h0TWFwOiBudWxsLCBub3JtYWxNYXA6IG51bGwsIGJ1bXBNYXA6IG51bGwsIHdpcmVmcmFtZTogZmFsc2UgfTtcblxuICAgICAgLy8gcGFyYW1ldGVycyBmcm9tIG1vZGVsIGZpbGVcblxuICAgICAgaWYgKCBtLnNoYWRpbmcgKSB7XG5cbiAgICAgICAgdmFyIHNoYWRpbmcgPSBtLnNoYWRpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoIHNoYWRpbmcgPT09ICdwaG9uZycgKSBtdHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG4gICAgICAgIGVsc2UgaWYgKCBzaGFkaW5nID09PSAnYmFzaWMnICkgbXR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIFRIUkVFWyBtLmJsZW5kaW5nIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtcGFycy5ibGVuZGluZyA9IFRIUkVFWyBtLmJsZW5kaW5nIF07XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5vcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgbS5vcGFjaXR5IDwgMS4wICkge1xuXG4gICAgICAgIG1wYXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbXBhcnMuZGVwdGhUZXN0ID0gbS5kZXB0aFRlc3Q7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtcGFycy5kZXB0aFdyaXRlID0gbS5kZXB0aFdyaXRlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbXBhcnMudmlzaWJsZSA9IG0udmlzaWJsZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0uZmxpcFNpZGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbXBhcnMuc2lkZSA9IFRIUkVFLkJhY2tTaWRlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5kb3VibGVTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1wYXJzLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtcGFycy53aXJlZnJhbWUgPSBtLndpcmVmcmFtZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgaWYgKCBtLnZlcnRleENvbG9ycyA9PT0gJ2ZhY2UnICkge1xuXG4gICAgICAgICAgbXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcblxuICAgICAgICB9IGVsc2UgaWYgKCBtLnZlcnRleENvbG9ycyApIHtcblxuICAgICAgICAgIG1wYXJzLnZlcnRleENvbG9ycyA9IFRIUkVFLlZlcnRleENvbG9ycztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gY29sb3JzXG5cbiAgICAgIGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XG5cbiAgICAgICAgbXBhcnMuY29sb3IgPSByZ2IyaGV4KCBtLmNvbG9yRGlmZnVzZSApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtLkRiZ0NvbG9yICkge1xuXG4gICAgICAgIG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0uY29sb3JTcGVjdWxhciApIHtcblxuICAgICAgICBtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5jb2xvckVtaXNzaXZlICkge1xuXG4gICAgICAgIG1wYXJzLmVtaXNzaXZlID0gcmdiMmhleCggbS5jb2xvckVtaXNzaXZlICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gbW9kaWZpZXJzXG5cbiAgICAgIGlmICggbS50cmFuc3BhcmVuY3kgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXI6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XG4gICAgICAgIG0ub3BhY2l0eSA9IG0udHJhbnNwYXJlbmN5O1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbXBhcnMub3BhY2l0eSA9IG0ub3BhY2l0eTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0uc3BlY3VsYXJDb2VmICkge1xuXG4gICAgICAgIG1wYXJzLnNoaW5pbmVzcyA9IG0uc3BlY3VsYXJDb2VmO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIHRleHR1cmVzXG5cbiAgICAgIGlmICggbS5tYXBEaWZmdXNlICYmIHRleHR1cmVQYXRoICkge1xuXG4gICAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ21hcCcsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0ubWFwTGlnaHQgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbGlnaHRNYXAnLCBtLm1hcExpZ2h0LCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0ubWFwQU8gJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYW9NYXAnLCBtLm1hcEFPLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0ubWFwQnVtcCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdidW1wTWFwJywgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5tYXBOb3JtYWwgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbm9ybWFsTWFwJywgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0ubWFwU3BlY3VsYXIgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnc3BlY3VsYXJNYXAnLCBtLm1hcFNwZWN1bGFyLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG0ubWFwQWxwaGEgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYWxwaGFNYXAnLCBtLm1hcEFscGhhLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblxuICAgICAgfVxuXG4gICAgICAvL1xuXG4gICAgICBpZiAoIG0ubWFwQnVtcFNjYWxlICkge1xuXG4gICAgICAgIG1wYXJzLmJ1bXBTY2FsZSA9IG0ubWFwQnVtcFNjYWxlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XG5cbiAgICAgICAgbXBhcnMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggbS5tYXBOb3JtYWxGYWN0b3IsIG0ubWFwTm9ybWFsRmFjdG9yICk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBtdHlwZSBdKCBtcGFycyApO1xuXG4gICAgICBpZiAoIG0uRGJnTmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IG0uRGJnTmFtZTtcblxuICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gICAgfTtcblxuICB9ICkoKVxuXG59O1xuXG5USFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XG5cbiAgaGFuZGxlcnM6IFtdLFxuXG4gIGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xuXG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xuXG4gICAgICB2YXIgcmVnZXggPSB0aGlzLmhhbmRsZXJzWyBpIF07XG4gICAgICB2YXIgbG9hZGVyICA9IHRoaXMuaGFuZGxlcnNbIGkgKyAxIF07XG5cbiAgICAgIGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xuXG4gICAgICAgIHJldHVybiBsb2FkZXI7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9YSFJMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlhIUkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XG5cbiAgICBpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpZiAoIG9uTG9hZCApIHtcblxuICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICBvbkxvYWQoIGNhY2hlZCApO1xuXG4gICAgICAgIH0sIDAgKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVkO1xuXG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblxuICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICBUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcy5yZXNwb25zZSApO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcy5yZXNwb25zZSApO1xuXG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgfSwgZmFsc2UgKTtcblxuICAgIGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcblxuICAgICAgfSwgZmFsc2UgKTtcblxuICAgIH1cblxuICAgIGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgICAgb25FcnJvciggZXZlbnQgKTtcblxuICAgICAgfSwgZmFsc2UgKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgaWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcbiAgICBpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgcmVxdWVzdC5zZW5kKCBudWxsICk7XG5cbiAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcblxuICB9LFxuXG4gIHNldFJlc3BvbnNlVHlwZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9LFxuXG4gIHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuSW1hZ2VMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5JbWFnZUxvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xuXG4gICAgaWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaWYgKCBvbkxvYWQgKSB7XG5cbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgb25Mb2FkKCBjYWNoZWQgKTtcblxuICAgICAgICB9LCAwICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlZDtcblxuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbWcnICk7XG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgIFRIUkVFLkNhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cbiAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XG5cbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICB9LCBmYWxzZSApO1xuXG4gICAgaWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgICAgb25Qcm9ncmVzcyggZXZlbnQgKTtcblxuICAgICAgfSwgZmFsc2UgKTtcblxuICAgIH1cblxuICAgIGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICAgIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICAgIH0sIGZhbHNlICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIGltYWdlLnNyYyA9IHVybDtcblxuICAgIHJldHVybiBpbWFnZTtcblxuICB9LFxuXG4gIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9KU09OTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuSlNPTkxvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHRleHR1cmVQYXRoID0gdGhpcy50ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID09PSBcInN0cmluZ1wiICkgPyB0aGlzLnRleHR1cmVQYXRoIDogVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5leHRyYWN0VXJsQmFzZSggdXJsICk7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuICAgICAgdmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuICAgICAgaWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ3NjZW5lJyApIHtcblxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG4gICAgICBvbkxvYWQoIG9iamVjdC5nZW9tZXRyeSwgb2JqZWN0Lm1hdGVyaWFscyApO1xuXG4gICAgfSApO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfSxcblxuICBzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXG4gICAgc2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcblxuICAgIHBhcnNlTW9kZWwoIHNjYWxlICk7XG5cbiAgICBwYXJzZVNraW4oKTtcbiAgICBwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xuXG4gICAgZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuICAgICAgZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUgJiAoIDEgPDwgcG9zaXRpb24gKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaiwgZmksXG5cbiAgICAgIG9mZnNldCwgekxlbmd0aCxcblxuICAgIGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxuXG4gICAgICB0eXBlLFxuICAgICAgaXNRdWFkLFxuICAgICAgaGFzTWF0ZXJpYWwsXG4gICAgICBoYXNGYWNlVmVydGV4VXYsXG4gICAgICBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxuICAgICAgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXG5cbiAgICB2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXG5cbiAgICAgIHV2TGF5ZXIsIHV2LCB1LCB2LFxuXG4gICAgICBmYWNlcyA9IGpzb24uZmFjZXMsXG4gICAgICB2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXG4gICAgICBub3JtYWxzID0ganNvbi5ub3JtYWxzLFxuICAgICAgY29sb3JzID0ganNvbi5jb2xvcnMsXG5cbiAgICAgIG5VdkxheWVycyA9IDA7XG5cbiAgICAgIGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICBpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG4gICAgICAgIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcbiAgICAgICAgdmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcbiAgICAgICAgdmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgfVxuXG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG4gICAgICAgIHR5cGUgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblxuICAgICAgICBpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcbiAgICAgICAgaGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XG4gICAgICAgIGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xuICAgICAgICBoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcbiAgICAgICAgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG4gICAgICAgIGhhc0ZhY2VDb2xvciAgICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XG4gICAgICAgIGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XG5cbiAgICAgICAgaWYgKCBpc1F1YWQgKSB7XG5cbiAgICAgICAgICBmYWNlQSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICAgIGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XG4gICAgICAgICAgZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG4gICAgICAgICAgZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgICBmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xuICAgICAgICAgIGZhY2VCLmEgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuICAgICAgICAgIGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuICAgICAgICAgIGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgICAgICAgICBtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgICAgZmFjZUEubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG4gICAgICAgICAgICBmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG4gICAgICAgICAgZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgdXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cbiAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG4gICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0gPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgICAgICAgICAgICAgdSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG4gICAgICAgICAgICAgICAgdiA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG4gICAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqICE9PSAyICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG4gICAgICAgICAgICAgICAgaWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG4gICAgICAgICAgICBub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cbiAgICAgICAgICAgIGZhY2VBLm5vcm1hbC5zZXQoXG4gICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG4gICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgaWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcbiAgICAgICAgICAgICAgaWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICBpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICAgICAgICAgIGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG4gICAgICAgICAgICBmYWNlQS5jb2xvci5zZXRIZXgoIGhleCApO1xuICAgICAgICAgICAgZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcblxuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgICAgICBoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuICAgICAgICAgICAgICBpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuICAgICAgICAgICAgICBpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgICBmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgICAgICAgZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgIGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuICAgICAgICAgIGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgIG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cbiAgICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuICAgICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgICAgICAgICAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgICAgICAgICAgICAgdSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG4gICAgICAgICAgICAgICAgdiA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG4gICAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cbiAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgICAgICAgICAgZmFjZS5ub3JtYWwuc2V0KFxuICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgICAgICAgICAgIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCBdXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgICAgZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XG5cbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cbiAgICAgIHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuICAgICAgaWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG4gICAgICAgICAgdmFyIHggPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5XZWlnaHRzWyBpIF07XG4gICAgICAgICAgdmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcbiAgICAgICAgICB2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xuICAgICAgICAgIHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cbiAgICAgICAgICBnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICgganNvbi5za2luSW5kaWNlcyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgICAgICAgIHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSBdO1xuICAgICAgICAgIHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XG4gICAgICAgICAgdmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcbiAgICAgICAgICB2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xuXG4gICAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcbiAgICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuICAgICAgfVxuXG5cbiAgICAgIC8vIGNvdWxkIGNoYW5nZSB0aGlzIHRvIGpzb24uYW5pbWF0aW9uc1swXSBvciByZW1vdmUgY29tcGxldGVseVxuXG4gICAgICBnZW9tZXRyeS5hbmltYXRpb24gPSBqc29uLmFuaW1hdGlvbjtcbiAgICAgIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBqc29uLmFuaW1hdGlvbnM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cbiAgICAgIGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgaSwgbCwgdiwgdmwsIGRzdFZlcnRpY2VzLCBzcmNWZXJ0aWNlcztcblxuICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXSA9IHt9O1xuICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XG4gICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuICAgICAgICAgIGRzdFZlcnRpY2VzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG4gICAgICAgICAgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG4gICAgICAgICAgZm9yICggdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcbiAgICAgICAgICAgIHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcbiAgICAgICAgICAgIHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcblxuICAgICAgICAgICAgZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBpLCBsLCBjLCBjbCwgZHN0Q29sb3JzLCBzcmNDb2xvcnMsIGNvbG9yO1xuXG4gICAgICAgIGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaENvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgICAgZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXSA9IHt9O1xuICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhDb2xvcnNbIGkgXS5uYW1lO1xuICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XG5cbiAgICAgICAgICBkc3RDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycztcbiAgICAgICAgICBzcmNDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzO1xuXG4gICAgICAgICAgZm9yICggYyA9IDAsIGNsID0gc3JjQ29sb3JzLmxlbmd0aDsgYyA8IGNsOyBjICs9IDMgKSB7XG5cbiAgICAgICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmYWEwMCApO1xuICAgICAgICAgICAgY29sb3Iuc2V0UkdCKCBzcmNDb2xvcnNbIGMgXSwgc3JjQ29sb3JzWyBjICsgMSBdLCBzcmNDb2xvcnNbIGMgKyAyIF0gKTtcbiAgICAgICAgICAgIGRzdENvbG9ycy5wdXNoKCBjb2xvciApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgIHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIG1hdGVyaWFscyA9IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoLCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICAgIGlmICggVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5uZWVkc1RhbmdlbnRzKCBtYXRlcmlhbHMgKSApIHtcblxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgdmFyIGlzTG9hZGluZyA9IGZhbHNlLCBpdGVtc0xvYWRlZCA9IDAsIGl0ZW1zVG90YWwgPSAwO1xuXG4gIHRoaXMub25Mb2FkID0gb25Mb2FkO1xuICB0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuXG4gIHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICBpdGVtc1RvdGFsICsrO1xuXG4gICAgaWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xuXG4gICAgICBpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlzTG9hZGluZyA9IHRydWU7XG5cbiAgfTtcblxuICB0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIGl0ZW1zTG9hZGVkICsrO1xuXG4gICAgaWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuICAgIH1cblxuICAgIGlmICggaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwgKSB7XG5cbiAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHNjb3BlLm9uTG9hZCgpO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxufTtcblxuVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG4gIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICAgIG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICAgIHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplICkgKTtcblxuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cbiAgICBpZiAoIGdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG4gICAgICAgIGdlb21ldHJ5LmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGJvdW5kaW5nU3BoZXJlID0ganNvbi5kYXRhLmJvdW5kaW5nU3BoZXJlO1xuXG4gICAgaWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgaWYgKCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRlcmlhbExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRlcmlhbExvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgICBvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBqc29uLnR5cGUgXTtcblxuICAgIGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XG4gICAgaWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcbiAgICBpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xuICAgIGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xuICAgIGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudW5pZm9ybXMgPSBqc29uLnVuaWZvcm1zO1xuICAgIGlmICgganNvbi5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hdHRyaWJ1dGVzID0ganNvbi5hdHRyaWJ1dGVzO1xuICAgIGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuICAgIGlmICgganNvbi5mcmFnbWVudFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBqc29uLmZyYWdtZW50U2hhZGVyO1xuICAgIGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xuICAgIGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xuICAgIGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xuICAgIGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xuICAgIGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xuICAgIGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xuICAgIGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuICAgIGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xuICAgIGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgLy8gZm9yIFBvaW50Q2xvdWRNYXRlcmlhbFxuICAgIGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuICAgIGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG4gICAgaWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9PYmplY3RMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk9iamVjdExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcbiAgdGhpcy50ZXh0dXJlUGF0aCA9ICcnO1xuXG59O1xuXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXG5cbiAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XG5cbiAgICAgIHRoaXMudGV4dHVyZVBhdGggPSB1cmwuc3Vic3RyaW5nKCAwLCB1cmwubGFzdEluZGV4T2YoICcvJyApICsgMSApO1xuXG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgICBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApLCBvbkxvYWQgKTtcblxuICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICB9LFxuXG4gIHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcblxuICAgIHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuICAgIH0gKTtcblxuICAgIHZhciB0ZXh0dXJlcyAgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xuICAgIHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xuXG4gICAgaWYgKCBqc29uLmltYWdlcyA9PT0gdW5kZWZpbmVkIHx8IGpzb24uaW1hZ2VzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuXG4gIH0sXG5cbiAgcGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG4gICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XG4gICAgICB2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeTtcbiAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XG5cbiAgICAgICAgc3dpdGNoICggZGF0YS50eXBlICkge1xuXG4gICAgICAgICAgY2FzZSAnUGxhbmVHZW9tZXRyeSc6XG4gICAgICAgICAgY2FzZSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFWyBkYXRhLnR5cGUgXShcbiAgICAgICAgICAgICAgZGF0YS53aWR0aCxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50c1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCb3hHZW9tZXRyeSc6XG4gICAgICAgICAgY2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEud2lkdGgsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICBkYXRhLmRlcHRoLFxuICAgICAgICAgICAgICBkYXRhLndpZHRoU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuZGVwdGhTZWdtZW50c1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgZGF0YS5zZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0NpcmNsZUdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLnNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzVG9wLFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1c0JvdHRvbSxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEub3BlbkVuZGVkLFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhU3RhcnQsXG4gICAgICAgICAgICAgIGRhdGEudGhldGFMZW5ndGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnU3BoZXJlR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS5waGlTdGFydCxcbiAgICAgICAgICAgICAgZGF0YS5waGlMZW5ndGgsXG4gICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLnBoaVN0YXJ0LFxuICAgICAgICAgICAgICBkYXRhLnBoaUxlbmd0aCxcbiAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLmRldGFpbFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdJY29zYWhlZHJvbkdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgIGRhdGEuZGV0YWlsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ09jdGFoZWRyb25HZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgIGRhdGEuZGV0YWlsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1RldHJhaGVkcm9uR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUmluZ0dlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUmluZ0dlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLmlubmVyUmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLm91dGVyUmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEucGhpU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEudGhldGFTdGFydCxcbiAgICAgICAgICAgICAgZGF0YS50aGV0YUxlbmd0aFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUb3J1c0dlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXMsXG4gICAgICAgICAgICAgIGRhdGEudHViZSxcbiAgICAgICAgICAgICAgZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS50dWJ1bGFyU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEuYXJjXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLnR1YmUsXG4gICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLnAsXG4gICAgICAgICAgICAgIGRhdGEucSxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTY2FsZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSwgdGhpcy50ZXh0dXJlUGF0aCApLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1RleHRHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS50ZXh0LFxuICAgICAgICAgICAgICBkYXRhLmRhdGFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgIGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBnZW9tZXRyaWVzO1xuXG4gIH0sXG5cbiAgcGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWxzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGdldFRleHR1cmUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcblxuICAgICAgfTtcblxuICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBqc29uWyBpIF07XG4gICAgICAgIHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xuXG4gICAgICAgIG1hdGVyaWFsLnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICAgICAgaWYgKCBkYXRhLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0gZGF0YS5kZXB0aFRlc3Q7XG4gICAgICAgIGlmICggZGF0YS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0gZGF0YS5kZXB0aFdyaXRlO1xuXG4gICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgIGlmICggZGF0YS5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGRhdGEubWFwICk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGRhdGEuYWxwaGFNYXAgKTtcbiAgICAgICAgICBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YS5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZSggZGF0YS5idW1wTWFwICk7XG4gICAgICAgIGlmICggZGF0YS5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGRhdGEuYnVtcFNjYWxlO1xuXG4gICAgICAgIGlmICggZGF0YS5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoIGRhdGEubm9ybWFsTWFwICk7XG4gICAgICAgIGlmICggZGF0YS5ub3JtYWxTY2FsZSApIG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEubm9ybWFsU2NhbGUsIGRhdGEubm9ybWFsU2NhbGUgKTtcblxuICAgICAgICBpZiAoIGRhdGEuc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSggZGF0YS5zcGVjdWxhck1hcCApO1xuXG4gICAgICAgIGlmICggZGF0YS5lbnZNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoIGRhdGEuZW52TWFwICk7XG4gICAgICAgICAgbWF0ZXJpYWwuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGRhdGEucmVmbGVjdGl2aXR5ICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gZGF0YS5yZWZsZWN0aXZpdHk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGRhdGEubGlnaHRNYXAgKTtcbiAgICAgICAgaWYgKCBkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGRhdGEubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgaWYgKCBkYXRhLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IGdldFRleHR1cmUoIGRhdGEuYW9NYXAgKTtcbiAgICAgICAgaWYgKCBkYXRhLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGRhdGEuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICAgICAgbWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IG1hdGVyaWFsO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0ZXJpYWxzO1xuXG4gIH0sXG5cbiAgcGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB2YXIgaW1hZ2VzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcblxuICAgICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggbWFuYWdlciApO1xuICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICAgIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgICAgICB1cmwgPSBzY29wZS50ZXh0dXJlUGF0aCArIHVybDtcblxuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGltYWdlID0ganNvblsgaSBdO1xuICAgICAgICBpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggaW1hZ2UudXJsICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZXM7XG5cbiAgfSxcblxuICBwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlICkge1xuXG4gICAgICBpZiAoIHR5cGVvZiggdmFsdWUgKSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcblxuICAgICAgcmV0dXJuIFRIUkVFWyB2YWx1ZSBdO1xuXG4gICAgfVxuXG4gICAgdmFyIHRleHR1cmVzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xuXG4gICAgICAgIGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcImltYWdlXCIgc3BlY2lmaWVkIGZvcicsIGRhdGEudXVpZCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgdGV4dHVyZS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgIGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcgKTtcbiAgICAgICAgaWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5yZXBlYXRbIDAgXSwgZGF0YS5yZXBlYXRbIDEgXSApO1xuICAgICAgICBpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyICk7XG4gICAgICAgIGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcbiAgICAgICAgaWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBkYXRhLndyYXAgKSApIHtcblxuICAgICAgICAgIHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSApO1xuICAgICAgICAgIHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZXM7XG5cbiAgfSxcblxuICBwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cbiAgICAgIHZhciBvYmplY3Q7XG5cbiAgICAgIHZhciBnZXRHZW9tZXRyeSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgICAgICBpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XG5cbiAgICAgIH07XG5cbiAgICAgIHZhciBnZXRNYXRlcmlhbCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xuXG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgY2FzZSAnU2NlbmUnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBbWJpZW50TGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cblxuICAgICAgICBjYXNlICdBcmVhTGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkFyZWFMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnU3BvdExpZ2h0JzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLmV4cG9uZW50LCBkYXRhLmRlY2F5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ01lc2gnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0xpbmUnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUG9pbnRDbG91ZCc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRDbG91ZCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnU3ByaXRlJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0dyb3VwJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICB9XG5cbiAgICAgIG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICBpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcbiAgICAgICAgbWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XG4gICAgICAgIGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xuICAgICAgICBpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XG4gICAgICBpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cbiAgICAgIGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcbiAgICAgIGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuICAgICAgaWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XG5cbiAgICAgICAgICBvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLmNoaWxkcmVuWyBjaGlsZCBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfVxuXG4gIH0oKVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cbiAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlICk7XG4gICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgfVxuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0JpbmFyeVRleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXG4gKi9cblxuVEhSRUUuRGF0YVRleHR1cmVMb2FkZXIgPSBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG4gIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gIC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG4gIHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn07XG5cblRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgICAgdmFyIHRleERhdGEgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIgKTtcblxuICAgICAgaWYgKCAhIHRleERhdGEgKSByZXR1cm47XG5cbiAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmltYWdlICkge1xuXG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXG4gICAgICB9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG4gICAgICB9XG5cbiAgICAgIHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICAgIHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWFnRmlsdGVyID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG4gICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5mb3JtYXQgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcblxuICAgICAgfVxuICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcblxuICAgICAgICB0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcblxuICAgICAgICB0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xuXG4gICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICB9XG5cbiAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cbiAgICByZXR1cm4gdGV4dHVyZTtcblxuICB9LFxuXG4gIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgLy8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcbiAgdGhpcy5fcGFyc2VyID0gbnVsbDtcblxufTtcblxuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGltYWdlcyA9IFtdO1xuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcbiAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuICAgIGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cbiAgICAgIHZhciBsb2FkZWQgPSAwO1xuXG4gICAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgICAgICAgIHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG4gICAgICAgICAgaW1hZ2VzWyBpIF0gPSB7XG4gICAgICAgICAgICB3aWR0aDogdGV4RGF0YXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcbiAgICAgICAgICAgIGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuICAgICAgICAgICAgbWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsb2FkZWQgKz0gMTtcblxuICAgICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gICAgICAgICAgICBpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcbiAgICAgICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgICB9O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG4gICAgICAgIGxvYWRUZXh0dXJlKCBpICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuXG4gICAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuICAgICAgICBpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcblxuICAgICAgICAgIHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuICAgICAgICAgICAgaW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcblxuICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgICAgICAgIGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgICAgIGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG4gICAgICAgICAgdGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuTWF0ZXJpYWxJZENvdW50ICsrIH0gKTtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuICB0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG4gIHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcblxuICB0aGlzLm9wYWNpdHkgPSAxO1xuICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgdGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG4gIHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3RvcjtcbiAgdGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG4gIHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xuICB0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICB0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xuICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cbiAgdGhpcy5kZXB0aEZ1bmMgPSBUSFJFRS5MZXNzRXF1YWxEZXB0aDtcbiAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuICB0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG4gIHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cbiAgdGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG4gIHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cbiAgdGhpcy5hbHBoYVRlc3QgPSAwO1xuXG4gIHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cbiAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXG5cbiAgZ2V0IG5lZWRzVXBkYXRlICgpIHtcblxuICAgIHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuICB9LFxuXG4gIHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gIH0sXG5cbiAgc2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcblxuICAgIGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuICAgICAgaWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBrZXkgaW4gdGhpcyApIHtcblxuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XG5cbiAgICAgICAgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XG5cbiAgICAgICAgICBjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XG5cbiAgICAgICAgICAvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXG4gICAgICAgICAgdGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICB0eXBlOiAnTWF0ZXJpYWwnLFxuICAgICAgICBnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cbiAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgIGlmICggdGhpcy5jb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gICAgaWYgKCB0aGlzLmVtaXNzaXZlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcbiAgICBpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuICAgIGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cbiAgICBpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMuYWxwaGFNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMubGlnaHRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgIGRhdGEuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcblxuICAgIH1cbiAgICBpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgICAgZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGU7IC8vIFJlbW92ZWQgZm9yIG5vdywgY2F1c2VzIGlzc3VlIGluIGVkaXRvciB1aS5qc1xuXG4gICAgfVxuICAgIGlmICggdGhpcy5zcGVjdWxhck1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgIGlmICggdGhpcy5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG4gICAgICBkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICBkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuICAgIGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cbiAgICBpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcbiAgICBpZiAoIHRoaXMuc2hhZGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2hhZGluZyAhPT0gVEhSRUUuU21vb3RoU2hhZGluZyApIGRhdGEuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcbiAgICBpZiAoIHRoaXMuYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuICAgIGlmICggdGhpcy5zaWRlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cbiAgICBpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG4gICAgaWYgKCB0aGlzLmFscGhhVGVzdCA+IDAgKSBkYXRhLmFscGhhVGVzdCA9IHRoaXMuYWxwaGFUZXN0O1xuICAgIGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICAgIGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cbiAgICB0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcblxuICAgIHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XG5cbiAgICB0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xuXG4gICAgdGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcbiAgICB0aGlzLmJsZW5kRHN0ID0gc291cmNlLmJsZW5kRHN0O1xuICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xuICAgIHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuICAgIHRoaXMuYmxlbmREc3RBbHBoYSA9IHNvdXJjZS5ibGVuZERzdEFscGhhO1xuICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcblxuICAgIHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcbiAgICB0aGlzLmRlcHRoVGVzdCA9IHNvdXJjZS5kZXB0aFRlc3Q7XG4gICAgdGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IHNvdXJjZS5wcmVjaXNpb247XG5cbiAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcbiAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3RvcjtcbiAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cbiAgICB0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XG5cbiAgICB0aGlzLm92ZXJkcmF3ID0gc291cmNlLm92ZXJkcmF3O1xuXG4gICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICd1cGRhdGUnIH0gKTtcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLk1hdGVyaWFsSWRDb3VudCA9IDA7XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXG4gKiAgbGluZWpvaW46IFwicm91bmRcIixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gIHRoaXMubGluZXdpZHRoID0gMTtcbiAgdGhpcy5saW5lY2FwID0gJ3JvdW5kJztcbiAgdGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gIHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcbiAgdGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XG4gIHRoaXMubGluZWpvaW4gPSBzb3VyY2UubGluZWpvaW47XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVEYXNoZWRNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBzY2FsZTogPGZsb2F0PixcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcbiAqICBnYXBTaXplOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICB0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy5zY2FsZSA9IDE7XG4gIHRoaXMuZGFzaFNpemUgPSAzO1xuICB0aGlzLmdhcFNpemUgPSAxO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XG5cblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgdGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuXG4gIHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XG4gIHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XG4gIHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgdGhpcy5hb01hcCA9IG51bGw7XG4gIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsO1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gIHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gIHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG4gIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cbiAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcblxuICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgdGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblxuICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgdGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gIHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuICB0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gIHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gIHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcbiAgdGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxuICogIHNoaW5pbmVzczogPGZsb2F0PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcbiAqXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG4gIHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XG4gIHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XG4gIHRoaXMuc2hpbmluZXNzID0gMzA7XG5cbiAgdGhpcy5tZXRhbCA9IGZhbHNlO1xuXG4gIHRoaXMubWFwID0gbnVsbDtcblxuICB0aGlzLmxpZ2h0TWFwID0gbnVsbDtcbiAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuICB0aGlzLmFvTWFwID0gbnVsbDtcbiAgdGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICB0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuICB0aGlzLmJ1bXBNYXAgPSBudWxsO1xuICB0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cbiAgdGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuICB0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICB0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICB0aGlzLmVudk1hcCA9IG51bGw7XG4gIHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgdGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcbiAgdGhpcy5zcGVjdWxhci5jb3B5KCBzb3VyY2Uuc3BlY3VsYXIgKTtcbiAgdGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xuXG4gIHRoaXMubWV0YWwgPSBzb3VyY2UubWV0YWw7XG5cbiAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gIHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgdGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuICB0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXG4gIHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuICB0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cbiAgdGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuICB0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG4gIHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cbiAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICB0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG4gIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cbiAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICB0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hEZXB0aE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblxuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbDtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG4gIHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG4gIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTXVsdGlNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTXVsdGlNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xuXG4gIHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxuICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5NdWx0aU1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTXVsdGlNYXRlcmlhbCxcblxuICB0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB2ZXJzaW9uOiA0LjIsXG4gICAgICAgIHR5cGU6ICdtYXRlcmlhbCcsXG4gICAgICAgIGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXG4gICAgICB9LFxuICAgICAgdXVpZDogdGhpcy51dWlkLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgbWF0ZXJpYWxzOiBbXVxuICAgIH07XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBvdXRwdXQubWF0ZXJpYWxzLnB1c2goIHRoaXMubWF0ZXJpYWxzWyBpIF0udG9KU09OKCkgKTtcblxuICAgIH1cblxuICAgIG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICBtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICBtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gIH1cblxufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IFRIUkVFLk11bHRpTWF0ZXJpYWw7XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9Qb2ludENsb3VkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc2l6ZTogPGZsb2F0PixcbiAqICBzaXplQXR0ZW51YXRpb246IDxib29sPixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZE1hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG4gIHRoaXMubWFwID0gbnVsbDtcblxuICB0aGlzLnNpemUgPSAxO1xuICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbDtcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgdGhpcy5zaXplID0gc291cmNlLnNpemU7XG4gIHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLicgKTtcbiAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLicgKTtcbiAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcbiAqXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBsaWdodHM6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cbiAgdGhpcy5kZWZpbmVzID0ge307XG4gIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG5cbiAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59JztcbiAgdGhpcy5mcmFnbWVudFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxufSc7XG5cbiAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICB0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gIHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXG5cbiAgdGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXG5cbiAgdGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXG5cbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXG4gIHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xuXG4gIHRoaXMuZGVyaXZhdGl2ZXMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xuXG4gIC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxuICAvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXG4gIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcbiAgICAnY29sb3InOiBbIDEsIDEsIDEgXSxcbiAgICAndXYnOiBbIDAsIDAgXSxcbiAgICAndXYyJzogWyAwLCAwIF1cbiAgfTtcblxuICB0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyApID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMuJyApO1xuICAgICAgcGFyYW1ldGVycy5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcbiAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xuXG4gIHRoaXMudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcblxuICB0aGlzLmF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcbiAgdGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XG5cbiAgdGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gIHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgdGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblxuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gIHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICBkYXRhLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gIGRhdGEudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG4gIGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUmF3U2hhZGVyTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLlNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICB0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuXG59O1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsO1xuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Nwcml0ZU1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgdXZPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gKiAgdXZTY2FsZTogbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgdGhpcy5mb2cgPSBmYWxzZTtcblxuICAvLyBzZXQgcGFyYW1ldGVyc1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlTWF0ZXJpYWw7XG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gIHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cbiAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLlRleHR1cmVJZENvdW50ICsrIH0gKTtcblxuICB0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuICB0aGlzLnNvdXJjZUZpbGUgPSAnJztcblxuICB0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xuICB0aGlzLm1pcG1hcHMgPSBbXTtcblxuICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cbiAgdGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gIHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gIHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG4gIHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgdGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cbiAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XG4gIHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG4gIHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcbiAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcbiAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG4gIHRoaXMuZmxpcFkgPSB0cnVlO1xuICB0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG4gIHRoaXMudmVyc2lvbiA9IDA7XG4gIHRoaXMub25VcGRhdGUgPSBudWxsO1xuXG59O1xuXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFRIUkVFLlVWTWFwcGluZztcblxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXG5cbiAgc2V0IG5lZWRzVXBkYXRlICggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgdGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcbiAgICB0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG4gICAgdGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cbiAgICB0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuICAgIHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cbiAgICB0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG4gICAgdGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cbiAgICB0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG4gICAgdGhpcy50eXBlID0gc291cmNlLnR5cGU7XG5cbiAgICB0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XG4gICAgdGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xuICAgIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuICAgIHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG4gICAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSBzb3VyY2UudW5wYWNrQWxpZ25tZW50O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgcmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0YVVSTCggaW1hZ2UgKSB7XG5cbiAgICAgIHZhciBjYW52YXM7XG5cbiAgICAgIGlmICggaW1hZ2UudG9EYXRhVVJMICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY2FudmFzID0gaW1hZ2U7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xuXG4gICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICB0eXBlOiAnVGV4dHVyZScsXG4gICAgICAgIGdlbmVyYXRvcjogJ1RleHR1cmUudG9KU09OJ1xuICAgICAgfSxcblxuICAgICAgdXVpZDogdGhpcy51dWlkLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuXG4gICAgICBtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cbiAgICAgIHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXG4gICAgICBvZmZzZXQ6IFsgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSBdLFxuICAgICAgd3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cbiAgICAgIG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxuICAgICAgYW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5XG4gICAgfTtcblxuICAgIGlmICggdGhpcy5pbWFnZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAgIGlmICggaW1hZ2UudXVpZCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGltYWdlLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xuICAgICAgICAgIHV1aWQ6IGltYWdlLnV1aWQsXG4gICAgICAgICAgdXJsOiBnZXREYXRhVVJMKCBpbWFnZSApXG4gICAgICAgIH07XG5cbiAgICAgIH1cblxuICAgICAgb3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcblxuICAgIH1cblxuICAgIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdID0gb3V0cHV0O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVGV4dHVyZUlkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DYW52YXNUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DYW52YXNUZXh0dXJlID0gZnVuY3Rpb24gKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLkNhbnZhc1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkNhbnZhc1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FudmFzVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN1YmVUZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICBtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZztcblxuICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gIHRoaXMuZmxpcFkgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVUZXh0dXJlO1xuXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5pbWFnZXMgPSBzb3VyY2UuaW1hZ2VzO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ29tcHJlc3NlZFRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24gKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XG5cbiAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICB0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gIHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG5cbiAgLy8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcbiAgLy8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuICB0aGlzLmZsaXBZID0gZmFsc2U7XG5cbiAgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cbiAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiAoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuICBUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gIHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxufTtcblxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRhdGFUZXh0dXJlO1xuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVmlkZW9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5WaWRlb1RleHR1cmUgPSBmdW5jdGlvbiAoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xuXG4gICAgaWYgKCB2aWRlby5yZWFkeVN0YXRlID09PSB2aWRlby5IQVZFX0VOT1VHSF9EQVRBICkge1xuXG4gICAgICBzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgfTtcblxuICB1cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmlkZW9UZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0dyb3VwJztcblxufTtcblxuVEhSRUUuR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcbi8vIEZpbGU6c3JjL29iamVjdHMvUG9pbnRDbG91ZC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZCc7XG5cbiAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRDbG91ZDtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgdmFyIG9iamVjdCA9IHRoaXM7XG4gICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICAgIHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50Q2xvdWQudGhyZXNob2xkO1xuXG4gICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcbiAgICB2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciB0ZXN0UG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCBpbmRleCApIHtcblxuICAgICAgdmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcblxuICAgICAgaWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xuICAgICAgICBpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICBkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxuICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgIG9iamVjdDogb2JqZWN0XG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgaWYgKCBhdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5LmRyYXdjYWxscztcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgZ2VvbWV0cnkuYWRkRHJhd0NhbGwoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBvaSA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG9pIDwgb2w7ICsrIG9pICkge1xuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbIG9pIF07XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQuc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0LmNvdW50O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXG4gICAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblxuICAgICAgICAgICAgdGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcblxuICAgICAgICAgIHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTigpO1xuXG4gIH1cblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG5cbiAgfVxuXG4gIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGVTeXN0ZW0gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50Q2xvdWQuJyApO1xuICByZXR1cm4gbmV3IFRIUkVFLlBvaW50Q2xvdWQoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxpbmUgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcblxuICBpZiAoIG1vZGUgPT09IDEgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTGluZTogVEhSRUUuTGluZVBpZWNlcyBtb2RlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XG5cbiAgfVxuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTGluZSc7XG5cbiAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG59O1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XG4gICAgdmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgc3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgaWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICB2YXIgdlN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGludGVyUmF5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyAyIDogMTtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5LmRyYXdjYWxscztcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgZ2VvbWV0cnkuYWRkRHJhd0NhbGwoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBvaSA9IDA7IG9pIDwgb2Zmc2V0cy5sZW5ndGg7IG9pICsrICkge1xuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbIG9pIF07XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQuc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0LmNvdW50O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQgLSAxOyBpICs9IHN0ZXAgKSB7XG5cbiAgICAgICAgICAgIHZhciBhID0gaW5kaWNlc1sgaSBdO1xuICAgICAgICAgICAgdmFyIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuXG4gICAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgICAgICAgICB2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXG4gICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgb2Zmc2V0SW5kZXg6IG9pLFxuICAgICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgICAgdlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSApO1xuICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xuXG4gICAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICAgIHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPSB0aGlzLmdlb21ldHJ5LnRvSlNPTigpO1xuXG4gIH1cblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG5cbiAgfVxuXG4gIGRhdGEub2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuICBkYXRhLm9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gREVQUkVDQVRFRFxuXG5USFJFRS5MaW5lU3RyaXAgPSAwO1xuVEhSRUUuTGluZVBpZWNlcyA9IDE7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGluZVNlZ21lbnRzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lU2VnbWVudHMgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG59O1xuXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lU2VnbWVudHM7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cbiAqL1xuXG5USFJFRS5NZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdNZXNoJztcblxuICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cbiAgdGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaDtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuXG4gIGlmICggdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtIDE7XG4gICAgdGhpcy5tb3JwaFRhcmdldEZvcmNlZE9yZGVyID0gW107XG4gICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcbiAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG4gICAgZm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIG0gXS5uYW1lIF0gPSBtO1xuXG4gICAgfVxuXG4gIH1cblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICBpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHJldHVybiB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdO1xuXG4gIH1cblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcblxuICByZXR1cm4gMDtcblxufTtcblxuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuICB2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgdmFyIHRlbXBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHRlbXBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG4gICAgaWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICBzcGhlcmUuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHtcblxuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcblxuICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICBpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgYSwgYiwgYztcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5LmRyYXdjYWxscztcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgZ2VvbWV0cnkuYWRkRHJhd0NhbGwoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBvaSA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG9pIDwgb2w7ICsrIG9pICkge1xuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbIG9pIF07XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQuc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0LmNvdW50O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgYSA9IGluZGljZXNbIGkgXTtcbiAgICAgICAgICAgIGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuICAgICAgICAgICAgYyA9IGluZGljZXNbIGkgKyAyIF07XG5cbiAgICAgICAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuICAgICAgICAgICAgdkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG4gICAgICAgICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZDLCB2QiwgdkEsIHRydWUgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvblBvaW50ID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG4gICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICAgICAgICBmYWNlOiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICksXG4gICAgICAgICAgICAgIGZhY2VJbmRleDogTWF0aC5mbG9vciggaSAvIDMgKSwgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xuICAgICAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XG5cbiAgICAgICAgICB2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgIHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuICAgICAgICAgIHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xuXG4gICAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uUG9pbnQgPT09IG51bGwgKSBjb250aW51ZTtcblxuICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgIGEgPSBpIC8gMztcbiAgICAgICAgICBiID0gYSArIDE7XG4gICAgICAgICAgYyA9IGEgKyAyO1xuXG4gICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcbiAgICAgICAgICAgIGZhY2U6IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKSxcbiAgICAgICAgICAgIGluZGV4OiBhLCAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3NcbiAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgfSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgdmFyIGlzRmFjZU1hdGVyaWFsID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xuICAgICAgdmFyIG1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcblxuICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblxuICAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGYgXTtcbiAgICAgICAgdmFyIGZhY2VNYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xuXG4gICAgICAgIGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuICAgICAgICBhID0gdmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgICBiID0gdmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgICBjID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgIGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG4gICAgICAgICAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgICAgICAgdkEuc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgdkIuc2V0KCAwLCAwLCAwICk7XG4gICAgICAgICAgdkMuc2V0KCAwLCAwLCAwICk7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xuXG4gICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XG5cbiAgICAgICAgICAgIGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XG5cbiAgICAgICAgICAgIHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGEgKSwgaW5mbHVlbmNlICk7XG4gICAgICAgICAgICB2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBiICksIGluZmx1ZW5jZSApO1xuICAgICAgICAgICAgdkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgYyApLCBpbmZsdWVuY2UgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZBLmFkZCggYSApO1xuICAgICAgICAgIHZCLmFkZCggYiApO1xuICAgICAgICAgIHZDLmFkZCggYyApO1xuXG4gICAgICAgICAgYSA9IHZBO1xuICAgICAgICAgIGIgPSB2QjtcbiAgICAgICAgICBjID0gdkM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZmFjZU1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBjLCBiLCBhLCB0cnVlICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYSwgYiwgYywgZmFjZU1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcbiAgICAgICAgICBmYWNlOiBmYWNlLFxuICAgICAgICAgIGZhY2VJbmRleDogZixcbiAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICB9ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5NZXNoLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBnZW9tZXRyaWVzIGNhY2hlXG4gIGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCBtZXRhICk7XG5cbiAgfVxuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oIG1ldGEgKTtcblxuICB9XG5cbiAgZGF0YS5vYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XG4gIGRhdGEub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0JvbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdCb25lJztcblxuICB0aGlzLnNraW4gPSBza2luO1xuXG59O1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgdGhpcy5za2luID0gc291cmNlLnNraW47XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbiA9IGZ1bmN0aW9uICggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICB0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcblxuICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAvLyBjb3B5IHRoZSBib25lIGFycmF5XG5cbiAgYm9uZXMgPSBib25lcyB8fCBbXTtcblxuICB0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblxuICAvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXG5cbiAgaWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICAvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG4gICAgLy8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuICAgIC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG4gICAgLy8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG4gICAgLy8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG4gICAgLy8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblxuICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxuICAgIHNpemUgPSBUSFJFRS5NYXRoLm5leHRQb3dlck9mVHdvKCBNYXRoLmNlaWwoIHNpemUgKSApO1xuICAgIHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xuXG4gICAgdGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcbiAgICB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcblxuICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lVGV4dHVyZVdpZHRoICogdGhpcy5ib25lVGV4dHVyZUhlaWdodCAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcbiAgICB0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcbiAgICB0aGlzLmJvbmVUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgdGhpcy5ib25lVGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRoaXMuYm9uZVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgdGhpcy5ib25lVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcblxuICB9XG5cbiAgLy8gdXNlIHRoZSBzdXBwbGllZCBib25lIGludmVyc2VzIG9yIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZXNcblxuICBpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgdGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xuXG4gICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcy5zbGljZSggMCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XG5cbiAgICAgIHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBUSFJFRS5NYXRyaXg0KCkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNhbGN1bGF0ZUludmVyc2VzID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cbiAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICB2YXIgaW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICBpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcblxuICAgICAgaW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgKTtcblxuICAgIH1cblxuICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBib25lO1xuXG4gIC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG4gIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuICAgIGlmICggYm9uZSApIHtcblxuICAgICAgYm9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXG5cbiAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICBib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG4gICAgaWYgKCBib25lICkge1xuXG4gICAgICBpZiAoIGJvbmUucGFyZW50ICkge1xuXG4gICAgICAgIGJvbmUubWF0cml4LmdldEludmVyc2UoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYm9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICB9XG5cbiAgICAgIGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG9mZnNldE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICAgIC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG4gICAgICBvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG4gICAgICBvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICB0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICB9O1xuXG59ICkoKTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cbiAgdGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcbiAgdGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgLy8gaW5pdCBib25lc1xuXG4gIC8vIFRPRE86IHJlbW92ZSBib25lIGNyZWF0aW9uIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiAob3RoZXIgdGhhblxuICAvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXG5cbiAgdmFyIGJvbmVzID0gW107XG5cbiAgaWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHZhciBib25lLCBnYm9uZTtcblxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArKyBiICkge1xuXG4gICAgICBnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuICAgICAgYm9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XG4gICAgICBib25lcy5wdXNoKCBib25lICk7XG5cbiAgICAgIGJvbmUubmFtZSA9IGdib25lLm5hbWU7XG4gICAgICBib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XG4gICAgICBib25lLnF1YXRlcm5pb24uZnJvbUFycmF5KCBnYm9uZS5yb3RxICk7XG4gICAgICBpZiAoIGdib25lLnNjbCAhPT0gdW5kZWZpbmVkICkgYm9uZS5zY2FsZS5mcm9tQXJyYXkoIGdib25lLnNjbCApO1xuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cbiAgICAgIGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgICBpZiAoIGdib25lLnBhcmVudCAhPT0gLSAxICkge1xuXG4gICAgICAgIGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG4gIHRoaXMuYmluZCggbmV3IFRIUkVFLlNrZWxldG9uKCBib25lcywgdW5kZWZpbmVkLCB1c2VWZXJ0ZXhUZXh0dXJlICksIHRoaXMubWF0cml4V29ybGQgKTtcblxufTtcblxuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tpbm5lZE1lc2g7XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG4gIHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuICBpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuICAgIGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG4gIH1cblxuICB0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5ub3JtYWxpemVTa2luV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XG5cbiAgICAgIHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xuXG4gICAgICBpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuICAgICAgICBzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdy5zZXQoIDEgKTsgLy8gdGhpcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYnkgdGhlIHNoYWRlciBhbnl3YXlcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICAvLyBza2lubmluZyB3ZWlnaHRzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBmb3IgVEhSRUUuQnVmZmVyR2VvbWV0cnlcblxuICB9XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcblxuICBUSFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cbiAgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XG5cbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICB9IGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImRldGFjaGVkXCIgKSB7XG5cbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaCB1bnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Nb3JwaEFuaW1NZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICB0aGlzLnR5cGUgPSAnTW9ycGhBbmltTWVzaCc7XG5cbiAgLy8gQVBJXG5cbiAgdGhpcy5kdXJhdGlvbiA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICB0aGlzLm1pcnJvcmVkTG9vcCA9IGZhbHNlO1xuICB0aGlzLnRpbWUgPSAwO1xuXG4gIC8vIGludGVybmFsc1xuXG4gIHRoaXMubGFzdEtleWZyYW1lID0gMDtcbiAgdGhpcy5jdXJyZW50S2V5ZnJhbWUgPSAwO1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gMTtcbiAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICB0aGlzLnNldEZyYW1lUmFuZ2UoIDAsIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggLSAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhBbmltTWVzaDtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RnJhbWVSYW5nZSA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuICB0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcbiAgdGhpcy5lbmRLZXlmcmFtZSA9IGVuZDtcblxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gMTtcbiAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5kaXJlY3Rpb24gPSAtIDE7XG4gIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgaWYgKCAhIGdlb21ldHJ5LmFuaW1hdGlvbnMgKSBnZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cbiAgdmFyIGZpcnN0QW5pbWF0aW9uLCBhbmltYXRpb25zID0gZ2VvbWV0cnkuYW5pbWF0aW9ucztcblxuICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG4gICAgdmFyIHBhcnRzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG4gICAgaWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG4gICAgICB2YXIgbGFiZWwgPSBwYXJ0c1sgMSBdO1xuXG4gICAgICBpZiAoICEgYW5pbWF0aW9uc1sgbGFiZWwgXSApIGFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cbiAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zWyBsYWJlbCBdO1xuXG4gICAgICBpZiAoIGkgPCBhbmltYXRpb24uc3RhcnQgKSBhbmltYXRpb24uc3RhcnQgPSBpO1xuICAgICAgaWYgKCBpID4gYW5pbWF0aW9uLmVuZCApIGFuaW1hdGlvbi5lbmQgPSBpO1xuXG4gICAgICBpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IGxhYmVsO1xuXG4gICAgfVxuXG4gIH1cblxuICBnZW9tZXRyeS5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25MYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwsIHN0YXJ0LCBlbmQgKSB7XG5cbiAgaWYgKCAhIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyApIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xuXG4gIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBsYWJlbCwgZnBzICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbIGxhYmVsIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICB0aGlzLnNldEZyYW1lUmFuZ2UoIGFuaW1hdGlvbi5zdGFydCwgYW5pbWF0aW9uLmVuZCApO1xuICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwICogKCAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGZwcyApO1xuICAgIHRoaXMudGltZSA9IDA7XG5cbiAgfSBlbHNlIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1vcnBoQW5pbU1lc2g6IGFuaW1hdGlvblsnICsgbGFiZWwgKyAnXSB1bmRlZmluZWQgaW4gLnBsYXlBbmltYXRpb24oKScgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgdmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmxlbmd0aDtcblxuICB0aGlzLnRpbWUgKz0gdGhpcy5kaXJlY3Rpb24gKiBkZWx0YTtcblxuICBpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xuXG4gICAgaWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMudGltZSA8IDAgKSB7XG5cbiAgICAgIHRoaXMuZGlyZWN0aW9uICo9IC0gMTtcblxuICAgICAgaWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMudGltZSA8IDAgKSB7XG5cbiAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLnRpbWUgPSB0aGlzLnRpbWUgJSB0aGlzLmR1cmF0aW9uO1xuXG4gICAgaWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XG5cbiAgfVxuXG4gIHZhciBrZXlmcmFtZSA9IHRoaXMuc3RhcnRLZXlmcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIHRoaXMudGltZSAvIGZyYW1lVGltZSApLCAwLCB0aGlzLmxlbmd0aCAtIDEgKTtcblxuICB2YXIgaW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gIGlmICgga2V5ZnJhbWUgIT09IHRoaXMuY3VycmVudEtleWZyYW1lICkge1xuXG4gICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDA7XG4gICAgaW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XG4gICAgaW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cbiAgICB0aGlzLmxhc3RLZXlmcmFtZSA9IHRoaXMuY3VycmVudEtleWZyYW1lO1xuICAgIHRoaXMuY3VycmVudEtleWZyYW1lID0ga2V5ZnJhbWU7XG5cbiAgfVxuXG4gIHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG4gIGlmICggdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgKSB7XG5cbiAgICBtaXggPSAxIC0gbWl4O1xuXG4gIH1cblxuICBpbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRLZXlmcmFtZSBdID0gbWl4O1xuICBpbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMSAtIG1peDtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuaW50ZXJwb2xhdGVUYXJnZXRzID0gZnVuY3Rpb24gKCBhLCBiLCB0ICkge1xuXG4gIHZhciBpbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgaW5mbHVlbmNlc1sgaSBdID0gMDtcblxuICB9XG5cbiAgaWYgKCBhID4gLSAxICkgaW5mbHVlbmNlc1sgYSBdID0gMSAtIHQ7XG4gIGlmICggYiA+IC0gMSApIGluZmx1ZW5jZXNbIGIgXSA9IHQ7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLmR1cmF0aW9uID0gc291cmNlLmR1cmF0aW9uO1xuICB0aGlzLm1pcnJvcmVkTG9vcCA9IHNvdXJjZS5taXJyb3JlZExvb3A7XG4gIHRoaXMudGltZSA9IHNvdXJjZS50aW1lO1xuXG4gIHRoaXMubGFzdEtleWZyYW1lID0gc291cmNlLmxhc3RLZXlmcmFtZTtcbiAgdGhpcy5jdXJyZW50S2V5ZnJhbWUgPSBzb3VyY2UuY3VycmVudEtleWZyYW1lO1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gc291cmNlLmRpcmVjdGlvbjtcbiAgdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBzb3VyY2UuZGlyZWN0aW9uQmFja3dhcmRzO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgbGV2ZWxzOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IFtdXG4gICAgfSxcbiAgICBvYmplY3RzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVscztcblxuICAgICAgfVxuICAgIH1cbiAgfSApO1xuXG59O1xuXG5cblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XG5cbiAgaWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuXG4gIGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cbiAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gIGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XG5cbiAgICBpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgfVxuXG4gIH1cblxuICBsZXZlbHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xuXG4gIHRoaXMuYWRkKCBvYmplY3QgKTtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5nZXRPYmplY3RGb3JEaXN0YW5jZSA9IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cbiAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gIGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgaWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xuXG4gICAgICBicmVhaztcblxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIGxldmVsc1sgaSAtIDEgXS5vYmplY3Q7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcblxuICAgIHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgaWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICAgIHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICB2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xuXG4gICAgICBsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBmb3IgKCA7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG59KCk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgZmFsc2UgKTtcblxuICB2YXIgbGV2ZWxzID0gc291cmNlLmxldmVscztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xuXG4gICAgdGhpcy5hZGRMZXZlbCggbGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlICk7XG5cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1Nwcml0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDIsICAwLCAyLCAzIF0gKTtcbiAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtIDAuNSwgLSAwLjUsIDAsICAgMC41LCAtIDAuNSwgMCwgICAwLjUsIDAuNSwgMCwgICAtIDAuNSwgMC41LCAwIF0gKTtcbiAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgMCwgMCwgICAxLCAwLCAgIDEsIDEsICAgMCwgMSBdICk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuICByZXR1cm4gZnVuY3Rpb24gU3ByaXRlKCBtYXRlcmlhbCApIHtcblxuICAgIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG4gICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XG5cbiAgfTtcblxufSApKCk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGU7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgdmFyIGRpc3RhbmNlU3EgPSByYXljYXN0ZXIucmF5LmRpc3RhbmNlU3FUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuICAgIHZhciBndWVzc1NpemVTcSA9IHRoaXMuc2NhbGUueCAqIHRoaXMuc2NhbGUueTtcblxuICAgIGlmICggZGlzdGFuY2VTcSA+IGd1ZXNzU2l6ZVNxICkge1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgZGlzdGFuY2U6IE1hdGguc3FydCggZGlzdGFuY2VTcSApLFxuICAgICAgcG9pbnQ6IHRoaXMucG9zaXRpb24sXG4gICAgICBmYWNlOiBudWxsLFxuICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICB9ICk7XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID0gdGhpcy5tYXRlcmlhbC50b0pTT04oKTtcblxuICB9XG5cbiAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlID0gVEhSRUUuU3ByaXRlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5sZW5zRmxhcmVzID0gW107XG5cbiAgdGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICB0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxlbnNGbGFyZTtcblxuXG4vKlxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuICBpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XG4gIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcbiAgaWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcbiAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG4gIGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cbiAgZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cbiAgdGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcbiAgICB0ZXh0dXJlOiB0ZXh0dXJlLCAvLyBUSFJFRS5UZXh0dXJlXG4gICAgc2l6ZTogc2l6ZSwgICAgIC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZSwgICAvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG4gICAgeDogMCwgeTogMCwgejogMCwgLy8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXG4gICAgc2NhbGU6IDEsICAgICAvLyBzY2FsZVxuICAgIHJvdGF0aW9uOiAwLCAgICAvLyByb3RhdGlvblxuICAgIG9wYWNpdHk6IG9wYWNpdHksIC8vIG9wYWNpdHlcbiAgICBjb2xvcjogY29sb3IsICAgLy8gY29sb3JcbiAgICBibGVuZGluZzogYmxlbmRpbmcgIC8vIGJsZW5kaW5nXG4gIH0gKTtcblxufTtcblxuLypcbiAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcbiAgdmFyIGZsYXJlO1xuICB2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcbiAgdmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XG5cbiAgZm9yICggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XG5cbiAgICBmbGFyZS54ID0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICsgdmVjWCAqIGZsYXJlLmRpc3RhbmNlO1xuICAgIGZsYXJlLnkgPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKyB2ZWNZICogZmxhcmUuZGlzdGFuY2U7XG5cbiAgICBmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcbiAgICBmbGFyZS5yb3RhdGlvbiArPSAoIGZsYXJlLndhbnRlZFJvdGF0aW9uIC0gZmxhcmUucm90YXRpb24gKSAqIDAuMjU7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICB0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xuICB0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gc291cmNlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrO1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICB0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xuXG4gIH1cblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL1NjZW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZSA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1NjZW5lJztcblxuICB0aGlzLmZvZyA9IG51bGw7XG4gIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cbiAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxufTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICBpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcbiAgaWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cbiAgdGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRm9nID0gZnVuY3Rpb24gKCBjb2xvciwgbmVhciwgZmFyICkge1xuXG4gIHRoaXMubmFtZSA9ICcnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cbiAgdGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xuICB0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XG5cbn07XG5cblRIUkVFLkZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZ0V4cDIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2dFeHAyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVuc2l0eSApIHtcblxuICB0aGlzLm5hbWUgPSAnJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuICB0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XG5cbn07XG5cblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rLmpzXG5cblRIUkVFLlNoYWRlckNodW5rID0ge307XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuICBkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhdGVzdF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGF0ZXN0X2ZyYWdtZW50J10gPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cXG4gIGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcbiAgdG90YWxBbWJpZW50TGlnaHQgKj0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXG4gIHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2J1bXBtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYnVtcG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcbiAgdW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuICAvLyBEZXJpdmF0aXZlIG1hcHMgLSBidW1wIG1hcHBpbmcgdW5wYXJhbWV0cml6ZWQgc3VyZmFjZXMgYnkgTW9ydGVuIE1pa2tlbHNlblxcbiAvLyBodHRwOi8vbW1pa2tlbHNlbjNkLmJsb2dzcG90LnNrLzIwMTEvMDcvZGVyaXZhdGl2ZS1tYXBzLmh0bWxcXG5cXG4gLy8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXFxuXFxuIHZlYzIgZEhkeHlfZndkKCkge1xcblxcbiAgICB2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuICAgdmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcbiAgIGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG4gICAgZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuICAgIGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcbiAgICByZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG4gIH1cXG5cXG4gdmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXG4gICAgdmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG4gICAgdmVjMyB2U2lnbWFZID0gZEZkeSggc3VyZl9wb3MgKTtcXG4gICAgdmVjMyB2TiA9IHN1cmZfbm9ybTsgICAgLy8gbm9ybWFsaXplZFxcblxcbiAgIHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG4gICB2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuICAgZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXG4gICAgdmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxuICAgIHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXG4gIH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gIGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcbiAgdkNvbG9yLnh5eiA9IGNvbG9yLnh5ejtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29tbW9uLmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb21tb24nXSA9IFwiI2RlZmluZSBQSSAzLjE0MTU5XFxuI2RlZmluZSBQSTIgNi4yODMxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuXFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXG4gIHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKSApLnh5eiApO1xcblxcbn1cXG5cXG4vLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0dMU0xfUHJvZ3JhbW1pbmcvQXBwbHlpbmdfTWF0cml4X1RyYW5zZm9ybWF0aW9uc1xcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcbiAgcmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBub3JtYWwsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxuXFxufVxcblxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuICBmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFxuICByZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxuXFxufVxcblxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG4gIHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxuXFxufVxcblxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcbiByZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxuXFxufVxcblxcbmZsb2F0IGNhbGNMaWdodEF0dGVudWF0aW9uKCBmbG9hdCBsaWdodERpc3RhbmNlLCBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXG4gaWYgKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcblxcbiAgICByZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuXFxuIH1cXG5cXG4gcmV0dXJuIDEuMDtcXG5cXG59XFxuXFxudmVjMyBGX1NjaGxpY2soIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgZG90TEggKSB7XFxuXFxuIHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90TEgsIDUuMCApICsgc3BlY3VsYXJDb2xvcjtcXG5cXG59XFxuXFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBpbiBmbG9hdCBkb3ROTCwgaW4gZmxvYXQgZG90TlYgKi8gKSB7XFxuXFxuIC8vIGdlb21ldHJ5IHRlcm0gaXMgKG7ii4VsKShu4ouFdikgLyA0KG7ii4VsKShu4ouFdilcXG5cXG4gIHJldHVybiAwLjI1O1xcblxcbn1cXG5cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gZmxvYXQgZG90TkggKSB7XFxuXFxuIC8vIGZhY3RvciBvZiAxL1BJIGluIGRpc3RyaWJ1dGlvbiB0ZXJtIG9taXR0ZWRcXG5cXG4gIHJldHVybiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxuXFxufVxcblxcbnZlYzMgQlJERl9CbGlublBob25nKCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgbGlnaHREaXIsIGluIHZlYzMgdmlld0RpciApIHtcXG5cXG4gIHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFxuIC8vZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG4gIC8vZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcbiBmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuIGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggbGlnaHREaXIsIGhhbGZEaXIgKSApO1xcblxcbiB2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFxuIGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGRvdE5MLCBkb3ROViAqLyApO1xcblxcbiAgZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcbiByZXR1cm4gRiAqIEcgKiBEO1xcblxcbn1cXG5cXG52ZWMzIGlucHV0VG9MaW5lYXIoIGluIHZlYzMgYSApIHtcXG5cXG4gI2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuICAgIHJldHVybiBwb3coIGEsIHZlYzMoIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuICNlbHNlXFxuXFxuICAgcmV0dXJuIGE7XFxuXFxuICNlbmRpZlxcblxcbn1cXG5cXG52ZWMzIGxpbmVhclRvT3V0cHV0KCBpbiB2ZWMzIGEgKSB7XFxuXFxuICNpZmRlZiBHQU1NQV9PVVRQVVRcXG5cXG4gICByZXR1cm4gcG93KCBhLCB2ZWMzKCAxLjAgLyBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcblxcbiAjZWxzZVxcblxcbiAgIHJldHVybiBhO1xcblxcbiAjZW5kaWZcXG5cXG59XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApXFxuXFxuIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiNlbHNlXFxuXFxuICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdG5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gdmVjMyBvYmplY3ROb3JtYWwgPSBza2lubmVkTm9ybWFsLnh5ejtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfTU9SUEhOT1JNQUxTIClcXG5cXG4gdmVjMyBvYmplY3ROb3JtYWwgPSBtb3JwaGVkTm9ybWFsO1xcblxcbiNlbHNlXFxuXFxuIHZlYzMgb2JqZWN0Tm9ybWFsID0gbm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBGTElQX1NJREVEXFxuXFxuICBvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFxuICB2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXG4gZW1pc3NpdmVDb2xvci5yZ2IgPSBpbnB1dFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yLnJnYiApO1xcblxcbiB0b3RhbEVtaXNzaXZlTGlnaHQgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG4gICNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuICAgIHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG4gICAvLyBUcmFuc2Zvcm1pbmcgTm9ybWFsIFZlY3RvcnMgd2l0aCB0aGUgSW52ZXJzZSBUcmFuc2Zvcm1hdGlvblxcbiAgICB2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuICAgI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG4gICAgIHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcbiAgICNlbHNlXFxuXFxuICAgICB2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcbiAgICAjZW5kaWZcXG5cXG4gICNlbHNlXFxuXFxuICAgdmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFxuICNlbmRpZlxcblxcbiAgI2lmZGVmIERPVUJMRV9TSURFRFxcbiAgIGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuICNlbHNlXFxuICAgZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG4gI2VuZGlmXFxuXFxuICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcbiAgIHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuICNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcbiAgICB2ZWMyIHNhbXBsZVVWO1xcbiAgICBzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG4gICBzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuICAgdmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcbiAgI2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXG4gICB2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSgodmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApKS54eXogKyB2ZWMzKDAuMCwwLjAsMS4wKSk7XFxuICAgIHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG4gICNlbmRpZlxcblxcbiAgZW52Q29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggZW52Q29sb3IueHl6ICk7XFxuXFxuICNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXG4gICBvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuICAjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXG4gICAgb3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuICAjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXG4gICAgb3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcbiAgI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcbiB1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG4gI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG4gICB1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG4gI2Vsc2VcXG4gICB1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuICNlbmRpZlxcbiAgdW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcbiAjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcbiAgICB1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4gICNlbHNlXFxuXFxuICAgdmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcbiAgI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcbiB2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuICB1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG4gIHZlYzMgd29ybGROb3JtYWwgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIG9iamVjdE5vcm1hbCwgbW9kZWxNYXRyaXggKTtcXG5cXG4gdmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcbiAgI2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG4gICB2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcbiAgI2Vsc2VcXG5cXG4gICB2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcbiAgI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG4gICAgZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG4gI2Vsc2VcXG5cXG4gICBmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuICAjZW5kaWZcXG5cXG4gICNpZmRlZiBGT0dfRVhQMlxcblxcbiAgIGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICkgKTtcXG5cXG4gICNlbHNlXFxuXFxuICAgZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcblxcbiAjZW5kaWZcXG4gIFxcbiAgb3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG4gdW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcbiAgI2lmZGVmIEZPR19FWFAyXFxuXFxuICAgdW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcbiAjZWxzZVxcblxcbiAgIHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG4gICAgdW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuICNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcbiAgdG90YWxBbWJpZW50TGlnaHQgKz0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuIHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleCddID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcbiAgdW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfbGFtYmVydF92ZXJ0ZXgnXSA9IFwidkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICB2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcbiAgIHZlYzMgbGlnaHRDb2xvciA9IHBvaW50TGlnaHRDb2xvclsgaSBdO1xcblxcbiAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG4gICB2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XFxuICAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG4gICAvLyBhdHRlbnVhdGlvblxcblxcbiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuICAgLy8gZGlmZnVzZVxcblxcbiAgICBmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuICAgdkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICAgICB2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAgI2VuZGlmXFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gIGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICAgdmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICAgdmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG4gICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggbGlnaHRQb3NpdGlvbiwgMS4wICk7XFxuICAgdmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1xcbiAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuICAgZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIG5vcm1hbGl6ZSggbGlnaHRQb3NpdGlvbiAtIHdvcmxkUG9zaXRpb24ueHl6ICkgKTtcXG5cXG4gICAgaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG4gICAgICBzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApICk7XFxuXFxuICAgICAvLyBhdHRlbnVhdGlvblxcblxcbiAgICAgIGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuICAgICBhdHRlbnVhdGlvbiAqPSBzcG90RWZmZWN0O1xcblxcbiAgICAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgICBmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuICAgICB2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggZG90UHJvZHVjdCApO1xcblxcbiAgICAgI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgICAgICB2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAgICAjZW5kaWZcXG5cXG4gICAgfVxcblxcbiB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbiBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICB2ZWMzIGxpZ2h0RGlyID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIHZpZXdNYXRyaXggKTtcXG5cXG4gICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG4gICB2TGlnaHRGcm9udCArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICAgICB2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuICAgICNlbmRpZlxcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgIHZlYzMgbGlnaHREaXIgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCB2aWV3TWF0cml4ICk7XFxuXFxuICAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcbiAgIGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG4gICB2TGlnaHRGcm9udCArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuICAgI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgICAgZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcbiAgICAgdkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcbiAgICAjZW5kaWZcXG5cXG4gIH1cXG5cXG4jZW5kaWZcXG5cXG52TGlnaHRGcm9udCArPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuIHZMaWdodEJhY2sgKz0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50J10gPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG4gIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFxuICNpZmRlZiBET1VCTEVfU0lERURcXG5cXG4gICBub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcbiAjZW5kaWZcXG5cXG4jZWxzZVxcblxcbiB2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcXG4gdmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7XFxuIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuIG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcbiBub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcbnZlYzMgdG90YWxEaWZmdXNlTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHRvdGFsU3BlY3VsYXJMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICB2ZWMzIGxpZ2h0UG9zaXRpb24gPSBwb2ludExpZ2h0UG9zaXRpb25bIGkgXTtcXG4gICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBsaWdodFBvc2l0aW9uLCAxLjAgKTtcXG4gICB2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcbiAgIC8vIGF0dGVudWF0aW9uXFxuXFxuICAgIGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG4gICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG4gICB0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcbiAgIC8vIHNwZWN1bGFyXFxuXFxuICAgdmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuICAgIHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gIGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICAgdmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICAgdmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG4gICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggbGlnaHRQb3NpdGlvbiwgMS4wICk7XFxuICAgdmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1xcbiAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG4gICBmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBsaWdodFBvc2l0aW9uIC0gdldvcmxkUG9zaXRpb24gKSApO1xcblxcbiAgIGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuICAgICAgc3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcbiAgICAgLy8gYXR0ZW51YXRpb25cXG5cXG4gICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcbiAgICAgYXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG4gICAgICAvLyBkaWZmdXNlXFxuXFxuICAgICAgZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcbiAgICAgdG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG4gICAgIC8vIHNwZWN1bGFyXFxuXFxuICAgICB2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG4gICAgICB0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcbiAgICB9XFxuXFxuIH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuIGZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgIHZlYzMgbGlnaHRDb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdO1xcblxcbiAgIHZlYzMgbGlnaHREaXIgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcbiAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcbiAgIHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcbiAgIC8vIHNwZWN1bGFyXFxuXFxuICAgdmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuICAgIHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuICBmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0RGlyID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcbiAgICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG4gICBmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuICAgdmVjMyBsaWdodENvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcbiAgICB0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yO1xcblxcbiAgICAvLyBzcGVjdWxhciAoc2t5IHRlcm0gb25seSlcXG5cXG4gICB2ZWMzIGJyZGYgPSBCUkRGX0JsaW5uUGhvbmcoIHNwZWN1bGFyLCBzaGluaW5lc3MsIG5vcm1hbCwgbGlnaHREaXIsIHZpZXdEaXIgKTtcXG5cXG4gICAgdG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1FVEFMXFxuXFxuIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICogc3BlY3VsYXIgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XFxuXFxuI2Vsc2VcXG5cXG4gIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQnXSA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG4gdW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG4gIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuICB1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuICB1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuIHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuICB1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHREZWNheVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcbiAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcbiAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcbiB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpbmVhcl90b19nYW1tYV9mcmFnbWVudCddID0gXCJcXG4gIG91dGdvaW5nTGlnaHQgPSBsaW5lYXJUb091dHB1dCggb3V0Z29pbmdMaWdodCApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuICBnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuIHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG4gICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuICAgIHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG4gI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuICAgIHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG4gI2VuZGlmXFxuXFxuICB1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG4gIGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFxuICAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcbiAgICB2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXG4jZWxzZVxcblxcbiAgICBnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cXG4gICNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcbiAgdmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcbiAgdGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblxcbiBkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG4gZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcbiAgdW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG4gdmVjMyBtb3JwaGVkTm9ybWFsID0gdmVjMyggMC4wICk7XFxuXFxuIG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcbiAgbW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuICBtb3JwaGVkTm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG4gIG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcbiAgbW9ycGhlZE5vcm1hbCArPSBub3JtYWw7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcbiAgI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuICB1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcbiAjZWxzZVxcblxcbiB1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcbiAjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG4gdmVjMyBtb3JwaGVkID0gdmVjMyggMC4wICk7XFxuIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuICBtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuICAjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuICBtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuICAjZW5kaWZcXG5cXG4gIG1vcnBoZWQgKz0gcG9zaXRpb247XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuICB1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuIC8vIFBlci1QaXhlbCBUYW5nZW50IFNwYWNlIE5vcm1hbCBNYXBwaW5nXFxuIC8vIGh0dHA6Ly9oYWNrc29mbGlmZS5ibG9nc3BvdC5jaC8yMDA5LzExL3Blci1waXhlbC10YW5nZW50LXNwYWNlLW5vcm1hbC1tYXBwaW5nLmh0bWxcXG5cXG4gdmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXG4gICAgdmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuICAgIHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xcbiAgICB2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcbiAgICB2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcbiAgICB2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxuICAgIHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuICAgdmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG4gICAgdmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG4gICAgbWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG4gICAgbWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuICAgcmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcbiB9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuICAjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuICAgIHZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcXG4gICAgZnJ1c3R1bUNvbG9yc1swXSA9IHZlYzMoIDEuMCwgMC41LCAwLjAgKTtcXG4gICBmcnVzdHVtQ29sb3JzWzFdID0gdmVjMyggMC4wLCAxLjAsIDAuOCApO1xcbiAgIGZydXN0dW1Db2xvcnNbMl0gPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XFxuXFxuICNlbmRpZlxcblxcbiAgZmxvYXQgZkRlcHRoO1xcbiB2ZWMzIHNoYWRvd0NvbG9yID0gdmVjMyggMS4wICk7XFxuXFxuIGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuICAgdmVjMyBzaGFkb3dDb29yZCA9IHZTaGFkb3dDb29yZFsgaSBdLnh5eiAvIHZTaGFkb3dDb29yZFsgaSBdLnc7XFxuXFxuICAgICAgIC8vIGlmICggc29tZXRoaW5nICYmIHNvbWV0aGluZyApIGJyZWFrcyBBVEkgT3BlbkdMIHNoYWRlciBjb21waWxlclxcbiAgICAgICAgLy8gaWYgKCBhbGwoIHNvbWV0aGluZywgc29tZXRoaW5nICkgKSB1c2luZyB0aGlzIGluc3RlYWRcXG5cXG4gICAgYnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcbiAgICBib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFxuICAgYnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcbiAgICBib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcbiAgIGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFxuICAgICAgc2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XFxuXFxuICAgICAjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXG4gICAgICAgICAgIC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXFxuICAgICAgICAgICAvLyAoOSBwaXhlbCBrZXJuZWwpXFxuICAgICAgICAgICAvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuICAgICAgICBmbG9hdCBzaGFkb3cgPSAwLjA7XFxuXFxuICAgLypcXG4gICAgICAgICAgICAvLyBuZXN0ZWQgbG9vcHMgYnJlYWtzIHNoYWRlciBjb21waWxlciAvIHZhbGlkYXRvciBvbiBzb21lIEFUSSBjYXJkcyB3aGVuIHVzaW5nIE9wZW5HTFxcbiAgICAgICAgICAgIC8vIG11c3QgZW5yb2xsIGxvb3AgbWFudWFsbHlcXG5cXG4gICAgICAgIGZvciAoIGZsb2F0IHkgPSAtMS4yNTsgeSA8PSAxLjI1OyB5ICs9IDEuMjUgKVxcbiAgICAgICAgIGZvciAoIGZsb2F0IHggPSAtMS4yNTsgeCA8PSAxLjI1OyB4ICs9IDEuMjUgKSB7XFxuXFxuICAgICAgICAgICB2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3Qgc2VlbSB0byBwcm9kdWNlIGFueSBub3RpY2VhYmxlIHZpc3VhbCBkaWZmZXJlbmNlIGNvbXBhcmVkIHRvIHNpbXBsZSB0ZXh0dXJlMkQgbG9va3VwXFxuICAgICAgICAgICAgICAgLy92ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRFByb2ooIHNoYWRvd01hcFsgaSBdLCB2ZWM0KCB2U2hhZG93Q29vcmRbIGkgXS53ICogKCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApLCAwLjA1LCB2U2hhZG93Q29vcmRbIGkgXS53ICkgKTtcXG5cXG4gICAgICAgICAgIGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG4gICAgICAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcbiAgICAgICAgICAgICBzaGFkb3cgKz0gMS4wO1xcblxcbiAgICAgICAgfVxcblxcbiAgICAgICBzaGFkb3cgLz0gOS4wO1xcblxcbiAgICAqL1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgc2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuXFxuICAgICAgICBmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG4gICAgICAgIGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcbiAgICAgICAgZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuICAgICAgIGZsb2F0IGR5MCA9IC0xLjI1ICogeVBpeGVsT2Zmc2V0O1xcbiAgICAgICBmbG9hdCBkeDEgPSAxLjI1ICogeFBpeGVsT2Zmc2V0O1xcbiAgICAgICAgZmxvYXQgZHkxID0gMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcbiAgICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1xcblxcbiAgICAgI2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcbiAgICAgICAgICAgIC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXFxuICAgICAgICAgICAvLyAoOSBwaXhlbCBrZXJuZWwpXFxuICAgICAgICAgICAvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuICAgICAgICBmbG9hdCBzaGFkb3cgPSAwLjA7XFxuXFxuICAgICAgIGZsb2F0IHhQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS54O1xcbiAgICAgICAgZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuXFxuICAgICAgICBmbG9hdCBkeDAgPSAtMS4wICogeFBpeGVsT2Zmc2V0O1xcbiAgICAgICAgZmxvYXQgZHkwID0gLTEuMCAqIHlQaXhlbE9mZnNldDtcXG4gICAgICAgIGZsb2F0IGR4MSA9IDEuMCAqIHhQaXhlbE9mZnNldDtcXG4gICAgICAgZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcbiAgICAgICBtYXQzIHNoYWRvd0tlcm5lbDtcXG4gICAgICAgIG1hdDMgZGVwdGhLZXJuZWw7XFxuXFxuICAgICAgIGRlcHRoS2VybmVsWzBdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFswXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMF1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzFdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFsxXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuICAgICAgIGRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFsyXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMl1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuICAgICAgICB2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XFxuICAgICAgIHNoYWRvd0tlcm5lbFswXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMF0sIHNoYWRvd1ogKSk7XFxuICAgICAgIHNoYWRvd0tlcm5lbFswXSAqPSB2ZWMzKDAuMjUpO1xcblxcbiAgICAgICAgc2hhZG93S2VybmVsWzFdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFsxXSwgc2hhZG93WiApKTtcXG4gICAgICAgc2hhZG93S2VybmVsWzFdICo9IHZlYzMoMC4yNSk7XFxuXFxuICAgICAgICBzaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1xcbiAgICAgICBzaGFkb3dLZXJuZWxbMl0gKj0gdmVjMygwLjI1KTtcXG5cXG4gICAgICAgIHZlYzIgZnJhY3Rpb25hbENvb3JkID0gMS4wIC0gZnJhY3QoIHNoYWRvd0Nvb3JkLnh5ICogc2hhZG93TWFwU2l6ZVtpXS54eSApO1xcblxcbiAgICAgICBzaGFkb3dLZXJuZWxbMF0gPSBtaXgoIHNoYWRvd0tlcm5lbFsxXSwgc2hhZG93S2VybmVsWzBdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcbiAgICAgICBzaGFkb3dLZXJuZWxbMV0gPSBtaXgoIHNoYWRvd0tlcm5lbFsyXSwgc2hhZG93S2VybmVsWzFdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblxcbiAgICAgICB2ZWM0IHNoYWRvd1ZhbHVlcztcXG4gICAgICAgIHNoYWRvd1ZhbHVlcy54ID0gbWl4KCBzaGFkb3dLZXJuZWxbMF1bMV0sIHNoYWRvd0tlcm5lbFswXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG4gICAgICAgIHNoYWRvd1ZhbHVlcy55ID0gbWl4KCBzaGFkb3dLZXJuZWxbMF1bMl0sIHNoYWRvd0tlcm5lbFswXVsxXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG4gICAgICAgIHNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMV0sIHNoYWRvd0tlcm5lbFsxXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG4gICAgICAgIHNoYWRvd1ZhbHVlcy53ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMl0sIHNoYWRvd0tlcm5lbFsxXVsxXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXG4gICAgICAgIHNoYWRvdyA9IGRvdCggc2hhZG93VmFsdWVzLCB2ZWM0KCAxLjAgKSApO1xcblxcbiAgICAgICAgc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuXFxuICAgICAjZWxzZVxcblxcbiAgICAgICB2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuICAgICAgIGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG4gICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXFxuICAgLy8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaXMgZGFya2VyXFxuXFxuICAgICAgICAgc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG4gICAgLy8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaGFzIHRoZSBzYW1lIGNvbG9yIGFzIHNpbmdsZSBzaGFkb3cgc3BvdFxcblxcbiAgICAvLyAgICAgICAgICBzaGFkb3dDb2xvciA9IG1pbiggc2hhZG93Q29sb3IsIHZlYzMoIHNoYWRvd0RhcmtuZXNzWyBpIF0gKSApO1xcblxcbiAgICAgICNlbmRpZlxcblxcbiAgICB9XFxuXFxuXFxuICAgI2lmZGVmIFNIQURPV01BUF9ERUJVR1xcblxcbiAgICAgIGlmICggaW5GcnVzdHVtICkgb3V0Z29pbmdMaWdodCAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuICAgI2VuZGlmXFxuXFxuICB9XFxuXFxuIG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hhZG93Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dNYXBbIE1BWF9TSEFET1dTIF07XFxuIHVuaWZvcm0gdmVjMiBzaGFkb3dNYXBTaXplWyBNQVhfU0hBRE9XUyBdO1xcblxcbiAgdW5pZm9ybSBmbG9hdCBzaGFkb3dEYXJrbmVzc1sgTUFYX1NIQURPV1MgXTtcXG4gIHVuaWZvcm0gZmxvYXQgc2hhZG93Qmlhc1sgTUFYX1NIQURPV1MgXTtcXG5cXG4gIHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuXFxuIGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuICAgY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcbiAgICBmbG9hdCBkZXB0aCA9IGRvdCggcmdiYV9kZXB0aCwgYml0X3NoaWZ0ICk7XFxuICAgcmV0dXJuIGRlcHRoO1xcblxcbiB9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuIHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuIHVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gIGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuICAgdlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFxuICB9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5iYXNlX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbmJhc2VfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gIG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcbiBtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG4gbWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuIG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ19wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiB1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG4gIHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXG4gI2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcbiAgIHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcbiAgICB1bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1xcbiAgIHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcblxcbiAgICBtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuICAgICAgZmxvYXQgaiA9IGkgKiA0LjA7XFxuICAgICAgZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcbiAgICAgIGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXG4gICAgIGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG4gICAgIGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlSGVpZ2h0ICk7XFxuXFxuICAgICAgeSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFxuICAgICB2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG4gICAgICB2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuICAgICAgbWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG4gICAgIHJldHVybiBib25lO1xcblxcbiAgICB9XFxuXFxuICNlbHNlXFxuXFxuICAgdW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuICAgbWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcbiAgICAgIG1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XFxuICAgICByZXR1cm4gYm9uZTtcXG5cXG4gICAgfVxcblxcbiAjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG4gdmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiAgI2Vsc2VcXG5cXG4gdmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXG4gI2VuZGlmXFxuXFxuICB2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG4gc2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuICBza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG4gIHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcbiAgc2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuICBza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5ub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gIG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcbiAgc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG4gIHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuICBza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcbiAgc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG4gIHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXG4gICNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuIHZlYzQgc2tpbm5lZE5vcm1hbCA9IHNraW5NYXRyaXggKiB2ZWM0KCBtb3JwaGVkTm9ybWFsLCAwLjAgKTtcXG5cXG4gI2Vsc2VcXG5cXG4gdmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICk7XFxuXFxuICAjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50J10gPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcbiB2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG4gc3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG5cXG4jZWxzZVxcblxcbiAgc3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuICB2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuICBhdHRyaWJ1dGUgdmVjMiB1djI7XFxuIHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcbiB2VXYyID0gdXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG4gdmFyeWluZyB2ZWMyIHZVdjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG4gdmFyeWluZyB2ZWMyIHZVdjtcXG4gdW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcbiAgdlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3dvcmxkcG9zX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnd29ybGRwb3NfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcblxcbiAjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1xcblxcbiAjZWxpZiBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcXG5cXG4gICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiAgI2Vsc2VcXG5cXG4gICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXG4gI2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zVXRpbHMuanNcblxuLyoqXG4gKiBVbmlmb3JtIFV0aWxpdGllc1xuICovXG5cblRIUkVFLlVuaWZvcm1zVXRpbHMgPSB7XG5cbiAgbWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XG5cbiAgICB2YXIgbWVyZ2VkID0ge307XG5cbiAgICBmb3IgKCB2YXIgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XG5cbiAgICAgIHZhciB0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XG5cbiAgICAgIGZvciAoIHZhciBwIGluIHRtcCApIHtcblxuICAgICAgICBtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xuXG4gICAgdmFyIHVuaWZvcm1zX2RzdCA9IHt9O1xuXG4gICAgZm9yICggdmFyIHUgaW4gdW5pZm9ybXNfc3JjICkge1xuXG4gICAgICB1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xuXG4gICAgICBmb3IgKCB2YXIgcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcblxuICAgICAgICB2YXIgcGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XG5cbiAgICAgICAgaWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcbiAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgfHxcbiAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgfHxcbiAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcbiAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDMgfHxcbiAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgfHxcbiAgICAgICAgICAgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cbiAgICAgICAgICB1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHBhcmFtZXRlcl9zcmMgKSApIHtcblxuICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zX2RzdDtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zTGliLmpzXG5cbi8qKlxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcbiAqL1xuXG5USFJFRS5Vbmlmb3Jtc0xpYiA9IHtcblxuICBjb21tb246IHtcblxuICAgIFwiZGlmZnVzZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxuICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXG4gICAgXCJtYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJvZmZzZXRSZXBlYXRcIiA6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9LFxuXG4gICAgXCJzcGVjdWxhck1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcImFscGhhTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG4gICAgXCJlbnZNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJmbGlwRW52TWFwXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0sXG4gICAgXCJyZWZsZWN0aXZpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcbiAgICBcInJlZnJhY3Rpb25SYXRpb1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfVxuXG4gIH0sXG5cbiAgYW9tYXA6IHtcblxuICAgIFwiYW9NYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJhb01hcEludGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuICB9LFxuXG4gIGxpZ2h0bWFwOiB7XG5cbiAgICBcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwibGlnaHRNYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cbiAgfSxcblxuICBlbWlzc2l2ZW1hcDoge1xuXG4gICAgXCJlbWlzc2l2ZU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuICB9LFxuXG4gIGJ1bXA6IHtcblxuICAgIFwiYnVtcE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcImJ1bXBTY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfVxuXG4gIH0sXG5cbiAgbm9ybWFsbWFwOiB7XG5cbiAgICBcIm5vcm1hbE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcIm5vcm1hbFNjYWxlXCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxuICB9LFxuXG4gIGZvZyA6IHtcblxuICAgIFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcbiAgICBcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgXCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXG4gICAgXCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XG5cbiAgfSxcblxuICBsaWdodHM6IHtcblxuICAgIFwiYW1iaWVudExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblxuICAgIFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwiZGlyZWN0aW9uYWxMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwiaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcbiAgICBcImhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInBvaW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwicG9pbnRMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJwb2ludExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJwb2ludExpZ2h0RGVjYXlcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInNwb3RMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwic3BvdExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHREaXN0YW5jZVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNwb3RMaWdodEFuZ2xlQ29zXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuICAgIFwic3BvdExpZ2h0RXhwb25lbnRcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHREZWNheVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfVxuXG4gIH0sXG5cbiAgcGFydGljbGU6IHtcblxuICAgIFwicHNDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxuICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuICAgIFwic2l6ZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuICAgIFwic2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcbiAgICBcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cbiAgICBcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXG4gICAgXCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgIFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxuICAgIFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxuXG4gIH0sXG5cbiAgc2hhZG93bWFwOiB7XG5cbiAgICBcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzaGFkb3dNYXBTaXplXCI6IHsgdHlwZTogXCJ2MnZcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInNoYWRvd0JpYXNcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzaGFkb3dEYXJrbmVzc1wiOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXG4gICAgXCJzaGFkb3dNYXRyaXhcIiA6IHsgdHlwZTogXCJtNHZcIiwgdmFsdWU6IFtdIH1cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qc1xuXG4vKipcbiAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5cblRIUkVFLlNoYWRlckxpYiA9IHtcblxuICAnYmFzaWMnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuICAgIF0gKSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuICAgICAgXCIgI2lmZGVmIFVTRV9FTlZNQVBcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgXCIgI2VuZGlmXCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG4gICAgICBcIiB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcbiAgICAgIFwiIHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSB2ZWMzKCAxLjAgKTtcIiwgLy8gaGFyZHdpcmVkXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogdG90YWxBbWJpZW50TGlnaHQ7XCIsIC8vIHNpbXBsZSBzaGFkZXJcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLCAgICAvLyBUT0RPOiBTaGFkb3dzIG9uIGFuIG90aGVyd2lzZSB1bmxpdCBzdXJmYWNlIGRvZXNuJ3QgbWFrZSBzZW5zZS5cblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gIH0sXG5cbiAgJ2xhbWJlcnQnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG4gICAgICB7XG4gICAgICAgIFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfVxuICAgICAgfVxuXG4gICAgXSApLFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwiI2RlZmluZSBMQU1CRVJUXCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG4gICAgICBcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgXCIgdmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXG5cbiAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuICAgICAgXCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cbiAgICAgIFwiIHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG4gICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLCAvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXG4gICAgICBcIiB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiICNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgXCIgICBpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcbiAgICAgIFwiICAgICBvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiB2TGlnaHRGcm9udCArIGVtaXNzaXZlO1wiLFxuICAgICAgXCIgICBlbHNlXCIsXG4gICAgICBcIiAgICAgb3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0QmFjayArIGVtaXNzaXZlO1wiLFxuXG4gICAgICBcIiAjZWxzZVwiLFxuXG4gICAgICBcIiAgIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqIHZMaWdodEZyb250ICsgZW1pc3NpdmU7XCIsXG5cbiAgICAgIFwiICNlbmRpZlwiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKCBcIlxcblwiIClcblxuICB9LFxuXG4gICdwaG9uZyc6IHtcblxuICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodG1hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cbiAgICAgIHtcbiAgICAgICAgXCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9LFxuICAgICAgICBcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXG4gICAgICAgIFwic2hpbmluZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAzMCB9XG4gICAgICB9XG5cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXG5cbiAgICAgIFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxuXG4gICAgICBcIiB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiNpZm5kZWYgRkxBVF9TSEFERURcIiwgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxuXG4gICAgICBcIiB2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxuXG4gICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCIgdlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCIjZGVmaW5lIFBIT05HXCIsXG5cbiAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcbiAgICAgIFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiB2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcbiAgICAgIFwiIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuICAgICAgXCIgdmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodENvbG9yO1wiLFxuICAgICAgXCIgdmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgfSxcblxuICAncGFydGljbGVfYmFzaWMnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwYXJ0aWNsZVwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXG5cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNpemU7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgIFwiICNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXG4gICAgICBcIiAgIGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXG4gICAgICBcIiAjZWxzZVwiLFxuICAgICAgXCIgICBnbF9Qb2ludFNpemUgPSBzaXplO1wiLFxuICAgICAgXCIgI2VuZGlmXCIsXG5cbiAgICAgIFwiIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSB2ZWMzIHBzQ29sb3I7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiB2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcbiAgICAgIFwiIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggcHNDb2xvciwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIiwgLy8gc2ltcGxlIHNoYWRlclxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gIH0sXG5cbiAgJ2Rhc2hlZCc6IHtcblxuICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXG4gICAgICB7XG4gICAgICAgIFwic2NhbGVcIiAgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgIFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgIFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cbiAgICAgIH1cblxuICAgIF0gKSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG4gICAgICBcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIiB2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXG5cbiAgICAgIFwiIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcbiAgICAgIFwiIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxuXG4gICAgICBcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiBpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcblxuICAgICAgXCIgICBkaXNjYXJkO1wiLFxuXG4gICAgICBcIiB9XCIsXG5cbiAgICAgIFwiIHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuICAgICAgXCIgdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgfSxcblxuICAnZGVwdGgnOiB7XG5cbiAgICB1bmlmb3Jtczoge1xuXG4gICAgICBcIm1OZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcbiAgICAgIFwibUZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAuMCB9LFxuICAgICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuICAgIH0sXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gZmxvYXQgbU5lYXI7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgbUZhcjtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuICAgICAgXCIgICBmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1wiLFxuXG4gICAgICBcIiAjZWxzZVwiLFxuXG4gICAgICBcIiAgIGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcblxuICAgICAgXCIgI2VuZGlmXCIsXG5cbiAgICAgIFwiIGZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XCIsXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBjb2xvciApLCBvcGFjaXR5ICk7XCIsXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gIH0sXG5cbiAgJ25vcm1hbCc6IHtcblxuICAgIHVuaWZvcm1zOiB7XG5cbiAgICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cbiAgICB9LFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiB2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgICAgXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gIH0sXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAgQ3ViZSBtYXAgc2hhZGVyXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgJ2N1YmUnOiB7XG5cbiAgICB1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgXCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuICAgICAgXCIgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKCBcIlxcblwiIClcblxuICB9LFxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gIEN1YmUgbWFwIHNoYWRlclxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICdlcXVpcmVjdCc6IHtcblxuICAgIHVuaWZvcm1zOiB7IFwidEVxdWlyZWN0XCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgXCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuICAgICAgXCIgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAvLyBcIiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcbiAgICAgICAgXCJ2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcIixcbiAgICAgICAgXCJ2ZWMyIHNhbXBsZVVWO1wiLFxuICAgICAgICBcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcbiAgICAgICAgXCJzYW1wbGVVVi54ID0gYXRhbiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcIixcbiAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gIH0sXG5cbiAgLyogRGVwdGggZW5jb2RpbmcgaW50byBSR0JBIHRleHR1cmVcbiAgICpcbiAgICogYmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXG4gICAqIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxuICAgKlxuICAgKiBvcmlnaW5hbGx5IGZyb21cbiAgICogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcbiAgICpcbiAgICogc2VlIGFsc29cbiAgICogaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXG4gICAqL1xuXG4gICdkZXB0aFJHQkEnOiB7XG5cbiAgICB1bmlmb3Jtczoge30sXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKCBcIlxcblwiICksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcblxuICAgICAgXCIgY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcIixcbiAgICAgIFwiIGNvbnN0IHZlYzQgYml0X21hc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcbiAgICAgIFwiIHZlYzQgcmVzID0gbW9kKCBkZXB0aCAqIGJpdF9zaGlmdCAqIHZlYzQoIDI1NSApLCB2ZWM0KCAyNTYgKSApIC8gdmVjNCggMjU1ICk7XCIsIC8vIFwiICB2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdF9zaGlmdCApO1wiLFxuICAgICAgXCIgcmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXG4gICAgICBcIiByZXR1cm4gcmVzO1wiLFxuXG4gICAgICBcIn1cIixcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxuXG4gICAgICBcIiAgIGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnRGVwdGhFWFQgKTtcIixcblxuICAgICAgXCIgI2Vsc2VcIixcblxuICAgICAgXCIgICBnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogKTtcIixcblxuICAgICAgXCIgI2VuZGlmXCIsXG5cbiAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICk7XCIsXG4gICAgICAgIC8vXCJmbG9hdCB6ID0gKCAoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKSAtIDMuMCApIC8gKCA0MDAwLjAgLSAzLjAgKTtcIixcbiAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXG4gICAgICAgIC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gdmVjNCggeiwgeiwgeiwgMS4wICk7XCIsXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xuXG4gIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gIHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcbiAgX2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cbiAgX3dpZHRoID0gX2NhbnZhcy53aWR0aCxcbiAgX2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXG4gIHBpeGVsUmF0aW8gPSAxLFxuXG4gIF9wcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnLFxuXG4gIF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiBmYWxzZSxcbiAgX2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG4gIF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxuICBfYW50aWFsaWFzID0gcGFyYW1ldGVycy5hbnRpYWxpYXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYW50aWFsaWFzIDogZmFsc2UsXG4gIF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuICBfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXG4gIF9sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBmYWxzZSxcblxuICBfY2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSxcbiAgX2NsZWFyQWxwaGEgPSAwO1xuXG4gIHZhciBsaWdodHMgPSBbXTtcblxuICB2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xuICB2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XG5cbiAgdmFyIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHMgPSBbXTtcbiAgdmFyIHRyYW5zcGFyZW50SW1tZWRpYXRlT2JqZWN0cyA9IFtdO1xuXG4gIHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XG5cbiAgdmFyIHNwcml0ZXMgPSBbXTtcbiAgdmFyIGxlbnNGbGFyZXMgPSBbXTtcblxuICAvLyBwdWJsaWMgcHJvcGVydGllc1xuXG4gIHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgLy8gY2xlYXJpbmdcblxuICB0aGlzLmF1dG9DbGVhciA9IHRydWU7XG4gIHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuICB0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcbiAgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcblxuICAvLyBzY2VuZSBncmFwaFxuXG4gIHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG4gIC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG4gIHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7IC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICB0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcbiAgdGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xuXG4gIC8vIG1vcnBoc1xuXG4gIHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcbiAgdGhpcy5tYXhNb3JwaE5vcm1hbHMgPSA0O1xuXG4gIC8vIGZsYWdzXG5cbiAgdGhpcy5hdXRvU2NhbGVDdWJlbWFwcyA9IHRydWU7XG5cbiAgLy8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG4gIHZhciBfdGhpcyA9IHRoaXMsXG5cbiAgX3Byb2dyYW1zID0gW10sXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcblxuICBfY3VycmVudFByb2dyYW0gPSBudWxsLFxuICBfY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbCxcbiAgX2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxuICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxuICBfY3VycmVudENhbWVyYSA9IG51bGwsXG5cbiAgX3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxuXG4gIF92aWV3cG9ydFggPSAwLFxuICBfdmlld3BvcnRZID0gMCxcbiAgX3ZpZXdwb3J0V2lkdGggPSBfY2FudmFzLndpZHRoLFxuICBfdmlld3BvcnRIZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcbiAgX2N1cnJlbnRXaWR0aCA9IDAsXG4gIF9jdXJyZW50SGVpZ2h0ID0gMCxcblxuICAvLyBmcnVzdHVtXG5cbiAgX2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxuXG4gICAvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcblxuICBfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cbiAgX3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gIC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG4gIF9kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gIF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcblxuICBfbGlnaHRzID0ge1xuXG4gICAgYW1iaWVudDogWyAwLCAwLCAwIF0sXG4gICAgZGlyZWN0aW9uYWw6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdIH0sXG4gICAgcG9pbnQ6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdLCBkaXN0YW5jZXM6IFtdLCBkZWNheXM6IFtdIH0sXG4gICAgc3BvdDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10sIGRpcmVjdGlvbnM6IFtdLCBhbmdsZXNDb3M6IFtdLCBleHBvbmVudHM6IFtdLCBkZWNheXM6IFtdIH0sXG4gICAgaGVtaTogeyBsZW5ndGg6IDAsIHNreUNvbG9yczogW10sIGdyb3VuZENvbG9yczogW10sIHBvc2l0aW9uczogW10gfVxuXG4gIH0sXG5cbiAgLy8gaW5mb1xuXG4gIF9pbmZvTWVtb3J5ID0ge1xuXG4gICAgcHJvZ3JhbXM6IDAsXG4gICAgZ2VvbWV0cmllczogMCxcbiAgICB0ZXh0dXJlczogMFxuXG4gIH0sXG5cbiAgX2luZm9SZW5kZXIgPSB7XG5cbiAgICBjYWxsczogMCxcbiAgICB2ZXJ0aWNlczogMCxcbiAgICBmYWNlczogMCxcbiAgICBwb2ludHM6IDBcblxuICB9O1xuXG4gIHRoaXMuaW5mbyA9IHtcblxuICAgIHJlbmRlcjogX2luZm9SZW5kZXIsXG4gICAgbWVtb3J5OiBfaW5mb01lbW9yeSxcbiAgICBwcm9ncmFtczogX3Byb2dyYW1zXG5cbiAgfTtcblxuICAvLyBpbml0aWFsaXplXG5cbiAgdmFyIF9nbDtcblxuICB0cnkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICBhbHBoYTogX2FscGhhLFxuICAgICAgZGVwdGg6IF9kZXB0aCxcbiAgICAgIHN0ZW5jaWw6IF9zdGVuY2lsLFxuICAgICAgYW50aWFsaWFzOiBfYW50aWFsaWFzLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgfTtcblxuICAgIF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcblxuICAgIGlmICggX2dsID09PSBudWxsICkge1xuXG4gICAgICBpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApICE9PSBudWxsICkge1xuXG4gICAgICAgIHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cbiAgfSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvciApO1xuXG4gIH1cblxuICB2YXIgZXh0ZW5zaW9ucyA9IG5ldyBUSFJFRS5XZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xuXG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XG4gIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuICBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgaWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDQyOTQ5NjcyOTY7XG5cbiAgfVxuXG4gIGlmICggX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cbiAgICBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xuXG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xuICB2YXIgcHJvcGVydGllcyA9IG5ldyBUSFJFRS5XZWJHTFByb3BlcnRpZXMoKTtcbiAgdmFyIG9iamVjdHMgPSBuZXcgVEhSRUUuV2ViR0xPYmplY3RzKCBfZ2wsIHByb3BlcnRpZXMsIHRoaXMuaW5mbyApO1xuXG4gIHZhciBidWZmZXJSZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG4gIHZhciBpbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcblxuICAvL1xuXG4gIGZ1bmN0aW9uIGdsQ2xlYXJDb2xvciggciwgZywgYiwgYSApIHtcblxuICAgIGlmICggX3ByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcblxuICAgICAgciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcblxuICAgIH1cblxuICAgIF9nbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlKCkge1xuXG4gICAgc3RhdGUuaW5pdCgpO1xuXG4gICAgX2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cbiAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0R0xTdGF0ZSgpIHtcblxuICAgIF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG4gICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcbiAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cbiAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBzdGF0ZS5yZXNldCgpO1xuXG4gIH1cblxuICBzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG4gIHRoaXMuY29udGV4dCA9IF9nbDtcbiAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gIC8vIHNoYWRvdyBtYXBcblxuICB2YXIgc2hhZG93TWFwID0gbmV3IFRIUkVFLldlYkdMU2hhZG93TWFwKCB0aGlzLCBsaWdodHMsIG9iamVjdHMgKTtcblxuICB0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblxuICAvLyBHUFUgY2FwYWJpbGl0aWVzXG5cbiAgdmFyIF9tYXhUZXh0dXJlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuICB2YXIgX21heFZlcnRleFRleHR1cmVzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuICB2YXIgX21heFRleHR1cmVTaXplID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9URVhUVVJFX1NJWkUgKTtcbiAgdmFyIF9tYXhDdWJlbWFwU2l6ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XG5cbiAgdmFyIF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gX21heFZlcnRleFRleHR1cmVzID4gMDtcbiAgdmFyIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyA9IF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG4gIHZhciBfc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMgPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgLy9cblxuXG5cbiAgLy9cblxuICB2YXIgX21heFByZWNpc2lvbiA9IHN0YXRlLmdldE1heFByZWNpc2lvbiggX3ByZWNpc2lvbiApO1xuXG4gIGlmICggX21heFByZWNpc2lvbiAhPT0gX3ByZWNpc2lvbiApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgX3ByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgX21heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuICAgIF9wcmVjaXNpb24gPSBfbWF4UHJlY2lzaW9uO1xuXG4gIH1cblxuICAvLyBQbHVnaW5zXG5cbiAgdmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcbiAgdmFyIGxlbnNGbGFyZVBsdWdpbiA9IG5ldyBUSFJFRS5MZW5zRmxhcmVQbHVnaW4oIHRoaXMsIGxlbnNGbGFyZXMgKTtcblxuICAvLyBBUElcblxuICB0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gX2dsO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcblxuICB9O1xuXG4gIHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbG9zZV9jb250ZXh0JyApLmxvc2VDb250ZXh0KCk7XG5cbiAgfTtcblxuICB0aGlzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gX3N1cHBvcnRzVmVydGV4VGV4dHVyZXM7XG5cbiAgfTtcblxuICB0aGlzLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIF9zdXBwb3J0c0luc3RhbmNlZEFycmF5cztcblxuICB9O1xuXG4gIHRoaXMuZ2V0TWF4QW5pc290cm9weSA9ICggZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XG5cbiAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHJldHVybiB2YWx1ZTtcblxuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG4gICAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgICB2YWx1ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgfVxuXG4gIH0gKSgpO1xuXG4gIHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIF9wcmVjaXNpb247XG5cbiAgfTtcblxuICB0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcblxuICB9O1xuXG4gIHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSBwaXhlbFJhdGlvID0gdmFsdWU7XG5cbiAgfTtcblxuICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgIGhlaWdodDogX2hlaWdodFxuICAgIH07XG5cbiAgfTtcblxuICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG4gICAgX3dpZHRoID0gd2lkdGg7XG4gICAgX2hlaWdodCA9IGhlaWdodDtcblxuICAgIF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXG4gICAgaWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XG5cbiAgICAgIF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgfTtcblxuICB0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgX3ZpZXdwb3J0WCA9IHggKiBwaXhlbFJhdGlvO1xuICAgIF92aWV3cG9ydFkgPSB5ICogcGl4ZWxSYXRpbztcblxuICAgIF92aWV3cG9ydFdpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgIF92aWV3cG9ydEhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cbiAgICBfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcblxuICB9O1xuXG4gIHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgIF9nbC5zY2lzc29yKFxuICAgICAgeCAqIHBpeGVsUmF0aW8sXG4gICAgICB5ICogcGl4ZWxSYXRpbyxcbiAgICAgIHdpZHRoICogcGl4ZWxSYXRpbyxcbiAgICAgIGhlaWdodCAqIHBpeGVsUmF0aW9cbiAgICApO1xuXG4gIH07XG5cbiAgdGhpcy5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcblxuICAgIHN0YXRlLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XG5cbiAgfTtcblxuICAvLyBDbGVhcmluZ1xuXG4gIHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfY2xlYXJDb2xvcjtcblxuICB9O1xuXG4gIHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG4gICAgX2NsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xuXG4gICAgX2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xuXG4gICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIF9jbGVhckFscGhhO1xuXG4gIH07XG5cbiAgdGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCBhbHBoYSApIHtcblxuICAgIF9jbGVhckFscGhhID0gYWxwaGE7XG5cbiAgICBnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgfTtcblxuICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cbiAgICB2YXIgYml0cyA9IDA7XG5cbiAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuICAgIGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG4gICAgaWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcblxuICAgIF9nbC5jbGVhciggYml0cyApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2dsLmNsZWFyKCBfZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2dsLmNsZWFyKCBfZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBfZ2wuY2xlYXIoIF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKTtcblxuICB9O1xuXG4gIHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuICAgIHRoaXMuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xuXG4gIH07XG5cbiAgLy8gUmVzZXRcblxuICB0aGlzLnJlc2V0R0xTdGF0ZSA9IHJlc2V0R0xTdGF0ZTtcblxuICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG4gIH07XG5cbiAgLy8gRXZlbnRzXG5cbiAgZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgcmVzZXRHTFN0YXRlKCk7XG4gICAgc2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuICAgIHByb3BlcnRpZXMuY2xlYXIoKTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgdmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cbiAgICB0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgcmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cbiAgICBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xuXG4gIH1cblxuICBmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XG5cbiAgICBtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgfVxuXG4gIC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuICBmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcblxuICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cbiAgICBpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuICAgICAgLy8gY3ViZSB0ZXh0dXJlXG5cbiAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyAyRCB0ZXh0dXJlXG5cbiAgICAgIGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgX2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWxsIHdlYmdsIHByb3BlcnRpZXNcbiAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggdGV4dHVyZSApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIGlmICggISByZW5kZXJUYXJnZXQgfHwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgX2dsLmRlbGV0ZVRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuICAgICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG4gICAgICBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgIH1cblxuICAgIHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuICAgIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cbiAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggbWF0ZXJpYWwgKTtcblxuICB9XG5cblxuICBmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApIHtcblxuICAgIHZhciBwcm9ncmFtID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbS5wcm9ncmFtO1xuXG4gICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBuID0gX3Byb2dyYW1zLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgICAgdmFyIHByb2dyYW1JbmZvID0gX3Byb2dyYW1zWyBpIF07XG5cbiAgICAgIGlmICggcHJvZ3JhbUluZm8ucHJvZ3JhbSA9PT0gcHJvZ3JhbSApIHtcblxuICAgICAgICB2YXIgbmV3UmVmZXJlbmNlQ291bnQgPSAtLSBwcm9ncmFtSW5mby51c2VkVGltZXM7XG5cbiAgICAgICAgaWYgKCBuZXdSZWZlcmVuY2VDb3VudCA9PT0gMCApIHtcblxuICAgICAgICAgIC8vIHRoZSBsYXN0IG1ldGVyaWFsIHRoYXQgaGFzIGJlZW4gdXNpbmcgdGhlIHByb2dyYW0gbGV0XG4gICAgICAgICAgLy8gZ28gb2YgaXQsIHNvIHJlbW92ZSBpdCBmcm9tIHRoZSAodW5vcmRlcmVkKSBfcHJvZ3JhbXNcbiAgICAgICAgICAvLyBzZXQgYW5kIGRlYWxsb2NhdGUgdGhlIEdMIHJlc291cmNlXG5cbiAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gbiAtIDE7XG5cbiAgICAgICAgICBfcHJvZ3JhbXNbIGkgXSA9IF9wcm9ncmFtc1sgbmV3TGVuZ3RoIF07XG4gICAgICAgICAgX3Byb2dyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgX2dsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcblxuICAgICAgICAgIF9pbmZvTWVtb3J5LnByb2dyYW1zID0gbmV3TGVuZ3RoO1xuXG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICAvLyBCdWZmZXIgcmVuZGVyaW5nXG5cbiAgdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cbiAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgdmFyIGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XG5cbiAgICBpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBidWZmZXJzLnV2ICkgYnVmZmVycy51diA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cbiAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XG4gICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG4gICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcblxuICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsICk7XG5cbiAgICAgIGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xuXG4gICAgICAgICAgdmFyIGFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xuXG4gICAgICAgICAgdmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XG4gICAgICAgICAgdmFyIG55ID0gKCBhcnJheVsgaSArIDEgXSArIGFycmF5WyBpICsgNCBdICsgYXJyYXlbIGkgKyA3IF0gKSAvIDM7XG4gICAgICAgICAgdmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XG5cbiAgICAgICAgICBhcnJheVsgaSArIDAgXSA9IG54O1xuICAgICAgICAgIGFycmF5WyBpICsgMSBdID0gbnk7XG4gICAgICAgICAgYXJyYXlbIGkgKyAyIF0gPSBuejtcblxuICAgICAgICAgIGFycmF5WyBpICsgMyBdID0gbng7XG4gICAgICAgICAgYXJyYXlbIGkgKyA0IF0gPSBueTtcbiAgICAgICAgICBhcnJheVsgaSArIDUgXSA9IG56O1xuXG4gICAgICAgICAgYXJyYXlbIGkgKyA2IF0gPSBueDtcbiAgICAgICAgICBhcnJheVsgaSArIDcgXSA9IG55O1xuICAgICAgICAgIGFycmF5WyBpICsgOCBdID0gbno7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG4gICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIH1cblxuICAgIGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnV2ICk7XG4gICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cbiAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcblxuICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcbiAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcblxuICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIH1cblxuICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XG5cbiAgICBvYmplY3QuY291bnQgPSAwO1xuXG4gIH07XG5cbiAgdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcblxuICAgIGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgdmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcbiAgICB2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG4gICAgaWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xuXG4gICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcbiAgICAgIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgLy8gbW9ycGggdGFyZ2V0c1xuXG4gICAgdmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XG4gICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIGFjdGl2ZUluZmx1ZW5jZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xuXG4gICAgICBpZiAoIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID4gOCApIHtcblxuICAgICAgICBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBpbmZsdWVuY2UgPSBhY3RpdmVJbmZsdWVuY2VzWyBpIF07XG4gICAgICAgIG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XG5cbiAgICAgICAgaWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcblxuICAgICAgICAgIHZhciBpbmRleCA9IGluZmx1ZW5jZVsgMSBdO1xuXG4gICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb25bIGluZGV4IF0gKTtcbiAgICAgICAgICBpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoQXR0cmlidXRlcy5ub3JtYWxbIGluZGV4IF0gKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XG4gICAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblxuICAgICAgaWYgKCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XG5cbiAgICAgICAgX2dsLnVuaWZvcm0xZnYoIHVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgbW9ycGhJbmZsdWVuY2VzICk7XG5cbiAgICAgIH1cblxuICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleDtcbiAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgaWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cbiAgICAgIGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XG5cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXI7XG5cbiAgICBpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuICAgICAgcmVuZGVyZXIuc2V0SW5kZXgoIGluZGV4ICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG4gICAgfVxuXG4gICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG4gICAgICBpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBncm91cCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgY291bnQ7XG5cbiAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb3VudCA9IGluZGV4LmFycmF5Lmxlbmd0aDtcblxuICAgICAgfSBlbHNlIGlmICggcG9zaXRpb24gaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICBjb3VudCA9IHBvc2l0aW9uLmRhdGEuYXJyYXkubGVuZ3RoIC8gMztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb3VudCA9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cbiAgICAgIH1cblxuICAgICAgZ3JvdXAgPSB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBjb3VudDogY291bnRcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgIGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG4gICAgICAgIHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogcGl4ZWxSYXRpbyApO1xuICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcblxuICAgICAgICByZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIHBvc2l0aW9uIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCAwLCBwb3NpdGlvbi5kYXRhLmNvdW50ICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuICAgICAgaWYgKCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCApIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXG5cbiAgICAgIHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogcGl4ZWxSYXRpbyApO1xuXG4gICAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyApIHtcblxuICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xuXG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlciggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cbiAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkICkge1xuXG4gICAgICByZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XG5cbiAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkICkgc3RhcnRJbmRleCA9IDA7XG5cbiAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgaWYgKCBwcm9ncmFtQXR0cmlidXRlID49IDAgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cbiAgICAgICAgICB2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICAgIHZhciBidWZmZXIgPSBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuICAgICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXG4gICAgICAgICAgICBpZiAoIGRhdGEgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogZGF0YS5jb3VudDtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcbiAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxuXG4gICAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggcHJvZ3JhbUF0dHJpYnV0ZSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgdmFyIHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XG5cbiAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgfVxuXG4gIC8vIFNvcnRpbmdcblxuICBmdW5jdGlvbiBudW1lcmljYWxTb3J0ICggYSwgYiApIHtcblxuICAgIHJldHVybiBiWyAwIF0gLSBhWyAwIF07XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuICAgIGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgICByZXR1cm4gYS5vYmplY3QucmVuZGVyT3JkZXIgLSBiLm9iamVjdC5yZW5kZXJPcmRlcjtcblxuICAgIH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XG5cbiAgICAgIHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblxuICAgIH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgICByZXR1cm4gYS56IC0gYi56O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG4gICAgaWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cbiAgICAgIHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG4gICAgfSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgICByZXR1cm4gYi56IC0gYS56O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBSZW5kZXJpbmdcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xuXG4gICAgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XG5cbiAgICAvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXG5cbiAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuICAgIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcbiAgICBfY3VycmVudENhbWVyYSA9IG51bGw7XG4gICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgLy8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cbiAgICBpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgLy8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG4gICAgaWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgbGlnaHRzLmxlbmd0aCA9IDA7XG5cbiAgICBvcGFxdWVPYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA9IDA7XG5cbiAgICBvcGFxdWVJbW1lZGlhdGVPYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzLmxlbmd0aCA9IDA7XG5cbiAgICBzcHJpdGVzLmxlbmd0aCA9IDA7XG4gICAgbGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xuXG4gICAgcHJvamVjdE9iamVjdCggc2NlbmUgKTtcblxuICAgIGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cbiAgICAgIG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcbiAgICAgIHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICBzaGFkb3dNYXAucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cbiAgICAvL1xuXG4gICAgX2luZm9SZW5kZXIuY2FsbHMgPSAwO1xuICAgIF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcbiAgICBfaW5mb1JlbmRlci5mYWNlcyA9IDA7XG4gICAgX2luZm9SZW5kZXIucG9pbnRzID0gMDtcblxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuICAgICAgdGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgaWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgICB2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cbiAgICAgIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcbiAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXG4gICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBvcGFxdWVJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG4gICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCB0cmFuc3BhcmVudEltbWVkaWF0ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxuXG4gICAgICBzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG4gICAgICByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG4gICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBvcGFxdWVJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG5cbiAgICAgIC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXG5cbiAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZyApO1xuICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG5cbiAgICB9XG5cbiAgICAvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcblxuICAgIHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcbiAgICBsZW5zRmxhcmVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFdpZHRoLCBfY3VycmVudEhlaWdodCApO1xuXG4gICAgLy8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuICAgIGlmICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgcmVuZGVyVGFyZ2V0Lm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG4gICAgc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG4gICAgc3RhdGUuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xuICAgIHN0YXRlLnNldENvbG9yV3JpdGUoIHRydWUgKTtcblxuICAgIC8vIF9nbC5maW5pc2goKTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCApIHtcblxuICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcblxuICAgICAgbGlnaHRzLnB1c2goIG9iamVjdCApO1xuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xuXG4gICAgICBzcHJpdGVzLnB1c2goIG9iamVjdCApO1xuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGVuc0ZsYXJlICkge1xuXG4gICAgICBsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xuXG4gICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgIGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cbiAgICAgICAgdHJhbnNwYXJlbnRJbW1lZGlhdGVPYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIG9wYXF1ZUltbWVkaWF0ZU9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkICl7XG5cbiAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgICAgb2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xuXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICBpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICBpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgX3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgICAgIHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgICAgICAgIG1hdGVyaWFsc1sgaSBdLnByb2dyYW0gPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWxzWyBpIF0gKS5wcm9ncmFtO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZW5kZXJJdGVtID0ge1xuICAgICAgICAgICAgaWQ6IG9iamVjdC5pZCxcbiAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgICAgbWF0ZXJpYWw6IG9iamVjdC5tYXRlcmlhbCxcbiAgICAgICAgICAgIHo6IF92ZWN0b3IzLnpcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuICAgICAgICAgICAgdHJhbnNwYXJlbnRPYmplY3RzLnB1c2goIHJlbmRlckl0ZW0gKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIG9wYXF1ZU9iamVjdHMucHVzaCggcmVuZGVySXRlbSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgcHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgdmFyIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XG4gICAgICB2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG5cbiAgICAgIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgICBvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xuXG4gICAgICBpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcblxuICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICAgICAgICB2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbIGogXTtcbiAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG4gICAgICAgICAgaWYgKCBncm91cE1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgX3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXG4gICAgICBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgb2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblxuICAgICAgaWYgKCBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXG4gICAgICBvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgICAgICBfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuICAgICAgfSApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBNYXRlcmlhbHNcblxuICB2YXIgc2hhZGVySURzID0ge1xuICAgIE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuICAgIE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG4gICAgTWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICAgIE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuICAgIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgUG9pbnRDbG91ZE1hdGVyaWFsOiAncGFydGljbGVfYmFzaWMnXG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcblxuICAgIHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuICAgIHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xuXG4gICAgLy8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcbiAgICAvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxuXG4gICAgdmFyIG1heExpZ2h0Q291bnQgPSBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICk7XG4gICAgdmFyIG1heFNoYWRvd3MgPSBhbGxvY2F0ZVNoYWRvd3MoIGxpZ2h0cyApO1xuICAgIHZhciBtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xuICAgIHZhciBwcmVjaXNpb24gPSBfcHJlY2lzaW9uO1xuXG4gICAgaWYgKCBtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgIHByZWNpc2lvbiA9IHN0YXRlLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XG5cbiAgICAgIGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5pbml0TWF0ZXJpYWw6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB7XG5cbiAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMsXG5cbiAgICAgIG1hcDogISEgbWF0ZXJpYWwubWFwLFxuICAgICAgZW52TWFwOiAhISBtYXRlcmlhbC5lbnZNYXAsXG4gICAgICBlbnZNYXBNb2RlOiBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcsXG4gICAgICBsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXG4gICAgICBhb01hcDogISEgbWF0ZXJpYWwuYW9NYXAsXG4gICAgICBlbWlzc2l2ZU1hcDogISEgbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXG4gICAgICBidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuICAgICAgbm9ybWFsTWFwOiAhISBtYXRlcmlhbC5ub3JtYWxNYXAsXG4gICAgICBzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG4gICAgICBhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXG5cbiAgICAgIGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXG5cbiAgICAgIHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXG4gICAgICBmb2c6IGZvZyxcbiAgICAgIHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuICAgICAgZm9nRXhwOiBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLFxuXG4gICAgICBmbGF0U2hhZGluZzogbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcsXG5cbiAgICAgIHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxuICAgICAgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cbiAgICAgIHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcbiAgICAgIG1heEJvbmVzOiBtYXhCb25lcyxcbiAgICAgIHVzZVZlcnRleFRleHR1cmU6IF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxuXG4gICAgICBtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcbiAgICAgIG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxuICAgICAgbWF4TW9ycGhUYXJnZXRzOiBfdGhpcy5tYXhNb3JwaFRhcmdldHMsXG4gICAgICBtYXhNb3JwaE5vcm1hbHM6IF90aGlzLm1heE1vcnBoTm9ybWFscyxcblxuICAgICAgbWF4RGlyTGlnaHRzOiBtYXhMaWdodENvdW50LmRpcmVjdGlvbmFsLFxuICAgICAgbWF4UG9pbnRMaWdodHM6IG1heExpZ2h0Q291bnQucG9pbnQsXG4gICAgICBtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXG4gICAgICBtYXhIZW1pTGlnaHRzOiBtYXhMaWdodENvdW50LmhlbWksXG5cbiAgICAgIG1heFNoYWRvd3M6IG1heFNoYWRvd3MsXG4gICAgICBzaGFkb3dNYXBFbmFibGVkOiBzaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBtYXhTaGFkb3dzID4gMCxcbiAgICAgIHNoYWRvd01hcFR5cGU6IHNoYWRvd01hcC50eXBlLFxuICAgICAgc2hhZG93TWFwRGVidWc6IHNoYWRvd01hcC5kZWJ1ZyxcblxuICAgICAgYWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXG4gICAgICBtZXRhbDogbWF0ZXJpYWwubWV0YWwsXG4gICAgICBkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcbiAgICAgIGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcblxuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBjb2RlXG5cbiAgICB2YXIgY2h1bmtzID0gW107XG5cbiAgICBpZiAoIHNoYWRlcklEICkge1xuXG4gICAgICBjaHVua3MucHVzaCggc2hhZGVySUQgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNodW5rcy5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xuICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XG5cbiAgICAgICAgY2h1bmtzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgICBjaHVua3MucHVzaCggbmFtZSApO1xuICAgICAgY2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIG5hbWUgXSApO1xuXG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBjaHVua3Muam9pbigpO1xuICAgIHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuICAgIGlmICggISBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSApIHtcblxuICAgICAgLy8gbmV3IG1hdGVyaWFsXG4gICAgICBtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xuXG4gICAgICAvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xuICAgICAgcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcblxuICAgIH0gZWxzZSBpZiAoIHNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XG4gICAgICByZXR1cm47XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBvbmx5IHJlYnVpbGQgdW5pZm9ybSBsaXN0XG4gICAgICBwcm9ncmFtQ2hhbmdlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBpZiAoIHNoYWRlcklEICkge1xuXG4gICAgICB2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBzaGFkZXJJRCBdO1xuXG4gICAgICBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcbiAgICAgICAgbmFtZTogbWF0ZXJpYWwudHlwZSxcbiAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcbiAgICAgICAgbmFtZTogbWF0ZXJpYWwudHlwZSxcbiAgICAgICAgdW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG4gICAgICB9O1xuXG4gICAgfVxuXG4gICAgdmFyIHByb2dyYW07XG5cbiAgICAvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcblxuICAgIGZvciAoIHZhciBwID0gMCwgcGwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cbiAgICAgIHZhciBwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgcCBdO1xuXG4gICAgICBpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cbiAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuXG4gICAgICAgIGlmICggcHJvZ3JhbUNoYW5nZSApIHtcblxuICAgICAgICAgIHByb2dyYW0udXNlZFRpbWVzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlcjtcbiAgICAgIHByb2dyYW0gPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtKCBfdGhpcywgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcbiAgICAgIF9wcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cbiAgICAgIF9pbmZvTWVtb3J5LnByb2dyYW1zID0gX3Byb2dyYW1zLmxlbmd0aDtcblxuICAgIH1cblxuICAgIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID0gcHJvZ3JhbTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XG5cbiAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhOb3JtYWxzOyBpICsrICkge1xuXG4gICAgICAgIGlmICggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIGkgXSA+PSAwICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IFtdO1xuXG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5nZXRVbmlmb3JtcygpO1xuICAgIGZvciAoIHZhciB1IGluIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zICkge1xuXG4gICAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XG5cbiAgICAgIGlmICggbG9jYXRpb24gKSB7XG5cbiAgICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdC5wdXNoKCBbIG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zWyB1IF0sIGxvY2F0aW9uIF0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cbiAgICBzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xuXG4gICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIHtcblxuICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcblxuICAgIH1cblxuICAgIHN0YXRlLnNldERlcHRoRnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG4gICAgc3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG4gICAgc3RhdGUuc2V0Q29sb3JXcml0ZSggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xuICAgIHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApIHtcblxuICAgIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgPyBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKSA6IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcbiAgICBzdGF0ZS5zZXRGbGlwU2lkZWQoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XG5cbiAgICBfdXNlZFRleHR1cmVVbml0cyA9IDA7XG5cbiAgICB2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlIHx8ICEgbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gKSB7XG5cbiAgICAgIGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKTtcbiAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICB2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcbiAgICB2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XG4gICAgdmFyIHJlZnJlc2hMaWdodHMgPSBmYWxzZTtcblxuICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0sXG4gICAgICBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuICAgICAgbV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuXG4gICAgaWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XG5cbiAgICAgIF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcbiAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW0uaWQ7XG5cbiAgICAgIHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcbiAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG4gICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuICAgICAgaWYgKCBfY3VycmVudE1hdGVyaWFsSWQgPT09IC0gMSApIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuICAgICAgX2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XG5cbiAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cbiAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICBpZiAoIF9sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG4gICAgICAgIF9nbC51bmlmb3JtMWYoIHBfdW5pZm9ybXMubG9nRGVwdGhCdWZGQywgMi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xuXG4gICAgICB9XG5cblxuICAgICAgaWYgKCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkgX2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XG5cbiAgICAgIC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcbiAgICAgIC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cbiAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwuZW52TWFwICkge1xuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbC5za2lubmluZyApIHtcblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuICAgIC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xuICAgIC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXG5cbiAgICBpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG4gICAgICBpZiAoIG9iamVjdC5iaW5kTWF0cml4ICYmIHBfdW5pZm9ybXMuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXgsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlICYmIHBfdW5pZm9ybXMuYmluZE1hdHJpeEludmVyc2UgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlV2lkdGggKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG4gICAgICAvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG4gICAgICBpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwubGlnaHRzICkge1xuXG4gICAgICAgIGlmICggX2xpZ2h0c05lZWRVcGRhdGUgKSB7XG5cbiAgICAgICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcbiAgICAgICAgICBzZXR1cExpZ2h0cyggbGlnaHRzICk7XG4gICAgICAgICAgX2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWZyZXNoTGlnaHRzICkge1xuXG4gICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG4gICAgICAgICAgbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHRydWUgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIGZhbHNlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0Jhc2ljKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG4gICAgICAgIG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgICAgbV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICEgbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xuXG4gICAgICBsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ICk7XG5cbiAgICB9XG5cbiAgICBsb2FkVW5pZm9ybXNNYXRyaWNlcyggcF91bmlmb3Jtcywgb2JqZWN0ICk7XG5cbiAgICBpZiAoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xuXG4gIH1cblxuICAvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG4gICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuICAgIHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG4gICAgdW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuICAgIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuICAgICAgdW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG4gICAgICB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cbiAgICB9XG5cbiAgICBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuICAgICAgdW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuICAgICAgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuICAgIH1cblxuICAgIC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuICAgIC8vIDEuIGNvbG9yIG1hcFxuICAgIC8vIDIuIHNwZWN1bGFyIG1hcFxuICAgIC8vIDMuIG5vcm1hbCBtYXBcbiAgICAvLyA0LiBidW1wIG1hcFxuICAgIC8vIDUuIGFscGhhIG1hcFxuICAgIC8vIDYuIGVtaXNzaXZlIG1hcFxuXG4gICAgdmFyIHV2U2NhbGVNYXA7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gICAgfVxuXG4gICAgaWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcbiAgICAgIHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcblxuICAgICAgdW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuICAgIH1cblxuICAgIHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcbiAgICB1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtIDE7XG5cbiAgICB1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG4gICAgdW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcbiAgICB1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XG4gICAgdW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGFydGljbGUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICB1bmlmb3Jtcy5wc0NvbG9yLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG4gICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG4gICAgdW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemU7XG4gICAgdW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfY2FudmFzLmhlaWdodCAvIDIuMDsgLy8gVE9ETzogQ2FjaGUgdGhpcy5cblxuICAgIHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblxuICAgIGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gbWF0ZXJpYWwubWFwLm9mZnNldDtcbiAgICAgIHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xuXG4gICAgICB1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2cgKCB1bmlmb3JtcywgZm9nICkge1xuXG4gICAgdW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XG5cbiAgICBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuICAgICAgdW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuICAgICAgdW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblxuICAgIH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cbiAgICAgIHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICB1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGluaW5lc3M7XG5cbiAgICB1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlO1xuICAgIHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XG5cbiAgICB1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuICAgIHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICB1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuICAgIHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICB1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMYW1iZXJ0ICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQmFzaWMgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICB1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuICAgIHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyAoIHVuaWZvcm1zLCBsaWdodHMgKSB7XG5cbiAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xuXG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycztcbiAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztcblxuICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5wb2ludC5jb2xvcnM7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcbiAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMucG9pbnQuZGlzdGFuY2VzO1xuICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kZWNheXM7XG5cbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LnBvc2l0aW9ucztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpc3RhbmNlcztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodEFuZ2xlQ29zLnZhbHVlID0gbGlnaHRzLnNwb3QuYW5nbGVzQ29zO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50LnZhbHVlID0gbGlnaHRzLnNwb3QuZXhwb25lbnRzO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5LnZhbHVlID0gbGlnaHRzLnNwb3QuZGVjYXlzO1xuXG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5za3lDb2xvcnM7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5ncm91bmRDb2xvcnM7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmhlbWkucG9zaXRpb25zO1xuXG4gIH1cblxuICAvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cbiAgZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUgKCB1bmlmb3JtcywgdmFsdWUgKSB7XG5cbiAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgdW5pZm9ybXMucG9pbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodEV4cG9uZW50Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU2hhZG93ICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcblxuICAgIGlmICggdW5pZm9ybXMuc2hhZG93TWF0cml4ICkge1xuXG4gICAgICB2YXIgaiA9IDA7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8ICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgKSB7XG5cbiAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXAudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hcDtcbiAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXBTaXplO1xuXG4gICAgICAgICAgdW5pZm9ybXMuc2hhZG93TWF0cml4LnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXRyaXg7XG5cbiAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93RGFya25lc3M7XG4gICAgICAgICAgdW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93QmlhcztcblxuICAgICAgICAgIGogKys7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcblxuICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XG5cbiAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgaWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XG5cbiAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXgsIGZhbHNlLCBvYmplY3Qubm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRleHR1cmVVbml0KCkge1xuXG4gICAgdmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cbiAgICBpZiAoIHRleHR1cmVVbml0ID49IF9tYXhUZXh0dXJlcyApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgX21heFRleHR1cmVzICk7XG5cbiAgICB9XG5cbiAgICBfdXNlZFRleHR1cmVVbml0cyArPSAxO1xuXG4gICAgcmV0dXJuIHRleHR1cmVVbml0O1xuXG4gIH1cblxuICBmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljICggdW5pZm9ybXMgKSB7XG5cbiAgICB2YXIgdGV4dHVyZSwgdGV4dHVyZVVuaXQsIG9mZnNldDtcblxuICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XG5cbiAgICAgIC8vIG5lZWRzVXBkYXRlIHByb3BlcnR5IGlzIG5vdCBhZGRlZCB0byBhbGwgdW5pZm9ybXMuXG4gICAgICBpZiAoIHVuaWZvcm0ubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgIHZhciB0eXBlID0gdW5pZm9ybS50eXBlO1xuICAgICAgdmFyIHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IHVuaWZvcm1zWyBqIF1bIDEgXTtcblxuICAgICAgc3dpdGNoICggdHlwZSApIHtcblxuICAgICAgICBjYXNlICcxaSc6XG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnMWYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzJmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzNmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzRmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSwgdmFsdWVbIDMgXSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzFpdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzNpdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzFmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzJmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzNmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzRmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ01hdHJpeDNmdic6XG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdNYXRyaXg0ZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBjYXNlICdpJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBpbnRlZ2VyXG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBmbG9hdFxuICAgICAgICAgIF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjInOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcbiAgICAgICAgICBfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjMnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjQnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcbiAgICAgICAgICBfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYyc6XG5cbiAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuQ29sb3JcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaXYxJzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2l2JzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICBfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdjEnOlxuXG4gICAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Z2JzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjJ2JzpcblxuICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIG9mZnNldCA9IGkgKiAyO1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Yzdic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBpICogMztcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndjR2JzpcblxuICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjRcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIG9mZnNldCA9IGkgKiA0O1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMCBdID0gdmFsdWVbIGkgXS54O1xuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMyBdID0gdmFsdWVbIGkgXS53O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbTMnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLk1hdHJpeDNcbiAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbTN2JzpcblxuICAgICAgICAgIC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDNcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogOSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ200JzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ200dic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXG5cbiAgICAgICAgICB0ZXh0dXJlID0gdmFsdWU7XG4gICAgICAgICAgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICBpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcbiAgICAgICAgICAgICAoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xuXG4gICAgICAgICAgICAvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xuXG4gICAgICAgICAgICBzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgICAgICAgIHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0dic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5UZXh0dXJlICgyZClcblxuICAgICAgICAgIGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBbXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICB0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZVsgaSBdO1xuICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xuXG4gICAgICAgICAgICBpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbG9yTGluZWFyKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDAgXSA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwTGlnaHRzICggbGlnaHRzICkge1xuXG4gICAgdmFyIGwsIGxsLCBsaWdodCxcbiAgICByID0gMCwgZyA9IDAsIGIgPSAwLFxuICAgIGNvbG9yLCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsXG4gICAgaW50ZW5zaXR5LFxuICAgIGRpc3RhbmNlLFxuXG4gICAgemxpZ2h0cyA9IF9saWdodHMsXG5cbiAgICBkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcbiAgICBkaXJQb3NpdGlvbnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxcblxuICAgIHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXG4gICAgcG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcbiAgICBwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxuICAgIHBvaW50RGVjYXlzID0gemxpZ2h0cy5wb2ludC5kZWNheXMsXG5cbiAgICBzcG90Q29sb3JzID0gemxpZ2h0cy5zcG90LmNvbG9ycyxcbiAgICBzcG90UG9zaXRpb25zID0gemxpZ2h0cy5zcG90LnBvc2l0aW9ucyxcbiAgICBzcG90RGlzdGFuY2VzID0gemxpZ2h0cy5zcG90LmRpc3RhbmNlcyxcbiAgICBzcG90RGlyZWN0aW9ucyA9IHpsaWdodHMuc3BvdC5kaXJlY3Rpb25zLFxuICAgIHNwb3RBbmdsZXNDb3MgPSB6bGlnaHRzLnNwb3QuYW5nbGVzQ29zLFxuICAgIHNwb3RFeHBvbmVudHMgPSB6bGlnaHRzLnNwb3QuZXhwb25lbnRzLFxuICAgIHNwb3REZWNheXMgPSB6bGlnaHRzLnNwb3QuZGVjYXlzLFxuXG4gICAgaGVtaVNreUNvbG9ycyA9IHpsaWdodHMuaGVtaS5za3lDb2xvcnMsXG4gICAgaGVtaUdyb3VuZENvbG9ycyA9IHpsaWdodHMuaGVtaS5ncm91bmRDb2xvcnMsXG4gICAgaGVtaVBvc2l0aW9ucyA9IHpsaWdodHMuaGVtaS5wb3NpdGlvbnMsXG5cbiAgICBkaXJMZW5ndGggPSAwLFxuICAgIHBvaW50TGVuZ3RoID0gMCxcbiAgICBzcG90TGVuZ3RoID0gMCxcbiAgICBoZW1pTGVuZ3RoID0gMCxcblxuICAgIGRpckNvdW50ID0gMCxcbiAgICBwb2ludENvdW50ID0gMCxcbiAgICBzcG90Q291bnQgPSAwLFxuICAgIGhlbWlDb3VudCA9IDAsXG5cbiAgICBkaXJPZmZzZXQgPSAwLFxuICAgIHBvaW50T2Zmc2V0ID0gMCxcbiAgICBzcG90T2Zmc2V0ID0gMCxcbiAgICBoZW1pT2Zmc2V0ID0gMDtcblxuICAgIGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuICAgICAgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgaWYgKCBsaWdodC5vbmx5U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgIGNvbG9yID0gbGlnaHQuY29sb3I7XG4gICAgICBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG4gICAgICBkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xuXG4gICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgciArPSBjb2xvci5yO1xuICAgICAgICBnICs9IGNvbG9yLmc7XG4gICAgICAgIGIgKz0gY29sb3IuYjtcblxuICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG4gICAgICAgIGRpckNvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgX2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG4gICAgICAgIF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgZGlyT2Zmc2V0ID0gZGlyTGVuZ3RoICogMztcblxuICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcbiAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgIHNldENvbG9yTGluZWFyKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIGRpckxlbmd0aCArPSAxO1xuXG4gICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XG5cbiAgICAgICAgcG9pbnRDb3VudCArPSAxO1xuXG4gICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgcG9pbnRPZmZzZXQgPSBwb2ludExlbmd0aCAqIDM7XG5cbiAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblxuICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAwIF0gPSBfdmVjdG9yMy54O1xuICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xuICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAyIF0gPSBfdmVjdG9yMy56O1xuXG4gICAgICAgIC8vIGRpc3RhbmNlIGlzIDAgaWYgZGVjYXkgaXMgMCwgYmVjYXVzZSB0aGVyZSBpcyBubyBhdHRlbnVhdGlvbiBhdCBhbGwuXG4gICAgICAgIHBvaW50RGlzdGFuY2VzWyBwb2ludExlbmd0aCBdID0gZGlzdGFuY2U7XG4gICAgICAgIHBvaW50RGVjYXlzWyBwb2ludExlbmd0aCBdID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cbiAgICAgICAgcG9pbnRMZW5ndGggKz0gMTtcblxuICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cbiAgICAgICAgc3BvdENvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICBzcG90T2Zmc2V0ID0gc3BvdExlbmd0aCAqIDM7XG5cbiAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblxuICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgIHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xuXG4gICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuICAgICAgICBfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgc3BvdEFuZ2xlc0Nvc1sgc3BvdExlbmd0aCBdID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XG4gICAgICAgIHNwb3RFeHBvbmVudHNbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LmV4cG9uZW50O1xuICAgICAgICBzcG90RGVjYXlzWyBzcG90TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgICAgICBzcG90TGVuZ3RoICs9IDE7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG4gICAgICAgIGhlbWlDb3VudCArPSAxO1xuXG4gICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgaGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xuXG4gICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgc2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcbiAgICAgICAgZ3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvcjtcblxuICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaUdyb3VuZENvbG9ycywgaGVtaU9mZnNldCwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIGhlbWlMZW5ndGggKz0gMTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbnVsbCBldmVudHVhbCByZW1haW5zIGZyb20gcmVtb3ZlZCBsaWdodHNcbiAgICAvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXG5cbiAgICBmb3IgKCBsID0gZGlyTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggZGlyQ29sb3JzLmxlbmd0aCwgZGlyQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGRpckNvbG9yc1sgbCBdID0gMC4wO1xuICAgIGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICBmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlTa3lDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlTa3lDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcblxuICAgIHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xuICAgIHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG4gICAgemxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG4gICAgemxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cbiAgICB6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG4gICAgemxpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuICAgIHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuICB9XG5cbiAgLy8gR0wgc3RhdGUgc2V0dGluZ1xuXG4gIHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cbiAgICBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XG5cbiAgICAgIHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyApIHtcblxuICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xuXG4gICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuICAgICAgfSBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xuXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gVGV4dHVyZXNcblxuICBmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyAoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgIHZhciBleHRlbnNpb247XG5cbiAgICBpZiAoIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcblxuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcblxuICAgICAgaWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4gKCAnICsgdGV4dHVyZS5zb3VyY2VGaWxlICsgJyApJyApO1xuXG4gICAgICB9XG5cbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuICAgICAgaWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4gKCAnICsgdGV4dHVyZS5zb3VyY2VGaWxlICsgJyApJyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuICAgIGlmICggZXh0ZW5zaW9uICYmIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuRmxvYXRUeXBlICYmIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuSGFsZkZsb2F0VHlwZSApIHtcblxuICAgICAgaWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcblxuICAgICAgICBfZ2wudGV4UGFyYW1ldGVyZiggdGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oIHRleHR1cmUuYW5pc290cm9weSwgX3RoaXMuZ2V0TWF4QW5pc290cm9weSgpICkgKTtcbiAgICAgICAgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgaWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XG5cbiAgICAgIHRleHR1cmUuX193ZWJnbEluaXQgPSB0cnVlO1xuXG4gICAgICB0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgIF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG4gICAgfVxuXG4gICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcbiAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuICAgIF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cbiAgICB0ZXh0dXJlLmltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIF9tYXhUZXh0dXJlU2l6ZSApO1xuXG4gICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZSxcbiAgICBpc0ltYWdlUG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcbiAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcblxuICAgIHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cbiAgICBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZSApIHtcblxuICAgICAgLy8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgICAgLy8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cbiAgICAgIGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuICAgICAgICBpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XG5cbiAgICAgICAgICBpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG4gICAgICAvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG4gICAgICAvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuICAgICAgaWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG4gICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuICB9XG5cbiAgdGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuICAgIGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuICAgICAgaWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgICB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplICggaW1hZ2UsIG1heFNpemUgKSB7XG5cbiAgICBpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG4gICAgICAvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxuICAgICAgLy8gcHJlbXVsdGlwbGllZCBhbHBoYS5cblxuICAgICAgdmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xuICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG4gICAgICByZXR1cm4gY2FudmFzO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG4gICAgaWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcblxuICAgICAgaWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG4gICAgICAgIGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgICAgICAgdGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXG4gICAgICAgIHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG4gICAgICAgIHZhciBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVsgMCBdIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmU7XG5cbiAgICAgICAgdmFyIGN1YmVJbWFnZSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgICAgICBpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgY3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBfbWF4Q3ViZW1hcFNpemUgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXG4gICAgICAgIGlzSW1hZ2VQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApLFxuICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cbiAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgICAgICBpZiAoICEgaXNDb21wcmVzc2VkICkge1xuXG4gICAgICAgICAgICBpZiAoIGlzRGF0YVRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG4gICAgICAgICAgICAgIGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRDdWJlVGV4dHVyZSgpXCIgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgICBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuICAgICAgICBpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xuXG4gIH1cblxuICAvLyBSZW5kZXIgdGFyZ2V0c1xuXG4gIGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXIgKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlVGFyZ2V0ICkge1xuXG4gICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlciAoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgLyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXG4gICAgfSBlbHNlIGlmICggISByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuU1RFTkNJTF9JTkRFWDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuICAgICovXG5cbiAgICB9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgJiYgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG4gICAgICBpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHRydWU7XG5cbiAgICAgIHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgX2luZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cbiAgICAgIC8vIFNldHVwIHRleHR1cmUsIGNyZWF0ZSByZW5kZXIgYW5kIGZyYW1lIGJ1ZmZlcnNcblxuICAgICAgdmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LmhlaWdodCApLFxuICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQuZm9ybWF0ICksXG4gICAgICAgIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudHlwZSApO1xuXG4gICAgICBpZiAoIGlzQ3ViZSApIHtcblxuICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBbXTtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cbiAgICAgICAgICBzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XG4gICAgICAgICAgc2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG4gICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tLl9fd2ViZ2xSZW5kZXJidWZmZXI7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblxuICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG4gICAgICAgIHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFXzJEICk7XG5cbiAgICAgICAgaWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XG5cbiAgICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIFJlbGVhc2UgZXZlcnl0aGluZ1xuXG4gICAgICBpZiAoIGlzQ3ViZSApIHtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgICAgfVxuXG4gICAgICBfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZnJhbWVidWZmZXIsIHdpZHRoLCBoZWlnaHQsIHZ4LCB2eTtcblxuICAgIGlmICggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgICAgaWYgKCBpc0N1YmUgKSB7XG5cbiAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuICAgICAgfVxuXG4gICAgICB3aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG5cbiAgICAgIHZ4ID0gMDtcbiAgICAgIHZ5ID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgICAgd2lkdGggPSBfdmlld3BvcnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IF92aWV3cG9ydEhlaWdodDtcblxuICAgICAgdnggPSBfdmlld3BvcnRYO1xuICAgICAgdnkgPSBfdmlld3BvcnRZO1xuXG4gICAgfVxuXG4gICAgaWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgICAgX2dsLnZpZXdwb3J0KCB2eCwgdnksIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgX2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuXG4gICAgfVxuXG4gICAgX2N1cnJlbnRXaWR0aCA9IHdpZHRoO1xuICAgIF9jdXJyZW50SGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIH07XG5cbiAgdGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24oIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xuXG4gICAgaWYgKCAhICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBpZiAoIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgKSB7XG5cbiAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgZm9ybWF0LiByZWFkUGl4ZWxzIGNhbiByZWFkIG9ubHkgUkdCQSBmb3JtYXQuJyApO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3RvcmUgPSBmYWxzZTtcblxuICAgICAgaWYgKCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xuXG4gICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuXG4gICAgICAgIHJlc3RvcmUgPSB0cnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XG5cbiAgICAgICAgX2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIF9nbC5SR0JBLCBfZ2wuVU5TSUdORURfQllURSwgYnVmZmVyICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCByZXN0b3JlICkge1xuXG4gICAgICAgIF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAgKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbFRleHR1cmUgKTtcbiAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcbiAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbFRleHR1cmUgKTtcbiAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcbiAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG4gIGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcblxuICAgIGlmICggZiA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG4gICAgICByZXR1cm4gX2dsLk5FQVJFU1Q7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gX2dsLkxJTkVBUjtcblxuICB9XG5cbiAgLy8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcblxuICBmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XG5cbiAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XG4gICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG4gICAgaWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xuICAgIGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xuICAgIGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcblxuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICBpZiAoIHAgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xuXG4gICAgfVxuXG4gICAgaWYgKCBwID09PSBUSFJFRS5BbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XG4gICAgaWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFGb3JtYXQgKSByZXR1cm4gX2dsLlJHQkE7XG4gICAgaWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XG4gICAgaWYgKCBwID09PSBUSFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xuICAgIGlmICggcCA9PT0gVEhSRUUuT25lRmFjdG9yICkgcmV0dXJuIF9nbC5PTkU7XG4gICAgaWYgKCBwID09PSBUSFJFRS5TcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuU1JDX0NPTE9SO1xuICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEE7XG4gICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgIGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQUxQSEE7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XG4gICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xuICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xuXG4gICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cbiAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cbiAgICB9XG5cbiAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cbiAgICBpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgICAgaWYgKCBwID09PSBUSFJFRS5NaW5FcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUlOX0VYVDtcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcblxuICB9XG5cbiAgLy8gQWxsb2NhdGlvbnNcblxuICBmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzICggb2JqZWN0ICkge1xuXG4gICAgaWYgKCBfc3VwcG9ydHNCb25lVGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgcmV0dXJuIDEwMjQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICAvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcbiAgICAgIC8vXG4gICAgICAvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuICAgICAgLy8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXG4gICAgICAvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXG5cbiAgICAgIHZhciBuVmVydGV4VW5pZm9ybXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcbiAgICAgIHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XG5cbiAgICAgIHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcblxuICAgICAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuICAgICAgICBtYXhCb25lcyA9IE1hdGgubWluKCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoLCBtYXhCb25lcyApO1xuXG4gICAgICAgIGlmICggbWF4Qm9uZXMgPCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSAnICsgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCArICcsIHRoaXMgR1BVIHN1cHBvcnRzIGp1c3QgJyArIG1heEJvbmVzICsgJyAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKScgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heEJvbmVzO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICkge1xuXG4gICAgdmFyIGRpckxpZ2h0cyA9IDA7XG4gICAgdmFyIHBvaW50TGlnaHRzID0gMDtcbiAgICB2YXIgc3BvdExpZ2h0cyA9IDA7XG4gICAgdmFyIGhlbWlMaWdodHMgPSAwO1xuXG4gICAgZm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuICAgICAgdmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cbiAgICAgIGlmICggbGlnaHQub25seVNoYWRvdyB8fCBsaWdodC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIGRpckxpZ2h0cyArKztcbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkgcG9pbnRMaWdodHMgKys7XG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgc3BvdExpZ2h0cyArKztcbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSBoZW1pTGlnaHRzICsrO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgJ2RpcmVjdGlvbmFsJzogZGlyTGlnaHRzLCAncG9pbnQnOiBwb2ludExpZ2h0cywgJ3Nwb3QnOiBzcG90TGlnaHRzLCAnaGVtaSc6IGhlbWlMaWdodHMgfTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKSB7XG5cbiAgICB2YXIgbWF4U2hhZG93cyA9IDA7XG5cbiAgICBmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG4gICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgaWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIG1heFNoYWRvd3MgKys7XG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIG1heFNoYWRvd3MgKys7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4U2hhZG93cztcblxuICB9XG5cbiAgLy8gREVQUkVDQVRFRFxuXG4gIHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XFwnICkuJyApO1xuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cbiAgfTtcblxuICB0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nICk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXFwnICkuJyApO1xuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNCbGVuZE1pbk1heCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicgKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG4gIH07XG5cbiAgdGhpcy5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfTtcblxuICB0aGlzLmFkZFByZVBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9O1xuXG4gIHRoaXMuYWRkUG9zdFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfTtcblxuICB0aGlzLnVwZGF0ZVNoYWRvd01hcCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgc2hhZG93TWFwRW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5lbmFibGVkO1xuXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xuICAgICAgICBzaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xuXG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3dNYXBUeXBlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gc2hhZG93TWFwLnR5cGU7XG5cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nICk7XG4gICAgICAgIHNoYWRvd01hcC50eXBlID0gdmFsdWU7XG5cbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvd01hcEN1bGxGYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gc2hhZG93TWFwLmN1bGxGYWNlO1xuXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XG4gICAgICAgIHNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xuXG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3dNYXBEZWJ1Zzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5kZWJ1ZztcblxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRGVidWcgaXMgbm93IC5zaGFkb3dNYXAuZGVidWcuJyApO1xuICAgICAgICBzaGFkb3dNYXAuZGVidWcgPSB2YWx1ZTtcblxuICAgICAgfVxuICAgIH1cbiAgfSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLndyYXBTID0gb3B0aW9ucy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gIHRoaXMud3JhcFQgPSBvcHRpb25zLndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICB0aGlzLm1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcbiAgdGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgdGhpcy5hbmlzb3Ryb3B5ID0gb3B0aW9ucy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaXNvdHJvcHkgOiAxO1xuXG4gIHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcbiAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcbiAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG4gIHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcbiAgdGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG4gIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuICB0aGlzLnNoYXJlRGVwdGhGcm9tID0gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSA6IG51bGw7XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQsXG5cbiAgc2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgaWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5kaXNwb3NlKCk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICB0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuICAgIHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XG4gICAgdGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuICAgIHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcbiAgICB0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cbiAgICB0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuICAgIHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcbiAgICB0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cbiAgICB0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG4gICAgdGhpcy50eXBlID0gc291cmNlLnR5cGU7XG5cbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgdGhpcy5zaGFyZURlcHRoRnJvbSA9IHNvdXJjZS5zaGFyZURlcHRoRnJvbTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cbiAgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG4gIHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcblxuICB2YXIgbW9kZTtcblxuICBmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuICAgIG1vZGUgPSB2YWx1ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cbiAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XG5cbiAgICBfaW5mb1JlbmRlci5jYWxscyArKztcbiAgICBfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcbiAgICBpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XG5cbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgaWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICBleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBwb3NpdGlvbi5kYXRhLmNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG4gIHRoaXMucmVuZGVyID0gcmVuZGVyO1xuICB0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XG5cbiAgdmFyIG1vZGU7XG5cbiAgZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cbiAgICBtb2RlID0gdmFsdWU7XG5cbiAgfVxuXG4gIHZhciB0eXBlLCBzaXplO1xuXG4gIGZ1bmN0aW9uIHNldEluZGV4KCBpbmRleCApIHtcblxuICAgIGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuICAgICAgc2l6ZSA9IDQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgc2l6ZSA9IDI7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xuXG4gICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xuXG4gICAgX2luZm9SZW5kZXIuY2FsbHMgKys7XG4gICAgX2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XG4gICAgaWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xuXG4gICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleDtcblxuICAgIGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwLCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gIH1cblxuICB0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuICB0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XG4gIHRoaXMucmVuZGVyID0gcmVuZGVyO1xuICB0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XG5cbiAgICB9XG5cbiAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgc3dpdGNoICggbmFtZSApIHtcblxuICAgICAgY2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuICAgIH1cblxuICAgIGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcblxuICAgIHJldHVybiBleHRlbnNpb247XG5cbiAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMR2VvbWV0cmllcyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cbiAgdmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICBmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgIGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXR1cm4gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgIH1cblxuICAgIGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuICAgIHZhciBidWZmZXJnZW9tZXRyeTtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICAgIH1cblxuICAgICAgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gYnVmZmVyZ2VvbWV0cnk7XG5cbiAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG4gICAgcmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xuXG4gIH1cblxuICBmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgIGRlbGV0ZUF0dHJpYnV0ZXMoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcblxuICAgIGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuICAgIGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XG4gICAgaWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgKSBkZWxldGVBdHRyaWJ1dGUoIHByb3BlcnR5LndpcmVmcmFtZSApO1xuXG4gICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICB2YXIgYnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuICAgIGlmICggYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyICk7XG4gICAgICByZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgICAgZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgICBwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlLmRhdGEgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5nZXQgPSBnZXQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTE9iamVjdHMuanNcblxuLyoqXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4qL1xuXG5USFJFRS5XZWJHTE9iamVjdHMgPSBmdW5jdGlvbiAoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xuXG4gIHZhciBnZW9tZXRyaWVzID0gbmV3IFRIUkVFLldlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKTtcblxuICAvL1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG4gICAgLy8gVE9ETzogQXZvaWQgdXBkYXRpbmcgdHdpY2UgKHdoZW4gdXNpbmcgc2hhZG93TWFwKS4gTWF5YmUgYWRkIGZyYW1lIGNvdW50ZXIuXG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0ICk7XG5cbiAgICBpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICBnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdICk7XG5cbiAgICB9XG5cbiAgICAvLyBtb3JwaCB0YXJnZXRzXG5cbiAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG4gICAgICB2YXIgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoIGFycmF5WyBpIF0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuICAgIHZhciBidWZmZXJUeXBlO1xuXG4gICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgYnVmZmVyVHlwZSA9IGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgYnVmZmVyVHlwZSA9IGdsLkFSUkFZX0JVRkZFUjtcblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XG5cbiAgICB2YXIgYXR0cmlidXRlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBkYXRhICk7XG5cbiAgICBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcblxuICAgIH0gZWxzZSBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiAhPT0gZGF0YS52ZXJzaW9uICkge1xuXG4gICAgICB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICkge1xuXG4gICAgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XG5cbiAgICB2YXIgdXNhZ2UgPSBnbC5TVEFUSUNfRFJBVztcblxuICAgIGlmICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGVcbiAgICAgICB8fCAoIGRhdGEgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgJiYgZGF0YS5keW5hbWljID09PSB0cnVlIClcbiAgICAgICB8fCAoIGRhdGEgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlciAmJiBkYXRhLmR5bmFtaWMgPT09IHRydWUgKSApIHtcblxuICAgICAgdXNhZ2UgPSBnbC5EWU5BTUlDX0RSQVc7XG5cbiAgICB9XG5cbiAgICBnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xuXG4gICAgYXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcblxuICAgIGlmICggZGF0YS51cGRhdGVSYW5nZSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcblxuICAgICAgLy8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcblxuICAgICAgZ2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgZGF0YS5hcnJheSApO1xuXG4gICAgfSBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMT2JqZWN0cy51cGRhdGVCdWZmZXI6IHVzaW5nIHVwZGF0ZVJhbmdlIGZvciBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGFuZCBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IGNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgICAgICAgICBkYXRhLmFycmF5LnN1YmFycmF5KCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKyBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcblxuICAgICAgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9IDA7IC8vIHJlc2V0IHJhbmdlXG5cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgaWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgcmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XG5cbiAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblxuICAgIGlmICggcHJvcGVydHkud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0eS53aXJlZnJhbWU7XG5cbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgdmFyIGluZGV4ID0gYXR0cmlidXRlcy5pbmRleDtcbiAgICB2YXIgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgLy8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xuXG4gICAgaWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICAgIHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgdmFyIGEgPSBhcnJheVsgaSArIDAgXTtcbiAgICAgICAgdmFyIGIgPSBhcnJheVsgaSArIDEgXTtcbiAgICAgICAgdmFyIGMgPSBhcnJheVsgaSArIDIgXTtcblxuICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGEsIGIgKSApIGluZGljZXMucHVzaCggYSwgYiApO1xuICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGIsIGMgKSApIGluZGljZXMucHVzaCggYiwgYyApO1xuICAgICAgICBpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGMsIGEgKSApIGluZGljZXMucHVzaCggYywgYSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gKCBhcnJheS5sZW5ndGggLyAzICkgLSAxOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgICAgIHZhciBhID0gaSArIDA7XG4gICAgICAgIHZhciBiID0gaSArIDE7XG4gICAgICAgIHZhciBjID0gaSArIDI7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcblxuICAgIHZhciBUeXBlQXJyYXkgPSBwb3NpdGlvbi5jb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICB2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlKCBuZXcgVHlwZUFycmF5KCBpbmRpY2VzICksIDEgKTtcblxuICAgIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XG5cbiAgICBwcm9wZXJ0eS53aXJlZnJhbWUgPSBhdHRyaWJ1dGU7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlO1xuXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkge1xuXG4gICAgdmFyIGhhc2ggPSBhIDwgYiA/IGEgKyAnXycgKyBiIDogYiArICdfJyArIGE7XG5cbiAgICBpZiAoIGVkZ2VzLmhhc093blByb3BlcnR5KCBoYXNoICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICBlZGdlc1sgaGFzaCBdID0gMTtcblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH1cblxuICB0aGlzLmdldEF0dHJpYnV0ZUJ1ZmZlciA9IGdldEF0dHJpYnV0ZUJ1ZmZlcjtcbiAgdGhpcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUgPSBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU7XG5cbiAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanNcblxuVEhSRUUuV2ViR0xQcm9ncmFtID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHByb2dyYW1JZENvdW50ID0gMDtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XG5cbiAgICB2YXIgY2h1bmtzID0gW107XG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xuXG4gICAgICB2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XG5cbiAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgIGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gY2h1bmtzLmpvaW4oICdcXG4nICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG4gICAgdmFyIHVuaWZvcm1zID0ge307XG5cbiAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcblxuICAgICAgdmFyIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICk7XG4gICAgICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFVOSUZPUk06XCIsIG5hbWUpO1xuXG4gICAgICB2YXIgc3VmZml4UG9zID0gbmFtZS5sYXN0SW5kZXhPZiggJ1swXScgKTtcbiAgICAgIGlmICggc3VmZml4UG9zICE9PSAtIDEgJiYgc3VmZml4UG9zID09PSBuYW1lLmxlbmd0aCAtIDMgKSB7XG5cbiAgICAgICAgdW5pZm9ybXNbIG5hbWUuc3Vic3RyKCAwLCBzdWZmaXhQb3MgKSBdID0gbG9jYXRpb247XG5cbiAgICAgIH1cblxuICAgICAgdW5pZm9ybXNbIG5hbWUgXSA9IGxvY2F0aW9uO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xuXG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cbiAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XG4gICAgICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcblxuICAgICAgLy8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lLCBpICk7XG5cbiAgICAgIGF0dHJpYnV0ZXNbIG5hbWUgXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nICE9PSAnJztcblxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgIHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcblxuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnZlcnRleFNoYWRlcjtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgdmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xuXG4gICAgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNoYWRvd01hcCApIHtcblxuICAgICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuXG4gICAgfSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG4gICAgICBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcblxuICAgIH1cblxuICAgIHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgIHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuICAgIHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuXG4gICAgaWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcblxuICAgICAgc3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgY2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG4gICAgICAgIGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuICAgICAgICBjYXNlIFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uOlxuICAgICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5NaXhPcGVyYXRpb246XG4gICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5BZGRPcGVyYXRpb246XG4gICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xuXG4gICAgLy9cblxuICAgIHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XG5cbiAgICAvL1xuXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICB2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcblxuICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbCApIHtcblxuICAgICAgcHJlZml4VmVydGV4ID0gJyc7XG4gICAgICBwcmVmaXhGcmFnbWVudCA9ICcnO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcHJlZml4VmVydGV4ID0gW1xuXG4gICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cbiAgICAgICAgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcblxuICAgICAgICBjdXN0b21EZWZpbmVzLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcblxuICAgICAgICByZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXG4gICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxuICAgICAgICAnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxuXG4gICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG4gICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cbiAgICAgICAgJyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxuXG4gICAgICAgIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gJyNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXG4gICAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXG5cbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cbiAgICAgICAgJyNpZmRlZiBVU0VfQ09MT1InLFxuXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgY29sb3I7JyxcblxuICAgICAgICAnI2VuZGlmJyxcblxuICAgICAgICAnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLFxuXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXG5cbiAgICAgICAgJyAjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXG5cbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JyxcbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxuXG4gICAgICAgICcgI2Vsc2UnLFxuXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcblxuICAgICAgICAnICNlbmRpZicsXG5cbiAgICAgICAgJyNlbmRpZicsXG5cbiAgICAgICAgJyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxuXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG4gICAgICAgICcgYXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxuXG4gICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICdcXG4nXG5cbiAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgICBwcmVmaXhGcmFnbWVudCA9IFtcblxuICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBtYXRlcmlhbC5kZXJpdmF0aXZlcyA/ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZScgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcblxuICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG4gICAgICAgICcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXG5cbiAgICAgICAgY3VzdG9tRGVmaW5lcyxcblxuICAgICAgICAnI2RlZmluZSBNQVhfRElSX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuICAgICAgICAnI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcblxuICAgICAgICAnI2RlZmluZSBNQVhfU0hBRE9XUyAnICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxuXG4gICAgICAgIHJlbmRlcmVyLmdhbW1hSW5wdXQgPyAnI2RlZmluZSBHQU1NQV9JTlBVVCcgOiAnJyxcbiAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXG4gICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICAgICAgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcbiAgICAgICAgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5tZXRhbCA/ICcjZGVmaW5lIE1FVEFMJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgICAgICdcXG4nXG5cbiAgICAgIF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgfVxuXG4gICAgdmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG4gICAgdmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cbiAgICB2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcbiAgICB2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cblxuICAgIGlmICggbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcblxuICAgIH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG4gICAgICAvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcbiAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xuXG4gICAgfVxuXG4gICAgZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcbiAgICB2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICB2YXIgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICB2YXIgcnVubmFibGUgPSB0cnVlO1xuICAgIHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG4gICAgaWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgICAgcnVubmFibGUgPSBmYWxzZTtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcblxuICAgIH0gZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XG5cbiAgICB9IGVsc2UgaWYgKCB2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJyApIHtcblxuICAgICAgaGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcblxuICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IHtcblxuICAgICAgICBydW5uYWJsZTogcnVubmFibGUsXG4gICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCxcblxuICAgICAgICBwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxuXG4gICAgICAgIHZlcnRleFNoYWRlcjoge1xuXG4gICAgICAgICAgbG9nOiB2ZXJ0ZXhMb2csXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXhWZXJ0ZXhcblxuICAgICAgICB9LFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiB7XG5cbiAgICAgICAgICBsb2c6IGZyYWdtZW50TG9nLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4RnJhZ21lbnRcblxuICAgICAgICB9XG5cbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICAvLyBjbGVhbiB1cFxuXG4gICAgZ2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuICAgIGdsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cbiAgICB2YXIgY2FjaGVkVW5pZm9ybXM7XG5cbiAgICB0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjYWNoZWRVbmlmb3JtcyA9IGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG5cbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcblxuICAgIHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgdGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICggY2FjaGVkQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcblxuICAgIH07XG5cbiAgICAvLyBERVBSRUNBVEVEXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9ICk7XG5cblxuICAgIC8vXG5cbiAgICB0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQgKys7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnVzZWRUaW1lcyA9IDE7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb3BlcnRpZXMuanNcblxuLyoqXG4qIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXG4qL1xuXG5USFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgdmFyIHV1aWQgPSBvYmplY3QudXVpZDtcbiAgICB2YXIgbWFwID0gcHJvcGVydGllc1sgdXVpZCBdO1xuXG4gICAgaWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbWFwID0ge307XG4gICAgICBwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuXG4gIH07XG5cbiAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIGRlbGV0ZSBwcm9wZXJ0aWVzWyBvYmplY3QudXVpZCBdO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHByb3BlcnRpZXMgPSB7fTtcblxuICB9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkZXIuanNcblxuVEhSRUUuV2ViR0xTaGFkZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgYWRkTGluZU51bWJlcnMgPSBmdW5jdGlvbiAoIHN0cmluZyApIHtcblxuICAgIHZhciBsaW5lcyA9IHN0cmluZy5zcGxpdCggJ1xcbicgKTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgbGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oICdcXG4nICk7XG5cbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG4gICAgZ2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cbiAgICBpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xuXG4gICAgfVxuXG4gICAgLy8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cbiAgICAvLyBjb25zb2xlLmxvZyggdHlwZSwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG4gICAgcmV0dXJuIHNoYWRlcjtcblxuICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZG93TWFwLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xTaGFkb3dNYXAgPSBmdW5jdGlvbiAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX29iamVjdHMgKSB7XG5cbiAgdmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0LFxuICBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGUsXG4gIF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcbiAgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gIF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICBfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICBfbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gIF9yZW5kZXJMaXN0ID0gW107XG5cbiAgLy8gaW5pdFxuXG4gIHZhciBkZXB0aFNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkZXB0aFJHQkFcIiBdO1xuICB2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XG5cbiAgdmFyIF9kZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyXG4gICB9ICk7XG5cbiAgdmFyIF9kZXB0aE1hdGVyaWFsTW9ycGggPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgbW9ycGhUYXJnZXRzOiB0cnVlXG4gIH0gKTtcblxuICB2YXIgX2RlcHRoTWF0ZXJpYWxTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG4gICAgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG4gICAgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgIHNraW5uaW5nOiB0cnVlXG4gIH0gKTtcblxuICB2YXIgX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgbW9ycGhUYXJnZXRzOiB0cnVlLFxuICAgIHNraW5uaW5nOiB0cnVlXG4gIH0gKTtcblxuICBfZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XG4gIF9kZXB0aE1hdGVyaWFsTW9ycGguX3NoYWRvd1Bhc3MgPSB0cnVlO1xuICBfZGVwdGhNYXRlcmlhbFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xuICBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XG5cbiAgLy9cblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLnR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XG4gIHRoaXMuY3VsbEZhY2UgPSBUSFJFRS5DdWxsRmFjZUZyb250O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcbiAgICBpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIC8vIHNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwXG5cbiAgICBfZ2wuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xuICAgIF9zdGF0ZS5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcblxuICAgIF9zdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcbiAgICBfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cbiAgICBpZiAoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG4gICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG4gICAgfVxuXG4gICAgX3N0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuXG4gICAgLy8gcmVuZGVyIGRlcHRoIG1hcFxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBsaWdodCA9IF9saWdodHNbIGkgXTtcblxuICAgICAgaWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgaWYgKCAhIGxpZ2h0LnNoYWRvd01hcCApIHtcblxuICAgICAgICB2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgIGlmICggc2NvcGUudHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcblxuICAgICAgICAgIHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlciwgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xuXG4gICAgICAgIGxpZ2h0LnNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgcGFycyApO1xuICAgICAgICBsaWdodC5zaGFkb3dNYXBTaXplID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQgKTtcblxuICAgICAgICBsaWdodC5zaGFkb3dNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggISBsaWdodC5zaGFkb3dDYW1lcmEgKSB7XG5cbiAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuICAgICAgICAgIGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhRm92LCBsaWdodC5zaGFkb3dNYXBXaWR0aCAvIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG4gICAgICAgICAgbGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhTGVmdCwgbGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCwgbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tLCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5TaGFkb3dNYXBQbHVnaW46IFVuc3VwcG9ydGVkIGxpZ2h0IHR5cGUgZm9yIHNoYWRvd1wiLCBsaWdodCApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzY2VuZS5hZGQoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xuXG4gICAgICAgIGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICYmICEgbGlnaHQuY2FtZXJhSGVscGVyICkge1xuXG4gICAgICAgIGxpZ2h0LmNhbWVyYUhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xuICAgICAgICBzY2VuZS5hZGQoIGxpZ2h0LmNhbWVyYUhlbHBlciApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBzaGFkb3dNYXAgPSBsaWdodC5zaGFkb3dNYXA7XG4gICAgICB2YXIgc2hhZG93TWF0cml4ID0gbGlnaHQuc2hhZG93TWF0cml4O1xuICAgICAgdmFyIHNoYWRvd0NhbWVyYSA9IGxpZ2h0LnNoYWRvd0NhbWVyYTtcblxuICAgICAgLy9cblxuICAgICAgc2hhZG93Q2FtZXJhLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgIF9tYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgICAgc2hhZG93Q2FtZXJhLmxvb2tBdCggX21hdHJpeFBvc2l0aW9uICk7XG4gICAgICBzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgICAgLy9cblxuICAgICAgaWYgKCBsaWdodC5jYW1lcmFIZWxwZXIgKSBsaWdodC5jYW1lcmFIZWxwZXIudmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG4gICAgICBpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgKSBsaWdodC5jYW1lcmFIZWxwZXIudXBkYXRlKCk7XG5cbiAgICAgIC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxuXG4gICAgICBzaGFkb3dNYXRyaXguc2V0KFxuICAgICAgICAwLjUsIDAuMCwgMC4wLCAwLjUsXG4gICAgICAgIDAuMCwgMC41LCAwLjAsIDAuNSxcbiAgICAgICAgMC4wLCAwLjAsIDAuNSwgMC41LFxuICAgICAgICAwLjAsIDAuMCwgMC4wLCAxLjBcbiAgICAgICk7XG5cbiAgICAgIHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcbiAgICAgIHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG4gICAgICAvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cbiAgICAgIF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgICBfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgICAvLyByZW5kZXIgc2hhZG93IG1hcFxuXG4gICAgICBfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcbiAgICAgIF9yZW5kZXJlci5jbGVhcigpO1xuXG4gICAgICAvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXG5cbiAgICAgIF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgIHByb2plY3RPYmplY3QoIHNjZW5lLCBzaGFkb3dDYW1lcmEgKTtcblxuXG4gICAgICAvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB2YXIgb2JqZWN0ID0gX3JlbmRlckxpc3RbIGogXTtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xuXG4gICAgICAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgICAgICAgICB2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG4gICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGdyb3Vwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XG4gICAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG4gICAgICAgICAgICBpZiAoIGdyb3VwTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIG51bGwsIGdlb21ldHJ5LCBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwgKSwgb2JqZWN0LCBncm91cCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgbnVsbCwgZ2VvbWV0cnksIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwgKSwgb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIEdMIHN0YXRlXG5cbiAgICB2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXG4gICAgY2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cbiAgICBfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xuICAgIF9zdGF0ZS5lbmFibGUoIF9nbC5CTEVORCApO1xuXG4gICAgaWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG4gICAgfVxuXG4gICAgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gICAgc2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICB2YXIgdXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBtYXRlcmlhbC5tb3JwaFRhcmdldHM7XG4gICAgdmFyIHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmc7XG5cbiAgICB2YXIgZGVwdGhNYXRlcmlhbDtcblxuICAgIGlmICggb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWwgKSB7XG5cbiAgICAgIGRlcHRoTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuICAgIH0gZWxzZSBpZiAoIHVzZVNraW5uaW5nICkge1xuXG4gICAgICBkZXB0aE1hdGVyaWFsID0gdXNlTW9ycGhpbmcgPyBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA6IF9kZXB0aE1hdGVyaWFsU2tpbjtcblxuICAgIH0gZWxzZSBpZiAoIHVzZU1vcnBoaW5nICkge1xuXG4gICAgICBkZXB0aE1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWxNb3JwaDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGRlcHRoTWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcblxuICAgIH1cblxuICAgIGRlcHRoTWF0ZXJpYWwudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XG4gICAgZGVwdGhNYXRlcmlhbC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XG4gICAgZGVwdGhNYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICByZXR1cm4gZGVwdGhNYXRlcmlhbDtcblxuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEgKSB7XG5cbiAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgKSB7XG5cbiAgICAgIGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgICAgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICAgICAgICBfcmVuZGVyTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xuXG4gICAgfVxuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU3RhdGUuanNcblxuLyoqXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4qL1xuXG5USFJFRS5XZWJHTFN0YXRlID0gZnVuY3Rpb24gKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKSB7XG5cbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xuICB2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcblxuICB2YXIgY2FwYWJpbGl0aWVzID0ge307XG5cbiAgdmFyIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cbiAgdmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG4gIHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcbiAgdmFyIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcblxuICB2YXIgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xuXG4gIHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuICB2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cbiAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xuXG4gIHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuICB2YXIgY3VycmVudFRleHR1cmVTbG90ID0gdW5kZWZpbmVkO1xuICB2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBnbC5jbGVhckNvbG9yKCAwLCAwLCAwLCAxICk7XG4gICAgZ2wuY2xlYXJEZXB0aCggMSApO1xuICAgIGdsLmNsZWFyU3RlbmNpbCggMCApO1xuXG4gICAgdGhpcy5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcbiAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcbiAgICBnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xuICAgIHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICB9O1xuXG4gIHRoaXMuaW5pdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLmVuYWJsZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXR0cmlidXRlICkge1xuXG4gICAgbmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcbiAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XG5cbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG4gICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XG5cbiAgICBpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcblxuICAgICAgZ2wuZW5hYmxlKCBpZCApO1xuICAgICAgY2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XG5cbiAgICBpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XG5cbiAgICAgIGdsLmRpc2FibGUoIGlkICk7XG4gICAgICBjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPT09IG51bGwgKSB7XG5cbiAgICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xuXG4gICAgICBpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XG4gICAgICAgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgKSB7XG5cbiAgICAgICAgdmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMucHVzaCggZm9ybWF0c1sgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xuXG4gIH07XG5cbiAgdGhpcy5nZXRNYXhQcmVjaXNpb24gPSBmdW5jdGlvbiAoIHByZWNpc2lvbiApIHtcblxuICAgIGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xuXG4gICAgICBpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcbiAgICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuXG4gICAgICB9XG5cbiAgICAgIHByZWNpc2lvbiA9ICdtZWRpdW1wJztcblxuICAgIH1cblxuICAgIGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XG5cbiAgICAgIGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG4gICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG4gICAgICAgIHJldHVybiAnbWVkaXVtcCc7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiAnbG93cCc7XG5cbiAgfTtcblxuICB0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24gKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEgKSB7XG5cbiAgICBpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgKSB7XG5cbiAgICAgIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk5vQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcblxuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcblxuICAgICAgICAvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuICAgICAgICB0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5NdWx0aXBseUJsZW5kaW5nICkge1xuXG4gICAgICAgIC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuXG4gICAgICAgIHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgICAgICBnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXG4gICAgfVxuXG4gICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cbiAgICAgIGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuICAgICAgYmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG4gICAgICBibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcblxuICAgICAgaWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcblxuICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG4gICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XG5cbiAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xuXG4gICAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuICAgICAgICBjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcbiAgICAgICAgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuICAgICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcbiAgICAgIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldERlcHRoRnVuYyA9IGZ1bmN0aW9uICggZGVwdGhGdW5jICkge1xuXG4gICAgaWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgIGlmICggZGVwdGhGdW5jICkge1xuXG4gICAgICAgIHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgIGNhc2UgVEhSRUUuTmV2ZXJEZXB0aDpcblxuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFRIUkVFLkFsd2F5c0RlcHRoOlxuXG4gICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFRIUkVFLkxlc3NEZXB0aDpcblxuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgVEhSRUUuTGVzc0VxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgVEhSRUUuRXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJFcXVhbERlcHRoOlxuXG4gICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJEZXB0aDpcblxuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgVEhSRUUuTm90RXF1YWxEZXB0aDpcblxuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xuXG4gICAgaWYgKCBkZXB0aFRlc3QgKSB7XG5cbiAgICAgIHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcblxuICAgIGlmICggY3VycmVudERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XG5cbiAgICAgIGdsLmRlcHRoTWFzayggZGVwdGhXcml0ZSApO1xuICAgICAgY3VycmVudERlcHRoV3JpdGUgPSBkZXB0aFdyaXRlO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRDb2xvcldyaXRlID0gZnVuY3Rpb24gKCBjb2xvcldyaXRlICkge1xuXG4gICAgaWYgKCBjdXJyZW50Q29sb3JXcml0ZSAhPT0gY29sb3JXcml0ZSApIHtcblxuICAgICAgZ2wuY29sb3JNYXNrKCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlLCBjb2xvcldyaXRlICk7XG4gICAgICBjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldEZsaXBTaWRlZCA9IGZ1bmN0aW9uICggZmxpcFNpZGVkICkge1xuXG4gICAgaWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XG5cbiAgICAgIGlmICggZmxpcFNpZGVkICkge1xuXG4gICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uICggd2lkdGggKSB7XG5cbiAgICBpZiAoIHdpZHRoICE9PSBjdXJyZW50TGluZVdpZHRoICkge1xuXG4gICAgICBnbC5saW5lV2lkdGgoIHdpZHRoICk7XG5cbiAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0UG9seWdvbk9mZnNldCA9IGZ1bmN0aW9uICggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuICAgIGlmICggcG9seWdvbk9mZnNldCApIHtcblxuICAgICAgdGhpcy5lbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMuZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBwb2x5Z29uT2Zmc2V0ICYmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xuXG4gICAgICBnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XG5cbiAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xuICAgICAgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggc2Npc3NvclRlc3QgKSB7XG5cbiAgICBpZiAoIHNjaXNzb3JUZXN0ICkge1xuXG4gICAgICB0aGlzLmVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLmRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gdGV4dHVyZVxuXG4gIHRoaXMuYWN0aXZlVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xTbG90ICkge1xuXG4gICAgaWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG4gICAgaWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuICAgICAgZ2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG4gICAgICBjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuYmluZFRleHR1cmUgPSBmdW5jdGlvbiAoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICkge1xuXG4gICAgaWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgX3RoaXMuYWN0aXZlVGV4dHVyZSgpO1xuXG4gICAgfVxuXG4gICAgdmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcblxuICAgIGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcbiAgICAgIGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXSA9IGJvdW5kVGV4dHVyZTtcblxuICAgIH1cblxuICAgIGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xuXG4gICAgICBnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKTtcblxuICAgICAgYm91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG4gICAgICBib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuY29tcHJlc3NlZFRleEltYWdlMkQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0cnkge1xuXG4gICAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgfSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy50ZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdHJ5IHtcblxuICAgICAgZ2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgfSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy9cblxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XG5cbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG4gICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjYXBhYmlsaXRpZXMgPSB7fTtcblxuICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cbiAgICBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXG4gICAgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xuICAgIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcblxuICAgIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuXG4gIH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL0xlbnNGbGFyZVBsdWdpbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGZsYXJlcyApIHtcblxuICB2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuICB2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcblxuICB2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICB2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG4gIHZhciBoYXNWZXJ0ZXhUZXh0dXJlO1xuXG4gIHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAgIC0gMSwgLSAxLCAgMCwgMCxcbiAgICAgICAxLCAtIDEsICAxLCAwLFxuICAgICAgIDEsICAxLCAgMSwgMSxcbiAgICAgIC0gMSwgIDEsICAwLCAxXG4gICAgXSApO1xuXG4gICAgdmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG4gICAgICAwLCAxLCAyLFxuICAgICAgMCwgMiwgM1xuICAgIF0gKTtcblxuICAgIC8vIGJ1ZmZlcnNcblxuICAgIHZlcnRleEJ1ZmZlciAgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBlbGVtZW50QnVmZmVyICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgIC8vIHRleHR1cmVzXG5cbiAgICB0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIG9jY2x1c2lvblRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG4gICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cbiAgICBoYXNWZXJ0ZXhUZXh0dXJlID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA+IDA7XG5cbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKCBoYXNWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICBzaGFkZXIgPSB7XG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXG4gICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcbiAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG4gICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcInZVViA9IHV2O1wiLFxuXG4gICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuICAgICAgICAgICAgICBcInZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcblxuICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcIixcbiAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXG4gICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1wiLFxuICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcIixcblxuICAgICAgICAgICAgICBcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG4gICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cbiAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxuXG4gICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAvLyBwaW5rIHNxdWFyZVxuXG4gICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcblxuICAgICAgICAgICAgLy8gcmVzdG9yZVxuXG4gICAgICAgICAgICBcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG4gICAgICAgICAgICAvLyBmbGFyZVxuXG4gICAgICAgICAgICBcIn0gZWxzZSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cbiAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc2hhZGVyID0ge1xuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcbiAgICAgICAgICBcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcbiAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cbiAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cbiAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cbiAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJ2VVYgPSB1djtcIixcblxuICAgICAgICAgICAgXCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuICAgICAgICAgICAgICBcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICBcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxuXG4gICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cbiAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cbiAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgLy8gcGluayBzcXVhcmVcblxuICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxuXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKCBtYXAsIHZVViApLnJnYiwgMC4wICk7XCIsXG5cbiAgICAgICAgICAgIC8vIHJlc3RvcmVcblxuICAgICAgICAgICAgXCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblxuICAgICAgICAgICAgLy8gZmxhcmVcblxuICAgICAgICAgICAgXCJ9IGVsc2Uge1wiLFxuXG4gICAgICAgICAgICAgIFwiZmxvYXQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXG5cbiAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XG5cbiAgICBhdHRyaWJ1dGVzID0ge1xuICAgICAgdmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwicG9zaXRpb25cIiApLFxuICAgICAgdXY6ICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwidXZcIiApXG4gICAgfTtcblxuICAgIHVuaWZvcm1zID0ge1xuICAgICAgcmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcbiAgICAgIG1hcDogICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwibWFwXCIgKSxcbiAgICAgIG9jY2x1c2lvbk1hcDogICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKSxcbiAgICAgIG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXG4gICAgICBjb2xvcjogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcImNvbG9yXCIgKSxcbiAgICAgIHNjYWxlOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NhbGVcIiApLFxuICAgICAgcm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXG4gICAgICBzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKVxuICAgIH07XG5cbiAgfTtcblxuICAvKlxuICAgKiBSZW5kZXIgbGVucyBmbGFyZXNcbiAgICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcbiAgICogICAgICAgICByZWFkcyB0aGVzZSBiYWNrIGFuZCBjYWxjdWxhdGVzIG9jY2x1c2lvbi5cbiAgICovXG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0ICkge1xuXG4gICAgaWYgKCBmbGFyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG4gICAgdmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgaW52QXNwZWN0ID0gdmlld3BvcnRIZWlnaHQgLyB2aWV3cG9ydFdpZHRoLFxuICAgICAgaGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoICogMC41LFxuICAgICAgaGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XG5cbiAgICB2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQsXG4gICAgICBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cbiAgICB2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxuICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGluaXQoKTtcblxuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG4gICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xuICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xuICAgIC8vIHNldHVwIGdsIGFuZCBjb21tb24gdXNlZCBhdHRyaWJzL3VuaWZvcm1zXG5cbiAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xuICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuICAgIHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuICAgIGdsLmRlcHRoTWFzayggZmFsc2UgKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcbiAgICAgIHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG4gICAgICAvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cblxuICAgICAgdmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XG5cbiAgICAgIHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcblxuICAgICAgdGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgICAgdGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgICAgLy8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xuXG4gICAgICBzY3JlZW5Qb3NpdGlvbi5jb3B5KCB0ZW1wUG9zaXRpb24gKTtcblxuICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xuICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKyBoYWxmVmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgIC8vIHNjcmVlbiBjdWxsXG5cbiAgICAgIGlmICggaGFzVmVydGV4VGV4dHVyZSB8fCAoXG4gICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPiAwICYmXG4gICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPCB2aWV3cG9ydFdpZHRoICYmXG4gICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPiAwICYmXG4gICAgICAgIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPCB2aWV3cG9ydEhlaWdodCApICkge1xuXG4gICAgICAgIC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XG5cblxuICAgICAgICAvLyByZW5kZXIgcGluayBxdWFkXG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XG4gICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcbiAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuXG4gICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XG4gICAgICAgIHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cbiAgICAgICAgLy8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICAgICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XG5cblxuICAgICAgICAvLyByZXN0b3JlIGdyYXBoaWNzXG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAxICk7XG4gICAgICAgIHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuICAgICAgICAvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xuXG4gICAgICAgIGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XG5cbiAgICAgICAgaWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcblxuICAgICAgICAgIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbmRlciBmbGFyZXNcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcbiAgICAgICAgc3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgICAgdmFyIHNwcml0ZSA9IGZsYXJlLmxlbnNGbGFyZXNbIGogXTtcblxuICAgICAgICAgIGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcblxuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueCA9IHNwcml0ZS54O1xuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xuICAgICAgICAgICAgc2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xuXG4gICAgICAgICAgICBzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydEhlaWdodDtcblxuICAgICAgICAgICAgc2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XG4gICAgICAgICAgICBzY2FsZS55ID0gc2l6ZTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcblxuICAgICAgICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCBzcHJpdGUudGV4dHVyZSwgMSApO1xuXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZ2xcblxuICAgIHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgc3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG4gICAgZ2wuZGVwdGhNYXNrKCB0cnVlICk7XG5cbiAgICByZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCBzaGFkZXIgKSB7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuXG4gICAgdmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcblxuICAgIGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xuICAgIGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XG5cbiAgICBnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cbiAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgcmV0dXJuIHByb2dyYW07XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9TcHJpdGVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcHJpdGVQbHVnaW4gPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzcHJpdGVzICkge1xuXG4gIHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gIHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG4gIHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG4gIHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuICB2YXIgdGV4dHVyZTtcblxuICAvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcblxuICB2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuICAgICAgLSAwLjUsIC0gMC41LCAgMCwgMCxcbiAgICAgICAgMC41LCAtIDAuNSwgIDEsIDAsXG4gICAgICAgIDAuNSwgICAwLjUsICAxLCAxLFxuICAgICAgLSAwLjUsICAgMC41LCAgMCwgMVxuICAgIF0gKTtcblxuICAgIHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuICAgICAgMCwgMSwgMixcbiAgICAgIDAsIDIsIDNcbiAgICBdICk7XG5cbiAgICB2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcbiAgICBnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgYXR0cmlidXRlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXG4gICAgICB1djogICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxuICAgIH07XG5cbiAgICB1bmlmb3JtcyA9IHtcbiAgICAgIHV2T2Zmc2V0OiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXG4gICAgICB1dlNjYWxlOiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cbiAgICAgIHJvdGF0aW9uOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG4gICAgICBzY2FsZTogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxuXG4gICAgICBjb2xvcjogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxuICAgICAgbWFwOiAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxuICAgICAgb3BhY2l0eTogICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxuXG4gICAgICBtb2RlbFZpZXdNYXRyaXg6ICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxuXG4gICAgICBmb2dUeXBlOiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXG4gICAgICBmb2dEZW5zaXR5OiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcbiAgICAgIGZvZ05lYXI6ICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcbiAgICAgIGZvZ0ZhcjogICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxuICAgICAgZm9nQ29sb3I6ICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuICAgICAgYWxwaGFUZXN0OiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxuICAgIH07XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICBjYW52YXMud2lkdGggPSA4O1xuICAgIGNhbnZhcy5oZWlnaHQgPSA4O1xuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cbiAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICBpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG4gICAgLy8gc2V0dXAgZ2xcblxuICAgIGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpbml0KCk7XG5cbiAgICB9XG5cbiAgICBnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgIHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICBzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XG5cbiAgICB2YXIgb2xkRm9nVHlwZSA9IDA7XG4gICAgdmFyIHNjZW5lRm9nVHlwZSA9IDA7XG4gICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcblxuICAgIGlmICggZm9nICkge1xuXG4gICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cbiAgICAgIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcbiAgICAgICAgb2xkRm9nVHlwZSA9IDE7XG4gICAgICAgIHNjZW5lRm9nVHlwZSA9IDE7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuICAgICAgICBvbGRGb2dUeXBlID0gMjtcbiAgICAgICAgc2NlbmVGb2dUeXBlID0gMjtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG4gICAgICBvbGRGb2dUeXBlID0gMDtcbiAgICAgIHNjZW5lRm9nVHlwZSA9IDA7XG5cbiAgICB9XG5cblxuICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuICAgICAgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcbiAgICAgIHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xuXG4gICAgfVxuXG4gICAgc3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgLy8gcmVuZGVyIGFsbCBzcHJpdGVzXG5cbiAgICB2YXIgc2NhbGUgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgICBzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XG5cbiAgICAgIHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xuICAgICAgc2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XG5cbiAgICAgIHZhciBmb2dUeXBlID0gMDtcblxuICAgICAgaWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgICAgIGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xuICAgICAgICBvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcblxuICAgICAgfVxuXG4gICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcbiAgICAgIGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcblxuICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcbiAgICAgIGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG4gICAgICBzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuICAgICAgc3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICAgIHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblxuICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcblxuICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCBtYXRlcmlhbC5tYXAsIDAgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XG5cbiAgICAgIH1cblxuICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIGdsXG5cbiAgICBzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICgpIHtcblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xuXG4gICAgICAncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuICAgICAgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcbiAgICAgICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuICAgICAgJ3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcbiAgICAgICd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcbiAgICAgICd1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7JyxcbiAgICAgICd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxuXG4gICAgICAnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JyxcbiAgICAgICdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG4gICAgICAndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgJ3ZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlOycsXG5cbiAgICAgICAgJ3ZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxuXG4gICAgICAgICd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgICAgICAncm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG4gICAgICAgICdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcblxuICAgICAgICAndmVjNCBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxuICAgICAgICAnZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247JyxcbiAgICAgICAgJ2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICdnbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgJ30nXG5cbiAgICBdLmpvaW4oICdcXG4nICkgKTtcblxuICAgIGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIFtcblxuICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cbiAgICAgICd1bmlmb3JtIHZlYzMgY29sb3I7JyxcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcblxuICAgICAgJ3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcbiAgICAgICd1bmlmb3JtIHZlYzMgZm9nQ29sb3I7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsnLFxuICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXG5cbiAgICAgICd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cbiAgICAgICd2b2lkIG1haW4oKSB7JyxcblxuICAgICAgICAndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXG5cbiAgICAgICAgJ2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcblxuICAgICAgICAnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxuXG4gICAgICAgICAgJ2Zsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudzsnLFxuICAgICAgICAgICdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcblxuICAgICAgICAgICdpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxuXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXG5cbiAgICAgICAgICAnfSBlbHNlIHsnLFxuXG4gICAgICAgICAgICAnY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcbiAgICAgICAgICAgICdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXG5cbiAgICAgICAgICAnfScsXG5cbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG4gICAgICAgICd9JyxcblxuICAgICAgJ30nXG5cbiAgICBdLmpvaW4oICdcXG4nICkgKTtcblxuICAgIGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG4gICAgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgICAgcmV0dXJuIGIueiAtIGEuejtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcblxuICAgIH1cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9HZW9tZXRyeVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5HZW9tZXRyeVV0aWxzID0ge1xuXG4gIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcblxuICAgIHZhciBtYXRyaXg7XG5cbiAgICBpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgIGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgbWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcbiAgICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5Mi5nZW9tZXRyeTtcblxuICAgIH1cblxuICAgIGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcblxuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xuICAgIHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9JbWFnZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIERhb3NoZW5nIE11IC8gaHR0cHM6Ly9naXRodWIuY29tL0Rhb3NoZW5nTXUvXG4gKi9cblxuVEhSRUUuSW1hZ2VVdGlscyA9IHtcblxuICBjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxuXG4gIGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuICAgIGxvYWRlci5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCB1bmRlZmluZWQsIG1hcHBpbmcgKTtcblxuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cbiAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICBpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG4gICAgfSApO1xuXG4gICAgdGV4dHVyZS5zb3VyY2VGaWxlID0gdXJsO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfSxcblxuICBsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggYXJyYXksIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgIHZhciBpbWFnZXMgPSBbXTtcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcbiAgICBsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIGltYWdlcywgbWFwcGluZyApO1xuXG4gICAgdmFyIGxvYWRlZCA9IDA7XG5cbiAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cbiAgICAgIGxvYWRlci5sb2FkKCBhcnJheVsgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG4gICAgICAgIHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuICAgICAgICBsb2FkZWQgKz0gMTtcblxuICAgICAgICBpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG4gICAgfTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuICAgICAgbG9hZFRleHR1cmUoIGkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gIH0sXG5cbiAgbG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG4gIH0sXG5cbiAgbG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cbiAgfSxcblxuICBnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xuXG4gICAgLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL2xhYi9oZWlnaHRub3JtYWwvXG5cbiAgICB2YXIgY3Jvc3MgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgIHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcblxuICAgIH07XG5cbiAgICB2YXIgc3VidHJhY3QgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgIHJldHVybiBbIGFbIDAgXSAtIGJbIDAgXSwgYVsgMSBdIC0gYlsgMSBdLCBhWyAyIF0gLSBiWyAyIF0gXTtcblxuICAgIH07XG5cbiAgICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKCBhICkge1xuXG4gICAgICB2YXIgbCA9IE1hdGguc3FydCggYVsgMCBdICogYVsgMCBdICsgYVsgMSBdICogYVsgMSBdICsgYVsgMiBdICogYVsgMiBdICk7XG4gICAgICByZXR1cm4gWyBhWyAwIF0gLyBsLCBhWyAxIF0gLyBsLCBhWyAyIF0gLyBsIF07XG5cbiAgICB9O1xuXG4gICAgZGVwdGggPSBkZXB0aCB8IDE7XG5cbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcblxuICAgIHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKS5kYXRhO1xuICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xuICAgIHZhciBvdXRwdXQgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgIGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xuXG4gICAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKysgKSB7XG5cbiAgICAgICAgdmFyIGx5ID0geSAtIDEgPCAwID8gMCA6IHkgLSAxO1xuICAgICAgICB2YXIgdXkgPSB5ICsgMSA+IGhlaWdodCAtIDEgPyBoZWlnaHQgLSAxIDogeSArIDE7XG4gICAgICAgIHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcbiAgICAgICAgdmFyIHV4ID0geCArIDEgPiB3aWR0aCAtIDEgPyB3aWR0aCAtIDEgOiB4ICsgMTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgIHZhciBvcmlnaW4gPSBbIDAsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgLSAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIC0gMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICBwb2ludHMucHVzaCggWyAwLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICBwb2ludHMucHVzaCggWyAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIDAsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgLSAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXG4gICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgIHZhciBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1fcG9pbnRzOyBpICsrICkge1xuXG4gICAgICAgICAgdmFyIHYxID0gcG9pbnRzWyBpIF07XG4gICAgICAgICAgdmFyIHYyID0gcG9pbnRzWyAoIGkgKyAxICkgJSBudW1fcG9pbnRzIF07XG4gICAgICAgICAgdjEgPSBzdWJ0cmFjdCggdjEsIG9yaWdpbiApO1xuICAgICAgICAgIHYyID0gc3VidHJhY3QoIHYyLCBvcmlnaW4gKTtcbiAgICAgICAgICBub3JtYWxzLnB1c2goIG5vcm1hbGl6ZSggY3Jvc3MoIHYxLCB2MiApICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbCA9IFsgMCwgMCwgMCBdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgbm9ybWFsWyAwIF0gKz0gbm9ybWFsc1sgaSBdWyAwIF07XG4gICAgICAgICAgbm9ybWFsWyAxIF0gKz0gbm9ybWFsc1sgaSBdWyAxIF07XG4gICAgICAgICAgbm9ybWFsWyAyIF0gKz0gbm9ybWFsc1sgaSBdWyAyIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbFsgMCBdIC89IG5vcm1hbHMubGVuZ3RoO1xuICAgICAgICBub3JtYWxbIDEgXSAvPSBub3JtYWxzLmxlbmd0aDtcbiAgICAgICAgbm9ybWFsWyAyIF0gLz0gbm9ybWFscy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGlkeCA9ICggeSAqIHdpZHRoICsgeCApICogNDtcblxuICAgICAgICBvdXRwdXRbIGlkeCBdID0gKCAoIG5vcm1hbFsgMCBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG4gICAgICAgIG91dHB1dFsgaWR4ICsgMSBdID0gKCAoIG5vcm1hbFsgMSBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG4gICAgICAgIG91dHB1dFsgaWR4ICsgMiBdID0gKCBub3JtYWxbIDIgXSAqIDI1NSApIHwgMDtcbiAgICAgICAgb3V0cHV0WyBpZHggKyAzIF0gPSAyNTU7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcblxuICAgIHJldHVybiBjYW52YXM7XG5cbiAgfSxcblxuICBnZW5lcmF0ZURhdGFUZXh0dXJlOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGNvbG9yICkge1xuXG4gICAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCAzICogc2l6ZSApO1xuXG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKCBjb2xvci5yICogMjU1ICk7XG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKCBjb2xvci5nICogMjU1ICk7XG4gICAgdmFyIGIgPSBNYXRoLmZsb29yKCBjb2xvci5iICogMjU1ICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG4gICAgICBkYXRhWyBpICogMyBdICAgICAgPSByO1xuICAgICAgZGF0YVsgaSAqIDMgKyAxIF0gPSBnO1xuICAgICAgZGF0YVsgaSAqIDMgKyAyIF0gPSBiO1xuXG4gICAgfVxuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIFRIUkVFLlJHQkZvcm1hdCApO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvU2NlbmVVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU2NlbmVVdGlscyA9IHtcblxuICBjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XG5cbiAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwO1xuXG4gIH0sXG5cbiAgZGV0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBwYXJlbnQsIHNjZW5lICkge1xuXG4gICAgY2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgIHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XG4gICAgc2NlbmUuYWRkKCBjaGlsZCApO1xuXG4gIH0sXG5cbiAgYXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xuXG4gICAgdmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgbWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgIGNoaWxkLmFwcGx5TWF0cml4KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgIHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcbiAgICBwYXJlbnQuYWRkKCBjaGlsZCApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL0ZvbnRVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRm9yIFRleHQgb3BlcmF0aW9ucyBpbiB0aHJlZS5qcyAoU2VlIFRleHRHZW9tZXRyeSlcbiAqXG4gKiBJdCB1c2VzIHRlY2huaXF1ZXMgdXNlZCBpbjpcbiAqXG4gKiAgVHJpYW5ndWxhdGlvbiBwb3J0ZWQgZnJvbSBBUzNcbiAqICAgIFNpbXBsZSBQb2x5Z29uIFRyaWFuZ3VsYXRpb25cbiAqICAgIGh0dHA6Ly9hY3Rpb25zbmlwcGV0LmNvbS8/cD0xNDYyXG4gKlxuICogIEEgTWV0aG9kIHRvIHRyaWFuZ3VsYXRlIHNoYXBlcyB3aXRoIGhvbGVzXG4gKiAgICBodHRwOi8vd3d3LnNha3JpLm5ldC9ibG9nLzIwMDkvMDYvMTIvYW4tYXBwcm9hY2gtdG8tdHJpYW5ndWxhdGluZy1wb2x5Z29ucy13aXRoLWhvbGVzL1xuICpcbiAqL1xuXG5USFJFRS5Gb250VXRpbHMgPSB7XG5cbiAgZmFjZXM6IHt9LFxuXG4gIC8vIEp1c3QgZm9yIG5vdy4gZmFjZVt3ZWlnaHRdW3N0eWxlXVxuXG4gIGZhY2U6ICdoZWx2ZXRpa2VyJyxcbiAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgc3R5bGU6ICdub3JtYWwnLFxuICBzaXplOiAxNTAsXG4gIGRpdmlzaW9uczogMTAsXG5cbiAgZ2V0RmFjZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdHJ5IHtcblxuICAgICAgcmV0dXJuIHRoaXMuZmFjZXNbIHRoaXMuZmFjZS50b0xvd2VyQ2FzZSgpIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcblxuICAgIH0gY2F0Y2ggKCBlICkge1xuXG4gICAgICB0aHJvdyBcIlRoZSBmb250IFwiICsgdGhpcy5mYWNlICsgXCIgd2l0aCBcIiArIHRoaXMud2VpZ2h0ICsgXCIgd2VpZ2h0IGFuZCBcIiArIHRoaXMuc3R5bGUgKyBcIiBzdHlsZSBpcyBtaXNzaW5nLlwiXG5cbiAgICB9XG5cbiAgfSxcblxuICBsb2FkRmFjZTogZnVuY3Rpb24gKCBkYXRhICkge1xuXG4gICAgdmFyIGZhbWlseSA9IGRhdGEuZmFtaWx5TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdmFyIFRocmVlRm9udCA9IHRoaXM7XG5cbiAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSB8fCB7fTtcblxuICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gfHwge307XG4gICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xuXG4gICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbiAgfSxcblxuICBkcmF3VGV4dDogZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgLy8gUmVuZGVyVGV4dFxuXG4gICAgdmFyIGksXG4gICAgICBmYWNlID0gdGhpcy5nZXRGYWNlKCksXG4gICAgICBzY2FsZSA9IHRoaXMuc2l6ZSAvIGZhY2UucmVzb2x1dGlvbixcbiAgICAgIG9mZnNldCA9IDAsXG4gICAgICBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApLFxuICAgICAgbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuXG4gICAgdmFyIGZvbnRQYXRocyA9IFtdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHZhciBwYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuICAgICAgdmFyIHJldCA9IHRoaXMuZXh0cmFjdEdseXBoUG9pbnRzKCBjaGFyc1sgaSBdLCBmYWNlLCBzY2FsZSwgb2Zmc2V0LCBwYXRoICk7XG4gICAgICBvZmZzZXQgKz0gcmV0Lm9mZnNldDtcblxuICAgICAgZm9udFBhdGhzLnB1c2goIHJldC5wYXRoICk7XG5cbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHdpZHRoXG5cbiAgICB2YXIgd2lkdGggPSBvZmZzZXQgLyAyO1xuICAgIC8vXG4gICAgLy8gZm9yICggcCA9IDA7IHAgPCBhbGxQdHMubGVuZ3RoOyBwKysgKSB7XG4gICAgLy9cbiAgICAvLyAgYWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcbiAgICAvL1xuICAgIC8vIH1cblxuICAgIC8vdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3RQb2ludHMoIGFsbFB0cywgY2hhcmFjdGVyUHRzICk7XG4gICAgLy9leHRyYWN0LmNvbnRvdXIgPSBhbGxQdHM7XG5cbiAgICAvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XG4gICAgLy9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xuXG4gICAgcmV0dXJuIHsgcGF0aHM6IGZvbnRQYXRocywgb2Zmc2V0OiB3aWR0aCB9O1xuXG4gIH0sXG5cblxuXG5cbiAgZXh0cmFjdEdseXBoUG9pbnRzOiBmdW5jdGlvbiAoIGMsIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKSB7XG5cbiAgICB2YXIgcHRzID0gW107XG5cbiAgICB2YXIgaSwgaTIsIGRpdmlzaW9ucyxcbiAgICAgIG91dGxpbmUsIGFjdGlvbiwgbGVuZ3RoLFxuICAgICAgc2NhbGVYLCBzY2FsZVksXG4gICAgICB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MixcbiAgICAgIGxhc3RlLFxuICAgICAgZ2x5cGggPSBmYWNlLmdseXBoc1sgYyBdIHx8IGZhY2UuZ2x5cGhzWyAnPycgXTtcblxuICAgIGlmICggISBnbHlwaCApIHJldHVybjtcblxuICAgIGlmICggZ2x5cGgubyApIHtcblxuICAgICAgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xuICAgICAgbGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XG5cbiAgICAgIHNjYWxlWCA9IHNjYWxlO1xuICAgICAgc2NhbGVZID0gc2NhbGU7XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcblxuICAgICAgICBhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyggYWN0aW9uICk7XG5cbiAgICAgICAgc3dpdGNoICggYWN0aW9uICkge1xuXG4gICAgICAgIGNhc2UgJ20nOlxuXG4gICAgICAgICAgLy8gTW92ZSBUb1xuXG4gICAgICAgICAgeCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICB5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuXG4gICAgICAgICAgcGF0aC5tb3ZlVG8oIHgsIHkgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsJzpcblxuICAgICAgICAgIC8vIExpbmUgVG9cblxuICAgICAgICAgIHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgeSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcbiAgICAgICAgICBwYXRoLmxpbmVUbyggeCwgeSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3EnOlxuXG4gICAgICAgICAgLy8gUXVhZHJhdGljQ3VydmVUb1xuXG4gICAgICAgICAgY3B4ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICBjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuICAgICAgICAgIGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG4gICAgICAgICAgY3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcblxuICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4LCBjcHkgKTtcblxuICAgICAgICAgIGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgICAgaWYgKCBsYXN0ZSApIHtcblxuICAgICAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgICAgICAgZm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcblxuICAgICAgICAgICAgICB2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xuICAgICAgICAgICAgICBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG4gICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYic6XG5cbiAgICAgICAgICAvLyBDdWJpYyBCZXppZXIgQ3VydmVcblxuICAgICAgICAgIGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuICAgICAgICAgIGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuICAgICAgICAgIGNweDIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXG4gICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG4gICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICBpZiAoIGxhc3RlICkge1xuXG4gICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICBmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG4gICAgICAgICAgICAgIHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG4gICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcbiAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG5cbiAgICByZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcblxuICB9XG5cbn07XG5cblxuVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG4gIC8vIFBhcmFtZXRlcnNcblxuICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICB2YXIgc2l6ZSA9IHBhcmFtZXRlcnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplIDogMTAwO1xuICB2YXIgY3VydmVTZWdtZW50cyA9IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzIDogNDtcblxuICB2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb250IDogJ2hlbHZldGlrZXInO1xuICB2YXIgd2VpZ2h0ID0gcGFyYW1ldGVycy53ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2VpZ2h0IDogJ25vcm1hbCc7XG4gIHZhciBzdHlsZSA9IHBhcmFtZXRlcnMuc3R5bGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3R5bGUgOiAnbm9ybWFsJztcblxuICBUSFJFRS5Gb250VXRpbHMuc2l6ZSA9IHNpemU7XG4gIFRIUkVFLkZvbnRVdGlscy5kaXZpc2lvbnMgPSBjdXJ2ZVNlZ21lbnRzO1xuXG4gIFRIUkVFLkZvbnRVdGlscy5mYWNlID0gZm9udDtcbiAgVEhSRUUuRm9udFV0aWxzLndlaWdodCA9IHdlaWdodDtcbiAgVEhSRUUuRm9udFV0aWxzLnN0eWxlID0gc3R5bGU7XG5cbiAgLy8gR2V0IGEgRm9udCBkYXRhIGpzb24gb2JqZWN0XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5Gb250VXRpbHMuZHJhd1RleHQoIHRleHQgKTtcblxuICB2YXIgcGF0aHMgPSBkYXRhLnBhdGhzO1xuICB2YXIgc2hhcGVzID0gW107XG5cbiAgZm9yICggdmFyIHAgPSAwLCBwbCA9IHBhdGhzLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XG5cbiAgfVxuXG4gIHJldHVybiBzaGFwZXM7XG5cbn07XG5cblxuLyoqXG4gKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xuICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcbiAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XG4gKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXG4gKlxuICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcbiAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxuICpcbiAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cbiAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKi9cblxuXG4oIGZ1bmN0aW9uICggbmFtZXNwYWNlICkge1xuXG4gIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gIC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcblxuICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uICggY29udG91ciwgaW5kaWNlcyApIHtcblxuICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cbiAgICBpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgdmVydEluZGljZXMgPSBbXTtcblxuICAgIC8qIHdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIHZlcnRzICovXG5cbiAgICB2YXIgdSwgdiwgdztcblxuICAgIGlmICggYXJlYSggY29udG91ciApID4gMC4wICkge1xuXG4gICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xuXG4gICAgfVxuXG4gICAgdmFyIG52ID0gbjtcblxuICAgIC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cblxuICAgIHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cblxuICAgIGZvciAoIHYgPSBudiAtIDE7IG52ID4gMjsgKSB7XG5cbiAgICAgIC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXG5cbiAgICAgIGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XG5cbiAgICAgICAgLy8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcblxuICAgICAgICAvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xuICAgICAgICAvL3JldHVybiBudWxsO1xuICAgICAgICAvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuRm9udFV0aWxzOiBXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gVHJpYW5ndWxhdGUucHJvY2VzcygpJyApO1xuXG4gICAgICAgIGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgfVxuXG4gICAgICAvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cblxuICAgICAgdSA9IHY7ICAgIGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cbiAgICAgIHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cbiAgICAgIHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuICAgICAgaWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuICAgICAgICB2YXIgYSwgYiwgYywgcywgdDtcblxuICAgICAgICAvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG4gICAgICAgIGEgPSB2ZXJ0c1sgdSBdO1xuICAgICAgICBiID0gdmVydHNbIHYgXTtcbiAgICAgICAgYyA9IHZlcnRzWyB3IF07XG5cbiAgICAgICAgLyogb3V0cHV0IFRyaWFuZ2xlICovXG5cbiAgICAgICAgcmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuICAgICAgICAgIGNvbnRvdXJbIGIgXSxcbiAgICAgICAgICBjb250b3VyWyBjIF0gXSApO1xuXG5cbiAgICAgICAgdmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuICAgICAgICAvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG4gICAgICAgIGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcyArKywgdCArKyApIHtcblxuICAgICAgICAgIHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBudiAtLTtcblxuICAgICAgICAvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xuXG4gICAgICAgIGNvdW50ID0gMiAqIG52O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cblxuICB2YXIgYXJlYSA9IGZ1bmN0aW9uICggY29udG91ciApIHtcblxuICAgIHZhciBuID0gY29udG91ci5sZW5ndGg7XG4gICAgdmFyIGEgPSAwLjA7XG5cbiAgICBmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG4gICAgICBhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiAwLjU7XG5cbiAgfTtcblxuICB2YXIgc25pcCA9IGZ1bmN0aW9uICggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XG5cbiAgICB2YXIgcDtcbiAgICB2YXIgYXgsIGF5LCBieCwgYnk7XG4gICAgdmFyIGN4LCBjeSwgcHgsIHB5O1xuXG4gICAgYXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcbiAgICBheSA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS55O1xuXG4gICAgYnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcbiAgICBieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xuXG4gICAgY3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcbiAgICBjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xuXG4gICAgaWYgKCBFUFNJTE9OID4gKCAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgKSAtICggKCBieSAtIGF5ICkgKiAoIGN4IC0gYXggKSApICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgYVgsIGFZLCBiWCwgYlksIGNYLCBjWTtcbiAgICB2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcbiAgICB2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcblxuICAgIGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcbiAgICBiWCA9IGF4IC0gY3g7ICBiWSA9IGF5IC0gY3k7XG4gICAgY1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xuXG4gICAgZm9yICggcCA9IDA7IHAgPCBuOyBwICsrICkge1xuXG4gICAgICBweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xuICAgICAgcHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcblxuICAgICAgaWYgKCAoICggcHggPT09IGF4ICkgJiYgKCBweSA9PT0gYXkgKSApIHx8XG4gICAgICAgICAoICggcHggPT09IGJ4ICkgJiYgKCBweSA9PT0gYnkgKSApIHx8XG4gICAgICAgICAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApICkgY29udGludWU7XG5cbiAgICAgIGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuICAgICAgYnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XG4gICAgICBjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcblxuICAgICAgLy8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG4gICAgICBhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XG4gICAgICBjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XG4gICAgICBiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cbiAgICAgIGlmICggKCBhQ1JPU1NicCA+PSAtIEVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBFUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9O1xuXG5cbiAgbmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2VzcztcbiAgbmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xuXG4gIHJldHVybiBuYW1lc3BhY2U7XG5cbn0gKSggVEhSRUUuRm9udFV0aWxzICk7XG5cbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXG5cblRIUkVFLnR5cGVmYWNlX2pzID0geyBmYWNlczogVEhSRUUuRm9udFV0aWxzLmZhY2VzLCBsb2FkRmFjZTogVEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlIH07XG5pZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIHNlbGYuX3R5cGVmYWNlX2pzID0gVEhSRUUudHlwZWZhY2VfanM7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpby5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW8gPSBmdW5jdGlvbiAoIGxpc3RlbmVyICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXG4gIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG4gIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICB0aGlzLnNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcblxuICB0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cbiAgdGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG4gIHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG4gIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblxuICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gIHRoaXMucGxheWJhY2tSYXRlID0gMTtcbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cbiAgdmFyIHNjb3BlID0gdGhpcztcblxuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXF1ZXN0Lm9wZW4oICdHRVQnLCBmaWxlLCB0cnVlICk7XG4gIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoIGUgKSB7XG5cbiAgICBzY29wZS5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggdGhpcy5yZXNwb25zZSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cbiAgICAgIHNjb3BlLnNvdXJjZS5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgIGlmICggc2NvcGUuYXV0b3BsYXkgKSBzY29wZS5wbGF5KCk7XG5cbiAgICB9ICk7XG5cbiAgfTtcbiAgcmVxdWVzdC5zZW5kKCk7XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuXG4gIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcbiAgICByZXR1cm47XG5cbiAgfVxuXG4gIHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgc291cmNlLmJ1ZmZlciA9IHRoaXMuc291cmNlLmJ1ZmZlcjtcbiAgc291cmNlLmxvb3AgPSB0aGlzLnNvdXJjZS5sb29wO1xuICBzb3VyY2Uub25lbmRlZCA9IHRoaXMuc291cmNlLm9uZW5kZWQ7XG4gIHNvdXJjZS5zdGFydCggMCwgdGhpcy5zdGFydFRpbWUgKTtcbiAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuXG4gIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICB0aGlzLmNvbm5lY3QoKTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgdGhpcy5zdGFydFRpbWUgPSAwO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICB0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgIHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgIHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcblxuICB9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICB0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuXG4gIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cbiAgICB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLnBsYXliYWNrUmF0ZTtcblxuICB9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUub25FbmRlZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICB0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiB0aGlzLnNvdXJjZS5sb29wO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UmVmRGlzdGFuY2UgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICB0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cbiAgICBwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cbiAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpb0xpc3RlbmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XG5cbiAgdGhpcy5jb250ZXh0ID0gbmV3ICggd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0ICkoKTtcblxufTtcblxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXVkaW9MaXN0ZW5lcjtcblxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG4gICAgdmFyIHVwID0gdGhpcy51cDtcblxuICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuICAgIG9yaWVudGF0aW9uLnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICBsaXN0ZW5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuICAgIGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB1cC54LCB1cC55LCB1cC56ICk7XG5cbiAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcbiAqXG4gKiBTb21lIGNvbW1vbiBvZiBDdXJ2ZSBtZXRob2RzXG4gKiAuZ2V0UG9pbnQodCksIGdldFRhbmdlbnQodClcbiAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYWdlbnRBdCh1KVxuICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcbiAqIC5nZXRMZW5ndGgoKVxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxuICpcbiAqIFRoaXMgZm9sbG93aW5nIGNsYXNzZXMgc3ViY2xhc3NlcyBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyZCBjbGFzc2VzIC0tXG4gKiBUSFJFRS5MaW5lQ3VydmVcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZVxuICogVEhSRUUuQXJjQ3VydmVcbiAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxuICpcbiAqIC0tIDNkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLlNwbGluZUN1cnZlM1xuICogVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aFxuICpcbiAqKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLy8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG4vLyAgLSB0IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICBjb25zb2xlLndhcm4oIFwiVEhSRUUuQ3VydmU6IFdhcm5pbmcsIGdldFBvaW50KCkgbm90IGltcGxlbWVudGVkIVwiICk7XG4gIHJldHVybiBudWxsO1xuXG59O1xuXG4vLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcbi8vIC0gdSBbMCAuLiAxXVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcbiAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcblxufTtcblxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICBpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuICB2YXIgZCwgcHRzID0gW107XG5cbiAgZm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG4gICAgcHRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG4gIH1cblxuICByZXR1cm4gcHRzO1xuXG59O1xuXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgaWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cbiAgdmFyIGQsIHB0cyA9IFtdO1xuXG4gIGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuICAgIHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG4gIH1cblxuICByZXR1cm4gcHRzO1xuXG59O1xuXG4vLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG4gIHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcblxufTtcblxuLy8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICBpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgPyAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA6IDIwMDtcblxuICBpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXG4gICAgJiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxuICAgICYmICEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuICAgIC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG4gIH1cblxuICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgdmFyIGNhY2hlID0gW107XG4gIHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuICB2YXIgcCwgc3VtID0gMDtcblxuICBjYWNoZS5wdXNoKCAwICk7XG5cbiAgZm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG4gICAgY3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XG4gICAgc3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuICAgIGNhY2hlLnB1c2goIHN1bSApO1xuICAgIGxhc3QgPSBjdXJyZW50O1xuXG4gIH1cblxuICB0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG4gIHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxufTtcblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUudXBkYXRlQXJjTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB0aGlzLmdldExlbmd0aHMoKTtcblxufTtcblxuLy8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VXRvVG1hcHBpbmcgPSBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xuXG4gIHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cbiAgdmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXG4gIHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG4gIGlmICggZGlzdGFuY2UgKSB7XG5cbiAgICB0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG4gIH1cblxuICAvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuICAvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG4gIHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xuXG4gIHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cbiAgICBpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuICAgIGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XG5cbiAgICBpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG4gICAgICBsb3cgPSBpICsgMTtcblxuICAgIH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xuXG4gICAgICBoaWdoID0gaSAtIDE7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBoaWdoID0gaTtcbiAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBET05FXG5cbiAgICB9XG5cbiAgfVxuXG4gIGkgPSBoaWdoO1xuXG4gIC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcblxuICBpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG4gICAgdmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcbiAgICByZXR1cm4gdDtcblxuICB9XG5cbiAgLy8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuICB2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xuICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG4gIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcblxuICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cbiAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG4gIHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG4gIHJldHVybiB0O1xuXG59O1xuXG4vLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuLy8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciBkZWx0YSA9IDAuMDAwMTtcbiAgdmFyIHQxID0gdCAtIGRlbHRhO1xuICB2YXIgdDIgPSB0ICsgZGVsdGE7XG5cbiAgLy8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG4gIGlmICggdDEgPCAwICkgdDEgPSAwO1xuICBpZiAoIHQyID4gMSApIHQyID0gMTtcblxuICB2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcbiAgdmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cbiAgdmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YiggcHQxICk7XG4gIHJldHVybiB2ZWMubm9ybWFsaXplKCk7XG5cbn07XG5cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcbiAgcmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xuXG59O1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIFV0aWxzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlLlV0aWxzID0ge1xuXG4gIHRhbmdlbnRRdWFkcmF0aWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcblxuICAgIHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xuXG4gIH0sXG5cbiAgLy8gUHVheSBCaW5nLCB0aGFua3MgZm9yIGhlbHBpbmcgd2l0aCB0aGlzIGRlcml2YXRpdmUhXG5cbiAgdGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgcmV0dXJuIC0gMyAqIHAwICogKCAxIC0gdCApICogKCAxIC0gdCApICArXG4gICAgICAzICogcDEgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgLSA2ICogdCAqIHAxICogKCAxIC0gdCApICtcbiAgICAgIDYgKiB0ICogIHAyICogKCAxIC0gdCApIC0gMyAqIHQgKiB0ICogcDIgK1xuICAgICAgMyAqIHQgKiB0ICogcDM7XG5cbiAgfSxcblxuICB0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgLy8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcblxuICAgIHZhciBoMDAgPSA2ICogdCAqIHQgLSA2ICogdDsgIC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxuICAgIHZhciBoMTAgPSAzICogdCAqIHQgLSA0ICogdCArIDE7IC8vIHReMyDiiJIgMnReMiArIHRcbiAgICB2YXIgaDAxID0gLSA2ICogdCAqIHQgKyA2ICogdDsgIC8vIOKIkiAydDMgKyAzdDJcbiAgICB2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7ICAvLyB0MyDiiJIgdDJcblxuICAgIHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XG5cbiAgfSxcblxuICAvLyBDYXRtdWxsLVJvbVxuXG4gIGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cbiAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcbiAgICB2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcbiAgICB2YXIgdDIgPSB0ICogdDtcbiAgICB2YXIgdDMgPSB0ICogdDI7XG4gICAgcmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgfVxuXG59O1xuXG5cbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIDNEIEN1cnZlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XG5cbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZVBhdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZVBhdGggPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5jdXJ2ZXMgPSBbXTtcbiAgdGhpcy5iZW5kcyA9IFtdO1xuXG4gIHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdXJ2ZVBhdGg7XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcblxuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPXG4gIC8vIElmIHRoZSBlbmRpbmcgb2YgY3VydmUgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgc3RhcnRpbmdcbiAgLy8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIFRPRE8gVGVzdFxuICAvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxuICAvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcbiAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XG4gIHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcblxuICBpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XG5cbiAgICB0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cbiAgfVxuXG59O1xuXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cbi8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuLy8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG4vLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gIHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICB2YXIgaSA9IDAsIGRpZmYsIGN1cnZlO1xuXG4gIC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG4gIHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cbiAgICBpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cbiAgICAgIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG4gICAgICBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cbiAgICAgIHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuICAgICAgcmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuICAgIH1cblxuICAgIGkgKys7XG5cbiAgfVxuXG4gIHJldHVybiBudWxsO1xuXG4gIC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG59OyovXG5cblxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICByZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuICAvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cbiAgaWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcblxuICAgIHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuICB9XG5cbiAgLy8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcbiAgLy8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cbiAgdmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XG4gIHZhciBpLCBpbCA9IHRoaXMuY3VydmVzLmxlbmd0aDtcblxuICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgc3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xuICAgIGxlbmd0aHMucHVzaCggc3VtcyApO1xuXG4gIH1cblxuICB0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cbiAgcmV0dXJuIGxlbmd0aHM7XG5cbn07XG5cblxuXG4vLyBSZXR1cm5zIG1pbiBhbmQgbWF4IGNvb3JkaW5hdGVzXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG5cbiAgdmFyIG1heFgsIG1heFksIG1heFo7XG4gIHZhciBtaW5YLCBtaW5ZLCBtaW5aO1xuXG4gIG1heFggPSBtYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBtaW5YID0gbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICB2YXIgcCwgaSwgaWwsIHN1bTtcblxuICB2YXIgdjMgPSBwb2ludHNbIDAgXSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjM7XG5cbiAgc3VtID0gdjMgPyBuZXcgVEhSRUUuVmVjdG9yMygpIDogbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICBmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBwID0gcG9pbnRzWyBpIF07XG5cbiAgICBpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xuICAgIGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcblxuICAgIGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XG4gICAgZWxzZSBpZiAoIHAueSA8IG1pblkgKSBtaW5ZID0gcC55O1xuXG4gICAgaWYgKCB2MyApIHtcblxuICAgICAgaWYgKCBwLnogPiBtYXhaICkgbWF4WiA9IHAuejtcbiAgICAgIGVsc2UgaWYgKCBwLnogPCBtaW5aICkgbWluWiA9IHAuejtcblxuICAgIH1cblxuICAgIHN1bS5hZGQoIHAgKTtcblxuICB9XG5cbiAgdmFyIHJldCA9IHtcblxuICAgIG1pblg6IG1pblgsXG4gICAgbWluWTogbWluWSxcbiAgICBtYXhYOiBtYXhYLFxuICAgIG1heFk6IG1heFlcblxuICB9O1xuXG4gIGlmICggdjMgKSB7XG5cbiAgICByZXQubWF4WiA9IG1heFo7XG4gICAgcmV0Lm1pblogPSBtaW5aO1xuXG4gIH1cblxuICByZXR1cm4gcmV0O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgdmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG4vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW50IHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gIHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XG4gIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55LCBwb2ludHNbIGkgXS56IHx8IDAgKSApO1xuXG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQmVuZCAvIFdyYXAgSGVscGVyIE1ldGhvZHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gV3JhcCBwYXRoIC8gQmVuZCBtb2RpZmllcnM/XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGggPSBmdW5jdGlvbiAoIGJlbmRwYXRoICkge1xuXG4gIHRoaXMuYmVuZHMucHVzaCggYmVuZHBhdGggKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cbiAgdmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBzZWdtZW50cyApOyAvLyBnZXRQb2ludHMgZ2V0U3BhY2VkUG9pbnRzXG4gIHZhciBpLCBpbDtcblxuICBpZiAoICEgYmVuZHMgKSB7XG5cbiAgICBiZW5kcyA9IHRoaXMuYmVuZHM7XG5cbiAgfVxuXG4gIGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgb2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuICB9XG5cbiAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cbiAgdmFyIG9sZFB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBzZWdtZW50cyApO1xuXG4gIHZhciBpLCBpbDtcblxuICBpZiAoICEgYmVuZHMgKSB7XG5cbiAgICBiZW5kcyA9IHRoaXMuYmVuZHM7XG5cbiAgfVxuXG4gIGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgb2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuICB9XG5cbiAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uICggb2xkUHRzLCBwYXRoICkge1xuXG4gIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgdmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcblxuICBmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBwID0gb2xkUHRzWyBpIF07XG5cbiAgICBvbGRYID0gcC54O1xuICAgIG9sZFkgPSBwLnk7XG5cbiAgICB4Tm9ybSA9IG9sZFggLyBib3VuZHMubWF4WDtcblxuICAgIC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xuICAgIC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxuXG4gICAgeE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xuXG4gICAgLy8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cbiAgICB2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcbiAgICB2YXIgbm9ybWFsID0gcGF0aC5nZXRUYW5nZW50KCB4Tm9ybSApO1xuICAgIG5vcm1hbC5zZXQoIC0gbm9ybWFsLnksIG5vcm1hbC54ICkubXVsdGlwbHlTY2FsYXIoIG9sZFkgKTtcblxuICAgIHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XG4gICAgcC55ID0gcGF0aFB0LnkgKyBub3JtYWwueTtcblxuICB9XG5cbiAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxuICpcbiAqKi9cblxuVEhSRUUuUGF0aCA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG4gIFRIUkVFLkN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5hY3Rpb25zID0gW107XG5cbiAgaWYgKCBwb2ludHMgKSB7XG5cbiAgICB0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XG5USFJFRS5QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhdGg7XG5cblRIUkVFLlBhdGhBY3Rpb25zID0ge1xuXG4gIE1PVkVfVE86ICdtb3ZlVG8nLFxuICBMSU5FX1RPOiAnbGluZVRvJyxcbiAgUVVBRFJBVElDX0NVUlZFX1RPOiAncXVhZHJhdGljQ3VydmVUbycsIC8vIEJlemllciBxdWFkcmF0aWMgY3VydmVcbiAgQkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsICAgICAvLyBCZXppZXIgY3ViaWMgY3VydmVcbiAgQ1NQTElORV9USFJVOiAnc3BsaW5lVGhydScsICAgICAgIC8vIENhdG11bGwtUm9tIHNwbGluZVxuICBBUkM6ICdhcmMnLCAgICAgICAgICAgICAgIC8vIENpcmNsZVxuICBFTExJUFNFOiAnZWxsaXBzZSdcbn07XG5cbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcblxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICB0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XG5cbiAgZm9yICggdmFyIHYgPSAxLCB2bGVuID0gdmVjdG9ycy5sZW5ndGg7IHYgPCB2bGVuOyB2ICsrICkge1xuXG4gICAgdGhpcy5saW5lVG8oIHZlY3RvcnNbIHYgXS54LCB2ZWN0b3JzWyB2IF0ueSApO1xuXG4gIH1cblxufTtcblxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5MaW5lQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSwgbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTElORV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhQ1AyeCwgYUNQMnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgYVgsIGFZICkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcbiAgLy8tLS1cbiAgdmFyIG5wdHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSBdO1xuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggbnB0cywgcHRzICk7XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBucHRzICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlUsIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG4vLyBGVVRVUkU6IENoYW5nZSB0aGUgQVBJIG9yIGZvbGxvdyBjYW52YXMgQVBJP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICB0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbiB9O1xuXG4gVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgdGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuIH07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gIHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuIH07XG5cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgdmFyIGFyZ3MgPSBbXG4gICAgYVgsIGFZLFxuICAgIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcbiAgICBhQ2xvY2t3aXNlLFxuICAgIGFSb3RhdGlvbiB8fCAwIC8vIGFSb3RhdGlvbiBpcyBvcHRpb25hbC5cbiAgXTtcbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XG4gIGFyZ3MucHVzaCggbGFzdFBvaW50LnggKTtcbiAgYXJncy5wdXNoKCBsYXN0UG9pbnQueSApO1xuXG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRSwgYXJnczogYXJncyB9ICk7XG5cbiB9O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuICBpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XG5cbiAgdmFyIHBvaW50cyA9IFtdO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IGRpdmlzaW9uczsgaSArKyApIHtcblxuICAgIHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuICAgIC8vaWYoICF0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKSB0aHJvdyBcIkRJRVwiO1xuXG4gIH1cblxuICAvLyBpZiAoIGNsb3NlZFBhdGggKSB7XG4gIC8vXG4gIC8vICBwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcbiAgLy9cbiAgLy8gfVxuXG4gIHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuICBpZiAoIHRoaXMudXNlU3BhY2VkUG9pbnRzICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKTtcblxuICB9XG5cbiAgZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xuXG4gIHZhciBwb2ludHMgPSBbXTtcblxuICB2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcbiAgdmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxuICAgIGxhc3RlLCBqLFxuICAgIHQsIHR4LCB0eTtcblxuICBmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XG5cbiAgICBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcbiAgICBhcmdzID0gaXRlbS5hcmdzO1xuXG4gICAgc3dpdGNoICggYWN0aW9uICkge1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPOlxuXG4gICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE86XG5cbiAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPOlxuXG4gICAgICBjcHggID0gYXJnc1sgMiBdO1xuICAgICAgY3B5ICA9IGFyZ3NbIDMgXTtcblxuICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcbiAgICAgIGNweTEgPSBhcmdzWyAxIF07XG5cbiAgICAgIGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG4gICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcblxuICAgICAgICB0ID0gaiAvIGRpdmlzaW9ucztcblxuICAgICAgICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcbiAgICAgICAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE86XG5cbiAgICAgIGNweCAgPSBhcmdzWyA0IF07XG4gICAgICBjcHkgID0gYXJnc1sgNSBdO1xuXG4gICAgICBjcHgxID0gYXJnc1sgMCBdO1xuICAgICAgY3B5MSA9IGFyZ3NbIDEgXTtcblxuICAgICAgY3B4MiA9IGFyZ3NbIDIgXTtcbiAgICAgIGNweTIgPSBhcmdzWyAzIF07XG5cbiAgICAgIGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgbGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlLng7XG4gICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgICAgY3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG4gICAgICAgIGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG4gICAgICB9XG5cblxuICAgICAgZm9yICggaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xuXG4gICAgICAgIHQgPSBqIC8gZGl2aXNpb25zO1xuXG4gICAgICAgIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuICAgICAgICB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblxuICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVTpcblxuICAgICAgbGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuICAgICAgdmFyIGxhc3QgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSwgbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXSApO1xuICAgICAgdmFyIHNwdHMgPSBbIGxhc3QgXTtcblxuICAgICAgdmFyIG4gPSBkaXZpc2lvbnMgKiBhcmdzWyAwIF0ubGVuZ3RoO1xuXG4gICAgICBzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xuXG4gICAgICB2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IG47IGogKysgKSB7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICk7XG5cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkFSQzpcblxuICAgICAgdmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcbiAgICAgICAgYVJhZGl1cyA9IGFyZ3NbIDIgXSxcbiAgICAgICAgYVN0YXJ0QW5nbGUgPSBhcmdzWyAzIF0sIGFFbmRBbmdsZSA9IGFyZ3NbIDQgXSxcbiAgICAgICAgYUNsb2Nrd2lzZSA9ICEhIGFyZ3NbIDUgXTtcblxuICAgICAgdmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcbiAgICAgIHZhciBhbmdsZTtcbiAgICAgIHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcblxuICAgICAgZm9yICggaiA9IDE7IGogPD0gdGRpdmlzaW9uczsgaiArKyApIHtcblxuICAgICAgICB0ID0gaiAvIHRkaXZpc2lvbnM7XG5cbiAgICAgICAgaWYgKCAhIGFDbG9ja3dpc2UgKSB7XG5cbiAgICAgICAgICB0ID0gMSAtIHQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuICAgICAgICB0eCA9IGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICAgICAgICB0eSA9IGFZICsgYVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcblxuICAgICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cbiAgICAgIH1cblxuICAgICAgLy9jb25zb2xlLmxvZyhwb2ludHMpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRTpcblxuICAgICAgdmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcbiAgICAgICAgeFJhZGl1cyA9IGFyZ3NbIDIgXSxcbiAgICAgICAgeVJhZGl1cyA9IGFyZ3NbIDMgXSxcbiAgICAgICAgYVN0YXJ0QW5nbGUgPSBhcmdzWyA0IF0sIGFFbmRBbmdsZSA9IGFyZ3NbIDUgXSxcbiAgICAgICAgYUNsb2Nrd2lzZSA9ICEhIGFyZ3NbIDYgXSxcbiAgICAgICAgYVJvdGF0aW9uID0gYXJnc1sgNyBdO1xuXG5cbiAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG4gICAgICB2YXIgYW5nbGU7XG4gICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cbiAgICAgIHZhciBjb3MsIHNpbjtcbiAgICAgIGlmICggYVJvdGF0aW9uICE9PSAwICkge1xuXG4gICAgICAgIGNvcyA9IE1hdGguY29zKCBhUm90YXRpb24gKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oIGFSb3RhdGlvbiApO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cbiAgICAgICAgdCA9IGogLyB0ZGl2aXNpb25zO1xuXG4gICAgICAgIGlmICggISBhQ2xvY2t3aXNlICkge1xuXG4gICAgICAgICAgdCA9IDEgLSB0O1xuXG4gICAgICAgIH1cblxuICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgICAgICAgdHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgdHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgICAgICBpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcblxuICAgICAgICAgIHZhciB4ID0gdHgsIHkgPSB0eTtcblxuICAgICAgICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICAgICAgICB0eCA9ICggeCAtIGFYICkgKiBjb3MgLSAoIHkgLSBhWSApICogc2luICsgYVg7XG4gICAgICAgICAgdHkgPSAoIHggLSBhWCApICogc2luICsgKCB5IC0gYVkgKSAqIGNvcyArIGFZO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICB9IC8vIGVuZCBzd2l0Y2hcblxuICB9XG5cblxuXG4gIC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cbiAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcbiAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG4gIGlmICggTWF0aC5hYnMoIGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCApIDwgRVBTSUxPTiAmJlxuICAgICAgIE1hdGguYWJzKCBsYXN0UG9pbnQueSAtIHBvaW50c1sgMCBdLnkgKSA8IEVQU0lMT04gKVxuICAgIHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxICk7XG4gIGlmICggY2xvc2VkUGF0aCApIHtcblxuICAgIHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xuXG59O1xuXG4vL1xuLy8gQnJlYWtzIHBhdGggaW50byBzaGFwZXNcbi8vXG4vLyAgQXNzdW1wdGlvbnMgKGlmIHBhcmFtZXRlciBpc0NDVz09dHJ1ZSB0aGUgb3Bwb3NpdGUgaG9sZHMpOlxuLy8gIC0gc29saWQgc2hhcGVzIGFyZSBkZWZpbmVkIGNsb2Nrd2lzZSAoQ1cpXG4vLyAgLSBob2xlcyBhcmUgZGVmaW5lZCBjb3VudGVyY2xvY2t3aXNlIChDQ1cpXG4vL1xuLy8gIElmIHBhcmFtZXRlciBub0hvbGVzPT10cnVlOlxuLy8gIC0gYWxsIHN1YlBhdGhzIGFyZSByZWdhcmRlZCBhcyBzb2xpZCBzaGFwZXNcbi8vICAtIGRlZmluaXRpb24gb3JkZXIgQ1cvQ0NXIGhhcyBubyByZWxldmFuY2Vcbi8vXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oIGlzQ0NXLCBub0hvbGVzICkge1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdWJwYXRocyggaW5BY3Rpb25zICkge1xuXG4gICAgdmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XG5cbiAgICB2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gaW5BY3Rpb25zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBpdGVtID0gaW5BY3Rpb25zWyBpIF07XG5cbiAgICAgIGFyZ3MgPSBpdGVtLmFyZ3M7XG4gICAgICBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcblxuICAgICAgaWYgKCBhY3Rpb24gPT09IFRIUkVFLlBhdGhBY3Rpb25zLk1PVkVfVE8gKSB7XG5cbiAgICAgICAgaWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcblxuICAgICAgICAgIHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG4gICAgICAgICAgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xuXG4gICAgICBzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xuXG4gICAgcmV0dXJuICBzdWJQYXRocztcblxuICB9XG5cbiAgZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG4gICAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG4gICAgICB2YXIgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgIHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG4gICAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuICAgIHJldHVybiBzaGFwZXM7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgIHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXG4gICAgLy8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuICAgIC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcbiAgICAvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuXG4gICAgICB2YXIgZWRnZUxvd1B0ICA9IGluUG9seWdvblsgcCBdO1xuICAgICAgdmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuICAgICAgdmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuICAgICAgdmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgLy8gbm90IHBhcmFsbGVsXG4gICAgICAgIGlmICggZWRnZUR5IDwgMCApIHtcblxuICAgICAgICAgIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XG4gICAgICAgICAgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblxuICAgICAgICB9XG4gICAgICAgIGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XG5cbiAgICAgICAgICBpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKSAgIHJldHVybiAgdHJ1ZTsgICAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgICAgICAgIC8vIGNvbnRpbnVlOyAgICAgICAgLy8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XG4gICAgICAgICAgaWYgKCBwZXJwRWRnZSA9PT0gMCApICAgICAgIHJldHVybiAgdHJ1ZTsgICAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgICAgICAgIGlmICggcGVycEVkZ2UgPCAwICkgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpbnNpZGUgPSAhIGluc2lkZTsgICAgLy8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgICAgICBpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSAgICAgY29udGludWU7ICAgICAvLyBwYXJhbGxlbFxuICAgICAgICAvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcbiAgICAgICAgaWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxuICAgICAgICAgICAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApICAgIHJldHVybiAgdHJ1ZTsgLy8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXG4gICAgICAgIC8vIGNvbnRpbnVlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gIGluc2lkZTtcblxuICB9XG5cblxuICB2YXIgc3ViUGF0aHMgPSBleHRyYWN0U3VicGF0aHMoIHRoaXMuYWN0aW9ucyApO1xuICBpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuICBpZiAoIG5vSG9sZXMgPT09IHRydWUgKSByZXR1cm4gIHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gIHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xuXG4gIGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxICkge1xuXG4gICAgdG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG4gICAgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICB0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgIHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgIHJldHVybiBzaGFwZXM7XG5cbiAgfVxuXG4gIHZhciBob2xlc0ZpcnN0ID0gISBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xuICBob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xuXG4gIC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cbiAgdmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcbiAgdmFyIG5ld1NoYXBlcyA9IFtdO1xuICB2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuICB2YXIgbWFpbklkeCA9IDA7XG4gIHZhciB0bXBQb2ludHM7XG5cbiAgbmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XG4gIG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG4gIHZhciBpLCBpbDtcblxuICBmb3IgKCBpID0gMCwgaWwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuICAgIHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG4gICAgc29saWQgPSBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XG4gICAgc29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcblxuICAgIGlmICggc29saWQgKSB7XG5cbiAgICAgIGlmICggKCAhIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKSBtYWluSWR4ICsrO1xuXG4gICAgICBuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFRIUkVFLlNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xuICAgICAgbmV3U2hhcGVzWyBtYWluSWR4IF0ucy5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgICAgbmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgICAgaWYgKCBob2xlc0ZpcnN0ICkgbWFpbklkeCArKztcbiAgICAgIG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgbmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWyAwIF0gfSApO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXG4gIGlmICggISBuZXdTaGFwZXNbIDAgXSApIHJldHVybiAgdG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cbiAgaWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblxuICAgIHZhciBhbWJpZ3VvdXMgPSBmYWxzZTtcbiAgICB2YXIgdG9DaGFuZ2UgPSBbXTtcblxuICAgIGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG4gICAgICBiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcblxuICAgIH1cbiAgICBmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuICAgICAgdmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbIHNJZHggXTtcbiAgICAgIGZvciAoIHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XG5cbiAgICAgICAgdmFyIGhvID0gc2hvWyBoSWR4IF07XG4gICAgICAgIHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xuXG4gICAgICAgICAgaWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcblxuICAgICAgICAgICAgaWYgKCBzSWR4ICE9PSBzMklkeCApIHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuICAgICAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cbiAgICAgICAgICAgICAgaG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICBhbWJpZ3VvdXMgPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuICAgICAgICAgIGJldHRlclNoYXBlSG9sZXNbIHNJZHggXS5wdXNoKCBobyApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiYW1iaWd1b3VzOiBcIiwgYW1iaWd1b3VzKTtcbiAgICBpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xuICAgICAgaWYgKCAhIGFtYmlndW91cyApICBuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblxuICAgIH1cblxuICB9XG5cbiAgdmFyIHRtcEhvbGVzLCBqLCBqbDtcbiAgZm9yICggaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xuICAgIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuICAgIHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xuICAgIGZvciAoIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICB0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cbiAgcmV0dXJuIHNoYXBlcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICB0aGlzLmhvbGVzID0gW107XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XG5USFJFRS5TaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGUgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cbiAgdmFyIGV4dHJ1ZGVkID0gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuICByZXR1cm4gZXh0cnVkZWQ7XG5cbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICB2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCwgaG9sZXNQdHMgPSBbXTtcblxuICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgaG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XG5cbiAgfVxuXG4gIHJldHVybiBob2xlc1B0cztcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlcyAoc3BhY2VkIGJ5IHJlZ3VsYXIgZGlzdGFuY2UpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcblxuICB9XG5cbiAgcmV0dXJuIGhvbGVzUHRzO1xuXG59O1xuXG5cbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIHJldHVybiB7XG5cbiAgICBzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zICksXG4gICAgaG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cbiAgfTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICBpZiAoIHRoaXMudXNlU3BhY2VkUG9pbnRzICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyggZGl2aXNpb25zICk7XG5cbiAgfVxuXG4gIHJldHVybiB0aGlzLmV4dHJhY3RBbGxQb2ludHMoIGRpdmlzaW9ucyApO1xuXG59O1xuXG4vL1xuLy8gVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHNXaXRoQmVuZCA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBiZW5kICkge1xuLy9cbi8vICByZXR1cm4ge1xuLy9cbi8vICAgIHNoYXBlOiB0aGlzLnRyYW5zZm9ybSggYmVuZCwgZGl2aXNpb25zICksXG4vLyAgICBob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcbi8vXG4vLyAgfTtcbi8vXG4vLyB9O1xuXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoc3BhY2VkIGJ5IHJlZ3VsYXIgZGlzdGFuY2UpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsU3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgcmV0dXJuIHtcblxuICAgIHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgKSxcbiAgICBob2xlczogdGhpcy5nZXRTcGFjZWRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuICB9O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5TaGFwZS5VdGlscyA9IHtcblxuICB0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xuXG4gICAgZnVuY3Rpb24gcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWdQdDEsIGluU2VnUHQyLCBpbk90aGVyUHQgKSB7XG5cbiAgICAgIC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xsaW5lYXIgdG8gdGhlIGluU2VnbWVudFxuICAgICAgaWYgKCBpblNlZ1B0MS54ICE9PSBpblNlZ1B0Mi54ICkge1xuXG4gICAgICAgIGlmICggaW5TZWdQdDEueCA8IGluU2VnUHQyLnggKSB7XG5cbiAgICAgICAgICByZXR1cm4gICggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmV0dXJuICAoICggaW5TZWdQdDIueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDEueCApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmICggaW5TZWdQdDEueSA8IGluU2VnUHQyLnkgKSB7XG5cbiAgICAgICAgICByZXR1cm4gICggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmV0dXJuICAoICggaW5TZWdQdDIueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDEueSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xuXG4gICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgdmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcbiAgICAgIHZhciBzZWcyZHggPSBpblNlZzJQdDIueCAtIGluU2VnMlB0MS54LCAgIHNlZzJkeSA9IGluU2VnMlB0Mi55IC0gaW5TZWcyUHQxLnk7XG5cbiAgICAgIHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcbiAgICAgIHZhciBzZWcxc2VnMmR5ID0gaW5TZWcxUHQxLnkgLSBpblNlZzJQdDEueTtcblxuICAgICAgdmFyIGxpbWl0ICAgPSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG4gICAgICB2YXIgcGVycFNlZzEgID0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIGxpbWl0ICkgPiBFUFNJTE9OICkge1xuXG4gICAgICAgIC8vIG5vdCBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBwZXJwU2VnMjtcbiAgICAgICAgaWYgKCBsaW1pdCA+IDAgKSB7XG5cbiAgICAgICAgICBpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG4gICAgICAgICAgaWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgICAgIHJldHVybiBbXTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCAoIHBlcnBTZWcxID4gMCApIHx8ICggcGVycFNlZzEgPCBsaW1pdCApICkgICAgIHJldHVybiBbXTtcbiAgICAgICAgICBwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuICAgICAgICAgIGlmICggKCBwZXJwU2VnMiA+IDAgKSB8fCAoIHBlcnBTZWcyIDwgbGltaXQgKSApICAgICByZXR1cm4gW107XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xuICAgICAgICBpZiAoIHBlcnBTZWcyID09PSAwICkge1xuXG4gICAgICAgICAgaWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgICAgICAgICAgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApICkgICByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIHBlcnBTZWcyID09PSBsaW1pdCApIHtcblxuICAgICAgICAgIGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MiBdO1xuXG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMj9cbiAgICAgICAgaWYgKCBwZXJwU2VnMSA9PT0gMCApICAgcmV0dXJuIFsgaW5TZWcyUHQxIF07XG4gICAgICAgIGlmICggcGVycFNlZzEgPT09IGxpbWl0ICkgcmV0dXJuIFsgaW5TZWcyUHQyIF07XG5cbiAgICAgICAgLy8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcbiAgICAgICAgcmV0dXJuICBbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxuICAgICAgICAgICAgICB5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgICAgICBpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxuICAgICAgICAgICAoIHNlZzJkeSAqIHNlZzFzZWcyZHggIT09IHNlZzJkeCAqIHNlZzFzZWcyZHkgKSApICAgICAgcmV0dXJuIFtdO1xuXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXG4gICAgICAgIHZhciBzZWcxUHQgPSAoICggc2VnMWR4ID09PSAwICkgJiYgKCBzZWcxZHkgPT09IDAgKSApOyAgLy8gc2VnbWVudDEgaXMganVzdCBhIHBvaW50P1xuICAgICAgICB2YXIgc2VnMlB0ID0gKCAoIHNlZzJkeCA9PT0gMCApICYmICggc2VnMmR5ID09PSAwICkgKTsgIC8vIHNlZ21lbnQyIGlzIGp1c3QgYSBwb2ludD9cbiAgICAgICAgLy8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXG4gICAgICAgIGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcblxuICAgICAgICAgIGlmICggKCBpblNlZzFQdDEueCAhPT0gaW5TZWcyUHQxLnggKSB8fFxuICAgICAgICAgICAgICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKSAgICByZXR1cm4gW107ICAvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXG4gICAgICAgICAgcmV0dXJuIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSB0aGUgc2FtZSBwb2ludFxuXG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VnbWVudCMxICBpcyBhIHNpbmdsZSBwb2ludFxuICAgICAgICBpZiAoIHNlZzFQdCApIHtcblxuICAgICAgICAgIGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5TZWcxUHQxICkgKSAgIHJldHVybiBbXTsgICAgLy8gYnV0IG5vdCBpbiBzZWdtZW50IzJcbiAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuICAgICAgICB9XG4gICAgICAgIC8vIHNlZ21lbnQjMiAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgaWYgKCBzZWcyUHQgKSB7XG5cbiAgICAgICAgICBpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApICkgICByZXR1cm4gW107ICAgIC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXG4gICAgICAgICAgcmV0dXJuIFsgaW5TZWcyUHQxIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBzZWdtZW50cywgd2hpY2ggbWlnaHQgb3ZlcmxhcFxuICAgICAgICB2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcbiAgICAgICAgdmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XG4gICAgICAgIGlmICggc2VnMWR4ICE9PSAwICkge1xuXG4gICAgICAgICAgLy8gdGhlIHNlZ21lbnRzIGFyZSBOT1Qgb24gYSB2ZXJ0aWNhbCBsaW5lXG4gICAgICAgICAgaWYgKCBpblNlZzFQdDEueCA8IGluU2VnMVB0Mi54ICkge1xuXG4gICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLng7XG4gICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLng7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLng7XG4gICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLng7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBpblNlZzJQdDEueCA8IGluU2VnMlB0Mi54ICkge1xuXG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLng7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIHRoZSBzZWdtZW50cyBhcmUgb24gYSB2ZXJ0aWNhbCBsaW5lXG4gICAgICAgICAgaWYgKCBpblNlZzFQdDEueSA8IGluU2VnMVB0Mi55ICkge1xuXG4gICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XG4gICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLnk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLnk7XG4gICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLnk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xuXG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLnk7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLnk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPD0gc2VnMm1pblZhbCApIHtcblxuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsICkgcmV0dXJuIFtdO1xuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApICB7XG5cbiAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIFsgc2VnMm1pbiBdO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsICkgcmV0dXJuIFsgc2VnMm1pbiwgc2VnMW1heCBdO1xuICAgICAgICAgIHJldHVybiAgWyBzZWcybWluLCBzZWcybWF4IF07XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsICkgcmV0dXJuIFtdO1xuICAgICAgICAgIGlmICggc2VnMW1pblZhbCA9PT0gc2VnMm1heFZhbCApICB7XG5cbiAgICAgICAgICAgIGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIFsgc2VnMW1pbiBdO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsICkgcmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xuICAgICAgICAgIHJldHVybiAgWyBzZWcxbWluLCBzZWcybWF4IF07XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XG5cbiAgICAgIC8vIFRoZSBvcmRlciBvZiBsZWdzIGlzIGltcG9ydGFudFxuXG4gICAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgICAgLy8gdHJhbnNsYXRpb24gb2YgYWxsIHBvaW50cywgc28gdGhhdCBWZXJ0ZXggaXMgYXQgKDAsMClcbiAgICAgIHZhciBsZWdGcm9tUHRYICA9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LCAgbGVnRnJvbVB0WSA9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuICAgICAgdmFyIGxlZ1RvUHRYICA9IGluTGVnVG9QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ1RvUHRZICAgPSBpbkxlZ1RvUHQueSAtIGluVmVydGV4Lnk7XG4gICAgICB2YXIgb3RoZXJQdFggID0gaW5PdGhlclB0LnggLSBpblZlcnRleC54LCAgb3RoZXJQdFkgICA9IGluT3RoZXJQdC55IC0gaW5WZXJ0ZXgueTtcblxuICAgICAgLy8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG4gICAgICB2YXIgZnJvbTJ0b0FuZ2xlICA9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcbiAgICAgIHZhciBmcm9tMm90aGVyQW5nbGUgPSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gRVBTSUxPTiApIHtcblxuICAgICAgICAvLyBhbmdsZSAhPSAxODAgZGVnLlxuXG4gICAgICAgIHZhciBvdGhlcjJ0b0FuZ2xlICAgPSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG4gICAgICAgIGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcblxuICAgICAgICAgIC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxuICAgICAgICAgIHJldHVybiAgKCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cbiAgICAgICAgICByZXR1cm4gICggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gYW5nbGUgPT0gMTgwIGRlZy5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xuICAgICAgICByZXR1cm4gICggZnJvbTJvdGhlckFuZ2xlID4gMCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcblxuICAgICAgdmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG4gICAgICB2YXIgaG9sZTtcblxuICAgICAgZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcbiAgICAgICAgdmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdmFyIHByZXZTaGFwZUlkeCA9IGluU2hhcGVJZHggLSAxO1xuICAgICAgICBpZiAoIHByZXZTaGFwZUlkeCA8IDAgKSAgICAgcHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xuXG4gICAgICAgIHZhciBuZXh0U2hhcGVJZHggPSBpblNoYXBlSWR4ICsgMTtcbiAgICAgICAgaWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKSAgbmV4dFNoYXBlSWR4ID0gMDtcblxuICAgICAgICB2YXIgaW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIHNoYXBlWyBpblNoYXBlSWR4IF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlWyBpbkhvbGVJZHggXSApO1xuICAgICAgICBpZiAoICEgaW5zaWRlQW5nbGUgKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xuICAgICAgICAgIHJldHVybiAgZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XG4gICAgICAgIHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcblxuICAgICAgICB2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xuICAgICAgICBpZiAoIHByZXZIb2xlSWR4IDwgMCApICAgICAgcHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcblxuICAgICAgICB2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xuICAgICAgICBpZiAoIG5leHRIb2xlSWR4ID4gbGFzdEhvbGVJZHggKSAgbmV4dEhvbGVJZHggPSAwO1xuXG4gICAgICAgIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xuICAgICAgICBpZiAoICEgaW5zaWRlQW5nbGUgKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKEhvbGUpOiBcIiArIGluSG9sZUlkeCArIFwiLCBQb2ludDogXCIgKyBzaGFwZVtpblNoYXBlSWR4XS54ICsgXCIvXCIgKyBzaGFwZVtpblNoYXBlSWR4XS55ICk7XG4gICAgICAgICAgcmV0dXJuICBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICB0cnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cbiAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggc2hhcGUgZWRnZXNcbiAgICAgICAgdmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICAgICAgZm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHggKysgKSB7XG5cbiAgICAgICAgICBuZXh0SWR4ID0gc0lkeCArIDE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xuICAgICAgICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbIHNJZHggXSwgc2hhcGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKSAgICByZXR1cm4gIHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgZmFsc2U7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVwSG9sZXMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG4gICAgICAgIC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGhvbGUgZWRnZXNcbiAgICAgICAgdmFyIGloSWR4LCBjaGtIb2xlLFxuICAgICAgICAgIGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICAgICAgZm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCArKyApIHtcblxuICAgICAgICAgIGNoa0hvbGUgPSBob2xlc1sgaW5kZXBIb2xlc1sgaWhJZHggXV07XG4gICAgICAgICAgZm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcblxuICAgICAgICAgICAgbmV4dElkeCA9IGhJZHggKyAxOyBuZXh0SWR4ICU9IGNoa0hvbGUubGVuZ3RoO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBjaGtIb2xlWyBoSWR4IF0sIGNoa0hvbGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApICAgIHJldHVybiAgdHJ1ZTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAgZmFsc2U7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcbiAgICAgICAgc2hhcGVQdCwgaG9sZVB0LFxuICAgICAgICBob2xlSWR4LCBjdXRLZXksIGZhaWxlZEN1dHMgPSBbXSxcbiAgICAgICAgdG1wU2hhcGUxLCB0bXBTaGFwZTIsXG4gICAgICAgIHRtcEhvbGUxLCB0bXBIb2xlMjtcblxuICAgICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICAgIGluZGVwSG9sZXMucHVzaCggaCApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5TaGFwZUluZGV4ID0gMDtcbiAgICAgIHZhciBjb3VudGVyID0gaW5kZXBIb2xlcy5sZW5ndGggKiAyO1xuICAgICAgd2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgY291bnRlciAtLTtcbiAgICAgICAgaWYgKCBjb3VudGVyIDwgMCApIHtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxuICAgICAgICAvLyB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuICAgICAgICBmb3IgKCBzaGFwZUluZGV4ID0gbWluU2hhcGVJbmRleDsgc2hhcGVJbmRleCA8IHNoYXBlLmxlbmd0aDsgc2hhcGVJbmRleCArKyApIHtcblxuICAgICAgICAgIHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xuICAgICAgICAgIGhvbGVJbmRleCA9IC0gMTtcblxuICAgICAgICAgIC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICAgICAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaCArKyApIHtcblxuICAgICAgICAgICAgaG9sZUlkeCA9IGluZGVwSG9sZXNbIGggXTtcblxuICAgICAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBjaGVja3NcbiAgICAgICAgICAgIGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xuICAgICAgICAgICAgaWYgKCBmYWlsZWRDdXRzWyBjdXRLZXkgXSAhPT0gdW5kZWZpbmVkICkgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBob2xlID0gaG9sZXNbIGhvbGVJZHggXTtcbiAgICAgICAgICAgIGZvciAoIHZhciBoMiA9IDA7IGgyIDwgaG9sZS5sZW5ndGg7IGgyICsrICkge1xuXG4gICAgICAgICAgICAgIGhvbGVQdCA9IGhvbGVbIGgyIF07XG4gICAgICAgICAgICAgIGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKSAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzU2hhcGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApICAgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c0hvbGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgIGhvbGVJbmRleCA9IGgyO1xuICAgICAgICAgICAgICBpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xuXG4gICAgICAgICAgICAgIHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xuICAgICAgICAgICAgICB0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xuICAgICAgICAgICAgICB0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuICAgICAgICAgICAgICB0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcblxuICAgICAgICAgICAgICBzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XG5cbiAgICAgICAgICAgICAgbWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XG5cbiAgICAgICAgICAgICAgLy8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xuICAgICAgICAgICAgICAvLyBnbG9iX0N1dExpbmVzLnB1c2goIFsgc2hhcGVQdCwgaG9sZVB0IF0gKTtcblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBob2xlSW5kZXggPj0gMCApIGJyZWFrOyAgICAvLyBob2xlLXZlcnRleCBmb3VuZFxuXG4gICAgICAgICAgICBmYWlsZWRDdXRzWyBjdXRLZXkgXSA9IHRydWU7ICAgICAgLy8gcmVtZW1iZXIgZmFpbHVyZVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggaG9sZUluZGV4ID49IDAgKSBicmVhazsgICAgLy8gaG9sZS12ZXJ0ZXggZm91bmRcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXBlOyAgICAgICAvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXG5cbiAgICB9XG5cblxuICAgIHZhciBpLCBpbCwgZiwgZmFjZSxcbiAgICAgIGtleSwgaW5kZXgsXG4gICAgICBhbGxQb2ludHNNYXAgPSB7fTtcblxuICAgIC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuICAgIHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG4gICAgZm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1sgaCBdICk7XG5cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xuXG4gICAgLy8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xuXG4gICAgICBpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcblxuICAgICAgfVxuXG4gICAgICBhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcblxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcbiAgICB2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcblxuICAgIHZhciB0cmlhbmdsZXMgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcbiAgICAvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xuXG4gICAgLy8gY2hlY2sgYWxsIGZhY2UgdmVydGljZXMgYWdhaW5zdCBhbGwgcG9pbnRzIG1hcFxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBmYWNlID0gdHJpYW5nbGVzWyBpIF07XG5cbiAgICAgIGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcblxuICAgICAgICBrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XG5cbiAgICAgICAgaW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGZhY2VbIGYgXSA9IGluZGV4O1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcblxuICB9LFxuXG4gIGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcblxuICAgIHJldHVybiBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggcHRzICkgPCAwO1xuXG4gIH0sXG5cbiAgLy8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcblxuICAvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcblxuICBiMnAwOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICB2YXIgayA9IDEgLSB0O1xuICAgIHJldHVybiBrICogayAqIHA7XG5cbiAgfSxcblxuICBiMnAxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICByZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG4gIH0sXG5cbiAgYjJwMjogZnVuY3Rpb24gKCB0LCBwICkge1xuXG4gICAgcmV0dXJuIHQgKiB0ICogcDtcblxuICB9LFxuXG4gIGIyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5iMnAwKCB0LCBwMCApICsgdGhpcy5iMnAxKCB0LCBwMSApICsgdGhpcy5iMnAyKCB0LCBwMiApO1xuXG4gIH0sXG5cbiAgLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gIGIzcDA6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIHA7XG5cbiAgfSxcblxuICBiM3AxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICB2YXIgayA9IDEgLSB0O1xuICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxuICB9LFxuXG4gIGIzcDI6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuXG4gIH0sXG5cbiAgYjNwMzogZnVuY3Rpb24gKCB0LCBwICkge1xuXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cbiAgfSxcblxuICBiMzogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgIHJldHVybiB0aGlzLmIzcDAoIHQsIHAwICkgKyB0aGlzLmIzcDEoIHQsIHAxICkgKyB0aGlzLmIzcDIoIHQsIHAyICkgKyAgdGhpcy5iM3AzKCB0LCBwMyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgTGluZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuICB0aGlzLnYxID0gdjE7XG4gIHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICB2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XG4gIHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cbiAgcmV0dXJuIHBvaW50O1xuXG59O1xuXG4vLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG4gIHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xuXG4gIHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIFF1YWRyYXRpYyBCZXppZXIgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcblxuICB0aGlzLnYwID0gdjA7XG4gIHRoaXMudjEgPSB2MTtcbiAgdGhpcy52MiA9IHYyO1xuXG59O1xuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlO1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICB2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG4gIHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblxuICByZXR1cm4gdmVjdG9yO1xuXG59O1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG4gIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG4gIC8vIHJldHVybnMgdW5pdCB2ZWN0b3JcblxuICByZXR1cm4gdmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ3ViaWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG4gIHRoaXMudjAgPSB2MDtcbiAgdGhpcy52MSA9IHYxO1xuICB0aGlzLnYyID0gdjI7XG4gIHRoaXMudjMgPSB2MztcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgdmFyIHR4LCB0eTtcblxuICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcbiAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciB0eCwgdHk7XG5cbiAgdHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuICB0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cbiAgdmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG4gIHRhbmdlbnQubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIHRhbmdlbnQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgU3BsaW5lIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcblxuICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbn07XG5cblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BsaW5lQ3VydmU7XG5cblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gIHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cbiAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgdmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICB2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICB2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcbiAgdmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cbiAgcmV0dXJuIHZlY3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgRWxsaXBzZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5FbGxpcHNlQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG4gIHRoaXMuYVggPSBhWDtcbiAgdGhpcy5hWSA9IGFZO1xuXG4gIHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XG4gIHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cbiAgdGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuICB0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcblxuICB0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG4gIHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XG5cbn07XG5cblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FbGxpcHNlQ3VydmU7XG5cblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgdmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cbiAgaWYgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gIGlmICggZGVsdGFBbmdsZSA+IE1hdGguUEkgKiAyICkgZGVsdGFBbmdsZSAtPSBNYXRoLlBJICogMjtcblxuICB2YXIgYW5nbGU7XG5cbiAgaWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgKSB7XG5cbiAgICBhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcblxuICB9IGVsc2Uge1xuXG4gICAgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgfVxuXG4gIHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuICB2YXIgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICBpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcblxuICAgIHZhciB0eCA9IHgsIHR5ID0geTtcblxuICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICB4ID0gKCB0eCAtIHRoaXMuYVggKSAqIGNvcyAtICggdHkgLSB0aGlzLmFZICkgKiBzaW4gKyB0aGlzLmFYO1xuICAgIHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XG5cbiAgfVxuXG4gIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gIFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxufTtcblxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBMaW5lM0RcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICBmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuICAgIHRoaXMudjEgPSB2MTtcbiAgICB0aGlzLnYyID0gdjI7XG5cbiAgfSxcblxuICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcbiAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIHQgKTtcbiAgICB2ZWN0b3IuYWRkKCB0aGlzLnYxICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG4gIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgUXVhZHJhdGljIEJlemllciAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG4gICAgdGhpcy52MCA9IHYwO1xuICAgIHRoaXMudjEgPSB2MTtcbiAgICB0aGlzLnYyID0gdjI7XG5cbiAgfSxcblxuICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XG4gICAgdmVjdG9yLnogPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxuICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ3ViaWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gIGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XG5cbiAgICB0aGlzLnYwID0gdjA7XG4gICAgdGhpcy52MSA9IHYxO1xuICAgIHRoaXMudjIgPSB2MjtcbiAgICB0aGlzLnYzID0gdjM7XG5cbiAgfSxcblxuICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xuICAgIHZlY3Rvci56ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxuICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIFNwbGluZSAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xuICAgIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuICB9LFxuXG4gIGZ1bmN0aW9uICggdCApIHtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgIHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICAgIHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgdmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG4gICAgdmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcbiAgICB2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG4gICAgdmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG4gICAgcmV0dXJuIHZlY3RvcjtcblxuICB9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICpcbiAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cbiAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXG4gKlxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG4gKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XG4gKi9cblxuVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyA9ICggZnVuY3Rpb24oKSB7XG5cbiAgdmFyXG4gICAgdG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBweCA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBweSA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBweiA9IG5ldyBDdWJpY1BvbHkoKTtcblxuICAvKlxuICBCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gICAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXG4gICAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG4gIFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbiAgYnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXG4gIHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cbiAgKi9cblxuICBmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XG5cbiAgfVxuXG4gIC8qXG4gICAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcbiAgICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG4gICAqIHN1Y2ggdGhhdFxuICAgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXG4gICAqICBhbmRcbiAgICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuICAgKi9cbiAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIHgwLCB4MSwgdDAsIHQxICkge1xuXG4gICAgdGhpcy5jMCA9IHgwO1xuICAgIHRoaXMuYzEgPSB0MDtcbiAgICB0aGlzLmMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcbiAgICB0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblxuICB9O1xuXG4gIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG4gICAgLy8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuICAgIHZhciB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XG4gICAgdmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuICAgIC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuICAgIHQxICo9IGR0MTtcbiAgICB0MiAqPSBkdDE7XG5cbiAgICAvLyBpbml0Q3ViaWNQb2x5XG4gICAgdGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xuXG4gIH07XG5cbiAgLy8gc3RhbmRhcmQgQ2F0bXVsbC1Sb20gc3BsaW5lOiBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHgxIGFuZCB4MiB3aXRoIHByZXZpb3VzL2ZvbGxvd2luZyBwb2ludHMgeDEveDRcbiAgQ3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Q2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgdGVuc2lvbiApIHtcblxuICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG4gIH07XG5cbiAgQ3ViaWNQb2x5LnByb3RvdHlwZS5jYWxjID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICB2YXIgdDIgPSB0ICogdDtcbiAgICB2YXIgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcblxuICB9O1xuXG4gIC8vIFN1YmNsYXNzIFRocmVlLmpzIGN1cnZlXG4gIHJldHVybiBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgICBmdW5jdGlvbiAoIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgICAgdGhpcy5wb2ludHMgPSBwIHx8IFtdO1xuXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uICggdCApIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICBwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgbDtcblxuICAgICAgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGlmICggbCA8IDIgKSBjb25zb2xlLmxvZyggJ2R1aCwgeW91IG5lZWQgYXQgbGVhc3QgMiBwb2ludHMnICk7XG5cbiAgICAgIHBvaW50ID0gKCBsIC0gMSApICogdDtcbiAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcblxuICAgICAgICBpbnRQb2ludCA9IGwgLSAyO1xuICAgICAgICB3ZWlnaHQgPSAxO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBwMCwgcDEsIHAyLCBwMztcblxuICAgICAgaWYgKCBpbnRQb2ludCA9PT0gMCApIHtcblxuICAgICAgICAvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxuICAgICAgICB0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuICAgICAgICBwMCA9IHRtcDtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBwMCA9IHBvaW50c1sgaW50UG9pbnQgLSAxIF07XG5cbiAgICAgIH1cblxuICAgICAgcDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgICBwMiA9IHBvaW50c1sgaW50UG9pbnQgKyAxIF07XG5cbiAgICAgIGlmICggaW50UG9pbnQgKyAyIDwgbCApIHtcblxuICAgICAgICBwMyA9IHBvaW50c1sgaW50UG9pbnQgKyAyIF1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG4gICAgICAgIHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMiBdICk7XG4gICAgICAgIHAzID0gdG1wO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy50eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy50eXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG4gICAgICAgIC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG4gICAgICAgIHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG4gICAgICAgIHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xuICAgICAgICB2YXIgZHQxID0gTWF0aC5wb3coIHAxLmRpc3RhbmNlVG9TcXVhcmVkKCBwMiApLCBwb3cgKTtcbiAgICAgICAgdmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cbiAgICAgICAgLy8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcbiAgICAgICAgaWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xuICAgICAgICBpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG4gICAgICAgIGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcblxuICAgICAgICBweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcbiAgICAgICAgcHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG4gICAgICAgIHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xuXG4gICAgICB9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcblxuICAgICAgICB2YXIgdGVuc2lvbiA9IHRoaXMudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy50ZW5zaW9uIDogMC41O1xuICAgICAgICBweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGVuc2lvbiApO1xuICAgICAgICBweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xuICAgICAgICBwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGVuc2lvbiApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIHB4LmNhbGMoIHdlaWdodCApLFxuICAgICAgICBweS5jYWxjKCB3ZWlnaHQgKSxcbiAgICAgICAgcHouY2FsYyggd2VpZ2h0IClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB2O1xuXG4gICAgfVxuXG4gICk7XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0Nsb3NlZFNwbGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDbG9zZWQgU3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gIGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cbiAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbiAgfSxcblxuICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDsgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXG5cbiAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgaW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xuXG4gICAgdmFyIHBvaW50MCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcbiAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyAoIGludFBvaW50ICAgICApICUgcG9pbnRzLmxlbmd0aCBdO1xuICAgIHZhciBwb2ludDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBwb2ludHMubGVuZ3RoIF07XG4gICAgdmFyIHBvaW50MyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIHBvaW50cy5sZW5ndGggXTtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKTtcbiAgICB2ZWN0b3IueiA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueiwgcG9pbnQxLnosIHBvaW50Mi56LCBwb2ludDMueiwgd2VpZ2h0ICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG4gIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9BbmltYXRpb25IYW5kbGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb25IYW5kbGVyID0ge1xuXG4gIExJTkVBUjogMCxcbiAgQ0FUTVVMTFJPTTogMSxcbiAgQ0FUTVVMTFJPTV9GT1JXQVJEOiAyLFxuXG4gIC8vXG5cbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApO1xuXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTtcblxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7XG5cbiAgfSxcblxuICAvL1xuXG4gIGFuaW1hdGlvbnM6IFtdLFxuXG4gIGluaXQ6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuICAgIGlmICggZGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSApIHJldHVybiBkYXRhO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBrZXlzXG5cbiAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGggKysgKSB7XG5cbiAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG1pbnVzIHRpbWVzXG5cbiAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lIDwgMCApIHtcblxuICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID0gMDtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHF1YXRlcm5pb25zXG5cbiAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgKSB7XG5cbiAgICAgICAgICB2YXIgcXVhdCA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdDtcbiAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLmZyb21BcnJheSggcXVhdCApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIG1vcnBoIHRhcmdldCBrZXlzXG5cbiAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aCAmJiBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAvLyBnZXQgYWxsIHVzZWRcblxuICAgICAgICB2YXIgdXNlZE1vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgbSA9IDA7IG0gPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xuXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXROYW1lID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF07XG4gICAgICAgICAgICB1c2VkTW9ycGhUYXJnZXRzWyBtb3JwaFRhcmdldE5hbWUgXSA9IC0gMTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS51c2VkTW9ycGhUYXJnZXRzID0gdXNlZE1vcnBoVGFyZ2V0cztcblxuXG4gICAgICAgIC8vIHNldCBhbGwgdXNlZCBvbiBhbGwgZnJhbWVzXG5cbiAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICAgIHZhciBpbmZsdWVuY2VzID0ge307XG5cbiAgICAgICAgICBmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIHVzZWRNb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXSA9PT0gbW9ycGhUYXJnZXROYW1lICkge1xuXG4gICAgICAgICAgICAgICAgaW5mbHVlbmNlc1sgbW9ycGhUYXJnZXROYW1lIF0gPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzWyBtIF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbSA9PT0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICBpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXMgPSBpbmZsdWVuY2VzO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cbiAgICAgIC8vIHJlbW92ZSBhbGwga2V5cyB0aGF0IGFyZSBvbiB0aGUgc2FtZSB0aW1lXG5cbiAgICAgIGZvciAoIHZhciBrID0gMTsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgLSAxIF0udGltZSApIHtcblxuICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5zcGxpY2UoIGssIDEgKTtcbiAgICAgICAgICBrIC0tO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cbiAgICAgIC8vIHNldCBpbmRleFxuXG4gICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xuXG4gICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLmluZGV4ID0gaztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZGF0YS5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICByZXR1cm4gZGF0YTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIHJvb3QgKSB7XG5cbiAgICB2YXIgcGFyc2VSZWN1cnNlSGllcmFyY2h5ID0gZnVuY3Rpb24gKCByb290LCBoaWVyYXJjaHkgKSB7XG5cbiAgICAgIGhpZXJhcmNoeS5wdXNoKCByb290ICk7XG5cbiAgICAgIGZvciAoIHZhciBjID0gMDsgYyA8IHJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBjICsrIClcbiAgICAgICAgcGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LmNoaWxkcmVuWyBjIF0sIGhpZXJhcmNoeSApO1xuXG4gICAgfTtcblxuICAgIC8vIHNldHVwIGhpZXJhcmNoeVxuXG4gICAgdmFyIGhpZXJhcmNoeSA9IFtdO1xuXG4gICAgaWYgKCByb290IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgIGZvciAoIHZhciBiID0gMDsgYiA8IHJvb3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBiICsrICkge1xuXG4gICAgICAgIGhpZXJhcmNoeS5wdXNoKCByb290LnNrZWxldG9uLmJvbmVzWyBiIF0gKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LCBoaWVyYXJjaHkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBoaWVyYXJjaHk7XG5cbiAgfSxcblxuICBwbGF5OiBmdW5jdGlvbiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGlmICggdGhpcy5hbmltYXRpb25zLmluZGV4T2YoIGFuaW1hdGlvbiApID09PSAtIDEgKSB7XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKCBhbmltYXRpb24gKTtcblxuICAgIH1cblxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICggYW5pbWF0aW9uICkge1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5hbmltYXRpb25zLmluZGV4T2YoIGFuaW1hdGlvbiApO1xuXG4gICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoIGRlbHRhVGltZU1TICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgdGhpcy5hbmltYXRpb25zWyBpIF0ucmVzZXRCbGVuZFdlaWdodHMoICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbnNbIGkgXS51cGRhdGUoIGRlbHRhVGltZU1TICk7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb24gPSBmdW5jdGlvbiAoIHJvb3QsIGRhdGEgKSB7XG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5pbml0KCBkYXRhICk7XG4gIHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggcm9vdCApO1xuXG4gIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB0aGlzLnRpbWVTY2FsZSA9IDE7XG5cbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgdGhpcy53ZWlnaHQgPSAwO1xuXG4gIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUjtcblxufTtcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uLFxuXG4gIGtleVR5cGVzOiAgWyBcInBvc1wiLCBcInJvdFwiLCBcInNjbFwiIF0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCBzdGFydFRpbWUsIHdlaWdodCApIHtcblxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHdlaWdodCA6IDE7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgIGlmICggb2JqZWN0LmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgb2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge1xuICAgICAgICAgIGFuaW1hdGlvbnM6IHt9LFxuICAgICAgICAgIGJsZW5kaW5nOiB7XG4gICAgICAgICAgICBwb3NpdGlvbldlaWdodDogMC4wLFxuICAgICAgICAgICAgcXVhdGVybmlvbldlaWdodDogMC4wLFxuICAgICAgICAgICAgc2NhbGVXZWlnaHQ6IDAuMFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9ucztcbiAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IGFuaW1hdGlvbnNbIG5hbWUgXTtcblxuICAgICAgaWYgKCBhbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGFuaW1hdGlvbkNhY2hlID0ge1xuICAgICAgICAgIHByZXZLZXk6IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9LFxuICAgICAgICAgIG5leHRLZXk6IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9LFxuICAgICAgICAgIG9yaWdpbmFsTWF0cml4OiBvYmplY3QubWF0cml4XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pbWF0aW9uc1sgbmFtZSBdID0gYW5pbWF0aW9uQ2FjaGU7XG5cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGtleXMgdG8gbWF0Y2ggb3VyIGN1cnJlbnQgdGltZVxuXG4gICAgICBmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5rZXlUeXBlc1sgdCBdO1xuXG4gICAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcbiAgICAgICAgdmFyIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cbiAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgcHJldktleSA9IG5leHRLZXk7XG4gICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XG4gICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIHJlc2V0QmxlbmRXZWlnaHRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICBpZiAoIGFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIGJsZW5kaW5nID0gYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmc7XG5cbiAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgPSAwLjA7XG4gICAgICAgIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSAwLjA7XG4gICAgICAgIGJsZW5kaW5nLnNjYWxlV2VpZ2h0ID0gMC4wO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICB1cGRhdGU6ICggZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5ld1ZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG5ld1F1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgLy8gQ2F0bXVsbC1Sb20gc3BsaW5lXG5cbiAgICB2YXIgaW50ZXJwb2xhdGVDYXRtdWxsUm9tID0gZnVuY3Rpb24gKCBwb2ludHMsIHNjYWxlICkge1xuXG4gICAgICB2YXIgYyA9IFtdLCB2MyA9IFtdLFxuICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcbiAgICAgIHBhLCBwYiwgcGMsIHBkO1xuXG4gICAgICBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHNjYWxlO1xuICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgICAgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICAgICAgY1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcbiAgICAgIGNbIDEgXSA9IGludFBvaW50O1xuICAgICAgY1sgMiBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IGludFBvaW50IDogaW50UG9pbnQgKyAxO1xuICAgICAgY1sgMyBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IGludFBvaW50IDogaW50UG9pbnQgKyAyO1xuXG4gICAgICBwYSA9IHBvaW50c1sgY1sgMCBdIF07XG4gICAgICBwYiA9IHBvaW50c1sgY1sgMSBdIF07XG4gICAgICBwYyA9IHBvaW50c1sgY1sgMiBdIF07XG4gICAgICBwZCA9IHBvaW50c1sgY1sgMyBdIF07XG5cbiAgICAgIHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xuICAgICAgdzMgPSB3ZWlnaHQgKiB3MjtcblxuICAgICAgdjNbIDAgXSA9IGludGVycG9sYXRlKCBwYVsgMCBdLCBwYlsgMCBdLCBwY1sgMCBdLCBwZFsgMCBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgdjNbIDEgXSA9IGludGVycG9sYXRlKCBwYVsgMSBdLCBwYlsgMSBdLCBwY1sgMSBdLCBwZFsgMSBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgICAgdjNbIDIgXSA9IGludGVycG9sYXRlKCBwYVsgMiBdLCBwYlsgMiBdLCBwY1sgMiBdLCBwZFsgMiBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuXG4gICAgICByZXR1cm4gdjM7XG5cbiAgICB9O1xuXG4gICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xuXG4gICAgICB2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcbiAgICAgICAgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgICAgcmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cbiAgICAgIGlmICggdGhpcy53ZWlnaHQgPT09IDAgKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vXG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG5cbiAgICAgIGlmICggdGhpcy5jdXJyZW50VGltZSA+IGR1cmF0aW9uIHx8IHRoaXMuY3VycmVudFRpbWUgPCAwICkge1xuXG4gICAgICAgIGlmICggdGhpcy5sb29wICkge1xuXG4gICAgICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcblxuICAgICAgICAgIGlmICggdGhpcy5jdXJyZW50VGltZSA8IDAgKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkdXJhdGlvbjtcblxuICAgICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkNhY2hlID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbIHRoaXMuZGF0YS5uYW1lIF07XG4gICAgICAgIHZhciBibGVuZGluZyA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5ibGVuZGluZztcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggcG9zL3JvdC9zY2xcblxuICAgICAgICBmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xuXG4gICAgICAgICAgLy8gZ2V0IGtleXNcblxuICAgICAgICAgIHZhciB0eXBlICAgID0gdGhpcy5rZXlUeXBlc1sgdCBdO1xuICAgICAgICAgIHZhciBwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdO1xuICAgICAgICAgIHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdO1xuXG4gICAgICAgICAgaWYgKCAoIHRoaXMudGltZVNjYWxlID4gMCAmJiBuZXh0S2V5LnRpbWUgPD0gdGhpcy5jdXJyZW50VGltZSApIHx8XG4gICAgICAgICAgICAoIHRoaXMudGltZVNjYWxlIDwgMCAmJiBwcmV2S2V5LnRpbWUgPj0gdGhpcy5jdXJyZW50VGltZSApICkge1xuXG4gICAgICAgICAgICBwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcbiAgICAgICAgICAgIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cbiAgICAgICAgICAgIHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuICAgICAgICAgICAgICBwcmV2S2V5ID0gbmV4dEtleTtcbiAgICAgICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcbiAgICAgICAgICAgIGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2NhbGUgPSAoIHRoaXMuY3VycmVudFRpbWUgLSBwcmV2S2V5LnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gcHJldktleS50aW1lICk7XG5cbiAgICAgICAgICB2YXIgcHJldlhZWiA9IHByZXZLZXlbIHR5cGUgXTtcbiAgICAgICAgICB2YXIgbmV4dFhZWiA9IG5leHRLZXlbIHR5cGUgXTtcblxuICAgICAgICAgIGlmICggc2NhbGUgPCAwICkgc2NhbGUgPSAwO1xuICAgICAgICAgIGlmICggc2NhbGUgPiAxICkgc2NhbGUgPSAxO1xuXG4gICAgICAgICAgLy8gaW50ZXJwb2xhdGVcblxuICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJwb3NcIiApIHtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUiApIHtcblxuICAgICAgICAgICAgICBuZXdWZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgbmV3VmVjdG9yLnkgPSBwcmV2WFlaWyAxIF0gKyAoIG5leHRYWVpbIDEgXSAtIHByZXZYWVpbIDEgXSApICogc2NhbGU7XG4gICAgICAgICAgICAgIG5ld1ZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgIC8vIGJsZW5kXG4gICAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuICAgICAgICAgICAgICBvYmplY3QucG9zaXRpb24ubGVycCggbmV3VmVjdG9yLCBwcm9wb3J0aW9uYWxXZWlnaHQgKTtcbiAgICAgICAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cbiAgICAgICAgICAgICAgcG9pbnRzWyAwIF0gPSB0aGlzLmdldFByZXZLZXlXaXRoKCBcInBvc1wiLCBoLCBwcmV2S2V5LmluZGV4IC0gMSApWyBcInBvc1wiIF07XG4gICAgICAgICAgICAgIHBvaW50c1sgMSBdID0gcHJldlhZWjtcbiAgICAgICAgICAgICAgcG9pbnRzWyAyIF0gPSBuZXh0WFlaO1xuICAgICAgICAgICAgICBwb2ludHNbIDMgXSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicG9zXCIsIGgsIG5leHRLZXkuaW5kZXggKyAxIClbIFwicG9zXCIgXTtcblxuICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlICogMC4zMyArIDAuMzM7XG5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IGludGVycG9sYXRlQ2F0bXVsbFJvbSggcG9pbnRzLCBzY2FsZSApO1xuICAgICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgYmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgLy8gYmxlbmRcblxuICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gb2JqZWN0LnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgIHZlY3Rvci54ID0gdmVjdG9yLnggKyAoIGN1cnJlbnRQb2ludFsgMCBdIC0gdmVjdG9yLnggKSAqIHByb3BvcnRpb25hbFdlaWdodDtcbiAgICAgICAgICAgICAgdmVjdG9yLnkgPSB2ZWN0b3IueSArICggY3VycmVudFBvaW50WyAxIF0gLSB2ZWN0b3IueSApICogcHJvcG9ydGlvbmFsV2VpZ2h0O1xuICAgICAgICAgICAgICB2ZWN0b3IueiA9IHZlY3Rvci56ICsgKCBjdXJyZW50UG9pbnRbIDIgXSAtIHZlY3Rvci56ICkgKiBwcm9wb3J0aW9uYWxXZWlnaHQ7XG5cbiAgICAgICAgICAgICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAgICAgICAgICAgIHZhciBmb3J3YXJkUG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKiAxLjAxICk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0KCBmb3J3YXJkUG9pbnRbIDAgXSwgZm9yd2FyZFBvaW50WyAxIF0sIGZvcndhcmRQb2ludFsgMiBdICk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN1YiggdmVjdG9yICk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAwO1xuICAgICAgICAgICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRhcmdldC54LCB0YXJnZXQueiApO1xuICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGlvbi5zZXQoIDAsIGFuZ2xlLCAwICk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSBcInJvdFwiICkge1xuXG4gICAgICAgICAgICBUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwKCBwcmV2WFlaLCBuZXh0WFlaLCBuZXdRdWF0LCBzY2FsZSApO1xuXG4gICAgICAgICAgICAvLyBBdm9pZCBwYXlpbmcgdGhlIGNvc3Qgb2YgYW4gYWRkaXRpb25hbCBzbGVycCBpZiB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAgICAgICBpZiAoIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uY29weSggbmV3UXVhdCApO1xuICAgICAgICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgVEhSRUUuUXVhdGVybmlvbi5zbGVycCggb2JqZWN0LnF1YXRlcm5pb24sIG5ld1F1YXQsIG9iamVjdC5xdWF0ZXJuaW9uLCBwcm9wb3J0aW9uYWxXZWlnaHQgKTtcbiAgICAgICAgICAgICAgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gXCJzY2xcIiApIHtcblxuICAgICAgICAgICAgbmV3VmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XG4gICAgICAgICAgICBuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgIG5ld1ZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcuc2NhbGVXZWlnaHQgKTtcbiAgICAgICAgICAgIG9iamVjdC5zY2FsZS5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgYmxlbmRpbmcuc2NhbGVXZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfTtcblxuICB9ICkoKSxcblxuICBnZXROZXh0S2V5V2l0aDogZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAga2V5ID0ga2V5IDwga2V5cy5sZW5ndGggLSAxID8ga2V5IDoga2V5cy5sZW5ndGggLSAxO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAga2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cbiAgICB9XG5cbiAgICBmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkgKysgKSB7XG5cbiAgICAgIGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG5cbiAgfSxcblxuICBnZXRQcmV2S2V5V2l0aDogZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICBrZXkgPSBrZXkgPiAwID8ga2V5IDogMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XG5cbiAgICB9XG5cblxuICAgIGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuICAgICAgaWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9LZXlGcmFtZUFuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Iga2hhbmcgZHVvbmdcbiAqIEBhdXRob3IgZXJpayBraXRzb25cbiAqL1xuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGF0YSApIHtcblxuICB0aGlzLnJvb3QgPSBkYXRhLm5vZGU7XG4gIHRoaXMuZGF0YSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuaW5pdCggZGF0YSApO1xuICB0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHRoaXMucm9vdCApO1xuICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgdGhpcy50aW1lU2NhbGUgPSAwLjAwMTtcbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gIHRoaXMubG9vcCA9IHRydWU7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBmaXJzdCBrZXlmcmFtZXNcblxuICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLFxuICAgICAgc2lkcyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5zaWRzLFxuICAgICAgb2JqID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblxuICAgIGlmICgga2V5cy5sZW5ndGggJiYgc2lkcyApIHtcblxuICAgICAgZm9yICggdmFyIHMgPSAwOyBzIDwgc2lkcy5sZW5ndGg7IHMgKysgKSB7XG5cbiAgICAgICAgdmFyIHNpZCA9IHNpZHNbIHMgXSxcbiAgICAgICAgICBuZXh0ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggc2lkLCBoLCAwICk7XG5cbiAgICAgICAgaWYgKCBuZXh0ICkge1xuXG4gICAgICAgICAgbmV4dC5hcHBseSggc2lkICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIG9iai5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgIG9iai5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICB9XG5cbn07XG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuS2V5RnJhbWVBbmltYXRpb24sXG5cbiAgcGxheTogZnVuY3Rpb24gKCBzdGFydFRpbWUgKSB7XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBzdGFydFRpbWUgOiAwO1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgICAgLy8gcmVzZXQga2V5IGNhY2hlXG5cbiAgICAgIHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBub2RlO1xuXG4gICAgICBmb3IgKCBoID0gMDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICAgIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgICAgaWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlID0ge307XG4gICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXggPSBvYmplY3QubWF0cml4O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgICAgIGlmICgga2V5cy5sZW5ndGggKSB7XG5cbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBrZXlzWyAwIF07XG4gICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0ga2V5c1sgMSBdO1xuXG4gICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1sgMCBdLnRpbWUsIHRoaXMuc3RhcnRUaW1lICk7XG4gICAgICAgICAgdGhpcy5lbmRUaW1lID0gTWF0aC5tYXgoIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdLnRpbWUsIHRoaXMuZW5kVGltZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZSggMCApO1xuXG4gICAgfVxuXG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wbGF5KCB0aGlzICk7XG5cbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNQYXVzZWQgID0gZmFsc2U7XG5cbiAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnN0b3AoIHRoaXMgKTtcblxuICAgIC8vIHJlc2V0IEpJVCBtYXRyaXggYW5kIHJlbW92ZSBjYWNoZVxuXG4gICAgZm9yICggdmFyIGggPSAwOyBoIDwgdGhpcy5kYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGggKysgKSB7XG5cbiAgICAgIHZhciBvYmogPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgIGlmICggbm9kZS5hbmltYXRpb25DYWNoZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XG5cbiAgICAgICAgb3JpZ2luYWwuY29weSggb2JqLm1hdHJpeCApO1xuICAgICAgICBvYmoubWF0cml4ID0gb3JpZ2luYWw7XG5cbiAgICAgICAgZGVsZXRlIG5vZGUuYW5pbWF0aW9uQ2FjaGU7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YSAqIHRoaXMudGltZVNjYWxlO1xuXG4gICAgLy9cblxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gKSB7XG5cbiAgICAgIHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIGR1cmF0aW9uICk7XG5cbiAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgIHZhciBrZXlzID0gbm9kZS5rZXlzLFxuICAgICAgICBhbmltYXRpb25DYWNoZSA9IG5vZGUuYW5pbWF0aW9uQ2FjaGU7XG5cblxuICAgICAgaWYgKCBrZXlzLmxlbmd0aCApIHtcblxuICAgICAgICB2YXIgcHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXk7XG4gICAgICAgIHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleTtcblxuICAgICAgICBpZiAoIG5leHRLZXkudGltZSA8PSB0aGlzLmN1cnJlbnRUaW1lICkge1xuXG4gICAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgICBwcmV2S2V5ID0gbmV4dEtleTtcbiAgICAgICAgICAgIG5leHRLZXkgPSBrZXlzWyBwcmV2S2V5LmluZGV4ICsgMSBdO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pbWF0aW9uQ2FjaGUucHJldktleSA9IHByZXZLZXk7XG4gICAgICAgICAgYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IG5leHRLZXk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbmV4dEtleS50aW1lID49IHRoaXMuY3VycmVudFRpbWUgKSB7XG5cbiAgICAgICAgICBwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCB0aGlzLmN1cnJlbnRUaW1lICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIG5leHRLZXkudGltZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgb2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICBnZXROZXh0S2V5V2l0aDogZnVuY3Rpb24gKCBzaWQsIGgsIGtleSApIHtcblxuICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG4gICAga2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkgKysgKSB7XG5cbiAgICAgIGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuICAgICAgICByZXR1cm4ga2V5c1sga2V5IF07XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBrZXlzWyAwIF07XG5cbiAgfSxcblxuICBnZXRQcmV2S2V5V2l0aDogZnVuY3Rpb24gKCBzaWQsIGgsIGtleSApIHtcblxuICAgIHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG4gICAga2V5ID0ga2V5ID49IDAgPyBrZXkgOiBrZXkgKyBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuICAgICAgaWYgKCBrZXlzWyBrZXkgXS5oYXNUYXJnZXQoIHNpZCApICkge1xuXG4gICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9Nb3JwaEFuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3Igd2lsbHktdnZ1IC8gaHR0cDovL3dpbGx5LXZ2dS5naXRodWIuaW9cbiAqL1xuXG5USFJFRS5Nb3JwaEFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbWVzaCApIHtcblxuICB0aGlzLm1lc2ggPSBtZXNoO1xuICB0aGlzLmZyYW1lcyA9IG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDtcbiAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gIHRoaXMuZHVyYXRpb24gPSAxMDAwO1xuICB0aGlzLmxvb3AgPSB0cnVlO1xuICB0aGlzLmxhc3RGcmFtZSA9IDA7XG4gIHRoaXMuY3VycmVudEZyYW1lID0gMDtcblxuICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk1vcnBoQW5pbWF0aW9uLFxuXG4gIHBsYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhO1xuXG4gICAgaWYgKCB0aGlzLmxvb3AgPT09IHRydWUgJiYgdGhpcy5jdXJyZW50VGltZSA+IHRoaXMuZHVyYXRpb24gKSB7XG5cbiAgICAgIHRoaXMuY3VycmVudFRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcblxuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1pbiggdGhpcy5jdXJyZW50VGltZSwgdGhpcy5kdXJhdGlvbiApO1xuXG4gICAgdmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmZyYW1lcztcbiAgICB2YXIgZnJhbWUgPSBNYXRoLmZsb29yKCB0aGlzLmN1cnJlbnRUaW1lIC8gZnJhbWVUaW1lICk7XG5cbiAgICB2YXIgaW5mbHVlbmNlcyA9IHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBpZiAoIGZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSApIHtcblxuICAgICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0RnJhbWUgXSA9IDA7XG4gICAgICBpbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRGcmFtZSBdID0gMTtcbiAgICAgIGluZmx1ZW5jZXNbIGZyYW1lIF0gPSAwO1xuXG4gICAgICB0aGlzLmxhc3RGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcblxuICAgIH1cblxuICAgIHZhciBtaXggPSAoIHRoaXMuY3VycmVudFRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuICAgIGluZmx1ZW5jZXNbIGZyYW1lIF0gPSBtaXg7XG4gICAgaW5mbHVlbmNlc1sgdGhpcy5sYXN0RnJhbWUgXSA9IDEgLSBtaXg7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Cb3hHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xuICovXG5cblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBkZXB0aDogZGVwdGgsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuICB9O1xuXG4gIHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcbiAgdGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG4gIHRoaXMuZGVwdGhTZWdtZW50cyA9IGRlcHRoU2VnbWVudHMgfHwgMTtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuICB2YXIgZGVwdGhfaGFsZiA9IGRlcHRoIC8gMjtcblxuICBidWlsZFBsYW5lKCAneicsICd5JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoX2hhbGYsIDAgKTsgLy8gcHhcbiAgYnVpbGRQbGFuZSggJ3onLCAneScsICAgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoX2hhbGYsIDEgKTsgLy8gbnhcbiAgYnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XG4gIGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodF9oYWxmLCAzICk7IC8vIG55XG4gIGJ1aWxkUGxhbmUoICd4JywgJ3knLCAgIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGhfaGFsZiwgNCApOyAvLyBwelxuICBidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiwgNSApOyAvLyBuelxuXG4gIGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgdmFyIHcsIGl4LCBpeSxcbiAgICBncmlkWCA9IHNjb3BlLndpZHRoU2VnbWVudHMsXG4gICAgZ3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcbiAgICB3aWR0aF9oYWxmID0gd2lkdGggLyAyLFxuICAgIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMixcbiAgICBvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd4JyApICkge1xuXG4gICAgICB3ID0gJ3onO1xuXG4gICAgfSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XG5cbiAgICAgIHcgPSAneSc7XG4gICAgICBncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cbiAgICB9IGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcblxuICAgICAgdyA9ICd4JztcbiAgICAgIGdyaWRYID0gc2NvcGUuZGVwdGhTZWdtZW50cztcblxuICAgIH1cblxuICAgIHZhciBncmlkWDEgPSBncmlkWCArIDEsXG4gICAgZ3JpZFkxID0gZ3JpZFkgKyAxLFxuICAgIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYLFxuICAgIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXG4gICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcblxuICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG4gICAgICBmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmVjdG9yWyB1IF0gPSAoIGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGYgKSAqIHVkaXI7XG4gICAgICAgIHZlY3RvclsgdiBdID0gKCBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGYgKSAqIHZkaXI7XG4gICAgICAgIHZlY3RvclsgdyBdID0gZGVwdGg7XG5cbiAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggdmVjdG9yICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cbiAgICAgIGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cbiAgICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuICAgICAgICB2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgdmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgdmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xuICAgICAgICB2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcbiAgICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcbiAgICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEgKyBvZmZzZXQsIGIgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcbiAgICAgICAgZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG4gICAgICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG4gICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuICAgICAgICBmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59O1xuXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEdlb21ldHJ5O1xuXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy53aWR0aCxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgIHRoaXMucGFyYW1ldGVycy5kZXB0aCxcbiAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmRlcHRoU2VnbWVudHNcbiAgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblRIUkVFLkN1YmVHZW9tZXRyeSA9IFRIUkVFLkJveEdlb21ldHJ5OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgaHVnaGVzXG4gKi9cblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdmFyIGksIHV2cyA9IFtdLFxuICBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBjZW50ZXJVViA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLjUsIDAuNSApO1xuXG4gIHRoaXMudmVydGljZXMucHVzaCggY2VudGVyICk7XG4gIHV2cy5wdXNoKCBjZW50ZXJVViApO1xuXG4gIGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cbiAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcbiAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyByYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gcmFkaXVzICsgMSApIC8gMiApICk7XG5cbiAgfVxuXG4gIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICBmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBpLCBpICsgMSwgMCwgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBpIF0uY2xvbmUoKSwgdXZzWyBpICsgMSBdLmNsb25lKCksIGNlbnRlclVWLmNsb25lKCkgXSApO1xuXG4gIH1cblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVHZW9tZXRyeTtcblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcbiAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgIHRoaXMucGFyYW1ldGVycy5zZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdmFyIHZlcnRpY2VzID0gc2VnbWVudHMgKyAyO1xuXG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgdmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMiApO1xuXG4gIC8vIGNlbnRlciBkYXRhIGlzIGFscmVhZHkgemVybywgYnV0IG5lZWQgdG8gc2V0IGEgZmV3IGV4dHJhc1xuICBub3JtYWxzWyAzIF0gPSAxLjA7XG4gIHV2c1sgMCBdID0gMC41O1xuICB1dnNbIDEgXSA9IDAuNTtcblxuICBmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XG5cbiAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuICAgIHBvc2l0aW9uc1sgaSBdID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICBwb3NpdGlvbnNbIGkgKyAxIF0gPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgbm9ybWFsc1sgaSArIDIgXSA9IDE7IC8vIG5vcm1hbCB6XG5cbiAgICB1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcbiAgICB1dnNbIGlpICsgMSBdID0gKCBwb3NpdGlvbnNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG4gIH1cblxuICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gIGZvciAoIHZhciBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuICAgIGluZGljZXMucHVzaCggaSApO1xuICAgIGluZGljZXMucHVzaCggaSArIDEgKTtcbiAgICBpbmRpY2VzLnB1c2goIDAgKTtcblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBpbmRpY2VzICksIDEgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5O1xuXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnNlZ21lbnRzLFxuICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICApO1xuXG4gIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXNUb3A6IHJhZGl1c1RvcCxcbiAgICByYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgcmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAyMDtcbiAgcmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcbiAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XG5cbiAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICBoZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG5cbiAgb3BlbkVuZGVkID0gb3BlbkVuZGVkICE9PSB1bmRlZmluZWQgPyBvcGVuRW5kZWQgOiBmYWxzZTtcbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIgKiBNYXRoLlBJO1xuXG4gIHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblxuICB2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XG5cbiAgZm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcbiAgICB2YXIgdXZzUm93ID0gW107XG5cbiAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcbiAgICB2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLnNpbiggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xuICAgICAgdmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xuICAgICAgdmVydGV4LnogPSByYWRpdXMgKiBNYXRoLmNvcyggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcbiAgICAgIHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xuXG4gICAgfVxuXG4gICAgdmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcbiAgICB1dnMucHVzaCggdXZzUm93ICk7XG5cbiAgfVxuXG4gIHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG4gIHZhciBuYSwgbmI7XG5cbiAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgIGlmICggcmFkaXVzVG9wICE9PSAwICkge1xuXG4gICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XG4gICAgICBuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgbmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xuICAgICAgbmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuICAgIH1cblxuICAgIG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcbiAgICBuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG5cbiAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG4gICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuXG4gICAgICB2YXIgbjEgPSBuYS5jbG9uZSgpO1xuICAgICAgdmFyIG4yID0gbmEuY2xvbmUoKTtcbiAgICAgIHZhciBuMyA9IG5iLmNsb25lKCk7XG4gICAgICB2YXIgbjQgPSBuYi5jbG9uZSgpO1xuXG4gICAgICB2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICB2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIHRvcCBjYXBcblxuICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzVG9wID4gMCApIHtcblxuICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xuXG4gICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHYxID0gdmVydGljZXNbIDAgXVsgeCBdO1xuICAgICAgdmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuICAgICAgdmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcbiAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG4gICAgICB2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgICB2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSwgdW5kZWZpbmVkLCAxICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIGJvdHRvbSBjYXBcblxuICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzQm90dG9tID4gMCApIHtcblxuICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gaGVpZ2h0SGFsZiwgMCApICk7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF07XG4gICAgICB2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcbiAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcbiAgICAgIHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcblxuICAgICAgdmFyIHV2MSA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCArIDEgXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSwgdW5kZWZpbmVkLCAyICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN5bGluZGVyR2VvbWV0cnk7XG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXNUb3AsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1c0JvdHRvbSxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLm9wZW5FbmRlZCxcbiAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0VkZ2VzR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5FZGdlc0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XG5cbiAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRocmVzaG9sZEFuZ2xlID0gKCB0aHJlc2hvbGRBbmdsZSAhPT0gdW5kZWZpbmVkICkgPyB0aHJlc2hvbGRBbmdsZSA6IDE7XG5cbiAgdmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aHJlc2hvbGRBbmdsZSApICk7XG5cbiAgdmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xuICB2YXIgc29ydEZ1bmN0aW9uID0gZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgcmV0dXJuIGEgLSBiO1xuXG4gIH07XG5cbiAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICB2YXIgZ2VvbWV0cnkyO1xuXG4gIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgIGdlb21ldHJ5MiA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XG5cbiAgfVxuXG4gIGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XG4gIGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG4gIHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgICBlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBoYXNoWyBrZXkgXSA9IHsgdmVydDE6IGVkZ2VbIDAgXSwgdmVydDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgdmFyIGNvb3JkcyA9IFtdO1xuXG4gIGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcblxuICAgIHZhciBoID0gaGFzaFsga2V5IF07XG5cbiAgICBpZiAoIGguZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgaC5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBoLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xuXG4gICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDEgXTtcbiAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgICAgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcbiAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGNvb3JkcyApLCAzICkgKTtcblxufTtcblxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cbiAqICBhbW91bnQ6IDxpbnQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG4gKlxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcbiAqICBmcmFtZXM6IDxUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXG4gKlxuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICoqL1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICBpZiAoIHR5cGVvZiggc2hhcGVzICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cbiAgICBzaGFwZXMgPSBbXTtcbiAgICByZXR1cm47XG5cbiAgfVxuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcblxuICBzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XG5cbiAgdGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgLy8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcbiAgLy8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXG4gIC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcblxuICAvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICB2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xuXG4gIGZvciAoIHZhciBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG4gICAgdmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG4gICAgdGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG4gIHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XG5cbiAgdmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXG4gIHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcbiAgdmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cbiAgdmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXG5cbiAgdmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG4gIHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXG4gIHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG4gIHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XG5cbiAgLy8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXG4gIHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcblxuICB2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuICBpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG4gICAgZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuICAgIGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuICAgIGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuICAgIC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuICAgIC8vIFJldXNlIFROQiBmcm9tIFR1YmVHZW9tdHJ5IGZvciBub3cuXG4gICAgLy8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuICAgIHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSApO1xuXG4gICAgLy8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XG5cbiAgICBiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBwb3NpdGlvbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIH1cblxuICAvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcblxuICBpZiAoICEgYmV2ZWxFbmFibGVkICkge1xuXG4gICAgYmV2ZWxTZWdtZW50cyA9IDA7XG4gICAgYmV2ZWxUaGlja25lc3MgPSAwO1xuICAgIGJldmVsU2l6ZSA9IDA7XG5cbiAgfVxuXG4gIC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG4gIHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcbiAgdmFyIHNjb3BlID0gdGhpcztcblxuICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgdmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG4gIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuICB2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuICB2YXIgcmV2ZXJzZSA9ICEgVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cbiAgaWYgKCByZXZlcnNlICkge1xuXG4gICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cbiAgICAvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgICAgaWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuICAgICAgICBob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXG5cbiAgfVxuXG5cbiAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSAoIHZlcnRpY2VzLCBob2xlcyApO1xuXG4gIC8qIFZlcnRpY2VzICovXG5cbiAgdmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcblxuICAgIGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuICAgIHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcblxuICB9XG5cbiAgdmFyIGIsIGJzLCB0LCB6LFxuICAgIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG4gIC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG4gIGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgLy8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuICAgIC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcbiAgICAvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcbiAgICAvL1xuICAgIC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG4gICAgLy8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuICAgIHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTsgICAgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG4gICAgLy8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxuICAgIC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cbiAgICB2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCwgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcbiAgICB2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCwgdl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblxuICAgIHZhciB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XG5cbiAgICAvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXG4gICAgdmFyIGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cbiAgICBpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBFUFNJTE9OICkge1xuXG4gICAgICAvLyBub3QgY29sbGluZWFyXG5cbiAgICAgIC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXG4gICAgICB2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG4gICAgICB2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcblxuICAgICAgLy8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG4gICAgICB2YXIgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcbiAgICAgIHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xuXG4gICAgICB2YXIgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcbiAgICAgIHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xuXG4gICAgICAvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG4gICAgICB2YXIgc2YgPSAoICAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG4gICAgICAgICAgICAoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCAgICApIC9cbiAgICAgICAgICAgICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuICAgICAgLy8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgICAgdl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xuICAgICAgdl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xuXG4gICAgICAvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuICAgICAgLy8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xuICAgICAgdmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xuICAgICAgaWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cbiAgICAgICAgcmV0dXJuICBuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cbiAgICAgIHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTsgICAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuICAgICAgaWYgKCB2X3ByZXZfeCA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgaWYgKCB2X25leHRfeCA+IEVQU0lMT04gKSB7XG5cbiAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoIHZfcHJldl94IDwgLSBFUFNJTE9OICkge1xuXG4gICAgICAgICAgaWYgKCB2X25leHRfeCA8IC0gRVBTSUxPTiApIHtcblxuICAgICAgICAgICAgZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcblxuICAgICAgICAgICAgZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcbiAgICAgICAgdl90cmFuc194ID0gLSB2X3ByZXZfeTtcbiAgICAgICAgdl90cmFuc195ID0gIHZfcHJldl94O1xuICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG4gICAgICAgIHZfdHJhbnNfeCA9IHZfcHJldl94O1xuICAgICAgICB2X3RyYW5zX3kgPSB2X3ByZXZfeTtcbiAgICAgICAgc2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiAgbmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cbiAgfVxuXG5cbiAgdmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG4gICAgaWYgKCBqID09PSBpbCApIGogPSAwO1xuICAgIGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuICAgIC8vICAoaiktLS0oaSktLS0oaylcbiAgICAvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcblxuICAgIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XG5cbiAgfVxuXG4gIHZhciBob2xlc01vdmVtZW50cyA9IFtdLCBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XG5cbiAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICBvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG4gICAgICBpZiAoIGogPT09IGlsICkgaiA9IDA7XG4gICAgICBpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cbiAgICAgIC8vICAoaiktLS0oaSktLS0oaylcbiAgICAgIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XG5cbiAgICB9XG5cbiAgICBob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG4gICAgdmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcblxuICB9XG5cblxuICAvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuICBmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cbiAgICAvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cbiAgICAvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XG4gICAgYnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luICggdCAqIE1hdGguUEkgLyAyICkgKTsgLy8gY3VydmVkXG4gICAgLy9icyA9IGJldmVsU2l6ZSAqIHQ7IC8vIGxpbmVhclxuXG4gICAgLy8gY29udHJhY3Qgc2hhcGVcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgIHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cbiAgICB9XG5cbiAgICAvLyBleHBhbmQgaG9sZXNcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBicyA9IGJldmVsU2l6ZTtcblxuICAvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICBpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgdiggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cbiAgICAgIG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcbiAgICAgIGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cbiAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuICAvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cbiAgdmFyIHM7XG5cbiAgZm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cbiAgICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICAgIGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgICAgIHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cbiAgICAgICAgbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuICAgICAgICBiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG4gICAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgICAgICB2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cblxuICAvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cbiAgLy9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuICBmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcblxuICAgIHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICB6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG4gICAgLy9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XG4gICAgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApO1xuXG4gICAgLy8gY29udHJhY3Qgc2hhcGVcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG4gICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuICAgIH1cblxuICAgIC8vIGV4cGFuZCBob2xlc1xuXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcbiAgICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG4gICAgICBmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuICAgICAgICBpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8qIEZhY2VzICovXG5cbiAgLy8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuICBidWlsZExpZEZhY2VzKCk7XG5cbiAgLy8gU2lkZXMgZmFjZXNcblxuICBidWlsZFNpZGVGYWNlcygpO1xuXG5cbiAgLy8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cbiAgICBpZiAoIGJldmVsRW5hYmxlZCApIHtcblxuICAgICAgdmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG4gICAgICB2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgICAvLyBCb3R0b20gZmFjZXNcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICBmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xuXG4gICAgICB9XG5cbiAgICAgIGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcbiAgICAgIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuICAgICAgLy8gVG9wIGZhY2VzXG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gQm90dG9tIGZhY2VzXG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBUb3AgZmFjZXNcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICBmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cbiAgZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cbiAgICB2YXIgbGF5ZXJvZmZzZXQgPSAwO1xuICAgIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcbiAgICBsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICBzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xuXG4gICAgICAvLywgdHJ1ZVxuICAgICAgbGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG4gICAgdmFyIGosIGs7XG4gICAgaSA9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCAtLSBpID49IDAgKSB7XG5cbiAgICAgIGogPSBpO1xuICAgICAgayA9IGkgLSAxO1xuICAgICAgaWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgICB2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cbiAgICAgIGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cbiAgICAgICAgdmFyIHNsZW4xID0gdmxlbiAqIHM7XG4gICAgICAgIHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cbiAgICAgICAgdmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcbiAgICAgICAgICBiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG4gICAgICAgICAgYyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuICAgICAgICAgIGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuICAgICAgICBmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XG5cbiAgICBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xuXG4gICAgYSArPSBzaGFwZXNPZmZzZXQ7XG4gICAgYiArPSBzaGFwZXNPZmZzZXQ7XG4gICAgYyArPSBzaGFwZXNPZmZzZXQ7XG5cbiAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMgKSApO1xuXG4gICAgdmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCBhLCBiLCBjICk7XG5cbiAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkLCB3YWxsQ29udG91ciwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcblxuICAgIGEgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIGIgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIGMgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIGQgKz0gc2hhcGVzT2Zmc2V0O1xuXG4gICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXG4gICAgdmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcblxuICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMCBdLCB1dnNbIDEgXSwgdXZzWyAzIF0gXSApO1xuICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XG5cbiAgZ2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgdmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG4gICAgdmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG4gICAgdmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgYS55ICksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi54LCBiLnkgKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIGMueSApXG4gICAgXTtcblxuICB9LFxuXG4gIGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICB2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcbiAgICB2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcbiAgICB2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcbiAgICB2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcblxuICAgIGlmICggTWF0aC5hYnMoIGEueSAtIGIueSApIDwgMC4wMSApIHtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXG4gICAgICBdO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi55LCAxIC0gYi56ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLnksIDEgLSBjLnogKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueSwgMSAtIGQueiApXG4gICAgICBdO1xuXG4gICAgfVxuXG4gIH1cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cbiAqXG4gKiBDcmVhdGVzIGEgb25lLXNpZGVkIHBvbHlnb25hbCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS4gU2ltaWxhciB0b1xuICogRXh0cnVkZUdlb21ldHJ5LlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXG4gKlxuICogIG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuVEhSRUUuU2hhcGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cbiAgaWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSBzaGFwZXMgPSBbIHNoYXBlcyBdO1xuXG4gIHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZUdlb21ldHJ5O1xuXG4vKipcbiAqIEFkZCBhbiBhcnJheSBvZiBzaGFwZXMgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICB0aGlzLmFkZFNoYXBlKCBzaGFwZXNbIGkgXSwgb3B0aW9ucyApO1xuXG4gIH1cblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBBZGRzIGEgc2hhcGUgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeSwgYmFzZWQgb24gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LlxuICovXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XG5cbiAgaWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XG4gIHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICB2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yID09PSB1bmRlZmluZWQgPyBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA6IG9wdGlvbnMuVVZHZW5lcmF0b3I7XG5cbiAgLy9cblxuICB2YXIgaSwgbCwgaG9sZTtcblxuICB2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gIHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICB2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcbiAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cbiAgdmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG4gIGlmICggcmV2ZXJzZSApIHtcblxuICAgIHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxuXG4gICAgZm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBob2xlID0gaG9sZXNbIGkgXTtcblxuICAgICAgaWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggaG9sZSApICkge1xuXG4gICAgICAgIGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV2ZXJzZSA9IGZhbHNlO1xuXG4gIH1cblxuICB2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuICAvLyBWZXJ0aWNlc1xuXG4gIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIGhvbGUgPSBob2xlc1sgaSBdO1xuICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XG5cbiAgfVxuXG4gIC8vXG5cbiAgdmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gIHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xuXG4gIH1cblxuICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuICAgIHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xuICAgIHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xuXG4gICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcbiAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cbi8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50c1xuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxuLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG4vLyAgICAyKnBpIGlzIGEgY2xvc2VkIGxhdGhlLCBsZXNzIHRoYW4gMlBJIGlzIGEgcG9ydGlvbi5cblxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoXG4gIH07XG5cbiAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCAxMjtcbiAgcGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuICBwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XG5cbiAgdmFyIGludmVyc2VQb2ludExlbmd0aCA9IDEuMCAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgdmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8PSBpbDsgaSArKyApIHtcblxuICAgIHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cbiAgICB2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcbiAgICAgIHMgPSBNYXRoLnNpbiggcGhpICk7XG5cbiAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICB2YXIgcHQgPSBwb2ludHNbIGogXTtcblxuICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcbiAgICAgIHZlcnRleC55ID0gcyAqIHB0LnggKyBjICogcHQueTtcbiAgICAgIHZlcnRleC56ID0gcHQuejtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgIH1cblxuICB9XG5cbiAgdmFyIG5wID0gcG9pbnRzLmxlbmd0aDtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICB2YXIgYmFzZSA9IGogKyBucCAqIGk7XG4gICAgICB2YXIgYSA9IGJhc2U7XG4gICAgICB2YXIgYiA9IGJhc2UgKyBucDtcbiAgICAgIHZhciBjID0gYmFzZSArIDEgKyBucDtcbiAgICAgIHZhciBkID0gYmFzZSArIDE7XG5cbiAgICAgIHZhciB1MCA9IGkgKiBpbnZlcnNlU2VnbWVudHM7XG4gICAgICB2YXIgdjAgPSBqICogaW52ZXJzZVBvaW50TGVuZ3RoO1xuICAgICAgdmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XG4gICAgICB2YXIgdjEgPSB2MCArIGludmVyc2VQb2ludExlbmd0aDtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG4gICAgICBdICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblxuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuICAgICAgXSApO1xuXG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG4gIH07XG5cbiAgdGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XG5cbn07XG5cblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lR2VvbWV0cnk7XG5cblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy53aWR0aCxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0LFxuICAgIHRoaXMucGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTZWdtZW50c1xuICApO1xuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAqL1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgfTtcblxuICB2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcbiAgdmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuICB2YXIgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcbiAgdmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXG4gIHZhciBncmlkWDEgPSBncmlkWCArIDE7XG4gIHZhciBncmlkWTEgPSBncmlkWSArIDE7XG5cbiAgdmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuICB2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XG4gIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xuXG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0MiA9IDA7XG5cbiAgZm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG4gICAgdmFyIHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XG5cbiAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cbiAgICAgIHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblxuICAgICAgdmVydGljZXNbIG9mZnNldCBdID0geDtcbiAgICAgIHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAtIHk7XG5cbiAgICAgIG5vcm1hbHNbIG9mZnNldCArIDIgXSA9IDE7XG5cbiAgICAgIHV2c1sgb2Zmc2V0MiBdID0gaXggLyBncmlkWDtcbiAgICAgIHV2c1sgb2Zmc2V0MiArIDEgXSA9IDEgLSAoIGl5IC8gZ3JpZFkgKTtcblxuICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICBvZmZzZXQyICs9IDI7XG5cbiAgICB9XG5cbiAgfVxuXG4gIG9mZnNldCA9IDA7XG5cbiAgdmFyIGluZGljZXMgPSBuZXcgKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xuXG4gIGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG4gICAgZm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cbiAgICAgIHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcbiAgICAgIHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgdmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgIHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG4gICAgICBpbmRpY2VzWyBvZmZzZXQgXSA9IGE7XG4gICAgICBpbmRpY2VzWyBvZmZzZXQgKyAxIF0gPSBiO1xuICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMiBdID0gZDtcblxuICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcbiAgICAgIGluZGljZXNbIG9mZnNldCArIDQgXSA9IGM7XG4gICAgICBpbmRpY2VzWyBvZmZzZXQgKyA1IF0gPSBkO1xuXG4gICAgICBvZmZzZXQgKz0gNjtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5JbmRleEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeShcbiAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGgsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodCxcbiAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcbiAgKTtcblxuICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxuICovXG5cblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uICggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG4gICAgcGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwO1xuICBvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIHx8IDUwO1xuXG4gIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICB0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XG4gIHBoaVNlZ21lbnRzID0gcGhpU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApIDogODtcblxuICB2YXIgaSwgbywgdXZzID0gW10sIHJhZGl1cyA9IGlubmVyUmFkaXVzLCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XG5cbiAgZm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50cyArIDE7IGkgKysgKSB7XG5cbiAgICAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuICAgIGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8gKysgKSB7XG5cbiAgICAgIC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgbyAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcbiAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcbiAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMiwgKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMiApICk7XG5cbiAgICB9XG5cbiAgICByYWRpdXMgKz0gcmFkaXVzU3RlcDtcblxuICB9XG5cbiAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuICAgIHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG4gICAgZm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzIDsgbyArKyApIHtcblxuICAgICAgLy8gbnVtYmVyIG9mIHNlZ21lbnRzIHBlciBjaXJjbGVcblxuICAgICAgdmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xuXG4gICAgICB2YXIgdjEgPSBzZWdtZW50O1xuICAgICAgdmFyIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuICAgICAgdmFyIHYzID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0gKTtcblxuICAgICAgdjEgPSBzZWdtZW50O1xuICAgICAgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG4gICAgICB2MyA9IHNlZ21lbnQgKyAxO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XG5cblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShcbiAgICB0aGlzLnBhcmFtZXRlcnMuaW5uZXJSYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLm91dGVyUmFkaXVzLFxuICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVNlZ21lbnRzLFxuICAgIHRoaXMucGFyYW1ldGVycy5waGlTZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFTdGFydCxcbiAgICB0aGlzLnBhcmFtZXRlcnMudGhldGFMZW5ndGhcbiAgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgY29uc29sZS5sb2coICdUSFJFRS5TcGhlcmVHZW9tZXRyeTogQ29uc2lkZXIgdXNpbmcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkgZm9yIGxvd2VyIG1lbW9yeSBmb290cHJpbnQuJyApO1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cbiAgd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuICBwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XG4gIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XG5cbiAgdmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xuXG4gIGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgdmFyIHZlcnRpY2VzUm93ID0gW107XG4gICAgdmFyIHV2c1JvdyA9IFtdO1xuXG4gICAgZm9yICggeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcbiAgICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG4gICAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIHZlcnRleC54ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgICAgdmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcbiAgICAgIHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xuXG4gICAgfVxuXG4gICAgdmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcbiAgICB1dnMucHVzaCggdXZzUm93ICk7XG5cbiAgfVxuXG4gIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICAgIHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG4gICAgICB2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuICAgICAgdmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cbiAgICAgIHZhciBuMSA9IHRoaXMudmVydGljZXNbIHYxIF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcbiAgICAgIHZhciBuMiA9IHRoaXMudmVydGljZXNbIHYyIF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcbiAgICAgIHZhciBuMyA9IHRoaXMudmVydGljZXNbIHYzIF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcbiAgICAgIHZhciBuNCA9IHRoaXMudmVydGljZXNbIHY0IF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcblxuICAgICAgdmFyIHV2MSA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYyID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXY0ID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYxIF0ueSApID09PSByYWRpdXMgKSB7XG5cbiAgICAgICAgdXYxLnggPSAoIHV2MS54ICsgdXYyLnggKSAvIDI7XG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjMsIHY0LCBbIG4xLCBuMywgbjQgXSApICk7XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djMsIHV2NCBdICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIE1hdGguYWJzKCB0aGlzLnZlcnRpY2VzWyB2MyBdLnkgKSA9PT0gcmFkaXVzICkge1xuXG4gICAgICAgIHV2My54ID0gKCB1djMueCArIHV2NC54ICkgLyAyO1xuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XG5cbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYyLCB2MywgdjQsIFsgbjIuY2xvbmUoKSwgbjMsIG40LmNsb25lKCkgXSApICk7XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYyLmNsb25lKCksIHV2MywgdXY0LmNsb25lKCkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUdlb21ldHJ5O1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzLFxuICAgIHRoaXMucGFyYW1ldGVycy5waGlTdGFydCxcbiAgICB0aGlzLnBhcmFtZXRlcnMucGhpTGVuZ3RoLFxuICAgIHRoaXMucGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuICAgIHRoaXMucGFyYW1ldGVycy50aGV0YUxlbmd0aFxuICApO1xuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqIGJhc2VkIG9uIFRIUkVFLlNwaGVyZUdlb21ldHJ5XG4gKi9cblxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgcGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG4gICAgdGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgfTtcblxuICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cbiAgd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuICBwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XG4gIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XG5cbiAgdmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xuXG4gIHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xuXG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICB2YXIgbm9ybWFscyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gIHZhciB1dnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG4gIHZhciBpbmRleCA9IDAsIHZlcnRpY2VzID0gW10sIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgZm9yICggdmFyIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgdmFyIHZlcnRpY2VzUm93ID0gW107XG5cbiAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuICAgIGZvciAoIHZhciB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuXG4gICAgICB2YXIgcHggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgICB2YXIgcHkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgICAgdmFyIHB6ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuICAgICAgbm9ybWFsLnNldCggcHgsIHB5LCBweiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBwb3NpdGlvbnMuc2V0WFlaKCBpbmRleCwgcHgsIHB5LCBweiApO1xuICAgICAgbm9ybWFscy5zZXRYWVooIGluZGV4LCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG4gICAgICB1dnMuc2V0WFkoIGluZGV4LCB1LCAxIC0gdiApO1xuXG4gICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCBpbmRleCApO1xuXG4gICAgICBpbmRleCArKztcblxuICAgIH1cblxuICAgIHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cbiAgfVxuXG4gIHZhciBpbmRpY2VzID0gW107XG5cbiAgZm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuICAgICAgdmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xuICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcbiAgICAgIHZhciB2NCA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuXG4gICAgICBpZiAoIHkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIHYxLCB2MiwgdjQgKTtcbiAgICAgIGlmICggeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2luZGV4JywgbmV3IFRIUkVFLkluZGV4QnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnk7XG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGl1cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnBoaVN0YXJ0LFxuICAgIHRoaXMucGFyYW1ldGVycy5waGlMZW5ndGgsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG4gICk7XG5cbiAgZ2VvbWV0cnkuY29weSggdGhpcyApO1xuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV4dEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBGb3IgY3JlYXRpbmcgM0QgdGV4dCBnZW9tZXRyeSBpbiB0aHJlZS5qc1xuICpcbiAqIFRleHQgPSAzRCBUZXh0XG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBzaXplOiAgICAgICA8ZmxvYXQ+LCAgLy8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogICAgIDxmbG9hdD4sICAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XG4gKiAgY3VydmVTZWdtZW50czogIDxpbnQ+LCAgICAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqXG4gKiAgZm9udDogICAgICAgPHN0cmluZz4sICAgLy8gZm9udCBuYW1lXG4gKiAgd2VpZ2h0OiAgICAgPHN0cmluZz4sICAgLy8gZm9udCB3ZWlnaHQgKG5vcm1hbCwgYm9sZClcbiAqICBzdHlsZTogICAgICA8c3RyaW5nPiwgICAvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgICAgIC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgICAgLy8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6ICAgIDxmbG9hdD4sICAgIC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcbiAqICB9XG4gKlxuICovXG5cbi8qICBVc2FnZSBFeGFtcGxlc1xuXG4gIC8vIFRleHRHZW9tZXRyeSB3cmFwcGVyXG5cbiAgdmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcblxuICAvLyBDb21wbGV0ZSBtYW5uZXJcblxuICB2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgb3B0aW9ucyApO1xuICB2YXIgdGV4dDNkID0gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGV4dFNoYXBlcywgb3B0aW9ucyApO1xuXG4qL1xuXG5cblRIUkVFLlRleHRHZW9tZXRyeSA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICB2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycyApO1xuXG4gIC8vIHRyYW5zbGF0ZSBwYXJhbWV0ZXJzIHRvIEV4dHJ1ZGVHZW9tZXRyeSBBUElcblxuICBwYXJhbWV0ZXJzLmFtb3VudCA9IHBhcmFtZXRlcnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmhlaWdodCA6IDUwO1xuXG4gIC8vIGRlZmF1bHRzXG5cbiAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID0gMTA7XG4gIGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcbiAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcblxuICBUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgdGV4dFNoYXBlcywgcGFyYW1ldGVycyApO1xuXG4gIHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xuXG59O1xuXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRleHRHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICovXG5cblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIHR1YmU6IHR1YmUsXG4gICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgIGFyYzogYXJjXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcbiAgdHViZSA9IHR1YmUgfHwgNDA7XG4gIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgdHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XG4gIGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdXZzID0gW10sIG5vcm1hbHMgPSBbXTtcblxuICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgICB2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG4gICAgICBjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG4gICAgICBjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuICAgICAgdmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgICAgdmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xuICAgICAgbm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZvciAoIHZhciBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICAgIHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG4gICAgICB2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG4gICAgICB2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcbiAgICAgIHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIFsgbm9ybWFsc1sgYSBdLmNsb25lKCksIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG4gICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIFsgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGMgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG4gICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnR1YmUsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxuICAgIHRoaXMucGFyYW1ldGVycy50dWJ1bGFyU2VnbWVudHMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmFyY1xuICApO1xuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNLbm90R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNEL3NyYy9hd2F5M2QvcHJpbWl0aXZlcy9Ub3J1c0tub3QuYXM/c3BlYz1zdm4yNDczJnI9MjQ3M1xuICovXG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIHAsIHEsIGhlaWdodFNjYWxlICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB0dWJlOiB0dWJlLFxuICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICB0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgaGVpZ2h0U2NhbGU6IGhlaWdodFNjYWxlXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcbiAgdHViZSA9IHR1YmUgfHwgNDA7XG4gIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgNjQ7XG4gIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA4O1xuICBwID0gcCB8fCAyO1xuICBxID0gcSB8fCAzO1xuICBoZWlnaHRTY2FsZSA9IGhlaWdodFNjYWxlIHx8IDE7XG5cbiAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XG4gIHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xuXG4gICAgZ3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICB2YXIgdSA9IGkgLyByYWRpYWxTZWdtZW50cyAqIDIgKiBwICogTWF0aC5QSTtcbiAgICB2YXIgcDEgPSBnZXRQb3MoIHUsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcbiAgICB2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG4gICAgdGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcbiAgICBuLmFkZFZlY3RvcnMoIHAyLCBwMSApO1xuXG4gICAgYml0YW4uY3Jvc3NWZWN0b3JzKCB0YW5nLCBuICk7XG4gICAgbi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XG4gICAgYml0YW4ubm9ybWFsaXplKCk7XG4gICAgbi5ub3JtYWxpemUoKTtcblxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuICAgICAgdmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XG4gICAgICB2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxuICAgICAgdmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgIHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgcG9zLnggPSBwMS54ICsgY3ggKiBuLnggKyBjeSAqIGJpdGFuLng7XG4gICAgICBwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcbiAgICAgIHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xuXG4gICAgICBncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xuXG4gICAgfVxuXG4gIH1cblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcblxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuICAgICAgdmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG4gICAgICB2YXIganAgPSAoIGogKyAxICkgJSB0dWJ1bGFyU2VnbWVudHM7XG5cbiAgICAgIHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XG4gICAgICB2YXIgYiA9IGdyaWRbIGlwIF1bIGogXTtcbiAgICAgIHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcbiAgICAgIHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgdmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG4gICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgZnVuY3Rpb24gZ2V0UG9zKCB1LCBpbl9xLCBpbl9wLCByYWRpdXMsIGhlaWdodFNjYWxlICkge1xuXG4gICAgdmFyIGN1ID0gTWF0aC5jb3MoIHUgKTtcbiAgICB2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xuICAgIHZhciBxdU92ZXJQID0gaW5fcSAvIGluX3AgKiB1O1xuICAgIHZhciBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XG5cbiAgICB2YXIgdHggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XG4gICAgdmFyIHR5ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xuICAgIHZhciB0eiA9IGhlaWdodFNjYWxlICogcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeTtcblxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcbiAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgIHRoaXMucGFyYW1ldGVycy50dWJlLFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcbiAgICB0aGlzLnBhcmFtZXRlcnMudHVidWxhclNlZ21lbnRzLFxuICAgIHRoaXMucGFyYW1ldGVycy5wLFxuICAgIHRoaXMucGFyYW1ldGVycy5xLFxuICAgIHRoaXMucGFyYW1ldGVycy5oZWlnaHRTY2FsZVxuICApO1xuXG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVHViZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcbiAqXG4gKiBNb2RpZmllZCBmcm9tIHRoZSBUb3J1c0tub3RHZW9tZXRyeSBieSBAb29zbW94aWVjb2RlXG4gKlxuICogQ3JlYXRlcyBhIHR1YmUgd2hpY2ggZXh0cnVkZXMgYWxvbmcgYSAzZCBzcGxpbmVcbiAqXG4gKiBVc2VzIHBhcmFsbGVsIHRyYW5zcG9ydCBmcmFtZXMgYXMgZGVzY3JpYmVkIGluXG4gKiBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcbiAqL1xuXG5USFJFRS5UdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIGNsb3NlZDogY2xvc2VkXG4gIH07XG5cbiAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcbiAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgY2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuICB0YXBlciA9IHRhcGVyIHx8IFRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyO1xuXG4gIHZhciBncmlkID0gW107XG5cbiAgdmFyIHNjb3BlID0gdGhpcyxcblxuICAgIHRhbmdlbnQsXG4gICAgbm9ybWFsLFxuICAgIGJpbm9ybWFsLFxuXG4gICAgbnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXG4gICAgdSwgdiwgcixcblxuICAgIGN4LCBjeSxcbiAgICBwb3MsIHBvczIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgIGksIGosXG4gICAgaXAsIGpwLFxuICAgIGEsIGIsIGMsIGQsXG4gICAgdXZhLCB1dmIsIHV2YywgdXZkO1xuXG4gIHZhciBmcmFtZXMgPSBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApLFxuICAgIHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxuICAgIG5vcm1hbHMgPSBmcmFtZXMubm9ybWFscyxcbiAgICBiaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xuXG4gIC8vIHByb3h5IGludGVybmFsc1xuICB0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG4gIHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XG4gIHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG4gIGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XG5cbiAgICByZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcblxuICB9XG5cbiAgLy8gY29uc3RydWN0IHRoZSBncmlkXG5cbiAgZm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICBncmlkWyBpIF0gPSBbXTtcblxuICAgIHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICBwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuICAgIHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuICAgIG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcbiAgICBiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG4gICAgciA9IHJhZGl1cyAqIHRhcGVyKCB1ICk7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgICB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cbiAgICAgIGN4ID0gLSByICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cbiAgICAgIGN5ID0gciAqIE1hdGguc2luKCB2ICk7XG5cbiAgICAgIHBvczIuY29weSggcG9zICk7XG4gICAgICBwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcbiAgICAgIHBvczIueSArPSBjeCAqIG5vcm1hbC55ICsgY3kgKiBiaW5vcm1hbC55O1xuICAgICAgcG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XG5cbiAgICAgIGdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xuXG4gICAgfVxuXG4gIH1cblxuXG4gIC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxuXG4gIGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgICBpcCA9ICggY2xvc2VkICkgPyAoIGkgKyAxICkgJSBzZWdtZW50cyA6IGkgKyAxO1xuICAgICAganAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcblxuICAgICAgYSA9IGdyaWRbIGkgXVsgaiBdOyAgIC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG4gICAgICBiID0gZ3JpZFsgaXAgXVsgaiBdO1xuICAgICAgYyA9IGdyaWRbIGlwIF1bIGpwIF07XG4gICAgICBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG4gICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcbiAgICAgIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVHViZUdlb21ldHJ5O1xuXG5USFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlciA9IGZ1bmN0aW9uICggdSApIHtcblxuICByZXR1cm4gMTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LlNpbnVzb2lkYWxUYXBlciA9IGZ1bmN0aW9uICggdSApIHtcblxuICByZXR1cm4gTWF0aC5zaW4oIE1hdGguUEkgKiB1ICk7XG5cbn07XG5cbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcblxuICB2YXIgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgIHRhbmdlbnRzID0gW10sXG4gICAgbm9ybWFscyA9IFtdLFxuICAgIGJpbm9ybWFscyA9IFtdLFxuXG4gICAgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBtYXQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gICAgbnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuICAgIHRoZXRhLFxuICAgIGVwc2lsb24gPSAwLjAwMDEsXG4gICAgc21hbGxlc3QsXG5cbiAgICB0eCwgdHksIHR6LFxuICAgIGksIHU7XG5cblxuICAvLyBleHBvc2UgaW50ZXJuYWxzXG4gIHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcbiAgdGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgdGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XG5cbiAgLy8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcblxuICBmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuICAgIHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICB0YW5nZW50c1sgaSBdID0gcGF0aC5nZXRUYW5nZW50QXQoIHUgKTtcbiAgICB0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xuXG4gIH1cblxuICBpbml0aWFsTm9ybWFsMygpO1xuXG4gIC8qXG4gIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xuICAgIC8vIGZpeGVkIHN0YXJ0IGJpbm9ybWFsLiBIYXMgZGFuZ2VycyBvZiAwIHZlY3RvcnNcbiAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBpZiAobGFzdEJpbm9ybWFsPT09dW5kZWZpbmVkKSBsYXN0Qmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuICAgIG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuICAgIGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcblxuICAgIC8vIFRoaXMgdXNlcyB0aGUgRnJlbmV0LVNlcnJldCBmb3JtdWxhIGZvciBkZXJpdmluZyBiaW5vcm1hbFxuICAgIHZhciB0MiA9IHBhdGguZ2V0VGFuZ2VudEF0KCBlcHNpbG9uICk7XG5cbiAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG4gICAgYmlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cbiAgICBub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBiaW5vcm1hbHNbIDAgXSwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpOyAvLyBsYXN0IGJpbm9ybWFsIHggdGFuZ2VudFxuICAgIGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xuXG4gICAgLy8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcbiAgICAvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlc3QgdGFuZ2VudCB4eXogY29tcG9uZW50XG5cbiAgICBub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG4gICAgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XG4gICAgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XG5cbiAgICBpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xuXG4gICAgICBzbWFsbGVzdCA9IHR4O1xuICAgICAgbm9ybWFsLnNldCggMSwgMCwgMCApO1xuXG4gICAgfVxuXG4gICAgaWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcblxuICAgICAgc21hbGxlc3QgPSB0eTtcbiAgICAgIG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuICAgIH1cblxuICAgIGlmICggdHogPD0gc21hbGxlc3QgKSB7XG5cbiAgICAgIG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcblxuICAgIH1cblxuICAgIHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XG4gICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuICB9XG5cblxuICAvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gIGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG4gICAgbm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG4gICAgYmlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuICAgIHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cbiAgICBpZiAoIHZlYy5sZW5ndGgoKSA+IGVwc2lsb24gKSB7XG5cbiAgICAgIHZlYy5ub3JtYWxpemUoKTtcblxuICAgICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cbiAgICAgIG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcblxuICAgIH1cblxuICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgfVxuXG5cbiAgLy8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG4gIGlmICggY2xvc2VkICkge1xuXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApLCAtIDEsIDEgKSApO1xuICAgIHRoZXRhIC89ICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgaWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSApID4gMCApIHtcblxuICAgICAgdGhldGEgPSAtIHRoZXRhO1xuXG4gICAgfVxuXG4gICAgZm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICAgIC8vIHR3aXN0IGEgbGl0dGxlLi4uXG4gICAgICBub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcbiAgICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Qb2x5aGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gIGRldGFpbCA9IGRldGFpbCB8fCAwO1xuXG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICBwcmVwYXJlKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIHZlcnRpY2VzWyBpICsgMiBdICkgKTtcblxuICB9XG5cbiAgdmFyIHAgPSB0aGlzLnZlcnRpY2VzO1xuXG4gIHZhciBmYWNlcyA9IFtdO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaiArKyApIHtcblxuICAgIHZhciB2MSA9IHBbIGluZGljZXNbIGkgXSBdO1xuICAgIHZhciB2MiA9IHBbIGluZGljZXNbIGkgKyAxIF0gXTtcbiAgICB2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XG5cbiAgICBmYWNlc1sgaiBdID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBqICk7XG5cbiAgfVxuXG4gIHZhciBjZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHN1YmRpdmlkZSggZmFjZXNbIGkgXSwgZGV0YWlsICk7XG5cbiAgfVxuXG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbVxuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgIHZhciB4MCA9IHV2c1sgMCBdLng7XG4gICAgdmFyIHgxID0gdXZzWyAxIF0ueDtcbiAgICB2YXIgeDIgPSB1dnNbIDIgXS54O1xuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KCB4MCwgTWF0aC5tYXgoIHgxLCB4MiApICk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKCB4MCwgTWF0aC5taW4oIHgxLCB4MiApICk7XG5cbiAgICBpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cbiAgICAgIC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcblxuICAgICAgaWYgKCB4MCA8IDAuMiApIHV2c1sgMCBdLnggKz0gMTtcbiAgICAgIGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XG4gICAgICBpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xuXG4gICAgfVxuXG4gIH1cblxuXG4gIC8vIEFwcGx5IHJhZGl1c1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cbiAgfVxuXG5cbiAgLy8gTWVyZ2UgdmVydGljZXNcblxuICB0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxuXG4gIC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxuXG4gIGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcblxuICAgIHZhciB2ZXJ0ZXggPSB2ZWN0b3Iubm9ybWFsaXplKCkuY2xvbmUoKTtcbiAgICB2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcblxuICAgIC8vIFRleHR1cmUgY29vcmRzIGFyZSBlcXVpdmFsZW50IHRvIG1hcCBjb29yZHMsIGNhbGN1bGF0ZSBhbmdsZSBhbmQgY29udmVydCB0byBmcmFjdGlvbiBvZiBhIGNpcmNsZS5cblxuICAgIHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcbiAgICB2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XG4gICAgdmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XG5cbiAgICByZXR1cm4gdmVydGV4O1xuXG4gIH1cblxuXG4gIC8vIEFwcHJveGltYXRlIGEgY3VydmVkIGZhY2Ugd2l0aCByZWN1cnNpdmVseSBzdWItZGl2aWRlZCB0cmlhbmdsZXMuXG5cbiAgZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MywgbWF0ZXJpYWxJbmRleCApIHtcblxuICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBtYXRlcmlhbEluZGV4ICk7XG4gICAgdGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICBjZW50cm9pZC5jb3B5KCB2MSApLmFkZCggdjIgKS5hZGQoIHYzICkuZGl2aWRlU2NhbGFyKCAzICk7XG5cbiAgICB2YXIgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcblxuICAgIHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcbiAgICAgIGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcbiAgICAgIGNvcnJlY3RVViggdjIudXYsIHYyLCBhemkgKSxcbiAgICAgIGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxuICAgIF0gKTtcblxuICB9XG5cblxuICAvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxuXG4gIGZ1bmN0aW9uIHN1YmRpdmlkZSggZmFjZSwgZGV0YWlsICkge1xuXG4gICAgdmFyIGNvbHMgPSBNYXRoLnBvdyggMiwgZGV0YWlsICk7XG4gICAgdmFyIGEgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmEgXSApO1xuICAgIHZhciBiID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcbiAgICB2YXIgYyA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYyBdICk7XG4gICAgdmFyIHYgPSBbXTtcblxuICAgIHZhciBtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xuXG4gICAgLy8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cbiAgICAgIHZbIGkgXSA9IFtdO1xuXG4gICAgICB2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuICAgICAgdmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcbiAgICAgIHZhciByb3dzID0gY29scyAtIGk7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqICsrICkge1xuXG4gICAgICAgIGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xuXG4gICAgICAgICAgdlsgaSBdWyBqIF0gPSBhajtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNvbHMgOyBpICsrICkge1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcblxuICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XG5cbiAgICAgICAgaWYgKCBqICUgMiA9PT0gMCApIHtcblxuICAgICAgICAgIG1ha2UoXG4gICAgICAgICAgICB2WyBpIF1bIGsgKyAxIF0sXG4gICAgICAgICAgICB2WyBpICsgMSBdWyBrIF0sXG4gICAgICAgICAgICB2WyBpIF1bIGsgXSxcbiAgICAgICAgICAgIG1hdGVyaWFsSW5kZXhcbiAgICAgICAgICApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBtYWtlKFxuICAgICAgICAgICAgdlsgaSBdWyBrICsgMSBdLFxuICAgICAgICAgICAgdlsgaSArIDEgXVsgayArIDEgXSxcbiAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgXSxcbiAgICAgICAgICAgIG1hdGVyaWFsSW5kZXhcbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuXG4gIC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuICBmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcblxuICB9XG5cblxuICAvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cbiAgZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG4gIH1cblxuXG4gIC8vIFRleHR1cmUgZml4aW5nIGhlbHBlci4gU3BoZXJlcyBoYXZlIHNvbWUgb2RkIGJlaGF2aW91cnMuXG5cbiAgZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xuXG4gICAgaWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1di54IC0gMSwgdXYueSApO1xuICAgIGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xuICAgIHJldHVybiB1di5jbG9uZSgpO1xuXG4gIH1cblxuXG59O1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5O1xuXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkoXG4gICAgdGhpcy5wYXJhbWV0ZXJzLnZlcnRpY2VzLFxuICAgIHRoaXMucGFyYW1ldGVycy5pbmRpY2VzLFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICApO1xuXG4gIHJldHVybiBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbn07XG5cblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuICByZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxuICovXG5cblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuICB2YXIgciA9IDEgLyB0O1xuXG4gIHZhciB2ZXJ0aWNlcyA9IFtcblxuICAgIC8vICjCsTEsIMKxMSwgwrExKVxuICAgIC0gMSwgLSAxLCAtIDEsICAgIC0gMSwgLSAxLCAgMSxcbiAgICAtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxuICAgICAxLCAtIDEsIC0gMSwgICAgIDEsIC0gMSwgIDEsXG4gICAgIDEsICAxLCAtIDEsICAgICAxLCAgMSwgIDEsXG5cbiAgICAvLyAoMCwgwrExL8+GLCDCsc+GKVxuICAgICAwLCAtIHIsIC0gdCwgICAgIDAsIC0gciwgIHQsXG4gICAgIDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXG5cbiAgICAvLyAowrExL8+GLCDCsc+GLCAwKVxuICAgIC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXG4gICAgIHIsIC0gdCwgIDAsICAgICByLCAgdCwgIDAsXG5cbiAgICAvLyAowrHPhiwgMCwgwrExL8+GKVxuICAgIC0gdCwgIDAsIC0gciwgICAgIHQsICAwLCAtIHIsXG4gICAgLSB0LCAgMCwgIHIsICAgICB0LCAgMCwgIHJcbiAgXTtcblxuICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXG4gICAgIDcsIDE5LCAxNywgICAgICA3LCAxNywgIDYsICAgICAgNywgIDYsIDE1LFxuICAgIDE3LCAgNCwgIDgsICAgICAxNywgIDgsIDEwLCAgICAgMTcsIDEwLCAgNixcbiAgICAgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXG4gICAgIDAsIDEyLCAgMSwgICAgICAwLCAgMSwgMTgsICAgICAgMCwgMTgsIDE2LFxuICAgICA2LCAxMCwgIDIsICAgICAgNiwgIDIsIDEzLCAgICAgIDYsIDEzLCAxNSxcbiAgICAgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXG4gICAgMTgsICAxLCAgOSwgICAgIDE4LCAgOSwgMTEsICAgICAxOCwgMTEsICAzLFxuICAgICA0LCAxNCwgMTIsICAgICAgNCwgMTIsICAwLCAgICAgIDQsICAwLCAgOCxcbiAgICAxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXG4gICAgMTksICA1LCAxNCwgICAgIDE5LCAxNCwgIDQsICAgICAxOSwgIDQsIDE3LFxuICAgICAxLCAxMiwgMTQsICAgICAgMSwgMTQsICA1LCAgICAgIDEsICA1LCAgOVxuICBdO1xuXG4gIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICB0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9O1xuXG59O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcbiAgICB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLFxuICAgIHRoaXMucGFyYW1ldGVycy5kZXRhaWxcbiAgKTtcblxuICBnZW9tZXRyeS5jb3B5KCB0aGlzICk7XG5cbiAgcmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9JY29zYWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cbiAgdmFyIHZlcnRpY2VzID0gW1xuICAgIC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuICAgICAwLCAtIDEsICB0LCAgICAwLCAgMSwgIHQsICAgIDAsIC0gMSwgLSB0LCAgICAwLCAgMSwgLSB0LFxuICAgICB0LCAgMCwgLSAxLCAgICB0LCAgMCwgIDEsICAgLSB0LCAgMCwgLSAxLCAgIC0gdCwgIDAsICAxXG4gIF07XG5cbiAgdmFyIGluZGljZXMgPSBbXG4gICAgIDAsIDExLCAgNSwgICAgMCwgIDUsICAxLCAgICAwLCAgMSwgIDcsICAgIDAsICA3LCAxMCwgICAgMCwgMTAsIDExLFxuICAgICAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcbiAgICAgMywgIDksICA0LCAgICAzLCAgNCwgIDIsICAgIDMsICAyLCAgNiwgICAgMywgIDYsICA4LCAgICAzLCAgOCwgIDksXG4gICAgIDQsICA5LCAgNSwgICAgMiwgIDQsIDExLCAgICA2LCAgMiwgMTAsICAgIDgsICA2LCAgNywgICAgOSwgIDgsICAxXG4gIF07XG5cbiAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gIHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcblxufTtcblxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICApO1xuXG4gIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL09jdGFoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAxLCAwLCAwLCAgIC0gMSwgMCwgMCwgICAgMCwgMSwgMCwgICAgMCwgLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLCAtIDFcbiAgXTtcblxuICB2YXIgaW5kaWNlcyA9IFtcbiAgICAwLCAyLCA0LCAgICAwLCA0LCAzLCAgICAwLCAzLCA1LCAgICAwLCA1LCAyLCAgICAxLCAyLCA1LCAgICAxLCA1LCAzLCAgICAxLCAzLCA0LCAgICAxLCA0LCAyXG4gIF07XG5cbiAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gIHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9O1xuXG59O1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeTtcblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICApO1xuXG4gIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcbiAgXTtcblxuICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG4gIF07XG5cbiAgVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gIHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcblxufTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XG5cblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxuICAgIHRoaXMucGFyYW1ldGVycy5yYWRpdXMsXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmRldGFpbFxuICApO1xuXG4gIGdlb21ldHJ5LmNvcHkoIHRoaXMgKTtcblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XG4gKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuICpcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XG4gKlxuICovXG5cblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSA9IGZ1bmN0aW9uICggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBmdW5jOiBmdW5jLFxuICAgIHNsaWNlczogc2xpY2VzLFxuICAgIHN0YWNrczogc3RhY2tzXG4gIH07XG5cbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcbiAgdmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG4gIHZhciBpLCBqLCBwO1xuICB2YXIgdSwgdjtcblxuICB2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cbiAgZm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xuXG4gICAgdiA9IGkgLyBzdGFja3M7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XG5cbiAgICAgIHUgPSBqIC8gc2xpY2VzO1xuXG4gICAgICBwID0gZnVuYyggdSwgdiApO1xuICAgICAgdmVydHMucHVzaCggcCApO1xuXG4gICAgfVxuXG4gIH1cblxuICB2YXIgYSwgYiwgYywgZDtcbiAgdmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuICBmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcblxuICAgIGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG4gICAgICBhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuICAgICAgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG4gICAgICBjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xuICAgICAgZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xuXG4gICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgICAgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG4gICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG5cbiAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICB1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgIHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gY29uc29sZS5sb2codGhpcyk7XG5cbiAgLy8gbWFnaWMgYnVsbGV0XG4gIC8vIHZhciBkaWZmID0gdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG4gIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xuICB2YXIgc29ydEZ1bmN0aW9uID0gZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgcmV0dXJuIGEgLSBiO1xuXG4gIH07XG5cbiAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICB2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcbiAgICB2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgLy8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG4gICAgdmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCA2ICogZmFjZXMubGVuZ3RoICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cbiAgICAgICAgZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgICAgIGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG4gICAgICAgICAgaGFzaFsga2V5IF0gPSB0cnVlO1xuICAgICAgICAgIG51bUVkZ2VzICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMjsgaiArKyApIHtcblxuICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzIFsgMiAqIGkgKyBqIF0gXTtcblxuICAgICAgICB2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgICAgICBjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XG4gICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0ZXgueTtcbiAgICAgICAgY29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIC8vIEluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcbiAgICAgIHZhciBkcmF3Y2FsbHMgPSBnZW9tZXRyeS5kcmF3Y2FsbHM7XG4gICAgICB2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgICBpZiAoIGRyYXdjYWxscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkuYWRkRHJhd0NhbGwoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG4gICAgICB2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgICBmb3IgKCB2YXIgbyA9IDAsIG9sID0gZHJhd2NhbGxzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG4gICAgICAgIHZhciBkcmF3Y2FsbCA9IGRyYXdjYWxsc1sgbyBdO1xuXG4gICAgICAgIHZhciBzdGFydCA9IGRyYXdjYWxsLnN0YXJ0O1xuICAgICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbC5jb3VudDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgICAgICAgZWRnZVsgMCBdID0gaW5kaWNlc1sgaSArIGogXTtcbiAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGluZGljZXNbIGkgKyAoIGogKyAxICkgJSAzIF07XG4gICAgICAgICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgICAgICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuICAgICAgICAgICAgICBoYXNoWyBrZXkgXSA9IHRydWU7XG4gICAgICAgICAgICAgIG51bUVkZ2VzICsrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG4gICAgICAgICAgdmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcbiAgICAgICAgICB2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xuXG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgIHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgICB2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcblxuICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgICAgIHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xuXG4gICAgICAgICAgdmFyIGluZGV4MSA9IDkgKiBpICsgMyAqIGo7XG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDEgXTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MSArIDIgXTtcblxuICAgICAgICAgIHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICAgIH1cblxuICB9XG5cbn07XG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XG5cbiAgc2l6ZSA9IHNpemUgfHwgMTtcblxuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgMCwgMCwgMCwgIHNpemUsIDAsIDAsXG4gICAgMCwgMCwgMCwgIDAsIHNpemUsIDAsXG4gICAgMCwgMCwgMCwgIDAsIDAsIHNpemVcbiAgXSApO1xuXG4gIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgMSwgMCwgMCwgIDEsIDAuNiwgMCxcbiAgICAwLCAxLCAwLCAgMC42LCAxLCAwLFxuICAgIDAsIDAsIDEsICAwLCAwLjYsIDFcbiAgXSApO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXhpc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICpcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcbiAqXG4gKiBQYXJhbWV0ZXJzOlxuICogIGRpciAtIFZlY3RvcjNcbiAqICBvcmlnaW4gLSBWZWN0b3IzXG4gKiAgbGVuZ3RoIC0gTnVtYmVyXG4gKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcbiAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXG4gKiAgaGVhZFdpZHRoIC0gTnVtYmVyXG4gKi9cblxuVEhSRUUuQXJyb3dIZWxwZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG5cbiAgdmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcbiAgY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcblxuICByZXR1cm4gZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cbiAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xuICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xuICAgIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcbiAgICBpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuICAgIHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cbiAgICB0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuICAgIHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5hZGQoIHRoaXMubGluZSApO1xuXG4gICAgdGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGNvbmVHZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcbiAgICB0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuICAgIHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcbiAgICB0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblxuICB9XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFycm93SGVscGVyO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgcmFkaWFucztcblxuICByZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XG5cbiAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG4gICAgfSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICByYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG4gICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG4gICAgfVxuXG4gIH07XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuICBpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG4gIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG4gIHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCAtIGhlYWRMZW5ndGgsIDEgKTtcbiAgdGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuXG4gIHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG4gIHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuICB0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgdGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcbiAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm94SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Cb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA3MiApLCAzICkgKTtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApICk7XG5cbiAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94SGVscGVyO1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgIGlmICggYm94LmVtcHR5KCkgKSByZXR1cm47XG5cbiAgICB2YXIgbWluID0gYm94Lm1pbjtcbiAgICB2YXIgbWF4ID0gYm94Lm1heDtcblxuICAgIC8qXG4gICAgICA1X19fXzRcbiAgICAxL19fXzAvfFxuICAgIHwgNl9ffF83XG4gICAgMi9fX18zL1xuXG4gICAgMDogbWF4LngsIG1heC55LCBtYXguelxuICAgIDE6IG1pbi54LCBtYXgueSwgbWF4LnpcbiAgICAyOiBtaW4ueCwgbWluLnksIG1heC56XG4gICAgMzogbWF4LngsIG1pbi55LCBtYXguelxuICAgIDQ6IG1heC54LCBtYXgueSwgbWluLnpcbiAgICA1OiBtaW4ueCwgbWF4LnksIG1pbi56XG4gICAgNjogbWluLngsIG1pbi55LCBtaW4uelxuICAgIDc6IG1heC54LCBtaW4ueSwgbWluLnpcbiAgICAqL1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgdmVydGljZXNbIDAgXSA9IG1heC54OyB2ZXJ0aWNlc1sgMSBdID0gbWF4Lnk7IHZlcnRpY2VzWyAyIF0gPSBtYXguejtcbiAgICB2ZXJ0aWNlc1sgMyBdID0gbWluLng7IHZlcnRpY2VzWyA0IF0gPSBtYXgueTsgdmVydGljZXNbIDUgXSA9IG1heC56O1xuXG4gICAgdmVydGljZXNbIDYgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNyBdID0gbWF4Lnk7IHZlcnRpY2VzWyA4IF0gPSBtYXguejtcbiAgICB2ZXJ0aWNlc1sgOSBdID0gbWluLng7IHZlcnRpY2VzWyAxMCBdID0gbWluLnk7IHZlcnRpY2VzWyAxMSBdID0gbWF4Lno7XG5cbiAgICB2ZXJ0aWNlc1sgMTIgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMTMgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMTQgXSA9IG1heC56O1xuICAgIHZlcnRpY2VzWyAxNSBdID0gbWF4Lng7IHZlcnRpY2VzWyAxNiBdID0gbWluLnk7IHZlcnRpY2VzWyAxNyBdID0gbWF4Lno7XG5cbiAgICB2ZXJ0aWNlc1sgMTggXSA9IG1heC54OyB2ZXJ0aWNlc1sgMTkgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMjAgXSA9IG1heC56O1xuICAgIHZlcnRpY2VzWyAyMSBdID0gbWF4Lng7IHZlcnRpY2VzWyAyMiBdID0gbWF4Lnk7IHZlcnRpY2VzWyAyMyBdID0gbWF4Lno7XG5cbiAgICAvL1xuXG4gICAgdmVydGljZXNbIDI0IF0gPSBtYXgueDsgdmVydGljZXNbIDI1IF0gPSBtYXgueTsgdmVydGljZXNbIDI2IF0gPSBtaW4uejtcbiAgICB2ZXJ0aWNlc1sgMjcgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMjggXSA9IG1heC55OyB2ZXJ0aWNlc1sgMjkgXSA9IG1pbi56O1xuXG4gICAgdmVydGljZXNbIDMwIF0gPSBtaW4ueDsgdmVydGljZXNbIDMxIF0gPSBtYXgueTsgdmVydGljZXNbIDMyIF0gPSBtaW4uejtcbiAgICB2ZXJ0aWNlc1sgMzMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMzUgXSA9IG1pbi56O1xuXG4gICAgdmVydGljZXNbIDM2IF0gPSBtaW4ueDsgdmVydGljZXNbIDM3IF0gPSBtaW4ueTsgdmVydGljZXNbIDM4IF0gPSBtaW4uejtcbiAgICB2ZXJ0aWNlc1sgMzkgXSA9IG1heC54OyB2ZXJ0aWNlc1sgNDAgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNDEgXSA9IG1pbi56O1xuXG4gICAgdmVydGljZXNbIDQyIF0gPSBtYXgueDsgdmVydGljZXNbIDQzIF0gPSBtaW4ueTsgdmVydGljZXNbIDQ0IF0gPSBtaW4uejtcbiAgICB2ZXJ0aWNlc1sgNDUgXSA9IG1heC54OyB2ZXJ0aWNlc1sgNDYgXSA9IG1heC55OyB2ZXJ0aWNlc1sgNDcgXSA9IG1pbi56O1xuXG4gICAgLy9cblxuICAgIHZlcnRpY2VzWyA0OCBdID0gbWF4Lng7IHZlcnRpY2VzWyA0OSBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MCBdID0gbWF4Lno7XG4gICAgdmVydGljZXNbIDUxIF0gPSBtYXgueDsgdmVydGljZXNbIDUyIF0gPSBtYXgueTsgdmVydGljZXNbIDUzIF0gPSBtaW4uejtcblxuICAgIHZlcnRpY2VzWyA1NCBdID0gbWluLng7IHZlcnRpY2VzWyA1NSBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1NiBdID0gbWF4Lno7XG4gICAgdmVydGljZXNbIDU3IF0gPSBtaW4ueDsgdmVydGljZXNbIDU4IF0gPSBtYXgueTsgdmVydGljZXNbIDU5IF0gPSBtaW4uejtcblxuICAgIHZlcnRpY2VzWyA2MCBdID0gbWluLng7IHZlcnRpY2VzWyA2MSBdID0gbWluLnk7IHZlcnRpY2VzWyA2MiBdID0gbWF4Lno7XG4gICAgdmVydGljZXNbIDYzIF0gPSBtaW4ueDsgdmVydGljZXNbIDY0IF0gPSBtaW4ueTsgdmVydGljZXNbIDY1IF0gPSBtaW4uejtcblxuICAgIHZlcnRpY2VzWyA2NiBdID0gbWF4Lng7IHZlcnRpY2VzWyA2NyBdID0gbWluLnk7IHZlcnRpY2VzWyA2OCBdID0gbWF4Lno7XG4gICAgdmVydGljZXNbIDY5IF0gPSBtYXgueDsgdmVydGljZXNbIDcwIF0gPSBtaW4ueTsgdmVydGljZXNbIDcxIF0gPSBtaW4uejtcblxuICAgIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gIH1cblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JvdW5kaW5nQm94SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuLy8gYSBoZWxwZXIgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYW4gb2JqZWN0XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweDg4ODg4ODtcblxuICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICB0aGlzLmJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuQm94R2VvbWV0cnkoIDEsIDEsIDEgKSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgd2lyZWZyYW1lOiB0cnVlIH0gKSApO1xuXG59O1xuXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm91bmRpbmdCb3hIZWxwZXI7XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuICB0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XG5cbiAgdGhpcy5ib3guY2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogIC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxuICogIC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuICogIC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcbiAqICAgIGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcbiAqL1xuXG5USFJFRS5DYW1lcmFIZWxwZXIgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzIH0gKTtcblxuICB2YXIgcG9pbnRNYXAgPSB7fTtcblxuICAvLyBjb2xvcnNcblxuICB2YXIgaGV4RnJ1c3R1bSA9IDB4ZmZhYTAwO1xuICB2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xuICB2YXIgaGV4VXAgPSAweDAwYWFmZjtcbiAgdmFyIGhleFRhcmdldCA9IDB4ZmZmZmZmO1xuICB2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcblxuICAvLyBuZWFyXG5cbiAgYWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJuMlwiLCBcIm40XCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcblxuICAvLyBmYXJcblxuICBhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuXG4gIC8vIHNpZGVzXG5cbiAgYWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJuMlwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcbiAgYWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblxuICAvLyBjb25lXG5cbiAgYWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xuICBhZGRMaW5lKCBcInBcIiwgXCJuMlwiLCBoZXhDb25lICk7XG4gIGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcbiAgYWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xuXG4gIC8vIHVwXG5cbiAgYWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGhleFVwICk7XG4gIGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xuICBhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcblxuICAvLyB0YXJnZXRcblxuICBhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGhleFRhcmdldCApO1xuICBhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XG5cbiAgLy8gY3Jvc3NcblxuICBhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xuICBhZGRMaW5lKCBcImNuM1wiLCBcImNuNFwiLCBoZXhDcm9zcyApO1xuXG4gIGFkZExpbmUoIFwiY2YxXCIsIFwiY2YyXCIsIGhleENyb3NzICk7XG4gIGFkZExpbmUoIFwiY2YzXCIsIFwiY2Y0XCIsIGhleENyb3NzICk7XG5cbiAgZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xuXG4gICAgYWRkUG9pbnQoIGEsIGhleCApO1xuICAgIGFkZFBvaW50KCBiLCBoZXggKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBoZXggKSB7XG5cbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG4gICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuICAgIGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgcG9pbnRNYXBbIGlkIF0gPSBbXTtcblxuICAgIH1cblxuICAgIHBvaW50TWFwWyBpZCBdLnB1c2goIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblxuICB9XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICB0aGlzLm1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhSGVscGVyO1xuXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnksIHBvaW50TWFwO1xuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgY2FtZXJhID0gbmV3IFRIUkVFLkNhbWVyYSgpO1xuXG4gIHZhciBzZXRQb2ludCA9IGZ1bmN0aW9uICggcG9pbnQsIHgsIHksIHogKSB7XG5cbiAgICB2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgIHZhciBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcblxuICAgIGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbIHBvaW50c1sgaSBdIF0uY29weSggdmVjdG9yICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgcG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xuXG4gICAgdmFyIHcgPSAxLCBoID0gMTtcblxuICAgIC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG4gICAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgLy8gY2VudGVyIC8gdGFyZ2V0XG5cbiAgICBzZXRQb2ludCggXCJjXCIsIDAsIDAsIC0gMSApO1xuICAgIHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcblxuICAgIC8vIG5lYXJcblxuICAgIHNldFBvaW50KCBcIm4xXCIsIC0gdywgLSBoLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJuMlwiLCAgIHcsIC0gaCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwibjNcIiwgLSB3LCAgIGgsIC0gMSApO1xuICAgIHNldFBvaW50KCBcIm40XCIsICAgdywgICBoLCAtIDEgKTtcblxuICAgIC8vIGZhclxuXG4gICAgc2V0UG9pbnQoIFwiZjFcIiwgLSB3LCAtIGgsIDEgKTtcbiAgICBzZXRQb2ludCggXCJmMlwiLCAgIHcsIC0gaCwgMSApO1xuICAgIHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XG4gICAgc2V0UG9pbnQoIFwiZjRcIiwgICB3LCAgIGgsIDEgKTtcblxuICAgIC8vIHVwXG5cbiAgICBzZXRQb2ludCggXCJ1MVwiLCAgIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuICAgIHNldFBvaW50KCBcInUyXCIsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwidTNcIiwgICAgICAgICAwLCBoICogMiwgICAtIDEgKTtcblxuICAgIC8vIGNyb3NzXG5cbiAgICBzZXRQb2ludCggXCJjZjFcIiwgLSB3LCAgIDAsIDEgKTtcbiAgICBzZXRQb2ludCggXCJjZjJcIiwgICB3LCAgIDAsIDEgKTtcbiAgICBzZXRQb2ludCggXCJjZjNcIiwgICAwLCAtIGgsIDEgKTtcbiAgICBzZXRQb2ludCggXCJjZjRcIiwgICAwLCAgIGgsIDEgKTtcblxuICAgIHNldFBvaW50KCBcImNuMVwiLCAtIHcsICAgMCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwiY24yXCIsICAgdywgICAwLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJjbjNcIiwgICAwLCAtIGgsIC0gMSApO1xuICAgIHNldFBvaW50KCBcImNuNFwiLCAgIDAsICAgaCwgLSAxICk7XG5cbiAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gIH07XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRGlyZWN0aW9uYWxMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNpemUgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMubGlnaHQgPSBsaWdodDtcbiAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHNpemUgPSBzaXplIHx8IDE7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgICBzaXplLCAwICksXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgICBzaXplLCAwICksXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgLSBzaXplLCAwICksXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgLSBzaXplLCAwICksXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgICBzaXplLCAwIClcbiAgKTtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICB0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gIHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcblxuICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoKVxuICApO1xuXG4gIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgdGhpcy50YXJnZXRMaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICB0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XG5cbiAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgIHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xuXG4gICAgdGhpcy5saWdodFBsYW5lLmxvb2tBdCggdjMgKTtcbiAgICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcbiAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yICk7XG5cbiAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9FZGdlc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQHBhcmFtIG9iamVjdCBUSFJFRS5NZXNoIHdob3NlIGdlb21ldHJ5IHdpbGwgYmUgdXNlZFxuICogQHBhcmFtIGhleCBsaW5lIGNvbG9yXG4gKiBAcGFyYW0gdGhyZXNob2xkQW5nbGUgdGhlIG1pbmltdW0gYW5nbGUgKGluIGRlZ3JlZXMpLFxuICogYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIGFkamFjZW50IGZhY2VzLFxuICogdGhhdCBpcyByZXF1aXJlZCB0byByZW5kZXIgYW4gZWRnZS4gQSB2YWx1ZSBvZiAxMCBtZWFuc1xuICogYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSBpcyBhdCBsZWFzdCAxMCBkZWdyZWVzLlxuICovXG5cblRIUkVFLkVkZ2VzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCwgdGhyZXNob2xkQW5nbGUgKSB7XG5cbiAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cbiAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRmFjZU5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuICAvLyBGYWNlTm9ybWFsc0hlbHBlciBvbmx5IHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5XG5cbiAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgdGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xuXG4gIHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cbiAgLy9cblxuICB2YXIgbk5vcm1hbHMgPSAwO1xuXG4gIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgIG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcblxuICB9XG5cbiAgLy9cblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuICAvL1xuXG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjtcblxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgLy9cblxuICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XG5cbiAgICB2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcblxuICAgIHZhciBpZHggPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICB2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cbiAgICAgIHYxLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApXG4gICAgICAgIC5hZGQoIHZlcnRpY2VzWyBmYWNlLmIgXSApXG4gICAgICAgIC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXG4gICAgICAgIC5kaXZpZGVTY2FsYXIoIDMgKVxuICAgICAgICAuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgICB2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICB9XG5cbiAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbn0oKSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9HcmlkSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5HcmlkSGVscGVyID0gZnVuY3Rpb24gKCBzaXplLCBzdGVwICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xuXG4gIHRoaXMuY29sb3IxID0gbmV3IFRIUkVFLkNvbG9yKCAweDQ0NDQ0NCApO1xuICB0aGlzLmNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHg4ODg4ODggKTtcblxuICBmb3IgKCB2YXIgaSA9IC0gc2l6ZTsgaSA8PSBzaXplOyBpICs9IHN0ZXAgKSB7XG5cbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgMCwgaSApLCBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgMCwgaSApLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIC0gc2l6ZSApLCBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgc2l6ZSApXG4gICAgKTtcblxuICAgIHZhciBjb2xvciA9IGkgPT09IDAgPyB0aGlzLmNvbG9yMSA6IHRoaXMuY29sb3IyO1xuXG4gICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cbiAgfVxuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyaWRIZWxwZXI7XG5cblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uKCBjb2xvckNlbnRlckxpbmUsIGNvbG9yR3JpZCApIHtcblxuICB0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xuICB0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xuXG4gIHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMubGlnaHQgPSBsaWdodDtcbiAgdGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gIHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMuY29sb3JzID0gWyBuZXcgVEhSRUUuQ29sb3IoKSwgbmV3IFRIUkVFLkNvbG9yKCkgXTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcbiAgZ2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuICB9XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcblxuICB0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICB0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgdGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcbiAgICB0aGlzLmNvbG9yc1sgMSBdLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcbiAgICB0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gIH1cblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Qb2ludExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICB0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIC8qXG4gIHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcbiAgdmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG4gIHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcbiAgdGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuICB2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xuXG4gIGlmICggZCA9PT0gMC4wICkge1xuXG4gICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG4gIH1cblxuICB0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XG4gICovXG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodEhlbHBlcjtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAvKlxuICB2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cbiAgaWYgKCBkID09PSAwLjAgKSB7XG5cbiAgICB0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG4gIH1cbiAgKi9cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU2tlbGV0b25IZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxuICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIHRoaXMuYm9uZXMgPSB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QgKTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG4gICAgaWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDAsIDEgKSApO1xuICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMSwgMCApICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGdlb21ldHJ5LmR5bmFtaWMgPSB0cnVlO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycywgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgdGhpcy5yb290ID0gb2JqZWN0O1xuXG4gIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNrZWxldG9uSGVscGVyO1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gIHZhciBib25lTGlzdCA9IFtdO1xuXG4gIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgIGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xuXG4gIH1cblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgYm9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdC5jaGlsZHJlblsgaSBdICkgKTtcblxuICB9XG5cbiAgcmV0dXJuIGJvbmVMaXN0O1xuXG59O1xuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgdmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcblxuICB2YXIgYm9uZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgdmFyIGogPSAwO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cbiAgICBpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXNbIGogXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblxuICAgICAgYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBqICsgMSBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG4gICAgICBqICs9IDI7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gIHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICB0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMSwgMSwgOCwgMSwgdHJ1ZSApO1xuXG4gIGdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcbiAgZ2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuXG4gIHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgdGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHRIZWxwZXI7XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDA7XG4gICAgdmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xuXG4gICAgdGhpcy5jb25lLnNjYWxlLnNldCggY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGggKTtcblxuICAgIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcbiAgICB2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuICAgIHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xuXG4gICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICB9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleE5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcblxuICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gIC8vXG5cbiAgdmFyIG5Ob3JtYWxzID0gMDtcblxuICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICBuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aCAqIDM7XG5cbiAgfSBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgIG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuY291bnRcblxuICB9XG5cbiAgLy9cblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuICAvL1xuXG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICBub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgdmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAvL1xuXG4gICAgdmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICB2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcblxuICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGZhY2VbIGtleXNbIGogXSBdIF07XG5cbiAgICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XG5cbiAgICAgICAgICB2MS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICB2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICAgICAgICBpZHggPSBpZHggKyAxO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgdmFyIG9ialBvcyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgIHZhciBvYmpOb3JtID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICAgIHZhciBpZHggPSAwO1xuXG4gICAgICAvLyBmb3Igc2ltcGxpY2l0eSwgaWdub3JlIGluZGV4IGFuZCBkcmF3Y2FsbHMsIGFuZCByZW5kZXIgZXZlcnkgbm9ybWFsXG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBvYmpQb3MuY291bnQ7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB2MS5zZXQoIG9ialBvcy5nZXRYKCBqICksIG9ialBvcy5nZXRZKCBqICksIG9ialBvcy5nZXRaKCBqICkgKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgdjIuc2V0KCBvYmpOb3JtLmdldFgoIGogKSwgb2JqTm9ybS5nZXRZKCBqICksIG9iak5vcm0uZ2V0WiggaiApICk7XG5cbiAgICAgICAgdjIuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxufSgpICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1ZlcnRleFRhbmdlbnRzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cbiAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgdGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4MDAwMGZmO1xuXG4gIHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cbiAgLy9cblxuICB2YXIgblRhbmdlbnRzID0gMDtcblxuICB2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuICBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICBuVGFuZ2VudHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGggKiAzO1xuXG4gIH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICBuVGFuZ2VudHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQuY291bnRcblxuICB9XG5cbiAgLy9cblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuICB2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5UYW5nZW50cyAqIDIgKiAzLCAzICk7XG5cbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cbiAgLy9cblxuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlcjtcblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgLy9cblxuICAgIHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgdmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cbiAgICAgIHZhciBpZHggPSAwO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZmFjZVsga2V5c1sgaiBdIF0gXTtcblxuICAgICAgICAgIHZhciB0YW5nZW50ID0gZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaiBdO1xuXG4gICAgICAgICAgdjEuY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgdjIuc2V0KCB0YW5nZW50LngsIHRhbmdlbnQueSwgdGFuZ2VudC56ICk7IC8vIHRhbmdlbnQudyB1c2VkIGZvciBiaXRhbmdlbnRzIG9ubHlcblxuICAgICAgICAgIHYyLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4V29ybGQgKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgICAgICAgcG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuICAgICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICAgIHZhciBvYmpQb3MgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICB2YXIgb2JqVGFuID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50O1xuXG4gICAgICB2YXIgaWR4ID0gMDtcblxuICAgICAgLy8gZm9yIHNpbXBsaWNpdHksIGlnbm9yZSBpbmRleCBhbmQgZHJhd2NhbGxzLCBhbmQgcmVuZGVyIGV2ZXJ5IHRhbmdlbnRcblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgICAgICB2Mi5zZXQoIG9ialRhbi5nZXRYKCBqICksIG9ialRhbi5nZXRZKCBqICksIG9ialRhbi5nZXRaKCBqICkgKTsgLy8gdGFuZ2VudC53IHVzZWQgZm9yIGJpdGFuZ2VudHMgb25seVxuXG4gICAgICAgIHYyLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4V29ybGQgKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgICAgIHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICBwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxufSgpICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1dpcmVmcmFtZUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcblxuICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9JbW1lZGlhdGVSZW5kZXJPYmplY3QuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHJlbmRlckNhbGxiYWNrICkge307XG5cbn07XG5cblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL01vcnBoQmxlbmRNZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICB0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcbiAgdGhpcy5hbmltYXRpb25zTGlzdCA9IFtdO1xuXG4gIC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cbiAgLy8gKGFsbCBmcmFtZXMgcGxheWVkIHRvZ2V0aGVyIGluIDEgc2Vjb25kKVxuXG4gIHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cbiAgdmFyIG5hbWUgPSBcIl9fZGVmYXVsdFwiO1xuXG4gIHZhciBzdGFydEZyYW1lID0gMDtcbiAgdmFyIGVuZEZyYW1lID0gbnVtRnJhbWVzIC0gMTtcblxuICB2YXIgZnBzID0gbnVtRnJhbWVzIC8gMTtcblxuICB0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xuICB0aGlzLnNldEFuaW1hdGlvbldlaWdodCggbmFtZSwgMSApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhCbGVuZE1lc2g7XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcblxuICB2YXIgYW5pbWF0aW9uID0ge1xuXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuXG4gICAgbGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXG5cbiAgICBmcHM6IGZwcyxcbiAgICBkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxuXG4gICAgbGFzdEZyYW1lOiAwLFxuICAgIGN1cnJlbnRGcmFtZTogMCxcblxuICAgIGFjdGl2ZTogZmFsc2UsXG5cbiAgICB0aW1lOiAwLFxuICAgIGRpcmVjdGlvbjogMSxcbiAgICB3ZWlnaHQ6IDEsXG5cbiAgICBkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxuICAgIG1pcnJvcmVkTG9vcDogZmFsc2VcblxuICB9O1xuXG4gIHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xuICB0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcblxuICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuICB2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG4gICAgdmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuICAgIGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xuXG4gICAgICB2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xuXG4gICAgICBpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cbiAgICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cbiAgICAgIGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xuICAgICAgaWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcblxuICAgICAgaWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xuXG4gICAgfVxuXG4gIH1cblxuICBmb3IgKCB2YXIgbmFtZSBpbiBmcmFtZVJhbmdlcyApIHtcblxuICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG4gICAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xuXG4gIH1cblxuICB0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICBhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5mcHMgPSBmcHM7XG4gICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICBhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICBhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi50aW1lID0gdGltZTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciB0aW1lID0gMDtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICB0aW1lID0gYW5pbWF0aW9uLnRpbWU7XG5cbiAgfVxuXG4gIHJldHVybiB0aW1lO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgdmFyIGR1cmF0aW9uID0gLSAxO1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gIH1cblxuICByZXR1cm4gZHVyYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi50aW1lID0gMDtcbiAgICBhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcblxuICB9IGVsc2Uge1xuXG4gICAgY29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcblxuICAgIGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XG5cbiAgICB2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcblxuICAgIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcblxuICAgIGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcblxuICAgICAgaWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtIDE7XG5cbiAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcblxuICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gMDtcbiAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICAgIH1cblxuICAgIHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XG4gICAgdmFyIHdlaWdodCA9IGFuaW1hdGlvbi53ZWlnaHQ7XG5cbiAgICBpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gMDtcbiAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cbiAgICAgIGFuaW1hdGlvbi5sYXN0RnJhbWUgPSBhbmltYXRpb24uY3VycmVudEZyYW1lO1xuICAgICAgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSA9IGtleWZyYW1lO1xuXG4gICAgfVxuXG4gICAgdmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuICAgIGlmICggYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyApIG1peCA9IDEgLSBtaXg7XG5cbiAgICBpZiAoIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgIT09IGFuaW1hdGlvbi5sYXN0RnJhbWUgKSB7XG5cbiAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gd2VpZ2h0O1xuXG4gICAgfVxuXG4gIH1cblxufTtcblxuIiwiLyohIChDKSBXZWJSZWZsZWN0aW9uIE1pdCBTdHlsZSBMaWNlbnNlICovXG4oZnVuY3Rpb24oZSx0LG4scil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcnQoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspZHQoZVtuXSx0KX1mdW5jdGlvbiBpdChlKXtmb3IodmFyIHQ9MCxuPWUubGVuZ3RoLHI7dDxuO3QrKylyPWVbdF0sbnQocixiW290KHIpXSl9ZnVuY3Rpb24gc3QoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2oodCkmJihkdCh0LGUpLHJ0KHQucXVlcnlTZWxlY3RvckFsbCh3KSxlKSl9fWZ1bmN0aW9uIG90KGUpe3ZhciB0PWUuZ2V0QXR0cmlidXRlKFwiaXNcIiksbj1lLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkscj1TLmNhbGwoeSx0P3YrdC50b1VwcGVyQ2FzZSgpOmQrbik7cmV0dXJuIHQmJi0xPHImJiF1dChuLHQpPy0xOnJ9ZnVuY3Rpb24gdXQoZSx0KXtyZXR1cm4tMTx3LmluZGV4T2YoZSsnW2lzPVwiJyt0KydcIl0nKX1mdW5jdGlvbiBhdChlKXt2YXIgdD1lLmN1cnJlbnRUYXJnZXQsbj1lLmF0dHJDaGFuZ2Uscj1lLnByZXZWYWx1ZSxpPWUubmV3VmFsdWU7USYmdC5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2smJmUuYXR0ck5hbWUhPT1cInN0eWxlXCImJnQuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUuYXR0ck5hbWUsbj09PWVbYV0/bnVsbDpyLG49PT1lW2xdP251bGw6aSl9ZnVuY3Rpb24gZnQoZSl7dmFyIHQ9c3QoZSk7cmV0dXJuIGZ1bmN0aW9uKGUpe1gucHVzaCh0LGUudGFyZ2V0KX19ZnVuY3Rpb24gbHQoZSl7SyYmKEs9ITEsZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaCxsdCkpLHJ0KChlLnRhcmdldHx8dCkucXVlcnlTZWxlY3RvckFsbCh3KSxlLmRldGFpbD09PW8/bzpzKSxCJiZwdCgpfWZ1bmN0aW9uIGN0KGUsdCl7dmFyIG49dGhpcztxLmNhbGwobixlLHQpLEcuY2FsbChuLHt0YXJnZXQ6bn0pfWZ1bmN0aW9uIGh0KGUsdCl7RChlLHQpLGV0P2V0Lm9ic2VydmUoZSx6KTooSiYmKGUuc2V0QXR0cmlidXRlPWN0LGVbaV09WihlKSxlLmFkZEV2ZW50TGlzdGVuZXIocCxHKSksZS5hZGRFdmVudExpc3RlbmVyKGMsYXQpKSxlLmNyZWF0ZWRDYWxsYmFjayYmUSYmKGUuY3JlYXRlZD0hMCxlLmNyZWF0ZWRDYWxsYmFjaygpLGUuY3JlYXRlZD0hMSl9ZnVuY3Rpb24gcHQoKXtmb3IodmFyIGUsdD0wLG49Ri5sZW5ndGg7dDxuO3QrKyllPUZbdF0sRS5jb250YWlucyhlKXx8KEYuc3BsaWNlKHQsMSksZHQoZSxvKSl9ZnVuY3Rpb24gZHQoZSx0KXt2YXIgbixyPW90KGUpOy0xPHImJih0dChlLGJbcl0pLHI9MCx0PT09cyYmIWVbc10/KGVbb109ITEsZVtzXT0hMCxyPTEsQiYmUy5jYWxsKEYsZSk8MCYmRi5wdXNoKGUpKTp0PT09byYmIWVbb10mJihlW3NdPSExLGVbb109ITAscj0xKSxyJiYobj1lW3QrXCJDYWxsYmFja1wiXSkmJm4uY2FsbChlKSl9aWYociBpbiB0KXJldHVybjt2YXIgaT1cIl9fXCIrcisoTWF0aC5yYW5kb20oKSoxZTU+PjApLHM9XCJhdHRhY2hlZFwiLG89XCJkZXRhY2hlZFwiLHU9XCJleHRlbmRzXCIsYT1cIkFERElUSU9OXCIsZj1cIk1PRElGSUNBVElPTlwiLGw9XCJSRU1PVkFMXCIsYz1cIkRPTUF0dHJNb2RpZmllZFwiLGg9XCJET01Db250ZW50TG9hZGVkXCIscD1cIkRPTVN1YnRyZWVNb2RpZmllZFwiLGQ9XCI8XCIsdj1cIj1cIixtPS9eW0EtWl1bQS1aMC05XSooPzotW0EtWjAtOV0rKSskLyxnPVtcIkFOTk9UQVRJT04tWE1MXCIsXCJDT0xPUi1QUk9GSUxFXCIsXCJGT05ULUZBQ0VcIixcIkZPTlQtRkFDRS1TUkNcIixcIkZPTlQtRkFDRS1VUklcIixcIkZPTlQtRkFDRS1GT1JNQVRcIixcIkZPTlQtRkFDRS1OQU1FXCIsXCJNSVNTSU5HLUdMWVBIXCJdLHk9W10sYj1bXSx3PVwiXCIsRT10LmRvY3VtZW50RWxlbWVudCxTPXkuaW5kZXhPZnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMubGVuZ3RoO3QtLSYmdGhpc1t0XSE9PWU7KTtyZXR1cm4gdH0seD1uLnByb3RvdHlwZSxUPXguaGFzT3duUHJvcGVydHksTj14LmlzUHJvdG90eXBlT2YsQz1uLmRlZmluZVByb3BlcnR5LGs9bi5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsTD1uLmdldE93blByb3BlcnR5TmFtZXMsQT1uLmdldFByb3RvdHlwZU9mLE89bi5zZXRQcm90b3R5cGVPZixNPSEhbi5fX3Byb3RvX18sXz1uLmNyZWF0ZXx8ZnVuY3Rpb24gdnQoZSl7cmV0dXJuIGU/KHZ0LnByb3RvdHlwZT1lLG5ldyB2dCk6dGhpc30sRD1PfHwoTT9mdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9OkwmJms/ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuLHI9TCh0KSxpPTAscz1yLmxlbmd0aDtpPHM7aSsrKW49cltpXSxULmNhbGwoZSxuKXx8QyhlLG4sayh0LG4pKX1yZXR1cm4gZnVuY3Rpb24odCxuKXtkbyBlKHQsbik7d2hpbGUoKG49QShuKSkmJiFOLmNhbGwobix0KSk7cmV0dXJuIHR9fSgpOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpZVtuXT10W25dO3JldHVybiBlfSksUD1lLk11dGF0aW9uT2JzZXJ2ZXJ8fGUuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixIPShlLkhUTUxFbGVtZW50fHxlLkVsZW1lbnR8fGUuTm9kZSkucHJvdG90eXBlLEI9IU4uY2FsbChILEUpLGo9Qj9mdW5jdGlvbihlKXtyZXR1cm4gZS5ub2RlVHlwZT09PTF9OmZ1bmN0aW9uKGUpe3JldHVybiBOLmNhbGwoSCxlKX0sRj1CJiZbXSxJPUguY2xvbmVOb2RlLHE9SC5zZXRBdHRyaWJ1dGUsUj1ILnJlbW92ZUF0dHJpYnV0ZSxVPXQuY3JlYXRlRWxlbWVudCx6PVAmJnthdHRyaWJ1dGVzOiEwLGNoYXJhY3RlckRhdGE6ITAsYXR0cmlidXRlT2xkVmFsdWU6ITB9LFc9UHx8ZnVuY3Rpb24oZSl7Sj0hMSxFLnJlbW92ZUV2ZW50TGlzdGVuZXIoYyxXKX0sWCxWPWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxlLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGUubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZSwxMCl9LCQ9ITEsSj0hMCxLPSEwLFE9ITAsRyxZLFosZXQsdHQsbnQ7T3x8TT8odHQ9ZnVuY3Rpb24oZSx0KXtOLmNhbGwodCxlKXx8aHQoZSx0KX0sbnQ9aHQpOih0dD1mdW5jdGlvbihlLHQpe2VbaV18fChlW2ldPW4oITApLGh0KGUsdCkpfSxudD10dCksQj8oSj0hMSxmdW5jdGlvbigpe3ZhciBlPWsoSCxcImFkZEV2ZW50TGlzdGVuZXJcIiksdD1lLnZhbHVlLG49ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEN1c3RvbUV2ZW50KGMse2J1YmJsZXM6ITB9KTt0LmF0dHJOYW1lPWUsdC5wcmV2VmFsdWU9dGhpcy5nZXRBdHRyaWJ1dGUoZSksdC5uZXdWYWx1ZT1udWxsLHRbbF09dC5hdHRyQ2hhbmdlPTIsUi5jYWxsKHRoaXMsZSksdGhpcy5kaXNwYXRjaEV2ZW50KHQpfSxyPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5oYXNBdHRyaWJ1dGUoZSkscj1uJiZ0aGlzLmdldEF0dHJpYnV0ZShlKSxpPW5ldyBDdXN0b21FdmVudChjLHtidWJibGVzOiEwfSk7cS5jYWxsKHRoaXMsZSx0KSxpLmF0dHJOYW1lPWUsaS5wcmV2VmFsdWU9bj9yOm51bGwsaS5uZXdWYWx1ZT10LG4/aVtmXT1pLmF0dHJDaGFuZ2U9MTppW2FdPWkuYXR0ckNoYW5nZT0wLHRoaXMuZGlzcGF0Y2hFdmVudChpKX0scz1mdW5jdGlvbihlKXt2YXIgdD1lLmN1cnJlbnRUYXJnZXQsbj10W2ldLHI9ZS5wcm9wZXJ0eU5hbWUscztuLmhhc093blByb3BlcnR5KHIpJiYobj1uW3JdLHM9bmV3IEN1c3RvbUV2ZW50KGMse2J1YmJsZXM6ITB9KSxzLmF0dHJOYW1lPW4ubmFtZSxzLnByZXZWYWx1ZT1uLnZhbHVlfHxudWxsLHMubmV3VmFsdWU9bi52YWx1ZT10W3JdfHxudWxsLHMucHJldlZhbHVlPT1udWxsP3NbYV09cy5hdHRyQ2hhbmdlPTA6c1tmXT1zLmF0dHJDaGFuZ2U9MSx0LmRpc3BhdGNoRXZlbnQocykpfTtlLnZhbHVlPWZ1bmN0aW9uKGUsbyx1KXtlPT09YyYmdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2smJnRoaXMuc2V0QXR0cmlidXRlIT09ciYmKHRoaXNbaV09e2NsYXNzTmFtZTp7bmFtZTpcImNsYXNzXCIsdmFsdWU6dGhpcy5jbGFzc05hbWV9fSx0aGlzLnNldEF0dHJpYnV0ZT1yLHRoaXMucmVtb3ZlQXR0cmlidXRlPW4sdC5jYWxsKHRoaXMsXCJwcm9wZXJ0eWNoYW5nZVwiLHMpKSx0LmNhbGwodGhpcyxlLG8sdSl9LEMoSCxcImFkZEV2ZW50TGlzdGVuZXJcIixlKX0oKSk6UHx8KEUuYWRkRXZlbnRMaXN0ZW5lcihjLFcpLEUuc2V0QXR0cmlidXRlKGksMSksRS5yZW1vdmVBdHRyaWJ1dGUoaSksSiYmKEc9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuLHIscztpZih0PT09ZS50YXJnZXQpe249dFtpXSx0W2ldPXI9Wih0KTtmb3IocyBpbiByKXtpZighKHMgaW4gbikpcmV0dXJuIFkoMCx0LHMsbltzXSxyW3NdLGEpO2lmKHJbc10hPT1uW3NdKXJldHVybiBZKDEsdCxzLG5bc10scltzXSxmKX1mb3IocyBpbiBuKWlmKCEocyBpbiByKSlyZXR1cm4gWSgyLHQscyxuW3NdLHJbc10sbCl9fSxZPWZ1bmN0aW9uKGUsdCxuLHIsaSxzKXt2YXIgbz17YXR0ckNoYW5nZTplLGN1cnJlbnRUYXJnZXQ6dCxhdHRyTmFtZTpuLHByZXZWYWx1ZTpyLG5ld1ZhbHVlOml9O29bc109ZSxhdChvKX0sWj1mdW5jdGlvbihlKXtmb3IodmFyIHQsbixyPXt9LGk9ZS5hdHRyaWJ1dGVzLHM9MCxvPWkubGVuZ3RoO3M8bztzKyspdD1pW3NdLG49dC5uYW1lLG4hPT1cInNldEF0dHJpYnV0ZVwiJiYocltuXT10LnZhbHVlKTtyZXR1cm4gcn0pKSx0W3JdPWZ1bmN0aW9uKG4scil7cD1uLnRvVXBwZXJDYXNlKCksJHx8KCQ9ITAsUD8oZXQ9ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUsdCl7Zm9yKHZhciBuPTAscj1lLmxlbmd0aDtuPHI7dChlW24rK10pKTt9cmV0dXJuIG5ldyBQKGZ1bmN0aW9uKHIpe2Zvcih2YXIgaSxzLG89MCx1PXIubGVuZ3RoO288dTtvKyspaT1yW29dLGkudHlwZT09PVwiY2hpbGRMaXN0XCI/KG4oaS5hZGRlZE5vZGVzLGUpLG4oaS5yZW1vdmVkTm9kZXMsdCkpOihzPWkudGFyZ2V0LFEmJnMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJiZpLmF0dHJpYnV0ZU5hbWUhPT1cInN0eWxlXCImJnMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGkuYXR0cmlidXRlTmFtZSxpLm9sZFZhbHVlLHMuZ2V0QXR0cmlidXRlKGkuYXR0cmlidXRlTmFtZSkpKX0pfShzdChzKSxzdChvKSksZXQub2JzZXJ2ZSh0LHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pKTooWD1bXSxWKGZ1bmN0aW9uIEUoKXt3aGlsZShYLmxlbmd0aClYLnNoaWZ0KCkuY2FsbChudWxsLFguc2hpZnQoKSk7VihFKX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLGZ0KHMpKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLGZ0KG8pKSksdC5hZGRFdmVudExpc3RlbmVyKGgsbHQpLHQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixsdCksdC5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKGUsbil7dmFyIHI9VS5hcHBseSh0LGFyZ3VtZW50cyksaT1cIlwiK2Uscz1TLmNhbGwoeSwobj92OmQpKyhufHxpKS50b1VwcGVyQ2FzZSgpKSxvPS0xPHM7cmV0dXJuIG4mJihyLnNldEF0dHJpYnV0ZShcImlzXCIsbj1uLnRvTG93ZXJDYXNlKCkpLG8mJihvPXV0KGkudG9VcHBlckNhc2UoKSxuKSkpLFE9IXQuY3JlYXRlRWxlbWVudC5pbm5lckhUTUxIZWxwZXIsbyYmbnQocixiW3NdKSxyfSxILmNsb25lTm9kZT1mdW5jdGlvbihlKXt2YXIgdD1JLmNhbGwodGhpcywhIWUpLG49b3QodCk7cmV0dXJuLTE8biYmbnQodCxiW25dKSxlJiZpdCh0LnF1ZXJ5U2VsZWN0b3JBbGwodykpLHR9KTtpZigtMjxTLmNhbGwoeSx2K3ApK1MuY2FsbCh5LGQrcCkpdGhyb3cgbmV3IEVycm9yKFwiQSBcIituK1wiIHR5cGUgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO2lmKCFtLnRlc3QocCl8fC0xPFMuY2FsbChnLHApKXRocm93IG5ldyBFcnJvcihcIlRoZSB0eXBlIFwiK24rXCIgaXMgaW52YWxpZFwiKTt2YXIgaT1mdW5jdGlvbigpe3JldHVybiBmP3QuY3JlYXRlRWxlbWVudChsLHApOnQuY3JlYXRlRWxlbWVudChsKX0sYT1yfHx4LGY9VC5jYWxsKGEsdSksbD1mP3JbdV0udG9VcHBlckNhc2UoKTpwLGM9eS5wdXNoKChmP3Y6ZCkrcCktMSxwO3JldHVybiB3PXcuY29uY2F0KHcubGVuZ3RoP1wiLFwiOlwiXCIsZj9sKydbaXM9XCInK24udG9Mb3dlckNhc2UoKSsnXCJdJzpsKSxpLnByb3RvdHlwZT1iW2NdPVQuY2FsbChhLFwicHJvdG90eXBlXCIpP2EucHJvdG90eXBlOl8oSCkscnQodC5xdWVyeVNlbGVjdG9yQWxsKHcpLHMpLGl9fSkod2luZG93LGRvY3VtZW50LE9iamVjdCxcInJlZ2lzdGVyRWxlbWVudFwiKTsiLCIvKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG5cbi8vIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbFxuKCBmdW5jdGlvbiAoIHJvb3QgKSB7XG5cblx0aWYgKCAncGVyZm9ybWFuY2UnIGluIHJvb3QgPT09IGZhbHNlICkge1xuXHRcdHJvb3QucGVyZm9ybWFuY2UgPSB7fTtcblx0fVxuXG5cdC8vIElFIDhcblx0RGF0ZS5ub3cgPSAoIERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH0gKTtcblxuXHRpZiAoICdub3cnIGluIHJvb3QucGVyZm9ybWFuY2UgPT09IGZhbHNlICkge1xuXHRcdHZhciBvZmZzZXQgPSByb290LnBlcmZvcm1hbmNlLnRpbWluZyAmJiByb290LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgPyBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERhdGUubm93KCk7XG5cblx0XHRyb290LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBEYXRlLm5vdygpIC0gb2Zmc2V0O1xuXHRcdH07XG5cdH1cblxufSApKCB0aGlzICk7XG5cbnZhciBUV0VFTiA9IFRXRUVOIHx8ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBfdHdlZW5zID0gW107XG5cblx0cmV0dXJuIHtcblxuXHRcdFJFVklTSU9OOiAnMTQnLFxuXG5cdFx0Z2V0QWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfdHdlZW5zO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRfdHdlZW5zID0gW107XG5cblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiAoIHR3ZWVuICkge1xuXG5cdFx0XHRfdHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIHR3ZWVuICkge1xuXG5cdFx0XHR2YXIgaSA9IF90d2VlbnMuaW5kZXhPZiggdHdlZW4gKTtcblxuXHRcdFx0aWYgKCBpICE9PSAtMSApIHtcblxuXHRcdFx0XHRfdHdlZW5zLnNwbGljZSggaSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHRcdGlmICggX3R3ZWVucy5sZW5ndGggPT09IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0dGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHRpbWUgOiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdHdoaWxlICggaSA8IF90d2VlbnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGlmICggX3R3ZWVuc1sgaSBdLnVwZGF0ZSggdGltZSApICkge1xuXG5cdFx0XHRcdFx0aSsrO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfdHdlZW5zLnNwbGljZSggaSwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblx0fTtcblxufSApKCk7XG5cblRXRUVOLlR3ZWVuID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dmFyIF9vYmplY3QgPSBvYmplY3Q7XG5cdHZhciBfdmFsdWVzU3RhcnQgPSB7fTtcblx0dmFyIF92YWx1ZXNFbmQgPSB7fTtcblx0dmFyIF92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuXHR2YXIgX2R1cmF0aW9uID0gMTAwMDtcblx0dmFyIF9yZXBlYXQgPSAwO1xuXHR2YXIgX3lveW8gPSBmYWxzZTtcblx0dmFyIF9pc1BsYXlpbmcgPSBmYWxzZTtcblx0dmFyIF9yZXZlcnNlZCA9IGZhbHNlO1xuXHR2YXIgX2RlbGF5VGltZSA9IDA7XG5cdHZhciBfc3RhcnRUaW1lID0gbnVsbDtcblx0dmFyIF9lYXNpbmdGdW5jdGlvbiA9IFRXRUVOLkVhc2luZy5MaW5lYXIuTm9uZTtcblx0dmFyIF9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLkxpbmVhcjtcblx0dmFyIF9jaGFpbmVkVHdlZW5zID0gW107XG5cdHZhciBfb25TdGFydENhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXHR2YXIgX29uVXBkYXRlQ2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uQ29tcGxldGVDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25TdG9wQ2FsbGJhY2sgPSBudWxsO1xuXG5cdC8vIFNldCBhbGwgc3RhcnRpbmcgdmFsdWVzIHByZXNlbnQgb24gdGhlIHRhcmdldCBvYmplY3Rcblx0Zm9yICggdmFyIGZpZWxkIGluIG9iamVjdCApIHtcblxuXHRcdF92YWx1ZXNTdGFydFsgZmllbGQgXSA9IHBhcnNlRmxvYXQob2JqZWN0W2ZpZWxkXSwgMTApO1xuXG5cdH1cblxuXHR0aGlzLnRvID0gZnVuY3Rpb24gKCBwcm9wZXJ0aWVzLCBkdXJhdGlvbiApIHtcblxuXHRcdGlmICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X2R1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHR9XG5cblx0XHRfdmFsdWVzRW5kID0gcHJvcGVydGllcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdFRXRUVOLmFkZCggdGhpcyApO1xuXG5cdFx0X2lzUGxheWluZyA9IHRydWU7XG5cblx0XHRfb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblxuXHRcdF9zdGFydFRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyB0aW1lIDogd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdF9zdGFydFRpbWUgKz0gX2RlbGF5VGltZTtcblxuXHRcdGZvciAoIHZhciBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kICkge1xuXG5cdFx0XHQvLyBjaGVjayBpZiBhbiBBcnJheSB3YXMgcHJvdmlkZWQgYXMgcHJvcGVydHkgdmFsdWVcblx0XHRcdGlmICggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXSBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHRcdGlmICggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgQXJyYXkgd2l0aCB0aGUgc3RhcnQgdmFsdWUgYXQgdGhlIGZyb250XG5cdFx0XHRcdF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gPSBbIF9vYmplY3RbIHByb3BlcnR5IF0gXS5jb25jYXQoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gPSBfb2JqZWN0WyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRpZiggKCBfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gaW5zdGFuY2VvZiBBcnJheSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0X3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdICo9IDEuMDsgLy8gRW5zdXJlcyB3ZSdyZSB1c2luZyBudW1iZXJzLCBub3Qgc3RyaW5nc1xuXHRcdFx0fVxuXG5cdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gPSBfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gfHwgMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCAhX2lzUGxheWluZyApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdFRXRUVOLnJlbW92ZSggdGhpcyApO1xuXHRcdF9pc1BsYXlpbmcgPSBmYWxzZTtcblxuXHRcdGlmICggX29uU3RvcENhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRfb25TdG9wQ2FsbGJhY2suY2FsbCggX29iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdG9wQ2hhaW5lZFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IF9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKyApIHtcblxuXHRcdFx0X2NoYWluZWRUd2VlbnNbIGkgXS5zdG9wKCk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmRlbGF5ID0gZnVuY3Rpb24gKCBhbW91bnQgKSB7XG5cblx0XHRfZGVsYXlUaW1lID0gYW1vdW50O1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5yZXBlYXQgPSBmdW5jdGlvbiAoIHRpbWVzICkge1xuXG5cdFx0X3JlcGVhdCA9IHRpbWVzO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy55b3lvID0gZnVuY3Rpb24oIHlveW8gKSB7XG5cblx0XHRfeW95byA9IHlveW87XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXG5cdHRoaXMuZWFzaW5nID0gZnVuY3Rpb24gKCBlYXNpbmcgKSB7XG5cblx0XHRfZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gaW50ZXJwb2xhdGlvbjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfY2hhaW5lZFR3ZWVucyA9IGFyZ3VtZW50cztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25TdGFydCA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRfb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uVXBkYXRlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblN0b3AgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdHZhciBwcm9wZXJ0eTtcblxuXHRcdGlmICggdGltZSA8IF9zdGFydFRpbWUgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIF9vblN0YXJ0Q2FsbGJhY2sgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0X29uU3RhcnRDYWxsYmFjay5jYWxsKCBfb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29uU3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHZhciBlbGFwc2VkID0gKCB0aW1lIC0gX3N0YXJ0VGltZSApIC8gX2R1cmF0aW9uO1xuXHRcdGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG5cdFx0dmFyIHZhbHVlID0gX2Vhc2luZ0Z1bmN0aW9uKCBlbGFwc2VkICk7XG5cblx0XHRmb3IgKCBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kICkge1xuXG5cdFx0XHR2YXIgc3RhcnQgPSBfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gfHwgMDtcblx0XHRcdHZhciBlbmQgPSBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRpZiAoIGVuZCBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHRcdF9vYmplY3RbIHByb3BlcnR5IF0gPSBfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKCBlbmQsIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUGFyc2VzIHJlbGF0aXZlIGVuZCB2YWx1ZXMgd2l0aCBzdGFydCBhcyBiYXNlIChlLmcuOiArMTAsIC0zKVxuXHRcdFx0XHRpZiAoIHR5cGVvZihlbmQpID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdGVuZCA9IHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQsIDEwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHByb3RlY3QgYWdhaW5zdCBub24gbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRpZiAoIHR5cGVvZihlbmQpID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdF9vYmplY3RbIHByb3BlcnR5IF0gPSBzdGFydCArICggZW5kIC0gc3RhcnQgKSAqIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggX29uVXBkYXRlQ2FsbGJhY2sgIT09IG51bGwgKSB7XG5cblx0XHRcdF9vblVwZGF0ZUNhbGxiYWNrLmNhbGwoIF9vYmplY3QsIHZhbHVlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGVsYXBzZWQgPT0gMSApIHtcblxuXHRcdFx0aWYgKCBfcmVwZWF0ID4gMCApIHtcblxuXHRcdFx0XHRpZiggaXNGaW5pdGUoIF9yZXBlYXQgKSApIHtcblx0XHRcdFx0XHRfcmVwZWF0LS07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuXHRcdFx0XHRmb3IoIHByb3BlcnR5IGluIF92YWx1ZXNTdGFydFJlcGVhdCApIHtcblxuXHRcdFx0XHRcdGlmICggdHlwZW9mKCBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdICkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gPSBfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gKyBwYXJzZUZsb2F0KF92YWx1ZXNFbmRbIHByb3BlcnR5IF0sIDEwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX3lveW8pIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF07XG5cdFx0XHRcdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gPSBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRcdFx0X3ZhbHVlc0VuZFsgcHJvcGVydHkgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gPSBfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfeW95bykge1xuXHRcdFx0XHRcdF9yZXZlcnNlZCA9ICFfcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfc3RhcnRUaW1lID0gdGltZSArIF9kZWxheVRpbWU7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBfb25Db21wbGV0ZUNhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X29uQ29tcGxldGVDYWxsYmFjay5jYWxsKCBfb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IF9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKyApIHtcblxuXHRcdFx0XHRcdF9jaGFpbmVkVHdlZW5zWyBpIF0uc3RhcnQoIHRpbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG59O1xuXG5cblRXRUVOLkVhc2luZyA9IHtcblxuXHRMaW5lYXI6IHtcblxuXHRcdE5vbmU6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGs7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWFkcmF0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiAoIDIgLSBrICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBrICogaztcblx0XHRcdHJldHVybiAtIDAuNSAqICggLS1rICogKCBrIC0gMiApIC0gMSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Q3ViaWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAtLWsgKiBrICogayArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBrICogayAqIGs7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAoIGsgLT0gMiApICogayAqIGsgKyAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWFydGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSAoIC0tayAqIGsgKiBrICogayApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEpIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuXHRcdFx0cmV0dXJuIC0gMC41ICogKCAoIGsgLT0gMiApICogayAqIGsgKiBrIC0gMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVpbnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcblx0XHRcdHJldHVybiAwLjUgKiAoICggayAtPSAyICkgKiBrICogayAqIGsgKiBrICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0U2ludXNvaWRhbDoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyggayAqIE1hdGguUEkgLyAyICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNpbiggayAqIE1hdGguUEkgLyAyICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDAuNSAqICggMSAtIE1hdGguY29zKCBNYXRoLlBJICogayApICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRFeHBvbmVudGlhbDoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coIDEwMjQsIGsgLSAxICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdyggMiwgLSAxMCAqIGsgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBNYXRoLnBvdyggMTAyNCwgayAtIDEgKTtcblx0XHRcdHJldHVybiAwLjUgKiAoIC0gTWF0aC5wb3coIDIsIC0gMTAgKiAoIGsgLSAxICkgKSArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdENpcmN1bGFyOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCggMSAtIGsgKiBrICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIDEgLSAoIC0tayAqIGsgKSApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEpIHJldHVybiAtIDAuNSAqICggTWF0aC5zcXJ0KCAxIC0gayAqIGspIC0gMSk7XG5cdFx0XHRyZXR1cm4gMC41ICogKCBNYXRoLnNxcnQoIDEgLSAoIGsgLT0gMikgKiBrKSArIDEpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0RWxhc3RpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdHJldHVybiAtICggYSAqIE1hdGgucG93KCAyLCAxMCAqICggayAtPSAxICkgKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdHJldHVybiAoIGEgKiBNYXRoLnBvdyggMiwgLSAxMCAqIGspICogTWF0aC5zaW4oICggayAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSArIDEgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcywgYSA9IDAuMSwgcCA9IDAuNDtcblx0XHRcdGlmICggayA9PT0gMCApIHJldHVybiAwO1xuXHRcdFx0aWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG5cdFx0XHRpZiAoICFhIHx8IGEgPCAxICkgeyBhID0gMTsgcyA9IHAgLyA0OyB9XG5cdFx0XHRlbHNlIHMgPSBwICogTWF0aC5hc2luKCAxIC8gYSApIC8gKCAyICogTWF0aC5QSSApO1xuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAtIDAuNSAqICggYSAqIE1hdGgucG93KCAyLCAxMCAqICggayAtPSAxICkgKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKTtcblx0XHRcdHJldHVybiBhICogTWF0aC5wb3coIDIsIC0xMCAqICggayAtPSAxICkgKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKiAwLjUgKyAxO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0QmFjazoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIGsgKiBrICogKCAoIHMgKyAxICkgKiBrIC0gcyApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqICggKCBzICsgMSApICogayArIHMgKSArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIDAuNSAqICggayAqIGsgKiAoICggcyArIDEgKSAqIGsgLSBzICkgKTtcblx0XHRcdHJldHVybiAwLjUgKiAoICggayAtPSAyICkgKiBrICogKCAoIHMgKyAxICkgKiBrICsgcyApICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Qm91bmNlOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMSAtIFRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0KCAxIC0gayApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoIGsgPCAoIDEgLyAyLjc1ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyIC8gMi43NSApICkge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAxLjUgLyAyLjc1ICkgKSAqIGsgKyAwLjc1O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyLjUgLyAyLjc1ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuMjUgLyAyLjc1ICkgKSAqIGsgKyAwLjkzNzU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuNjI1IC8gMi43NSApICkgKiBrICsgMC45ODQzNzU7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoIGsgPCAwLjUgKSByZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5JbiggayAqIDIgKSAqIDAuNTtcblx0XHRcdHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCggayAqIDIgLSAxICkgKiAwLjUgKyAwLjU7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5UV0VFTi5JbnRlcnBvbGF0aW9uID0ge1xuXG5cdExpbmVhcjogZnVuY3Rpb24gKCB2LCBrICkge1xuXG5cdFx0dmFyIG0gPSB2Lmxlbmd0aCAtIDEsIGYgPSBtICogaywgaSA9IE1hdGguZmxvb3IoIGYgKSwgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtcblxuXHRcdGlmICggayA8IDAgKSByZXR1cm4gZm4oIHZbIDAgXSwgdlsgMSBdLCBmICk7XG5cdFx0aWYgKCBrID4gMSApIHJldHVybiBmbiggdlsgbSBdLCB2WyBtIC0gMSBdLCBtIC0gZiApO1xuXG5cdFx0cmV0dXJuIGZuKCB2WyBpIF0sIHZbIGkgKyAxID4gbSA/IG0gOiBpICsgMSBdLCBmIC0gaSApO1xuXG5cdH0sXG5cblx0QmV6aWVyOiBmdW5jdGlvbiAoIHYsIGsgKSB7XG5cblx0XHR2YXIgYiA9IDAsIG4gPSB2Lmxlbmd0aCAtIDEsIHB3ID0gTWF0aC5wb3csIGJuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW4sIGk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSBuOyBpKysgKSB7XG5cdFx0XHRiICs9IHB3KCAxIC0gaywgbiAtIGkgKSAqIHB3KCBrLCBpICkgKiB2WyBpIF0gKiBibiggbiwgaSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBiO1xuXG5cdH0sXG5cblx0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKCB2LCBrICkge1xuXG5cdFx0dmFyIG0gPSB2Lmxlbmd0aCAtIDEsIGYgPSBtICogaywgaSA9IE1hdGguZmxvb3IoIGYgKSwgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG5cblx0XHRpZiAoIHZbIDAgXSA9PT0gdlsgbSBdICkge1xuXG5cdFx0XHRpZiAoIGsgPCAwICkgaSA9IE1hdGguZmxvb3IoIGYgPSBtICogKCAxICsgayApICk7XG5cblx0XHRcdHJldHVybiBmbiggdlsgKCBpIC0gMSArIG0gKSAlIG0gXSwgdlsgaSBdLCB2WyAoIGkgKyAxICkgJSBtIF0sIHZbICggaSArIDIgKSAlIG0gXSwgZiAtIGkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggayA8IDAgKSByZXR1cm4gdlsgMCBdIC0gKCBmbiggdlsgMCBdLCB2WyAwIF0sIHZbIDEgXSwgdlsgMSBdLCAtZiApIC0gdlsgMCBdICk7XG5cdFx0XHRpZiAoIGsgPiAxICkgcmV0dXJuIHZbIG0gXSAtICggZm4oIHZbIG0gXSwgdlsgbSBdLCB2WyBtIC0gMSBdLCB2WyBtIC0gMSBdLCBmIC0gbSApIC0gdlsgbSBdICk7XG5cblx0XHRcdHJldHVybiBmbiggdlsgaSA/IGkgLSAxIDogMCBdLCB2WyBpIF0sIHZbIG0gPCBpICsgMSA/IG0gOiBpICsgMSBdLCB2WyBtIDwgaSArIDIgPyBtIDogaSArIDIgXSwgZiAtIGkgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFV0aWxzOiB7XG5cblx0XHRMaW5lYXI6IGZ1bmN0aW9uICggcDAsIHAxLCB0ICkge1xuXG5cdFx0XHRyZXR1cm4gKCBwMSAtIHAwICkgKiB0ICsgcDA7XG5cblx0XHR9LFxuXG5cdFx0QmVybnN0ZWluOiBmdW5jdGlvbiAoIG4gLCBpICkge1xuXG5cdFx0XHR2YXIgZmMgPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkZhY3RvcmlhbDtcblx0XHRcdHJldHVybiBmYyggbiApIC8gZmMoIGkgKSAvIGZjKCBuIC0gaSApO1xuXG5cdFx0fSxcblxuXHRcdEZhY3RvcmlhbDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBhID0gWyAxIF07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIG4gKSB7XG5cblx0XHRcdFx0dmFyIHMgPSAxLCBpO1xuXHRcdFx0XHRpZiAoIGFbIG4gXSApIHJldHVybiBhWyBuIF07XG5cdFx0XHRcdGZvciAoIGkgPSBuOyBpID4gMTsgaS0tICkgcyAqPSBpO1xuXHRcdFx0XHRyZXR1cm4gYVsgbiBdID0gcztcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpLFxuXG5cdFx0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcblxuXHRcdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsIHYxID0gKCBwMyAtIHAxICkgKiAwLjUsIHQyID0gdCAqIHQsIHQzID0gdCAqIHQyO1xuXHRcdFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbiggZnVuY3Rpb24gKCByb290ICkge1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFRXRUVOO1xuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHQvLyBOb2RlLmpzXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBUV0VFTjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gR2xvYmFsIHZhcmlhYmxlXG5cdFx0cm9vdC5UV0VFTiA9IFRXRUVOO1xuXG5cdH1cblxufSApKCB0aGlzICk7XG4iLCIvKiBnbG9iYWwgRXZlbnQsIEhUTUxFbGVtZW50ICovXG5cbnJlcXVpcmUoJy4uL3ZyLXJlZ2lzdGVyLWVsZW1lbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXG4gICd2ci1hc3NldHMnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hFdmVudExpc3RlbmVyczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXNzZXRMb2FkZWQgPSB0aGlzLmFzc2V0TG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFzc2V0c1BlbmRpbmcgPSAwO1xuICAgICAgICAgICAgdHJhdmVyc2VET00odGhpcyk7XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmF2ZXJzZURPTSAobm9kZSkge1xuICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUudGFnTmFtZTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYgJiYgdGFnTmFtZSAmJiB0YWdOYW1lLmluZGV4T2YoJ1ZSLScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnRMaXN0ZW5lcihub2RlKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFzc2V0c1BlbmRpbmcrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlRE9NKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVyIChub2RlKSB7XG4gICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgYXNzZXRMb2FkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3NldExvYWRlZDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2V0c1BlbmRpbmctLTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2V0c1BlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWQ6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCBlbW1pdHRpbmcgdGhlIGxvYWRlZCBldmVudCBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTG9hZGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdsb2FkZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4pO1xuIiwicmVxdWlyZSgnLi4vdnItcmVnaXN0ZXItZWxlbWVudCcpO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKTtcbnZhciBWUk9iamVjdCA9IHJlcXVpcmUoJy4vdnItb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItY2FtZXJhJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBwcm9iYWJseSBtYW5hZ2VkIHdpdGhpbiB2ci1zY2VuZVxuICAgICAgICAgICAgdGhpcy5zY2VuZUVsLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUluaXRpYWxWYWx1ZXMoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2FtZXJhIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHZhciBmb3YgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdmb3YnKSkgfHwgNDU7XG4gICAgICAgICAgICB2YXIgbmVhciA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ25lYXInKSkgfHwgMTtcbiAgICAgICAgICAgIHZhciBmYXIgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdmYXInKSkgfHwgMTAwMDA7XG4gICAgICAgICAgICB2YXIgYXNwZWN0ID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnYXNwZWN0JykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIFNldHRpbmcgdGhyZWUuanMgY2FtZXJhIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZm92ID0gZm92O1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5uZWFyID0gbmVhcjtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZmFyID0gZmFyO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZUluaXRpYWxWYWx1ZXM6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdFZhbHVlcykgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgeDogcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgneCcpKSB8fCAwLFxuICAgICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd5JykpIHx8IDAsXG4gICAgICAgICAgICAgIHo6IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3onKSkgfHwgMCxcbiAgICAgICAgICAgICAgcm90WDogcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgncm90WCcpKSB8fCAwLFxuICAgICAgICAgICAgICByb3RZOiBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdyb3RZJykpIHx8IDAsXG4gICAgICAgICAgICAgIHJvdFo6IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdFonKSkgfHwgMCxcbiAgICAgICAgICAgICAgZm92OiBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdmb3YnKSkgfHwgNDUsXG4gICAgICAgICAgICAgIG5lYXI6IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ25hcicpKSB8fCAxLFxuICAgICAgICAgICAgICBmYXI6IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2ZhcicpKSB8fCAxMDAwMCxcbiAgICAgICAgICAgICAgYXNwZWN0OiBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdhc3BlY3QnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZUluaXRpYWxWYWx1ZXM6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRWYWx1ZXMpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneCcsIHRoaXMuaW5pdFZhbHVlcy54KTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd5JywgdGhpcy5pbml0VmFsdWVzLnkpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3onLCB0aGlzLmluaXRWYWx1ZXMueik7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncm90WCcsIHRoaXMuaW5pdFZhbHVlcy5yb3RYKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyb3RZJywgdGhpcy5pbml0VmFsdWVzLnJvdFkpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdFonLCB0aGlzLmluaXRWYWx1ZXMucm90Wik7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZm92JywgdGhpcy5pbml0VmFsdWVzLmZvdik7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmVhcicsIHRoaXMuaW5pdFZhbHVlcy5mYXIpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2ZhcicsIHRoaXMuaW5pdFZhbHVlcy5mYXIpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FzcGVjdCcsIHRoaXMuaW5pdFZhbHVlcy5hc3BlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNldDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVJbml0aWFsVmFsdWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4pO1xuIiwiLyogZ2xvYmFsIEV2ZW50LCBIVE1MRWxlbWVudCAqL1xuXG5yZXF1aXJlKCcuLi92ci1yZWdpc3Rlci1lbGVtZW50Jyk7XG5cbi8qKlxuICpcbiAqIFZSTm9kZSBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRoZSBWUiBtYXJrdXBcbiAqIEl0IG1hbmFnZXMgbG9hZGluZyBvZiBvYmplY3RzLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLW5vZGUnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAge1xuXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAvL1xuICAgICAgICAvLyAgIE5hdGl2ZSBjdXN0b20gZWxlbWVudHMgY2FsbGJhY2tzICAgLy9cbiAgICAgICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC8vXG5cbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY2VuZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndnItc2NlbmUnKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVFbCA9IHNjZW5lRWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IC8qIG5vLW9wICovIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgZW1taXR0aW5nIHRoZSBsb2FkZWQgZXZlbnQgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0xvYWRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaztcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnbG9hZGVkJyk7XG4gICAgICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaykgeyBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suYXBwbHkodGhpcyk7IH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsIi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuXG5yZXF1aXJlKCcuLi92ci1yZWdpc3Rlci1lbGVtZW50Jyk7XG5cbnZhciBUSFJFRSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90aHJlZScpO1xudmFyIFZSTm9kZSA9IHJlcXVpcmUoJy4vdnItbm9kZScpO1xudmFyIFZSVXRpbHMgPSByZXF1aXJlKCcuLi92ci11dGlscycpO1xuXG4vKipcbiAqXG4gKiBWUk9CamVjdCByZXByZXNlbnRzIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSAzRCBzY2VuZS5cbiAqIFRoZXkgYWxsIGhhdmUgYSBwb3NpdGlvbiwgcm90YXRpb24gYW5kIGEgc2NhbGUuXG4gKlxuICovXG52YXIgVlJPYmplY3QgPSBtb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLW9iamVjdCcsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBWUk5vZGUucHJvdG90eXBlLFxuICAgICAge1xuXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAvL1xuICAgICAgICAvLyAgIE5hdGl2ZSBjdXN0b20gZWxlbWVudHMgY2FsbGJhY2tzICAgLy9cbiAgICAgICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC8vXG5cbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gdGhpcy5vYmplY3QzRCB8fCBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgLy8gUm90YXRpb25cbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyb3RhdGlvbicpO1xuICAgICAgICAgICAgdmFyIHJvdGF0aW9uWCA9IFRIUkVFLk1hdGguZGVnVG9SYWQocm90YXRpb24ueCk7XG4gICAgICAgICAgICB2YXIgcm90YXRpb25ZID0gVEhSRUUuTWF0aC5kZWdUb1JhZChyb3RhdGlvbi55KTtcbiAgICAgICAgICAgIHZhciByb3RhdGlvblogPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKHJvdGF0aW9uLnopO1xuXG4gICAgICAgICAgICAvLyBTY2FsZVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NjYWxlJyk7XG5cbiAgICAgICAgICAgIC8vIFNldHRpbmcgdGhyZWUuanMgcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELnJvdGF0aW9uLm9yZGVyID0gJ1lYWic7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELnJvdGF0aW9uLnNldChyb3RhdGlvblgsIHJvdGF0aW9uWSwgcm90YXRpb25aKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0Quc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnopO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2hlbiBjcmVhdGluZyBhbiBlbGVtZW50IGZyb20gSlMgaXMgbm90IGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgICAgICAgICAgLy8gYSBwYXJlbnQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uIEl0J3MgdXAgdG8gdGhlIGFyYml0cmFyeVxuICAgICAgICAgICAgLy8gSlMgdG8gYXR0YWNoIHRoZSBlbGVtZW50IHRvIHRoZSBET00uIFdlIGNvdmVyIHRoaXNcbiAgICAgICAgICAgIC8vIGNhc2UgaGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNMb2FkZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB0aGlzLmFkZFRvUGFyZW50KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQ6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIWVsLm9iamVjdDNEKSB7XG4gICAgICAgICAgICAgIFZSVXRpbHMuZXJyb3IoXCJUcnlpbmcgdG8gYWRkIGFuIG9iamVjdDNEIHRoYXQgZG9lc24ndCBleGlzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuYWRkKGVsLm9iamVjdDNEKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRUb1BhcmVudDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRFbCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciBhdHRhY2hlZFRvUGFyZW50ID0gdGhpcy5hdHRhY2hlZFRvUGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgYXR0YWNoZWRUb1BhcmVudCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgYW4gb2JqZWN0IHRvIGF0dGFjaCBpdHNlbGYgbXVsdGlwbGUgdGltZXMgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgdGhpcy5hdHRhY2hlZFRvUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcmVudC5hZGQodGhpcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGNhbGxpbmcgbG9hZCBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTG9hZGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHRvIHRoZSBhc3NvY2lhdGVkIERPTSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELmVsID0gdGhpcztcbiAgICAgICAgICAgIC8vIEl0IGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgdGhyZWVqcyBwYXJlbnQgb2JqZWN0M0RcbiAgICAgICAgICAgIHRoaXMuYWRkVG9QYXJlbnQoKTtcbiAgICAgICAgICAgIC8vIEl0IHNldHMgZGVmYXVsdCB2YWx1ZXMgb24gdGhlIGF0dHJpYnV0ZXMgaWYgdGhleSdyZSBub3QgZGVmaW5lZFxuICAgICAgICAgICAgdGhpcy5pbml0QXR0cmlidXRlcygpO1xuICAgICAgICAgICAgLy8gU2V0dXAgYW5pbWF0aW9ucyBpZiB0aGVyZSdzIGFueVxuICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRpb25zKCk7XG4gICAgICAgICAgICBWUk5vZGUucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBdHRyaWJ1dGU6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIHZhbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIChhdHRyID09PSAncG9zaXRpb24nIHx8XG4gICAgICAgICAgICAgICBhdHRyID09PSAncm90YXRpb24nIHx8XG4gICAgICAgICAgICAgICBhdHRyID09PSAnc2NhbGUnKSkge1xuICAgICAgICAgICAgICB2YWwgPSBbdmFsLngsIHZhbC55LCB2YWwuel0uam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIsIHZhbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRC5yZW1vdmUoZWwub2JqZWN0M0QpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncm90YXRpb24nKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzY2FsZScpO1xuICAgICAgICAgICAgaWYgKCFwb3NpdGlvbikgeyB0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCAnMCAwIDAnKTsgfVxuICAgICAgICAgICAgaWYgKCFyb3RhdGlvbikgeyB0aGlzLnNldEF0dHJpYnV0ZSgncm90YXRpb24nLCAnMCAwIDAnKTsgfVxuICAgICAgICAgICAgaWYgKCFzY2FsZSkgeyB0aGlzLnNldEF0dHJpYnV0ZSgnc2NhbGUnLCAnMSAxIDEnKTsgfVxuICAgICAgICAgICAgLy8gV2UgZm9yY2UgYW4gYXR0cmlidXRlIHVwZGF0ZSBpZiBhbGwgdGhlIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQuXG4gICAgICAgICAgICAvLyBJdCBzeW5jcyB0aGUgYXR0cmlidXRlcyB3aXRoIHRoZSBvYmplY3QzRC5cbiAgICAgICAgICAgIGlmIChzY2FsZSAmJiByb3RhdGlvbiAmJiBzY2FsZSkge1xuICAgICAgICAgICAgICBWUk9iamVjdC5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQW5pbWF0aW9uczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9ucykgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBhbmltYXRpb25zLmZvckVhY2goYXR0YWNoT2JqZWN0KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaE9iamVjdCAoYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhbmltYXRpb25OYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFlbCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgZWwuYWRkKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEF0dHJpYnV0ZToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0cmlidXRlKTtcbiAgICAgICAgICAgIHJldHVybiBWUlV0aWxzLnBhcnNlQXR0cmlidXRlU3RyaW5nKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9XG4gICAgICB9KVxuICB9XG4pO1xuIiwiLyogZ2xvYmFsIE1lc3NhZ2VDaGFubmVsLCBwZXJmb3JtYW5jZSwgUHJvbWlzZSAqL1xuXG5yZXF1aXJlKCcuLi92ci1yZWdpc3Rlci1lbGVtZW50Jyk7XG5cbnZhciBUV0VFTiA9IHJlcXVpcmUoJ3R3ZWVuLmpzJyk7XG5cbnZhciBUSFJFRSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90aHJlZScpO1xudmFyIFZSTm9kZSA9IHJlcXVpcmUoJy4vdnItbm9kZScpO1xuXG52YXIgVlJTY2VuZSA9IG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItc2NlbmUnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJOb2RlLnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hGdWxsc2NyZWVuTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnNldHVwU2NlbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNodXRkb3duOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hFdmVudExpc3RlbmVyczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZWxlbWVudExvYWRlZCA9IHRoaXMuZWxlbWVudExvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSAwO1xuICAgICAgICAgICAgdmFyIGFzc2V0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZyLWFzc2V0cycpO1xuICAgICAgICAgICAgaWYgKGFzc2V0cyAmJiAhYXNzZXRzLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdFbGVtZW50cysrO1xuICAgICAgICAgICAgICBhc3NldHMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZWxlbWVudExvYWRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmF2ZXJzZURPTSh0aGlzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlRE9NIChub2RlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gd2FpdCBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXQncyBub3QgdGhlIHNjZW5lIGl0c2VsZlxuICAgICAgICAgICAgICAvLyBhbmQgaXQncyBhIFZSIGVsZW1lbnRcbiAgICAgICAgICAgICAgLy8gYW5kIHRoZSBub2RlIGhhcyBub3QgbG9hZGVkIHlldFxuICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gc2VsZiAmJiBzZWxmLmlzVlJOb2RlKG5vZGUpICYmICFub2RlLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50TGlzdGVuZXIobm9kZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wZW5kaW5nRWxlbWVudHMrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlRE9NKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVyIChub2RlKSB7XG4gICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZWxlbWVudExvYWRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzVlJOb2RlOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBUbyBjaGVjayBpZiBhIERPTSBlbGVtbnQgaXMgYSBWUiBlbGVtZW50XG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgYmUgY2hlY2tpbmcgZm9yIHRoZSBwcm90b3R5cGUgbGlrZSB0aGlzXG4gICAgICAgICAgICAvLyBpZiAoVlJOb2RlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG5vZGUpKVxuICAgICAgICAgICAgLy8gU2FmYXJpIGFuZCBDaHJvbWUgZG9lc24ndCBzZWVtIHRvIGhhdmUgdGhlIHByb3BlclxuICAgICAgICAgICAgLy8gcHJvdG90eXBlIGF0dGFjaGVkIHRvIHRoZSBub2RlIGJlZm9yZSB0aGUgY3JlYXRlZENhbGxiYWNrXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBpcyBjYWxsZWQuIFRvIGRldGVybWluZSB0aGF0IGFuIGVsZW1lbnQgaXMgYSBWUlxuICAgICAgICAgICAgLy8gcmVsYXRlZCBub2RlIHdlIGNoZWNrIGlmIHRoZSB0YWcgbmFtZSBzdGFydHMgd2l0aCBWUi1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZnJhZ2lsZS4gV2UgaGF2ZSB0byB1bmRlcnN0YW5kIHdoeSB0aGUgYmVoYXZpb3VyIGJldHdlZW5cbiAgICAgICAgICAgIC8vIGZpcmVmb3ggYW5kIHRoZSBvdGhlciBicm93c2Vyc1xuICAgICAgICAgICAgLy8gaXMgbm90IGNvbnNpc3RlbnQuIEZpcmVmb3ggaXMgdGhlIG9ubHkgb25lIHRoYXQgYmVoYXZlcyBhcyBvbmVcbiAgICAgICAgICAgIC8vIGV4cGVjdHM6IFRoZSBub2RlcyBoYXZlIHRoZSBwcm9wZXIgcHJvdG90eXBlIGF0dGFjaGVkIHRvIHRoZW0gYXRcbiAgICAgICAgICAgIC8vIGFueSB0aW1lIGR1cmluZyB0aGVpciBsaWZlY3ljbGUuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS5pbmRleE9mKCdWUi0nKSA9PT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoTWVzc2FnZUxpc3RlbmVyczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlLmRhdGEgJiYgZS5kYXRhLnR5cGUgPT09ICdmdWxsc2NyZWVuJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNldCByZW5kZXJlciB3aXRoIGZ1bGxzY3JlZW4gVlIgZW50ZXIgYW5kIGV4aXQuXG4gICAgICAgICAgICAgICAgICBjYXNlICdlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U3RlcmVvUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdleGl0JzpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRNb25vUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoRnVsbHNjcmVlbkxpc3RlbmVyczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZnVsbHNjcmVlbiBjaGFuZ2VzXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5mdWxsc2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuZnVsbHNjcmVlbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVsbHNjcmVlbkNoYW5nZToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gdGhlIG1vbm8gcmVuZGVyZXIgaWYgd2UgaGF2ZSBkcm9wcGVkIG91dCBvZiBmdWxsc2NyZWVuIFZSIG1vZGUuXG4gICAgICAgICAgICB2YXIgZnNFbGVtZW50ID0gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIWZzRWxlbWVudCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5tb25vUmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVsZW1lbnRMb2FkZWQ6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRWxlbWVudHMtLTtcbiAgICAgICAgICAgIC8vIElmIHdlIHN0aWxsIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0VsZW1lbnRzID4gMCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByZW5kZXIgbG9vcCBpcyBhbHJlYWR5IHJ1bm5pbmdcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlckxvb3BTdGFydGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdGhpcy5zZXR1cExvYWRlcigpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgICAgICAgIC8vIEl0IGtpY2tzIG9mZiB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTG9vcFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVudGVyVnJCdXR0b246IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZyQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICB2ckJ1dHRvbi50ZXh0Q29udGVudCA9ICdFbnRlciBWUic7XG4gICAgICAgICAgICB2ckJ1dHRvbi5jbGFzc05hbWUgPSAndnItYnV0dG9uJztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodnJCdXR0b24pO1xuICAgICAgICAgICAgdnJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmVudGVyVlIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiBsb2FkZXIgaXMgaW4gVlIgbW9kZS5cbiAgICAgICAgdnJMb2FkZXJNb2RlOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgICB3aW5kb3cudG9wLnBvc3RNZXNzYWdlKHt0eXBlOiAnY2hlY2tWcid9LCAnKicsIFtjaGFubmVsLnBvcnQyXSk7XG4gICAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCEhbWVzc2FnZS5kYXRhLmRhdGEuaXNWcik7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0dXBMb2FkZXI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gaW5zaWRlIGxvYWRlciwgY2hlY2sgZm9yIHZyIG1vZGUgYmVmb3JlIGtpY2tpbmcgb2ZmIHJlbmRlciBsb29wLlxuICAgICAgICAgICAgaWYgKHdpbmRvdy50b3AgIT09IHdpbmRvdy5zZWxmKSB7XG4gICAgICAgICAgICAgIHNlbGYuYXR0YWNoTWVzc2FnZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgICBzZWxmLnZyTG9hZGVyTW9kZSgpLnRoZW4oZnVuY3Rpb24gKGlzVnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWcikge1xuICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTdGVyZW9SZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLnNldE1vbm9SZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wLnBvc3RNZXNzYWdlKHt0eXBlOiAncmVhZHknfSwgJyonKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLmNyZWF0ZUVudGVyVnJCdXR0b24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U3RlcmVvUmVuZGVyZXI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMuc3RlcmVvUmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRNb25vUmVuZGVyZXI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMubW9ub1JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0dXBTY2VuZToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9ycyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgndnItY29udHJvbHMnKTtcbiAgICAgICAgICAgIC8vIHF1ZXJ5U2VsZWN0b3JBbGwgcmV0dXJucyBhIE5vZGVMaXN0IHRoYXQgaXQncyBub3QgYSBub3JtYWwgYXJyYXlcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29udmVydFxuICAgICAgICAgICAgdGhpcy5iZWhhdmlvcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmJlaGF2aW9ycyk7XG4gICAgICAgICAgICAvLyBUaGUgY2FudmFzIHdoZXJlIHRoZSBXZWJHTCBjb250ZXh0IHdpbGwgYmUgcGFpbnRlZFxuICAgICAgICAgICAgdGhpcy5zZXR1cENhbnZhcygpO1xuICAgICAgICAgICAgLy8gVGhlIHRocmVlLmpzIHJlbmRlcmVyIHNldHVwXG4gICAgICAgICAgICB0aGlzLnNldHVwUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIC8vIHRocmVlLmpzIGNhbWVyYSBzZXR1cFxuICAgICAgICAgICAgdGhpcy5zZXR1cENhbWVyYSgpO1xuICAgICAgICAgICAgLy8gY3Vyc29yIGNhbWVyYSBzZXR1cFxuICAgICAgICAgICAgdGhpcy5zZXR1cEN1cnNvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cENhbnZhczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy5jbGFzc0xpc3QuYWRkKCd2ci1jYW52YXMnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUNhbnZhcy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldHVwQ2FtZXJhOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjYW1lcmFFbCA9IHRoaXMucXVlcnlTZWxlY3RvcigndnItY2FtZXJhJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdCBhIHVzZXItZGVmaW5lZCBjYW1lcmEsIHdlIGNyZWF0ZSBvbmUuXG4gICAgICAgICAgICBpZiAoIWNhbWVyYUVsKSB7XG4gICAgICAgICAgICAgIGNhbWVyYUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndnItY2FtZXJhJyk7XG4gICAgICAgICAgICAgIGNhbWVyYUVsLnNldEF0dHJpYnV0ZSgnZm92JywgNDUpO1xuICAgICAgICAgICAgICBjYW1lcmFFbC5zZXRBdHRyaWJ1dGUoJ25lYXInLCAxKTtcbiAgICAgICAgICAgICAgY2FtZXJhRWwuc2V0QXR0cmlidXRlKCdmYXInLCAxMDAwMCk7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2FtZXJhRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cEN1cnNvcjoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd2ci1jdXJzb3InKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVudGVyVlI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMuc3RlcmVvUmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLnN0ZXJlb1JlbmRlcmVyLnNldEZ1bGxTY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldHVwUmVuZGVyZXI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlciA9IHRoaXMubW9ub1JlbmRlcmVyID1cbiAgICAgICAgICAgICAgKFZSU2NlbmUgJiYgVlJTY2VuZS5yZW5kZXJlcikgfHwgLy8gVG8gcHJldmVudCBjcmVhdGluZyBtdWx0aXBsZSByZW5kZXJpbmcgY29udGV4dHNcbiAgICAgICAgICAgICAgbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe2NhbnZhczogY2FudmFzLCBhbnRpYWxpYXM6IHRydWUsIGFscGhhOiB0cnVlfSk7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNvcnRPYmplY3RzID0gZmFsc2U7XG4gICAgICAgICAgICBWUlNjZW5lLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICAgICAgICAgIHRoaXMuc3RlcmVvUmVuZGVyZXIgPSBuZXcgVEhSRUUuVlJFZmZlY3QocmVuZGVyZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gKFZSU2NlbmUgJiYgVlJTY2VuZS5zY2VuZSkgfHwgbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgICAgICBWUlNjZW5lLnNjZW5lID0gdGhpcy5vYmplY3QzRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplQ2FudmFzOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgICAgICAgIC8vIE1ha2UgaXQgdmlzdWFsbHkgZmlsbCB0aGUgcG9zaXRpb25lZCBwYXJlbnRcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGludGVybmFsIHNpemUgdG8gbWF0Y2hcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgLy8gVXBkYXRlcyBjYW1lcmFcbiAgICAgICAgICAgIGNhbWVyYS5hc3BlY3QgPSBjYW52YXMub2Zmc2V0V2lkdGggLyBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgdGhlIHNpemUgY2hhbmdlXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFlbC5vYmplY3QzRCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuYWRkKGVsLm9iamVjdDNEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQmVoYXZpb3I6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGJlaGF2aW9yKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9ycy5wdXNoKGJlaGF2aW9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFlbC5vYmplY3QzRCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QucmVtb3ZlKGVsLm9iamVjdDNEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBUV0VFTi51cGRhdGUodCk7XG4gICAgICAgICAgICAvLyBVcGRhdGVzIGJlaGF2aW9yc1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvcnMuZm9yRWFjaChmdW5jdGlvbiAoYmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgYmVoYXZpb3IudXBkYXRlKHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLm9iamVjdDNELCB0aGlzLmNhbWVyYSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgfVxuKTtcbiIsIi8qKlxuICogaHR0cDovL3d3dy5hbGV4YW5kcmUtcGVzdGFuYS5jb20vd2ViZ2wvUEJSVmlld2VyLmh0bWxcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRIUkVFKSB7XG5cblx0cmV0dXJuIHtcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XCIsXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMyIHV2U2NhbGU7XCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblx0XHRcdFwidmFyeWluZyBtYXQzIHRibjtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodFZlY3RvcjtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZUZXN0Tm9ybWFsO1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpXCIsXG5cdFx0XHRcIntcIixcblx0XHRcdFwidlV2ID0gdXZTY2FsZSAqIHV2O1wiLFxuXG5cdFx0XHRcInZlYzMgdk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpO1wiLFxuXHRcdFx0XCJ2ZWMzIHZUYW5nZW50ID0gbm9ybWFsaXplKG5vcm1hbE1hdHJpeCAqIHRhbmdlbnQueHl6KTtcIixcblx0XHRcdFwidmVjMyB2Qmlub3JtYWwgPSBub3JtYWxpemUoY3Jvc3Modk5vcm1hbCwgdlRhbmdlbnQpICogdGFuZ2VudC53KTtcIixcblxuXHRcdFx0XCJ0Ym4gPSBtYXQzKHZUYW5nZW50LCB2Qmlub3JtYWwsIHZOb3JtYWwpO1wiLFxuXG5cdFx0XHRcInZMaWdodFZlY3RvciA9IG5vcm1hbGl6ZSh2ZWMzKDAuNCwgMC4yICwwLjIpKTtcIixcblxuXHRcdFx0XCJ2UG9zaXRpb24gPSBwb3NpdGlvbjtcIixcblx0XHRcdFwidlRlc3ROb3JtYWwgPSBub3JtYWw7XCIsXG5cblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcblxuXHRcdFx0XCJ9XCJcblx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVwiLFxuXG5cdCAgICBcInVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwMDtcIixcblx0ICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXAxO1wiLFxuXHQgICAgXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDI7XCIsXG5cdCAgICBcInVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwMztcIixcblx0ICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA0O1wiLFxuXHQgICAgXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDU7XCIsXG5cdCAgICBcInVuaWZvcm0gdmVjMyBiYXNlQ29sb3I7XCIsXG5cblx0ICAgIFwidW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XCIsXG5cdCAgICBcInVuaWZvcm0gZmxvYXQgbWV0YWxsaWM7XCIsXG5cdCAgICBcInVuaWZvcm0gZmxvYXQgbGlnaHRJbnRlbnNpdHk7XCIsXG5cblx0ICAgIFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblx0ICAgIFwidmFyeWluZyBtYXQzIHRibjtcIixcblx0ICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodFZlY3RvcjtcIixcblx0ICAgIFwidmFyeWluZyB2ZWMzIHZUZXN0Tm9ybWFsO1wiLFxuXHQgICAgXCJ2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1wiLFxuXG5cdFx0ICBcInZlYzMgRGlmZnVzZSh2ZWMzIHBBbGJlZG8pXCIsXG5cdFx0XHRcIntcIixcblx0XHRcdCAgXCJyZXR1cm4gcEFsYmVkby9QSTtcIixcblx0XHRcdFwifVwiLFxuXG5cdFx0ICBcIi8vLS0tLS0tLS0tLSBOb3JtYWwgZGlzdHJpYnV0aW9uIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0vL1wiLFxuXHRcdFx0XCJmbG9hdCBOb3JtYWxEaXN0cmlidXRpb25fR0dYKGZsb2F0IGEsIGZsb2F0IE5kSClcIixcblx0XHRcdFwie1wiLFxuXHRcdFx0ICAgIFwiLy8gSXNvdHJvcGljIGdneC5cIixcblx0XHRcdCAgICBcImZsb2F0IGEyID0gYSphO1wiLFxuXHRcdFx0ICAgIFwiZmxvYXQgTmRIMiA9IE5kSCAqIE5kSDtcIixcblxuXHRcdFx0ICAgIFwiZmxvYXQgZGVub21pbmF0b3IgPSBOZEgyICogKGEyIC0gMS4wKSArIDEuMDtcIixcblx0XHRcdCAgICBcImRlbm9taW5hdG9yICo9IGRlbm9taW5hdG9yO1wiLFxuXHRcdFx0ICAgIFwiZGVub21pbmF0b3IgKj0gUEk7XCIsXG5cblx0XHRcdCAgICBcInJldHVybiBhMiAvIGRlbm9taW5hdG9yO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiLy8tLS0tLS0tLS0tIEdlb21ldHJpYyBzaGFkb3dpbmcgLS0tLS0tLS0tLS0tLy9cIixcblx0XHRcdFwiZmxvYXQgR2VvbWV0cmljX1NtaXRoX1NjaGxpY2tfR0dYKGZsb2F0IGEsIGZsb2F0IE5kViwgZmxvYXQgTmRMKVwiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0XHQgICAgXCIvLyBTbWl0aCBzY2hsaWNrLUdHWC5cIixcblx0XHRcdCAgICBcImZsb2F0IGsgPSBhICogMC41O1wiLFxuXHRcdFx0ICAgIFwiZmxvYXQgR1YgPSBOZFYgLyAoTmRWICogKDEuMCAtIGspICsgayk7XCIsXG5cdFx0XHQgICAgXCJmbG9hdCBHTCA9IE5kTCAvIChOZEwgKiAoMS4wIC0gaykgKyBrKTtcIixcblxuXHRcdFx0ICAgIFwicmV0dXJuIEdWICogR0w7XCIsXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCIvLy0tLS0tLS0tLS0gRnJlc25lbCAtLS0tLS0tLS0tLS0vL1wiLFxuXHRcdFx0XCJ2ZWMzIEZyZXNuZWxfU2NobGljayh2ZWMzIHNwZWN1bGFyQ29sb3IsIHZlYzMgaCwgdmVjMyB2KVwiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0XHQgIFwicmV0dXJuIChzcGVjdWxhckNvbG9yICsgKDEuMCAtIHNwZWN1bGFyQ29sb3IpICogcG93KCgxLjAgLSBjbGFtcChkb3QodiwgaCksIDAuMCwgMS4wKSksIDUuMCkpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiLy8tLS0tLS0tLS0tIEJSREYgdGVybXMgLS0tLS0tLS0tLS0tLy9cIixcblx0XHRcdFwiZmxvYXQgU3BlY3VsYXJfRChmbG9hdCBhLCBmbG9hdCBOZEgpXCIsXG5cdFx0XHRcIntcIixcblx0XHRcdFx0XCJyZXR1cm4gTm9ybWFsRGlzdHJpYnV0aW9uX0dHWChhLCBOZEgpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwidmVjMyBTcGVjdWxhcl9GKHZlYzMgc3BlY3VsYXJDb2xvciwgdmVjMyBoLCB2ZWMzIHYpXCIsXG5cdFx0XHRcIntcIixcblx0XHRcdFx0XCJyZXR1cm4gRnJlc25lbF9TY2hsaWNrKHNwZWN1bGFyQ29sb3IsIGgsIHYpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwidmVjMyBTcGVjdWxhcl9GX1JvdWdobmVzcyh2ZWMzIHNwZWN1bGFyQ29sb3IsIGZsb2F0IGEsIHZlYzMgaCwgdmVjMyB2KVwiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0XHRcdFwicmV0dXJuIChzcGVjdWxhckNvbG9yICsgKG1heCh2ZWMzKDEuMCAtIGEpLCBzcGVjdWxhckNvbG9yKSAtIHNwZWN1bGFyQ29sb3IpICogcG93KCgxLjAgLSBjbGFtcChkb3QodiwgaCksIDAuMCwgMS4wKSksIDUuMCkpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiZmxvYXQgU3BlY3VsYXJfRyhmbG9hdCBhLCBmbG9hdCBOZFYsIGZsb2F0IE5kTCwgZmxvYXQgTmRILCBmbG9hdCBWZEgsIGZsb2F0IExkVilcIixcblx0XHRcdFwie1wiLFxuXHRcdFx0XHRcInJldHVybiBHZW9tZXRyaWNfU21pdGhfU2NobGlja19HR1goYSwgTmRWLCBOZEwpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwidmVjMyBTcGVjdWxhcih2ZWMzIHNwZWN1bGFyQ29sb3IsIHZlYzMgaCwgdmVjMyB2LCB2ZWMzIGwsIGZsb2F0IGEsIGZsb2F0IE5kTCwgZmxvYXQgTmRWLCBmbG9hdCBOZEgsIGZsb2F0IFZkSCwgZmxvYXQgTGRWKVwiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0XHQgICBcInJldHVybiAoKFNwZWN1bGFyX0QoYSwgTmRIKSAqIFNwZWN1bGFyX0coYSwgTmRWLCBOZEwsIE5kSCwgVmRILCBMZFYpKSAqIFNwZWN1bGFyX0Yoc3BlY3VsYXJDb2xvciwgdiwgaCkgKSAvICg0LjAgKiBOZEwgKiBOZFYgKyAwLjAwMDEpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwidmVjMyBDb21wdXRlTGlnaHQodmVjMyBhbGJlZG9Db2xvcix2ZWMzIHNwZWN1bGFyQ29sb3IsIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0UG9zaXRpb24sIHZlYzMgbGlnaHRDb2xvciwgdmVjMyBsaWdodERpciwgdmVjMyB2aWV3RGlyKVwiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0ICAgIFwiLy8gQ29tcHV0ZSBzb21lIHVzZWZ1bCB2YWx1ZXMuXCIsXG5cdFx0ICAgIFwiZmxvYXQgTmRMID0gY2xhbXAoZG90KG5vcm1hbCwgbGlnaHREaXIpLCAwLjAsIDEuMCk7XCIsXG5cdFx0ICAgIFwiZmxvYXQgTmRWID0gY2xhbXAoZG90KG5vcm1hbCwgdmlld0RpciksIDAuMCwgMS4wKTtcIixcblx0XHQgICAgXCJ2ZWMzIGggPSBub3JtYWxpemUobGlnaHREaXIgKyB2aWV3RGlyKTtcIixcblx0XHQgICAgXCJmbG9hdCBOZEggPSBjbGFtcChkb3Qobm9ybWFsLCBoKSwgMC4wLCAxLjApO1wiLFxuXHRcdCAgICBcImZsb2F0IFZkSCA9IGNsYW1wKGRvdCh2aWV3RGlyLCBoKSwgMC4wLCAxLjApO1wiLFxuXHRcdCAgICBcImZsb2F0IExkViA9IGNsYW1wKGRvdChsaWdodERpciwgdmlld0RpciksIDAuMCwgMS4wKTtcIixcblx0XHQgICAgXCJmbG9hdCBhID0gbWF4KDAuMDAxLCByb3VnaG5lc3MgKiByb3VnaG5lc3MpO1wiLFxuXG5cdFx0ICAgIFwidmVjMyBjRGlmZiA9IERpZmZ1c2UoYWxiZWRvQ29sb3IpO1wiLFxuXHRcdCAgICBcInZlYzMgY1NwZWMgPSBTcGVjdWxhcihzcGVjdWxhckNvbG9yLCBoLCB2aWV3RGlyLCBsaWdodERpciwgYSwgTmRMLCBOZFYsIE5kSCwgVmRILCBMZFYpO1wiLFxuXG5cdFx0ICAgIFwicmV0dXJuIGxpZ2h0Q29sb3IgKiBOZEwgKiAoY0RpZmYgKiAoMS4wIC0gY1NwZWMpICsgY1NwZWMpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiLy8gT2ssIHRoaXMgaXMgdWdseSwgYnV0IHRoZXJlIGlzIGFuIGV4cGxhbmF0aW9uIC4uLlwiLFxuXHRcdFx0XCIvLyBXZWJHTCBuZWVkIHRoZSBleHRlbnNpb24gRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCBpbiBvcmRlciB0byB1c2UgdGV4dHVyZUN1YmVMb2QsIGFuZCBpdCdzIG5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIsXG5cdFx0XHRcIi8vIFdpdGggdGV4dHVyZUN1YmUgdGhlIG1pcG1hcCBpcyBhdXRvbWF0aWNhbGx5IGFwcGxpZWQsIGFuZCB5b3UgY2FuIG9ubHkgYWRkIGEgYmlhcy5cIixcblx0XHRcdFwiLy8gVG8gYXZvaWQgdGhhdCBJIHNhdmVkIGVhY2ggbWlwIGxldmVsIGluIGEgc2VwYXJhdGUgY3ViZW1hcC5cIixcblx0XHRcdFwiLy8gSWYgdGhlcmUgaXMgYSBsZXNzIGF3ZnVsbCB3YXkgdG8gZG8gdGhpcyBJJ2QgYmUgaGFwcHkgdG8ga25vdyAhXCIsXG5cdFx0XHRcInZlYzMgQ29tcHV0ZUVudkNvbG9yKGZsb2F0IHJvdWdobmVzcywgdmVjMyByZWZsZWN0aW9uVmVjdG9yKVwiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0XHRcdFwiZmxvYXQgYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcyAqIDYuMDtcIixcblx0XHRcdFx0XCJpZiAoIGEgPCAxLjApXCIsXG5cdFx0XHRcdFwie1wiLFxuXHRcdFx0XHRcdFwicmV0dXJuIG1peCh0ZXh0dXJlQ3ViZShlbnZNYXAwLCByZWZsZWN0aW9uVmVjdG9yKS5yZ2IsIHRleHR1cmVDdWJlKGVudk1hcDEsIHJlZmxlY3Rpb25WZWN0b3IpLnJnYiwgYSk7XCIsXG5cdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFwiaWYgKCBhIDwgMi4wKVwiLFxuXHRcdFx0XHRcIntcIixcblx0XHRcdFx0XHRcInJldHVybiBtaXgodGV4dHVyZUN1YmUoZW52TWFwMSwgcmVmbGVjdGlvblZlY3RvcikucmdiLCB0ZXh0dXJlQ3ViZShlbnZNYXAyLCByZWZsZWN0aW9uVmVjdG9yKS5yZ2IsIGEgLSAxLjApO1wiLFxuXHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcImlmICggYSA8IDMuMClcIixcblx0XHRcdFx0XCJ7XCIsXG5cdFx0XHRcdFx0XCJyZXR1cm4gbWl4KHRleHR1cmVDdWJlKGVudk1hcDIsIHJlZmxlY3Rpb25WZWN0b3IpLnJnYiwgdGV4dHVyZUN1YmUoZW52TWFwMywgcmVmbGVjdGlvblZlY3RvcikucmdiLCBhIC0gMi4wKTtcIixcblx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XCJpZiAoIGEgPCA0LjApXCIsXG5cdFx0XHRcdFwie1wiLFxuXHRcdFx0XHRcdFwicmV0dXJuIG1peCh0ZXh0dXJlQ3ViZShlbnZNYXAzLCByZWZsZWN0aW9uVmVjdG9yKS5yZ2IsIHRleHR1cmVDdWJlKGVudk1hcDQsIHJlZmxlY3Rpb25WZWN0b3IpLnJnYiwgYSAtIDMuMCk7XCIsXG5cdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFwiaWYgKCBhIDwgNS4wKVwiLFxuXHRcdFx0XHRcIntcIixcblx0XHRcdFx0XHRcInJldHVybiBtaXgodGV4dHVyZUN1YmUoZW52TWFwNCwgcmVmbGVjdGlvblZlY3RvcikucmdiLCB0ZXh0dXJlQ3ViZShlbnZNYXA1LCByZWZsZWN0aW9uVmVjdG9yKS5yZ2IsIGEgLSA0LjApO1wiLFxuXHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcInJldHVybiB0ZXh0dXJlQ3ViZShlbnZNYXA1LCByZWZsZWN0aW9uVmVjdG9yKS5yZ2I7XCIsXG5cdFx0XHRcIn1cIixcblxuXHQgICAgXCJ2b2lkIG1haW4oKVwiLFxuXHQgICAgXCJ7XCIsXG5cdCAgICAgIFwidmVjMyBub3JtYWwgPSB2VGVzdE5vcm1hbDtcIixcblxuXHQgICAgICBcInZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZShjYW1lcmFQb3NpdGlvbiAtIHZQb3NpdGlvbik7XCIsXG5cdCAgICAgIFwidmVjMyBhbGJlZG9Db3JyZWN0ZWQgPSBwb3coYWJzKGJhc2VDb2xvci5yZ2IpLCB2ZWMzKDIuMikpO1wiLFxuXG5cdCAgICAgIFwidmVjMyByZWFsQWxiZWRvID0gYmFzZUNvbG9yIC0gYmFzZUNvbG9yICogbWV0YWxsaWM7XCIsXG5cdCAgICAgIFwidmVjMyByZWFsU3BlY3VsYXJDb2xvciA9IG1peCh2ZWMzKDAuMDMsIDAuMDMsIDAuMDMpLCBiYXNlQ29sb3IsIG1ldGFsbGljKTtcIixcblxuXHQgICAgICBcInZlYzMgbGlnaHQxID0gQ29tcHV0ZUxpZ2h0KCByZWFsQWxiZWRvLCByZWFsU3BlY3VsYXJDb2xvciwgbm9ybWFsLCB2TGlnaHRWZWN0b3IsIHZlYzMoMC40LCAwLjQyLCAwLjM3KSwgdkxpZ2h0VmVjdG9yLCB2aWV3RGlyKTtcIixcblxuXHQgICAgICBcInZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3QoLXZpZXdEaXIsIG5vcm1hbCk7XCIsXG5cdCAgXHRcdFwidmVjMyBlbnZDb2xvciA9IENvbXB1dGVFbnZDb2xvcihyb3VnaG5lc3MsIHJlZmxlY3RWZWN0b3IpO1wiLFxuXG5cdCAgXHRcdFwidmVjMyBlbnZGcmVzbmVsID0gU3BlY3VsYXJfRl9Sb3VnaG5lc3MocmVhbFNwZWN1bGFyQ29sb3IsIHJvdWdobmVzcyAqIHJvdWdobmVzcywgbm9ybWFsLCB2aWV3RGlyKTtcIixcblxuXHQgIFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhsaWdodEludGVuc2l0eSkgKiBsaWdodDEgKyAxLjAgKiBlbnZGcmVzbmVsICogZW52Q29sb3IgKyByZWFsQWxiZWRvICogMC4wMSwgMS4wKTtcIixcblx0ICAgIFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIilcblxuXHR9O1xuXG59O1xuIiwicmVxdWlyZSgnLi92ci1yZWdpc3Rlci1lbGVtZW50Jyk7XG5cbnZhciBWUlV0aWxzID0gcmVxdWlyZSgnLi92ci11dGlscycpO1xudmFyIFZSTm9kZSA9IHJlcXVpcmUoJy4vY29yZS92ci1ub2RlJyk7XG5cbnZhciBUV0VFTiA9IHJlcXVpcmUoJ3R3ZWVuLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItYW5pbWF0aW9uJywge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZSTm9kZS5wcm90b3R5cGUsIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdkZWxheScpKSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2R1cmF0aW9uJykpIHx8IDEwMDA7XG4gICAgICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnbG9vcCcpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlJyk7XG4gICAgICAgICAgICB0aGlzLnRvID0gVlJVdGlscy5wYXJzZUF0dHJpYnV0ZVN0cmluZyh0aGlzLmF0dHJpYnV0ZSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3RvJykpO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IG9iai5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgICAgIG5ldyBUV0VFTi5Ud2Vlbihmcm9tKVxuICAgICAgICAgICAgICAudG8odGhpcy50bywgdGhpcy5kdXJhdGlvbilcbiAgICAgICAgICAgICAgLmRlbGF5KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAgIC5vblVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHRoaXMpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH0pO1xuIiwicmVxdWlyZSgnLi92ci1yZWdpc3Rlci1lbGVtZW50Jyk7XG5cbnZhciBWUk5vZGUgPSByZXF1aXJlKCcuL2NvcmUvdnItbm9kZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLWJlaGF2aW9yJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZSTm9kZS5wcm90b3R5cGUsXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRWwuYWRkQmVoYXZpb3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRhZ3MgdGhhdCBpbmhlcml0IGZyb20gVlJCZWhhdmlvciBzaG91bGQgZGVmaW5lIHRoZWlyIG93biB1cGRhdGVcbiAgICAgICAgLy8gZnVuY3Rpb24uXG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IC8qIG5vIG9wICovIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInZhciBUSFJFRSA9IHJlcXVpcmUoJy4uL2xpYi90aHJlZScpO1xuXG52YXIgVlJPYmplY3QgPSByZXF1aXJlKCcuL2NvcmUvdnItb2JqZWN0Jyk7XG4vLyBUbyBhdm9pZCByZWNhbGN1bGF0aW9uIGF0IGV2ZXJ5IG1vdXNlIG1vdmVtZW50IHRpY2tcbnZhciBQSV8yID0gTWF0aC5QSSAvIDI7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItY29udHJvbHMnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLFxuICAgICAge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgICAgICAgICAgdGhpcy5wcmV2VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAvLyBUaGUgY2FudmFzIHdoZXJlIHRoZSBzY2VuZSBpcyBwYWludGVkXG4gICAgICAgICAgICB0aGlzLmNhbnZhc0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndnItc2NlbmUnKS5jYW52YXM7XG5cbiAgICAgICAgICAgIC8vIFRvIGtlZXAgdHJhY2sgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgICAgdGhpcy5rZXlzID0ge307XG4gICAgICAgICAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IDY1O1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgICAgIHRoaXMucGl0Y2hPYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICAgICAgICAgIHRoaXMueWF3T2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gICAgICAgICAgICB0aGlzLnlhd09iamVjdC5wb3NpdGlvbi55ID0gMTA7XG4gICAgICAgICAgICB0aGlzLnlhd09iamVjdC5hZGQodGhpcy5waXRjaE9iamVjdCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdsb2NvbW90aW9uJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW91c2UtbG9vaycsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLmF0dGFjaE1vdXNlS2V5Ym9hcmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvY29tb3Rpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnbG9jb21vdGlvbicpO1xuICAgICAgICAgICAgdmFyIG1vdXNlTG9vayA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb3VzZS1sb29rJyk7XG4gICAgICAgICAgICB0aGlzLmxvY29tb3Rpb24gPSBsb2NvbW90aW9uID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB0aGlzLm1vdXNlTG9vayA9IG1vdXNlTG9vayA9PT0gJ3RydWUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgICAgIHZhciBwaXRjaE9iamVjdCA9IHRoaXMucGl0Y2hPYmplY3Q7XG4gICAgICAgICAgICB2YXIgeWF3T2JqZWN0ID0gdGhpcy55YXdPYmplY3Q7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9ICh0aW1lIC0gdGhpcy5wcmV2VGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICB2YXIgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnByZXZUaW1lID0gdGltZTtcblxuICAgICAgICAgICAgdmVsb2NpdHkueCAtPSB2ZWxvY2l0eS54ICogMTAuMCAqIGRlbHRhO1xuICAgICAgICAgICAgdmVsb2NpdHkueiAtPSB2ZWxvY2l0eS56ICogMTAuMCAqIGRlbHRhO1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICAgICAgICAgIHZhciB4ID0gcG9zaXRpb24ueCB8fCAwO1xuICAgICAgICAgICAgdmFyIHkgPSBwb3NpdGlvbi55IHx8IDA7XG4gICAgICAgICAgICB2YXIgeiA9IHBvc2l0aW9uLnogfHwgMDtcblxuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJyk7XG4gICAgICAgICAgICB2YXIgcm90WiA9IHJvdGF0aW9uLnogfHwgMDtcblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jb21vdGlvbikge1xuICAgICAgICAgICAgICBpZiAoa2V5c1s2NV0pIHsgLy8gTGVmdFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5LnggLT0gYWNjZWxlcmF0aW9uICogZGVsdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGtleXNbODddKSB7IC8vIFVwXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkueiAtPSBhY2NlbGVyYXRpb24gKiBkZWx0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoa2V5c1s2OF0pIHsgLy8gUmlnaHRcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eS54ICs9IGFjY2VsZXJhdGlvbiAqIGRlbHRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChrZXlzWzgzXSkgeyAvLyBEb3duXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkueiArPSBhY2NlbGVyYXRpb24gKiBkZWx0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5c1s5MF0pIHsgLy8gWlxuICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgIHogPSAwO1xuXG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgLy8gc2NlbmUucmVzZXRTZW5zb3IoKTtcblxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgICB4ID0gcG9zaXRpb24ueCB8fCAwO1xuICAgICAgICAgICAgICB5ID0gcG9zaXRpb24ueSB8fCAwO1xuICAgICAgICAgICAgICB6ID0gcG9zaXRpb24ueiB8fCAwO1xuXG4gICAgICAgICAgICAgIHJvdGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJyk7XG4gICAgICAgICAgICAgIHJvdFogPSByb3RhdGlvbi56IHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyb3RhdGlvbicsIHtcbiAgICAgICAgICAgICAgeDogVEhSRUUuTWF0aC5yYWRUb0RlZyhwaXRjaE9iamVjdC5yb3RhdGlvbi54KSxcbiAgICAgICAgICAgICAgeTogVEhSRUUuTWF0aC5yYWRUb0RlZyh5YXdPYmplY3Qucm90YXRpb24ueSksXG4gICAgICAgICAgICAgIHo6IHJvdFpcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbW92ZW1lbnRWZWN0b3IgPSB0aGlzLmdldE1vdmVtZW50VmVjdG9yKGRlbHRhKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHtcbiAgICAgICAgICAgICAgeDogeCArIG1vdmVtZW50VmVjdG9yLngsXG4gICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgIHo6IHogKyBtb3ZlbWVudFZlY3Rvci56XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoTW91c2VLZXlib2FyZExpc3RlbmVyczoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzRWwgPSB0aGlzLmNhbnZhc0VsO1xuXG4gICAgICAgICAgICAvLyBLZXlib2FyZCBldmVudHNcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vbktleVVwLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gTW91c2UgRXZlbnRzXG4gICAgICAgICAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgY2FudmFzRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgY2FudmFzRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcGl0Y2hPYmplY3QgPSB0aGlzLnBpdGNoT2JqZWN0O1xuICAgICAgICAgICAgdmFyIHlhd09iamVjdCA9IHRoaXMueWF3T2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1vdXNlRG93biA9IHRoaXMubW91c2VEb3duO1xuXG4gICAgICAgICAgICBpZiAoIW1vdXNlRG93biB8fCAhdGhpcy5tb3VzZUxvb2spIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHZhciBtb3ZlbWVudFggPSBldmVudC5tb3ZlbWVudFggfHwgZXZlbnQubW96TW92ZW1lbnRYIHx8IGV2ZW50LndlYmtpdE1vdmVtZW50WCB8fCAwO1xuICAgICAgICAgICAgdmFyIG1vdmVtZW50WSA9IGV2ZW50Lm1vdmVtZW50WSB8fCBldmVudC5tb3pNb3ZlbWVudFkgfHwgZXZlbnQud2Via2l0TW92ZW1lbnRZIHx8IDA7XG5cbiAgICAgICAgICAgIHlhd09iamVjdC5yb3RhdGlvbi55IC09IG1vdmVtZW50WCAqIDAuMDAyO1xuICAgICAgICAgICAgcGl0Y2hPYmplY3Qucm90YXRpb24ueCAtPSBtb3ZlbWVudFkgKiAwLjAwMjtcbiAgICAgICAgICAgIHBpdGNoT2JqZWN0LnJvdGF0aW9uLnggPSBNYXRoLm1heCgtUElfMiwgTWF0aC5taW4oUElfMiwgcGl0Y2hPYmplY3Qucm90YXRpb24ueCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlRG93bjoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubGFzdE1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlVXA6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25LZXlEb3duOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5rZXlzW2V2ZW50LmtleUNvZGVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25LZXlVcDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5c1tldmVudC5rZXlDb2RlXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNb3ZlbWVudFZlY3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjModmVsb2NpdHkueCAqIGRlbHRhLCAwLCB2ZWxvY2l0eS56ICogZGVsdGEpO1xuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gbmV3IFRIUkVFLkV1bGVyKDAsIDAsIDAsICdZWFonKTtcbiAgICAgICAgICAgIHZhciBwaXRjaE9iamVjdCA9IHRoaXMucGl0Y2hPYmplY3Q7XG4gICAgICAgICAgICB2YXIgeWF3T2JqZWN0ID0gdGhpcy55YXdPYmplY3Q7XG4gICAgICAgICAgICByb3RhdGlvbi5zZXQocGl0Y2hPYmplY3Qucm90YXRpb24ueCwgeWF3T2JqZWN0LnJvdGF0aW9uLnksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5hcHBseUV1bGVyKHJvdGF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbik7XG4iLCJyZXF1aXJlKCcuL3ZyLXJlZ2lzdGVyLWVsZW1lbnQnKTtcblxudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vbGliL3RocmVlJyk7XG5cbnZhciBWUk9iamVjdCA9IHJlcXVpcmUoJy4vY29yZS92ci1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXG4gICd2ci1jdXJzb3InLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJPYmplY3QucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaEV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VEb3duOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0M0QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R2VvbWV0cnk6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JhZGl1cycpKSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dlb21ldHJ5Jyk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnlFbCA9IGdlb21ldHJ5SWQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIGdlb21ldHJ5SWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIChnZW9tZXRyeUVsICYmIGdlb21ldHJ5RWwuZ2VvbWV0cnkpIHx8IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShyYWRpdXMsIDY0LCA0MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJyk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxFbCA9IG1hdGVyaWFsSWQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIG1hdGVyaWFsSWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIChtYXRlcmlhbEVsICYmIG1hdGVyaWFsRWwubWF0ZXJpYWwpIHx8IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6IDB4ZmYwMDAwLCBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVyc2VjdDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0cykge1xuICAgICAgICAgICAgdmFyIHJheWNhc3RlciA9IHRoaXMucmF5Y2FzdGVyO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMub2JqZWN0M0Q7XG4gICAgICAgICAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIGN1cnNvci5sb2NhbFRvV29ybGQoY3Vyc29yUG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZS5vYmplY3QzRDtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQb3NpdGlvbiA9IHBhcmVudC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgcGFyZW50LmxvY2FsVG9Xb3JsZChwYXJlbnRQb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gY3Vyc29yUG9zaXRpb24uc3ViKHBhcmVudFBvc2l0aW9uKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHJheWNhc3Rlci5zZXQocGFyZW50UG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMob2JqZWN0cywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUNsaWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY2VuZSA9IHRoaXMuc2NlbmVFbC5vYmplY3QzRDtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RlZE9iamVjdHMgPSB0aGlzLmludGVyc2VjdChzY2VuZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBpbnRlcnNlY3RlZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIG9iai5vYmplY3QuZWwuY2xpY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInJlcXVpcmUoJy4vdnItcmVnaXN0ZXItZWxlbWVudCcpO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi9saWIvdGhyZWUnKTtcbnZhciBWUk5vZGUgPSByZXF1aXJlKCcuL2NvcmUvdnItbm9kZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcbiAgJ3ZyLWZvZycsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBWUk5vZGUucHJvdG90eXBlLCB7XG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sb3InKSB8fCAweEZGRkZGRjtcbiAgICAgICAgICAgIHZhciBuZWFyID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnbmVhcicpIHx8IDEpO1xuICAgICAgICAgICAgdmFyIGZhciA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2ZhcicpIHx8IDEwMDApO1xuICAgICAgICAgICAgdGhpcy5mb2cgPSB0aGlzLnNjZW5lRWwub2JqZWN0M0QuZm9nID0gbmV3IFRIUkVFLkZvZyhjb2xvciwgbmVhciwgZmFyKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuKTtcbiIsInJlcXVpcmUoJy4vdnItcmVnaXN0ZXItZWxlbWVudCcpO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi9saWIvdGhyZWUnKTtcbnZhciBWUk5vZGUgPSByZXF1aXJlKCcuL2NvcmUvdnItbm9kZScpO1xudmFyIFZSVXRpbHMgPSByZXF1aXJlKCcuL3ZyLXV0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItZ2VvbWV0cnknLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJOb2RlLnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cEdlb21ldHJ5KCk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0dXBHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlID0gdGhpcy5wcmltaXRpdmUgPSB0aGlzLmdldEF0dHJpYnV0ZSgncHJpbWl0aXZlJykgfHwgJ0JveCc7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnk7XG4gICAgICAgICAgICB2YXIgcmFkaXVzO1xuICAgICAgICAgICAgc3dpdGNoIChwcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnQm94JzpcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSB8fCAyMDA7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKSB8fCAyMDA7XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnZGVwdGgnKSkgfHwgMjAwO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KHdpZHRoLCBoZWlnaHQsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnU3BoZXJlJzpcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdyYWRpdXMnKSkgfHwgMTAwO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KHJhZGl1cywgMzIsIDMyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnVG9ydXMnOlxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3JhZGl1cycpKSB8fCAyMDA7XG4gICAgICAgICAgICAgICAgdmFyIHR1YmUgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd0dWJlJykpIHx8IDEwO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkocmFkaXVzLCB0dWJlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBWUlV0aWxzLndhcm4oJ1ByaW1pdGl2ZSB0eXBlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gIH1cbik7XG4iLCJyZXF1aXJlKCcuL3ZyLXJlZ2lzdGVyLWVsZW1lbnQnKTtcblxudmFyIFZST2JqZWN0ID0gcmVxdWlyZSgnLi9jb3JlL3ZyLW9iamVjdCcpO1xudmFyIFZSTm9kZSA9IHJlcXVpcmUoJy4vY29yZS92ci1ub2RlJyk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi9saWIvdGhyZWUnKTtcbnZhciBWUlV0aWxzID0gcmVxdWlyZSgnLi92ci11dGlscycpO1xuXG5yZXF1aXJlKCcuL2NvcmUvdnItY2FtZXJhJyk7XG5yZXF1aXJlKCcuL2NvcmUvdnItc2NlbmUnKTtcbnJlcXVpcmUoJy4vY29yZS92ci1hc3NldHMnKTtcblxucmVxdWlyZSgnLi92ci1hbmltYXRpb24nKTtcbnJlcXVpcmUoJy4vdnItYmVoYXZpb3InKTtcbnJlcXVpcmUoJy4vdnItY29udHJvbHMnKTtcbnJlcXVpcmUoJy4vdnItY3Vyc29yJyk7XG5yZXF1aXJlKCcuL3ZyLWZvZycpO1xucmVxdWlyZSgnLi92ci1nZW9tZXRyeScpO1xucmVxdWlyZSgnLi92ci1tYXRlcmlhbCcpO1xucmVxdWlyZSgnLi92ci1tZXNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUSFJFRTogVEhSRUUsXG4gIFZST2JqZWN0OiBWUk9iamVjdCxcbiAgVlJOb2RlOiBWUk5vZGUsXG4gIHV0aWxzOiBWUlV0aWxzXG59O1xuIiwicmVxdWlyZSgnLi92ci1yZWdpc3Rlci1lbGVtZW50Jyk7XG5cbnZhciBUSFJFRSA9IHJlcXVpcmUoJy4uL2xpYi90aHJlZScpO1xudmFyIFZSTm9kZSA9IHJlcXVpcmUoJy4vY29yZS92ci1ub2RlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxuICAndnItbWF0ZXJpYWwnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgVlJOb2RlLnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMuc2V0dXBNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sb3InKSB8fCBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmY7XG4gICAgICAgICAgICB2YXIgcm91Z2huZXNzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JvdWdobmVzcycpIHx8ICcxLjAnO1xuICAgICAgICAgICAgdmFyIG1ldGFsbGljID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21ldGFsbGljJykgfHwgJzAuNSc7XG5cbiAgICAgICAgICAgIHRoaXMucm91Z2huZXNzID0gcGFyc2VGbG9hdChyb3VnaG5lc3MpO1xuICAgICAgICAgICAgdGhpcy5tZXRhbGxpYyA9IHBhcnNlRmxvYXQobWV0YWxsaWMpO1xuICAgICAgICAgICAgdGhpcy5saWdodEludGVuc2l0eSA9IDcuMDAxO1xuICAgICAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5WZWN0b3IzKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRlcmlhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVNYXRlcmlhbDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXMuYmFzZUNvbG9yLnZhbHVlID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZSA9IHRoaXMucm91Z2huZXNzO1xuICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXMubWV0YWxsaWMudmFsdWUgPSB0aGlzLm1ldGFsbGljO1xuICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXMubGlnaHRJbnRlbnNpdHkudmFsdWUgPSB0aGlzLmxpZ2h0SW50ZW5zaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFNoYWRlciBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB2YXIgYmFzZUNvbG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoMC41LCAwLjUsIDAuNSk7XG4gICAgICAgICAgICB2YXIgcm91Z2huZXNzID0gMS4wO1xuICAgICAgICAgICAgdmFyIG1ldGFsbGljID0gMC41O1xuICAgICAgICAgICAgdmFyIGxpZ2h0SW50ZW5zaXR5ID0gNy4wMDE7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50cyBvZiB0aGUgZnVuY3Rpb24gQ29tcHV0ZUVudkNvbG9yIGZvciB0aGUgZXhwbGFuYXRpb25zIG9uIHRoaXMgaHVnIG51bWJlciBvZiBjdWJlbWFwcy5cbiAgICAgICAgICAgIC8vIEN1YmUgTWFwIG1pcCAwXG4gICAgICAgICAgICB2YXIgcGF0aCA9ICdpbWFnZXMvcGJyL21hc2tvbmFpdmVfbTAwX2MwJztcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSAnLnBuZyc7XG4gICAgICAgICAgICB2YXIgdXJscyA9IFtcbiAgICAgICAgICAgICAgcGF0aCArICcwJyArIGZvcm1hdCwgcGF0aCArICcxJyArIGZvcm1hdCxcbiAgICAgICAgICAgICAgcGF0aCArICcyJyArIGZvcm1hdCwgcGF0aCArICczJyArIGZvcm1hdCxcbiAgICAgICAgICAgICAgcGF0aCArICc0JyArIGZvcm1hdCwgcGF0aCArICc1JyArIGZvcm1hdFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBjdWJlTWFwTWlwMCA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlKHVybHMpO1xuICAgICAgICAgICAgY3ViZU1hcE1pcDAuZm9ybWF0ID0gVEhSRUUuUkdCRm9ybWF0O1xuXG4gICAgICAgICAgICAvLyBDdWJlIE1hcCBtaXAgMVxuICAgICAgICAgICAgcGF0aCA9ICdpbWFnZXMvcGJyL21hc2tvbmFpdmVfbTAxX2MwJztcbiAgICAgICAgICAgIGZvcm1hdCA9ICcucG5nJztcbiAgICAgICAgICAgIHVybHMgPSBbXG4gICAgICAgICAgICAgIHBhdGggKyAnMCcgKyBmb3JtYXQsIHBhdGggKyAnMScgKyBmb3JtYXQsXG4gICAgICAgICAgICAgIHBhdGggKyAnMicgKyBmb3JtYXQsIHBhdGggKyAnMycgKyBmb3JtYXQsXG4gICAgICAgICAgICAgIHBhdGggKyAnNCcgKyBmb3JtYXQsIHBhdGggKyAnNScgKyBmb3JtYXRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgY3ViZU1hcE1pcDEgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSh1cmxzKTtcbiAgICAgICAgICAgIGN1YmVNYXBNaXAxLmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdDtcblxuICAgICAgICAgICAgLy8gQ3ViZSBNYXAgbWlwIDJcbiAgICAgICAgICAgIHBhdGggPSAnaW1hZ2VzL3Bici9tYXNrb25haXZlX20wMl9jMCc7XG4gICAgICAgICAgICBmb3JtYXQgPSAnLnBuZyc7XG4gICAgICAgICAgICB1cmxzID0gW1xuICAgICAgICAgICAgICBwYXRoICsgJzAnICsgZm9ybWF0LCBwYXRoICsgJzEnICsgZm9ybWF0LFxuICAgICAgICAgICAgICBwYXRoICsgJzInICsgZm9ybWF0LCBwYXRoICsgJzMnICsgZm9ybWF0LFxuICAgICAgICAgICAgICBwYXRoICsgJzQnICsgZm9ybWF0LCBwYXRoICsgJzUnICsgZm9ybWF0XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGN1YmVNYXBNaXAyID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUodXJscyk7XG4gICAgICAgICAgICBjdWJlTWFwTWlwMi5mb3JtYXQgPSBUSFJFRS5SR0JGb3JtYXQ7XG5cbiAgICAgICAgICAgIC8vIEN1YmUgTWFwIG1pcCAzXG4gICAgICAgICAgICBwYXRoID0gJ2ltYWdlcy9wYnIvbWFza29uYWl2ZV9tMDNfYzAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gJy5wbmcnO1xuICAgICAgICAgICAgdXJscyA9IFtcbiAgICAgICAgICAgICAgcGF0aCArICcwJyArIGZvcm1hdCwgcGF0aCArICcxJyArIGZvcm1hdCxcbiAgICAgICAgICAgICAgcGF0aCArICcyJyArIGZvcm1hdCwgcGF0aCArICczJyArIGZvcm1hdCxcbiAgICAgICAgICAgICAgcGF0aCArICc0JyArIGZvcm1hdCwgcGF0aCArICc1JyArIGZvcm1hdFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBjdWJlTWFwTWlwMyA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlKHVybHMpO1xuICAgICAgICAgICAgY3ViZU1hcE1pcDMuZm9ybWF0ID0gVEhSRUUuUkdCRm9ybWF0O1xuXG4gICAgICAgICAgICAvLyBDdWJlIE1hcCBtaXAgNFxuICAgICAgICAgICAgcGF0aCA9ICdpbWFnZXMvcGJyL21hc2tvbmFpdmVfbTA0X2MwJztcbiAgICAgICAgICAgIGZvcm1hdCA9ICcucG5nJztcbiAgICAgICAgICAgIHVybHMgPSBbXG4gICAgICAgICAgICAgIHBhdGggKyAnMCcgKyBmb3JtYXQsIHBhdGggKyAnMScgKyBmb3JtYXQsXG4gICAgICAgICAgICAgIHBhdGggKyAnMicgKyBmb3JtYXQsIHBhdGggKyAnMycgKyBmb3JtYXQsXG4gICAgICAgICAgICAgIHBhdGggKyAnNCcgKyBmb3JtYXQsIHBhdGggKyAnNScgKyBmb3JtYXRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgY3ViZU1hcE1pcDQgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSh1cmxzKTtcbiAgICAgICAgICAgIGN1YmVNYXBNaXA0LmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdDtcblxuICAgICAgICAgICAgLy8gQ3ViZSBNYXAgbWlwIDVcbiAgICAgICAgICAgIHBhdGggPSAnaW1hZ2VzL3Bici9tYXNrb25haXZlX20wNV9jMCc7XG4gICAgICAgICAgICBmb3JtYXQgPSAnLnBuZyc7XG4gICAgICAgICAgICB1cmxzID0gW1xuICAgICAgICAgICAgICBwYXRoICsgJzAnICsgZm9ybWF0LCBwYXRoICsgJzEnICsgZm9ybWF0LFxuICAgICAgICAgICAgICBwYXRoICsgJzInICsgZm9ybWF0LCBwYXRoICsgJzMnICsgZm9ybWF0LFxuICAgICAgICAgICAgICBwYXRoICsgJzQnICsgZm9ybWF0LCBwYXRoICsgJzUnICsgZm9ybWF0XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGN1YmVNYXBNaXA1ID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUodXJscyk7XG4gICAgICAgICAgICBjdWJlTWFwTWlwNS5mb3JtYXQgPSBUSFJFRS5SR0JGb3JtYXQ7XG5cbiAgICAgICAgICAgIHZhciBzaGFkZXJQQlIgPSBUSFJFRS5TaGFkZXJMaWIucGJyO1xuXG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgIGJhc2VDb2xvcjoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3YzJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBiYXNlQ29sb3JcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZW52TWFwMDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3QnLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGN1YmVNYXBNaXAwXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGVudk1hcDE6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdWJlTWFwTWlwMVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBlbnZNYXAyOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndCcsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY3ViZU1hcE1pcDJcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZW52TWFwMzoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3QnLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGN1YmVNYXBNaXAzXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGVudk1hcDQ6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdWJlTWFwTWlwNFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBlbnZNYXA1OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndCcsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY3ViZU1hcE1pcDVcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcm91Z2huZXNzOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogcm91Z2huZXNzXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIG1ldGFsbGljOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0YWxsaWNcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgbGlnaHRJbnRlbnNpdHk6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaWdodEludGVuc2l0eVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB1dlNjYWxlOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndjInLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKDEuMCwgMS4wKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXJQQlIudmVydGV4U2hhZGVyLFxuICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyUEJSLmZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgfVxuKTtcbiIsInJlcXVpcmUoJy4vdnItcmVnaXN0ZXItZWxlbWVudCcpO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi9saWIvdGhyZWUnKTtcbnZhciBWUk9iamVjdCA9IHJlcXVpcmUoJy4vY29yZS92ci1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXG4gICd2ci1tZXNoJyxcbiAge1xuICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgIFZST2JqZWN0LnByb3RvdHlwZSwge1xuICAgICAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIGlmIChtYXRlcmlhbCkge1xuICAgICAgICAgICAgICB0aGlzLm9iamVjdDNELm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9iamVjdDNELmdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHZW9tZXRyeToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnlJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdnZW9tZXRyeScpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5RWwgPSBnZW9tZXRyeUlkID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBnZW9tZXRyeUlkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiAoZ2VvbWV0cnlFbCAmJiBnZW9tZXRyeUVsLmdlb21ldHJ5KSB8fCBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMjAwLCAyMDAsIDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hdGVyaWFsOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJyk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxFbCA9IG1hdGVyaWFsSWQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIG1hdGVyaWFsSWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsRWwgJiYgbWF0ZXJpYWxFbC5tYXRlcmlhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gIH1cbik7XG4iLCIvLyBQb2x5ZmlsbCBgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50YC5cbnJlcXVpcmUoJ2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQnKTtcblxuLypcbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAtLS0tLS0tLS0tLS0tIFdBUk5JTkcgV0FSTklORyBXQVJOSU5HIFdBUk5JTkcgLS0tLS0tLS0tLS0tLS1cbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuIFRoaXMgbW9kdWxlIHdyYXBzIHJlZ2lzdGVyRWxlbWVudCB0byBkZWFsIHdpdGhcbiBjb21wb25lbnRzIHRoYXQgaW5oZXJpdCBmcm9tIFZSTm9kZSBhbmQgVlJPYmplY3QuXG4gSXQncyBhIHBhc3MgdGhyb3VnaCBpbiBhbnkgb3RoZXIgY2FzZS5cblxuIEl0IHdyYXBzIHNvbWUgb2YgdGhlIHByb3RvdHlwZSBtZXRob2RzXG4gb2YgdGhlIGNyZWF0ZWQgZWxlbWVudCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZ1xuIGZ1bmN0aW9ucyBpbiB0aGUgYmFzZSBjbGFzc2VzIChWUk9iamVjdCBhbmQgVlJOb2RlKSBhcmUgYWxzb1xuIGludm9rZWQuIFRoZSBtZXRob2QgaW4gdGhlIGJhc2UgY2xhc3MgaXMgYWx3YXlzIGNhbGwgYmVmb3JlIHRoZVxuIG9uZSBpbiB0aGUgZGVyaXZlZCBvYmplY3QuXG5cbiovXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9iaiBUaGUgcHJvdG90eXBlIG9mIHRoZSBuZXcgZWxlbWVudFxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvdG90eXBlIG9mIHRoZSBuZXcgZWxlbWVudFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBvYmopIHtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iai5wcm90b3R5cGUpO1xuICB2YXIgbmV3T2JqID0gb2JqO1xuXG4gIC8vIERvZXMgdGhlIGVsZW1lbnQgaW5oZXJpdCBmcm9tIFZSTm9kZT9cbiAgaWYgKFZSTm9kZSAmJiBwcm90byA9PT0gVlJOb2RlLnByb3RvdHlwZSkge1xuICAgIG5ld09iaiA9IHdyYXBWUk5vZGVNZXRob2RzKG9iai5wcm90b3R5cGUpO1xuICAgIG5ld09iaiA9IHtwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUocHJvdG8sIG5ld09iail9O1xuICB9XG5cbiAgLy8gRG9lcyB0aGUgZWxlbWVudCBpbmhlcml0IGZyb20gVlJPYmplY3Q/XG4gIGlmIChWUk9iamVjdCAmJiBwcm90byA9PT0gVlJPYmplY3QucHJvdG90eXBlKSB7XG4gICAgbmV3T2JqID0gd3JhcFZST2JqZWN0TWV0aG9kcyhvYmoucHJvdG90eXBlKTtcbiAgICBuZXdPYmogPSB7cHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKHByb3RvLCBuZXdPYmopfTtcbiAgfVxuXG4gIHJldHVybiByZWdpc3RlckVsZW1lbnQuY2FsbChkb2N1bWVudCwgdGFnTmFtZSwgbmV3T2JqKTtcbn07XG5cbi8qKlxuICogVGhpcyB3cmFwcHMgc29tZSBvZiB0aGUgb2JqIG1ldGhvZHMgdG8gY2FsbCB0aG9zZSBvbiBWUk5vZGUgYmFzZSBjbGFzZVxuICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdHMgdGhhdCBjb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgd3JhcHBlZFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBpbnB1dCBwYXJhbWV0ZXIgYnV0XG4gKiB3aXRoIHNvbWUgb2YgbWV0aG9kcyB3cmFwcGVkLlxuICovXG5mdW5jdGlvbiB3cmFwVlJOb2RlTWV0aG9kcyAob2JqKSB7XG4gIHZhciBuZXdPYmogPSB7fTtcbiAgd3JhcE1ldGhvZHMobmV3T2JqLCBbJ2NyZWF0ZWRDYWxsYmFjayddLCBvYmosIFZSTm9kZS5wcm90b3R5cGUpO1xuICBjb3B5UHJvcGVydGllcyhvYmosIG5ld09iaik7XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogVGhpcyB3cmFwcHMgc29tZSBvZiB0aGUgb2JqIG1ldGhvZHMgdG8gY2FsbCB0aG9zZSBvbiBWUk9iamVjdCBiYXNlIGNsYXNlXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0cyB0aGF0IGNvbnRhaW5zIHRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSB3cmFwcGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIGlucHV0IHBhcmFtZXRlciBidXRcbiAqIHdpdGggc29tZSBvZiBtZXRob2RzIHdyYXBwZWQuXG4gKi9cbmZ1bmN0aW9uIHdyYXBWUk9iamVjdE1ldGhvZHMgKG9iaikge1xuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciB2ck5vZGVNZXRob2RzID0gWydjcmVhdGVkQ2FsbGJhY2snXTtcbiAgdmFyIHZyT2JqZWN0TWV0aG9kcyA9IFtcbiAgICAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgJ2RldHRhY2hlZENhbGxiYWNrJ1xuICBdO1xuICB3cmFwTWV0aG9kcyhuZXdPYmosIHZyTm9kZU1ldGhvZHMsIG9iaiwgVlJOb2RlLnByb3RvdHlwZSk7XG4gIHdyYXBNZXRob2RzKG5ld09iaiwgdnJPYmplY3RNZXRob2RzLCBvYmosIFZST2JqZWN0LnByb3RvdHlwZSk7XG4gIC8vIENvcGllcyB0aGUgcmVtYWluaW5nIHByb3BlcnRpZXMgaW50byB0aGUgbmV3IG9iamVjdFxuICBjb3B5UHJvcGVydGllcyhvYmosIG5ld09iaik7XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogV3JhcHMgYSBsaXN0IGEgbWV0aG9kcyB0byBlbnN1cmUgdGhhdCB0aG9zZSBpbiB0aGUgYmFzZSBjbGFzcyBhcmUgY2FsbGVkIHRocm91Z2ggdGhlIGRlcml2ZWQgb25lXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldE9iaiBPYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHdyYXBwZWQgbWV0aG9kc1xuICogQHBhcmFtICB7YXJyYXl9IG1ldGhvZExpc3QgTGlzdCBvZiBtZXRob2RzIGZyb20gdGhlIGRlcml2ZWRPYmogdGhhdCB3aWxsIGJlIHdyYXBwZWRcbiAqIEBwYXJhbSAge29iamVjdH0gZGVyaXZlZE9iamVjdCBPYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBiYXNlT2JqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJhc2VPYmogT2JqZWN0IHRoYXQgZGVyaXZlZE9iaiBpbmhlcml0cyBmcm9tXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHdyYXBNZXRob2RzICh0YXJnZXRPYmosIG1ldGhvZExpc3QsIGRlcml2ZWRPYmosIGJhc2VPYmopIHtcbiAgbWV0aG9kTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgd3JhcE1ldGhvZCh0YXJnZXRPYmosIG1ldGhvZE5hbWUsIGRlcml2ZWRPYmosIGJhc2VPYmopO1xuICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwcyBvbmUgbWV0aG9kIHRvIGVuc3VyZSB0aGF0IHRoZSBvbmUgaW4gdGhlIGJhc2UgY2xhc3MgaXMgY2FsbGVkIGJlZm9yZSB0aGUgb25lXG4gKiBpbiB0aGUgZGVyaXZlZCBvbmVcbiAqIEBwYXJhbSAge29iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdpbGwgY29udGFpbiB0aGUgd3JhcHBlZCBtZXRob2RcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSB3cmFwcGVkXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlcml2ZWRPYmplY3QgT2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYmFzZU9ialxuICogQHBhcmFtICB7b2JqZWN0fSBiYXNlT2JqIE9iamVjdCB0aGF0IGRlcml2ZWRPYmogaW5oZXJpdHMgZnJvbVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB3cmFwTWV0aG9kIChvYmosIG1ldGhvZE5hbWUsIGRlcml2ZWRPYmosIGJhc2VPYmopIHtcbiAgdmFyIGRlcml2ZWRNZXRob2QgPSBkZXJpdmVkT2JqW21ldGhvZE5hbWVdO1xuICB2YXIgYmFzZU1ldGhvZCA9IGJhc2VPYmpbbWV0aG9kTmFtZV07XG4gIGlmICghZGVyaXZlZE1ldGhvZCB8fCAhYmFzZU1ldGhvZCkgeyByZXR1cm47IH1cbiAgLy8gV3JhcHBlclxuICAvLyBUaGUgYmFzZSBtZXRob2QgaXMgY2FsbGVkIGJlZm9yZSB0aGUgb25lIGluIHRoZSBkZXJpdmVkIGNsYXNzXG4gIHZhciB3cmFwcGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIGJhc2VNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZGVyaXZlZE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBvYmpbbWV0aG9kTmFtZV0gPSB7dmFsdWU6IHdyYXBwZXJNZXRob2QsIHdyaXRhYmxlOiB3aW5kb3cuZGVidWd9O1xufVxuXG4vKipcbiAqIEl0IGNvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIGlmIHRoZXkgZG9uJ3QgZXhpc3QgYWxyZWFkeVxuICogQHBhcmFtICB7b2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB3aGVyZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgZnJvbVxuICogQHBhcmFtICB7W3R5cGVdfSBkZXN0aW5hdGlvbiBUaGUgb2JqZWN0IHdoZXJlIHByb3BlcnRpZXMgYXJlIGNvcGllZCB0b1xuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb3B5UHJvcGVydGllcyAoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpO1xuICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKCFkZXN0aW5hdGlvbltwcm9wXSkge1xuICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSB7dmFsdWU6IHNvdXJjZVtwcm9wXSwgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z307XG4gICAgfVxuICB9KTtcbn1cblxudmFyIFZSTm9kZSA9IHJlcXVpcmUoJy4vY29yZS92ci1ub2RlJyk7XG52YXIgVlJPYmplY3QgPSByZXF1aXJlKCcuL2NvcmUvdnItb2JqZWN0Jyk7XG4iLCJ2YXIgZXJyb3IgPSBtb2R1bGUuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICBjb25zb2xlLndhcm4obXNnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlQXR0cmlidXRlU3RyaW5nID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgc3RyKSB7XG4gIHZhciB2YWx1ZXM7XG4gIHZhciB2YWx1ZSA9IHN0cjtcbiAgaWYgKGF0dHJpYnV0ZSA9PT0gJ3Bvc2l0aW9uJyB8fFxuICAgICAgYXR0cmlidXRlID09PSAncm90YXRpb24nIHx8XG4gICAgICBhdHRyaWJ1dGUgPT09ICdzY2FsZScpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIGVycm9yKCdhdHRyIHN0cmluZyBzaG91bGQgYmUgbGVuIDMsIGV4OiAgKDAgMSAyKScpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHtcbiAgICAgIHg6IHBhcnNlRmxvYXQodmFsdWVzWzBdKSxcbiAgICAgIHk6IHBhcnNlRmxvYXQodmFsdWVzWzFdKSxcbiAgICAgIHo6IHBhcnNlRmxvYXQodmFsdWVzWzJdKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGJyb3dzZXIgZmllbGQsIGNoZWNrIG91dCB0aGUgYnJvd3NlciBmaWVsZCBhdCBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJvd3NlcmlmeS1oYW5kYm9vayNicm93c2VyLWZpZWxkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBDcmVhdGUgYSA8bGluaz4gdGFnIHdpdGggb3B0aW9uYWwgZGF0YSBhdHRyaWJ1dGVzXG4gICAgY3JlYXRlTGluazogZnVuY3Rpb24oaHJlZiwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICggISBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSA8c3R5bGU+IHRhZyB3aXRoIG9wdGlvbmFsIGRhdGEgYXR0cmlidXRlc1xuICAgIGNyZWF0ZVN0eWxlOiBmdW5jdGlvbihjc3NUZXh0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoc3R5bGUuc2hlZXQpIHsgLy8gZm9yIGpzZG9tIGFuZCBJRTkrXG4gICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBjc3NUZXh0O1xuICAgICAgICAgICAgc3R5bGUuc2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7IC8vIGZvciBJRTggYW5kIGJlbG93XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIH0gZWxzZSB7IC8vIGZvciBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsInZhciBjc3MgPSBcImJvZHksaHRtbHtoZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW59LnZyLWNhbnZhc3toZWlnaHQ6MTAwJTtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6MTAwJX1idXR0b257YmFja2dyb3VuZC1jb2xvcjojMzAzMDMwO2JvcmRlcjoxcHggc29saWQgI2ZmZjtjb2xvcjojZmZmO2N1cnNvcjpwb2ludGVyO2xlZnQ6MDtwYWRkaW5nOjVweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt3aWR0aDo5MHB4O3otaW5kZXg6OTk5OTk5fWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmdyYXk7Y29sb3I6I2ZmZn0udnItYnV0dG9ue3RvcDoyMHB4O2xlZnQ6MzBweH1cIjsgKHJlcXVpcmUoXCJicm93c2VyaWZ5LWNzc1wiKS5jcmVhdGVTdHlsZShjc3MsIHsgXCJocmVmXCI6IFwic3R5bGUvaW5kZXguY3NzXCJ9KSk7IG1vZHVsZS5leHBvcnRzID0gY3NzOyJdfQ==
